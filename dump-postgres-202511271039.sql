--
-- PostgreSQL database dump
--

-- Dumped from database version 12.22 (Ubuntu 12.22-0ubuntu0.20.04.4)
-- Dumped by pg_dump version 12.22 (Ubuntu 12.22-0ubuntu0.20.04.4)

-- Started on 2025-11-27 11:39:04 +06

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 8 (class 2615 OID 49232)
-- Name: analytics; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA analytics;


ALTER SCHEMA analytics OWNER TO postgres;

--
-- TOC entry 10 (class 2615 OID 49233)
-- Name: functioncalls; Type: SCHEMA; Schema: -; Owner: postgres
--

CREATE SCHEMA functioncalls;


ALTER SCHEMA functioncalls OWNER TO postgres;

--
-- TOC entry 2 (class 3079 OID 32807)
-- Name: pldbgapi; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pldbgapi WITH SCHEMA public;


--
-- TOC entry 6092 (class 0 OID 0)
-- Dependencies: 2
-- Name: EXTENSION pldbgapi; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pldbgapi IS 'server-side support for debugging PL/pgSQL functions';


--
-- TOC entry 574 (class 1255 OID 49234)
-- Name: get_sellinginfo_day(date); Type: FUNCTION; Schema: analytics; Owner: postgres
--

CREATE FUNCTION analytics.get_sellinginfo_day(indate date, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
	r							record;
	p_date			  date;
	p_found				numeric;

BEGIN
		--  ismeuser2:  first need to check if get_sellinginfo_day record exists in the table
        
        IF (SELECT COUNT(*) FROM analytics.jobcheck WHERE jobname = 'get_sellinginfo_day') = 0 THEN
            INSERT INTO analytics.jobcheck (jobname, last_update_start, last_update_end) 
                VALUES ('get_sellinginfo_day', now(), NULL);
        ELSE
		-- Фиксирование даты и времени последней отработки (Начало выполнения)
		    UPDATE analytics.jobcheck
			    SET last_update_start = clock_timestamp()::timestamp
				    WHERE jobname = 'get_sellinginfo_day';
		END IF;
		-- Для ручного выполнения. Автоматически будет выполнять сбор за предыдущий день от времени запуска.
		IF indate IS NULL THEN
			p_date := current_date - 1;
		ELSE
			p_date := indate;
		END IF;
				
		IF p_date = current_date THEN
			 result := json_build_object('code','error','text','Запрещено делать расчет на текущий день!','date',now());
			 return next;
			 return;
		END IF;
				
		SELECT 1 INTO p_found
			FROM analytics.sellinginfo_day
				WHERE "date" = p_date
					LIMIT 1;
		IF FOUND THEN
			 result := json_build_object('code','success','text',p_date,'date',now(),'note','repeated');
			 return next;
			 return;
		END IF;					
		
		-- Сохранение данных для отчетов
		INSERT INTO analytics.sellinginfo_day(company,point,product,gross_profit,units,proceeds,"cost","date")
		/*SELECT company, point, product,
			SUM(coalesce(((stockdiary.price-coalesce(stockdiary.purchaseprice,0)) * stockdiary.units),0)) as gross_profit,
			SUM(stockdiary.units) as units,
			SUM(coalesce((stockdiary.price * stockdiary.units),0)) as salesamount,
			SUM(coalesce((coalesce(stockdiary.purchaseprice,0) * stockdiary.units),0)) as cost,
			stockdiary.date
				FROM public.stockdiary
					WHERE stockdiary.reason in (-1,2)
						AND stockdiary.date::date = p_date
							GROUP BY stockdiary.company, stockdiary.point, stockdiary.product, stockdiary."attributes", stockdiary."date";*/
		/*SELECT t.company, t.point, t.product, t.gross_profit, t.units, t.salesamount, t.cost, t.date
			FROM (
				SELECT s.company, s.point, s.product,
					SUM(coalesce(((stockdiary.price-coalesce(stockdiary.purchaseprice,0)) * stockdiary.units),0)) as gross_profit,
					SUM(coalesce(stockdiary.units,0)) as units,
					SUM(coalesce(s.units,0)) as stockunits,
					SUM(coalesce((stockdiary.price * stockdiary.units),0)) as salesamount,
					SUM(coalesce((coalesce(stockdiary.purchaseprice,0) * stockdiary.units),0)) as cost, p_date as date
						FROM analytics.stockcurrent_part_snapshots s
							LEFT JOIN public.stockdiary ON (stockdiary.company = s.company and stockdiary.product = s.product and stockdiary.point = s.point and
																								stockdiary.attributes = s.attributes and stockdiary.reason in (-1,2) and stockdiary.date::date = s.snapdate)
								GROUP BY s.company, s.point, s.product, stockdiary."date") t
				WHERE (t.units <> 0 OR t.stockunits <> 0)					
					AND s.snapdate = p_date;*/
			SELECT t.company, t.point, t.product, t.gross_profit, t.units, t.salesamount, t.cost, t.date
			FROM (
				SELECT p.company, coalesce(s.point,stockdiary.point) as point, p.id as product,
					SUM(coalesce(((stockdiary.price-coalesce(stockdiary.purchaseprice,0)) * stockdiary.units),0)) as gross_profit,
					SUM(coalesce(stockdiary.units,0)) as units,
					SUM(coalesce(s.units,0)) as stockunits,
					SUM(coalesce((stockdiary.price * stockdiary.units),0)) as salesamount,
					SUM(coalesce((coalesce(stockdiary.purchaseprice,0) * stockdiary.units),0)) as cost, p_date as date
						FROM public.products p
							LEFT JOIN analytics.stockcurrent_part_snapshots s ON (p.company = s.company and p.id = s.product and snapdate = p_date)
							LEFT JOIN public.stockdiary ON (stockdiary.company = p.company and stockdiary.product = p.id and stockdiary.reason in (-1,2) and stockdiary.date::date = p_date)
								GROUP BY p.company, coalesce(s.point,stockdiary.point), p.id) t
				WHERE (t.units <> 0 OR t.stockunits <> 0);								
	
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE analytics.jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'get_sellinginfo_day';
	
  result := json_build_object('code','success','text',p_date,'date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION analytics.get_sellinginfo_day(indate date, OUT result json) OWNER TO postgres;

--
-- TOC entry 771 (class 1255 OID 49236)
-- Name: get_sellinginfo_month(date); Type: FUNCTION; Schema: analytics; Owner: postgres
--

CREATE FUNCTION analytics.get_sellinginfo_month(indate date, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
	r							record;
	p_date			  date;
	p_found				numeric;
	p_date_start  date;
BEGIN
		--  ismeuser2:  first need to check if get_sellinginfo_day record exists in the table
        
        IF (SELECT COUNT(*) FROM analytics.jobcheck WHERE jobname = 'get_sellinginfo_month') = 0 THEN
            INSERT INTO analytics.jobcheck (jobname, last_update_start, last_update_end) 
                VALUES ('get_sellinginfo_month', now(), NULL);
        ELSE		
		-- Фиксирование даты и времени последней отработки (Начало выполнения)
		    UPDATE analytics.jobcheck
			    SET last_update_start = clock_timestamp()::timestamp
				    WHERE jobname = 'get_sellinginfo_month';
		END IF;
		-- Для ручного выполнения. Автоматически будет выполнять сбор за предыдущий день(месяц) от времени запуска.
		IF indate IS NULL THEN
			p_date := current_date - 1;
			p_date_start := date_trunc('month', p_date)::date;
		ELSE
			p_date := indate;
			p_date_start := date_trunc('month', indate)::date;
		END IF;
		
		-- Если не последний день месяца - данные не рассчитываем, т.к. должны считать за предыдущую неделю
		IF p_date <> (date_trunc('month', p_date::date) + interval '1 month' - interval '1 day')::date THEN
			 result := json_build_object('code','success','text',p_date,'date',now(),'note','not_time');
			 return next;
			 return;
		END IF;
				
		SELECT 1 INTO p_found
			FROM analytics.sellinginfo_month
				WHERE "date" = p_date_start
					LIMIT 1;
		IF FOUND THEN
			 result := json_build_object('code','success','text',p_date,'date',now(),'note','repeated');
			 return next;
			 return;
		END IF;					
		
		-- Сохранение данных для отчетов
		INSERT INTO analytics.sellinginfo_month(company,point,product,gross_profit,units,proceeds,"cost","date")
		SELECT company, point, product, SUM(gross_profit) as gross_profit, SUM(units) as units, SUM(proceeds) as salesamount,
						SUM("cost") as cost, p_date_start
				FROM analytics.sellinginfo_week
					WHERE date BETWEEN p_date_start AND p_date
							GROUP BY company, point, product;
							
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE analytics.jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'get_sellinginfo_month';						
	
  result := json_build_object('code','success','text',p_date,'date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION analytics.get_sellinginfo_month(indate date, OUT result json) OWNER TO postgres;

--
-- TOC entry 772 (class 1255 OID 49237)
-- Name: get_sellinginfo_week(date); Type: FUNCTION; Schema: analytics; Owner: postgres
--

CREATE FUNCTION analytics.get_sellinginfo_week(indate date, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
	r							record;
	p_date			  date;
	p_found				numeric;
BEGIN
		--  ismeuser2:  first need to check if get_sellinginfo_day record exists in the table
        
        IF (SELECT COUNT(*) FROM analytics.jobcheck WHERE jobname = 'get_sellinginfo_week') = 0 THEN
            INSERT INTO analytics.jobcheck (jobname, last_update_start, last_update_end) 
                VALUES ('get_sellinginfo_week', now(), NULL);
        ELSE		
		-- Фиксирование даты и времени последней отработки (Начало выполнения)
		    UPDATE analytics.jobcheck
			    SET last_update_start = clock_timestamp()::timestamp
				    WHERE jobname = 'get_sellinginfo_week';
		END IF;
		-- Для ручного выполнения. Автоматически будет выполнять сбор за предыдущую неделю от времени запуска.
		IF indate IS NULL THEN
			p_date := current_date - 1;
		ELSE
			p_date := indate;
		END IF;
		
		-- Если не воскресение - данные не рассчитываем, т.к. должны считать за предыдущую неделю
		IF EXTRACT(ISODOW FROM p_date) <> 7 THEN
			 result := json_build_object('code','success','text',p_date,'date',now(),'note','not_time');
			 return next;
			 return;
		END IF;
		
		SELECT 1 INTO p_found
			FROM analytics.sellinginfo_week
				WHERE "date" = p_date - 6
					LIMIT 1;
		IF FOUND THEN
			 result := json_build_object('code','success','text',p_date,'date',now(),'note','repeated');
			 return next;
			 return;
		END IF;					
		
		-- Сохранение данных для отчетов
		INSERT INTO analytics.sellinginfo_week(company,point,product, gross_profit,units,proceeds,"cost","date")
		SELECT company, point, product, SUM(gross_profit) as gross_profit, SUM(units) as units, SUM(proceeds) as salesamount,
						SUM("cost") as cost, p_date - 6
				FROM analytics.sellinginfo_day
					WHERE date BETWEEN p_date - 6 AND p_date
							GROUP BY company, point, product;
							
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE analytics.jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'get_sellinginfo_week';						
	
  result := json_build_object('code','success','text',p_date,'date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION analytics.get_sellinginfo_week(indate date, OUT result json) OWNER TO postgres;

--
-- TOC entry 773 (class 1255 OID 49238)
-- Name: prepare_report(json); Type: FUNCTION; Schema: analytics; Owner: postgres
--

CREATE FUNCTION analytics.prepare_report(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	 p_company         		bigint;
	 p_point         			bigint := 0;
	 p_spoint         	  varchar;
	 p_user						 		bigint;
	 p_error		      	 	varchar;
	 p_inf  							json;
	 p_x									int;
	 p_y 									int;
	 p_a									int;
	 p_b 									int;
	 p_days 							int;
	 p_type 							int;
	 p_profit							varchar;
	 p_sql 								text;
	 
BEGIN

	-- {"user":48,"company":17,"a":80,"b":95,"x":10,"y":25,"days",90,"profit":"units/grossprofit","type":1}
	delete from analytics.temp_rep_collection;
	
	SELECT (inf)::json into p_inf;
	
	p_company  := cast(p_inf->>'company' as bigint);
	p_spoint   := lower(trim(p_inf->>'point'));	
	p_user     := cast(p_inf->>'user' as bigint);
	p_x        := cast(p_inf->>'x' as int);
	p_y        := cast(p_inf->>'y' as int);
	p_a        := cast(p_inf->>'a' as int);
	p_b        := cast(p_inf->>'b' as int);
	p_days     := cast(p_inf->>'days' as int);
	p_profit   := lower(trim(p_inf->>'profit'));
	p_type     := cast(p_inf->>'type' as int);
	
	if p_spoint <> 'all' then
		select p.stock into p_point from "public".pointset p where
		p.point = cast(p_spoint as bigint);
	end if;
	
	p_sql := '	
	insert into analytics.temp_rep_collection("user","company","product","name",code,total_line,"share",cum_share,coeff,abc,xyz)
  select
		'||p_user||',
		'||p_company||',
		c.id,
		c.name,
		c.code,
		c.total_line,
		c.share,
		c.cum_share,
		c.coeff,
		case when c.cum_share <= '||p_a||' then ''A''
				 when c.cum_share <= '||p_b||' then ''B'' else ''C''
		end as abc,
		case when c.coeff < 0 then null 
				 when c.coeff <= '||p_x||' then ''X'' 
				 when c.coeff <= '||p_y||' then ''Y'' 
				 when c.coeff is null then null else ''Z''
		end as xyz
	from (select 
					b.company,
					b.id,
					b.name,
					b.code,
					b.total_line,
					b.share,
					b.coeff,
					round(sum(b.share) OVER (ORDER BY b.share desc, b.total_line desc, b.gross_profit desc, b.name),2) as cum_share
				from (select 
								a.company,
								a.id,
								a.name,
								a.code,
								a.total_line,
								sum(a.gross_profit) as gross_profit,
								round(coalesce(case when a.total > 0 then a.total_line/a.total else 0 end * 100,0)::numeric,4) as share,'
								||case when p_profit = 'units' then
								'round(case when sum(a.units) <> 0 then (stddev_pop(a.units)/AVG(a.units)) * 100 else null end,2) as coeff'
								else
								'round(case when sum(a.gross_profit) <> 0 then (stddev_pop(a.gross_profit)/AVG(a.gross_profit)) * 100 
								else null end::numeric,2) as coeff' 
								end||'
						from (select 
										p.company,
										p.id,
										p.name, 
										p.code,
										coalesce(sum(d.units),0) as units, 
										coalesce(sum(d.gross_profit),0) as gross_profit,'
										||case when p_profit = 'units' then
											'round(coalesce(sum(sum(d.units)) OVER (PARTITION BY p.name),0),2) as total_line,
											round(coalesce(sum(sum(d.units)) OVER (),0),2) as total'
										else 
											'round(coalesce(sum(sum(d.gross_profit)) OVER (PARTITION BY p.name),0)::numeric,2) as total_line,
										round(coalesce(sum(sum(d.gross_profit)) OVER (),0)::numeric,2) as total' 
										end||'
								from
									public.products as p '
									||case when p_type = 1 then
									'right join analytics.sellinginfo_day as d on (
										p.company=d.company
										and p.id=d.product 
										and (d.point = '||p_point||' or 0 = '||p_point||')
										and d.date between current_date - '||p_days||' and current_date) '
									when p_type = 2 then
									'right join analytics.sellinginfo_week as d on(
										p.company=d.company 
										and p.id=d.product
										and (d.point = '||p_point||' or 0 = '||p_point||')
										and d.date between date_trunc(''week'',current_date-(interval ''1 week''*'||p_days||'))::date and current_date) '
									else
									'right join analytics.sellinginfo_month as d on(
										p.company=d.company 
										and p.id=d.product
										and (d.point = '||p_point||' or 0 = '||p_point||')
										and d.date between date_trunc(''month'',current_date-(interval ''1 month''*'||p_days||'))::date and current_date) '
									end||'
								where
									p.company = '||p_company||'
									and p.deleted IS FALSE
								group by d.date, p.id, p.name, p.code, p.company
								order by p.name
							)as a
						group by a.company,a.id,a.name,a.code,a.total_line,a.total,share
				)as b
		)as c
	order by c.share desc';
	
	--RAISE NOTICE 'p_sql: %', p_sql;
	
	EXECUTE p_sql;
	
  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
	WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;	 
END;
$$;


ALTER FUNCTION analytics.prepare_report(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 774 (class 1255 OID 49240)
-- Name: stockcurrent_snapshot(); Type: FUNCTION; Schema: analytics; Owner: postgres
--

CREATE FUNCTION analytics.stockcurrent_snapshot(OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
BEGIN
 
        IF (SELECT COUNT(*) FROM analytics.jobcheck WHERE jobname = 'stockcurrent_snapshot') = 0 THEN
            INSERT INTO analytics.jobcheck (jobname, last_update_start, last_update_end) 
                VALUES ('stockcurrent_snapshot', now(), NULL);
        ELSE
		-- Фиксирование даты и времени последней отработки (Начало выполнения)
		    UPDATE analytics.jobcheck
			    SET last_update_start = clock_timestamp()::timestamp
				    WHERE jobname = 'stockcurrent_snapshot';
		END IF;	
	-- Фиксирование количества товаров на конец дня
	INSERT INTO analytics.stockcurrent_part_snapshots(company,point,product,attributes,units,date,purchaseprice,snapdate,price)
		SELECT s.company,s.point,s.product,s.attributes,round(s.units::numeric,3),s.date,round(s.purchaseprice::numeric,2),current_date-1,coalesce(p.price,0)
			FROM stockcurrent_part s
				INNER JOIN stockcurrent s2 on (s.company = s2.company and s.point = s2.point and s.product = s2.product and s.attributes = s2.attributes)
				INNER JOIN storeprices p on (s2.company = p.company and s2.id = p.stock)
				INNER JOIN companies c on (s.company = c.id)
				  WHERE round(s.units::numeric,3) <> 0
						AND c.status = 'ACTIVE';		
	
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE analytics.jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'stockcurrent_snapshot';

  result := json_build_object('code','success','text','','date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION analytics.stockcurrent_snapshot(OUT result json) OWNER TO postgres;

--
-- TOC entry 775 (class 1255 OID 49241)
-- Name: add_attributes_new(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.add_attributes_new(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object       json;
 p_error           varchar;
 p_attrlist_code	 bigint;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_company         bigint;
BEGIN

	-- {"user" : 1, "listcode" : "1", "attribcode" : "1", "value" : "Гы-гы"}  

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM public.get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;
		
		-- Так как фронт не справляется(27.01.2021)
		IF cast(json_object->>'attribcode' as bigint) = 2 AND (json_object->>'value') NOT LIKE '____-__-__' THEN
			RAISE SQLSTATE 'S0001';
		END IF;

		IF json_object->>'listcode' IS NULL OR CAST(json_object->>'listcode' as bigint) = 0 THEN
		
		  INSERT INTO public.attributelistcode(id,company)
			  VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
				  RETURNING id INTO p_attrlist_code;
			
			------30.01.2023
			if not exists(select * from public.attrlist where listcode=p_attrlist_code and attribute=cast(json_object->>'attribcode' as bigint)
			   and company=p_company) then
			------30.01.2023
				 
			INSERT INTO public.attrlist(listcode,attribute,value,istemp,company)
			  VALUES(p_attrlist_code,cast(json_object->>'attribcode' as bigint),json_object->>'value',true,p_company);
			 
			 ------30.01.2023
			 end if;
			 ------30.01.2023
				
		ELSE
		
			p_attrlist_code := cast(json_object->>'listcode' as bigint);
			
		   ------30.01.2023
			if not exists(select * from public.attrlist where listcode=p_attrlist_code and attribute=cast(json_object->>'attribcode' as bigint)
			   and company=p_company) then
			------30.01.2023
			   
			INSERT INTO public.attrlist(listcode,attribute,value,istemp,company)
			  VALUES(p_attrlist_code,cast(json_object->>'attribcode' as bigint),json_object->>'value',true,p_company);
			 
			 ------30.01.2023
			 end if;
			 ------30.01.2023
			
		END IF;
		
		
			

		result := json_build_object('code','success','text',p_attrlist_code);
    return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Некорректная дата!');
		 return next;
	 WHEN OTHERS THEN
		 --RAISE NOTICE 'internal_error: %', SQLERRM;
		 --GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;















$$;


ALTER FUNCTION functioncalls.add_attributes_new(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 776 (class 1255 OID 49242)
-- Name: admin_partner_edit(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.admin_partner_edit(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;

  

BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';	
  p_text:=cast(trim(json_object->>'access') as varchar);
 
  if (exists(SELECT id, accesspartner FROM public.admin_accesspartner where id=1)) then
 
      
    UPDATE public.admin_accesspartner
SET accesspartner=cast(trim(json_object->>'access') as varchar)
WHERE id=1;
    else
    
    INSERT INTO public.admin_accesspartner
(id,accesspartner)
VALUES(1,cast(trim(json_object->>'access') as varchar));
  
  END IF;

 

	
    result := json_build_object('code',p_result,'text',p_text);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.admin_partner_edit(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 777 (class 1255 OID 49243)
-- Name: admin_partner_select(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.admin_partner_select(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;

  

BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';	
  p_text:='';
 
  if (exists(SELECT id, accesspartner FROM public.admin_accesspartner where id=1)) then
 
     SELECT accesspartner into p_text FROM public.admin_accesspartner where id=1;     
  
  END IF;

 

	
    result := json_build_object('code',p_result,'text',p_text);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.admin_partner_select(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 778 (class 1255 OID 49244)
-- Name: cashboxes_info_dop(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.cashboxes_info_dop(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;
p_company_in						 bigint;
  r                			 record;
 p_send_point		 				 bigint  := 0;


BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';	
  
  select 
json_agg(json_build_object('id',points.company,'point',points.id,'name',points.name,
				'cashboxes', (
					select json_agg(json_build_object('cashbox',cashboxes.id,'name',cashboxes.name))
						from cashboxes
							INNER JOIN points p on p.id = cashboxes.point and p.status = 'ACTIVE' and p.id = points.id
							where cashboxes.deleted=false and cashboxes.isengaged=true
							group by p.id
					)
				)) as points into j_object
 from
points  inner join  (select point from cashboxes 
where cashboxes.deleted=false and cashboxes.isengaged=true group by point) as pointsactive
 on (points.id=pointsactive.point)
 where points.status='ACTIVE' ;
 

	
    result := json_build_object('code',p_result,'points',j_object);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.cashboxes_info_dop(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 779 (class 1255 OID 49245)
-- Name: check_messages_export(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.check_messages_export(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
 json_object       json;
 p_error           varchar;
 p_invoice     varchar;
 p_type       varchar;
 p_altinvoice    varchar;
 p_cashbox_vers  varchar;
 p_cashbox_id  bigint;
 p_last_check_time    timestamp;
 p_is_deleted         boolean;
 p_date       date;

BEGIN

 -- {"cashbox" : "1", "vers" : "20.257"}  
 
 SELECT (inf)::json into json_object;
 
 p_cashbox_id := cast(json_object->>'cashbox' as bigint);
 p_cashbox_vers := cast(json_object->>'vers' as varchar);
 p_date := cast(json_object->>'date' as date);


    -- Check if cashbox is deleted
    select updatetime, deleted into p_last_check_time, p_is_deleted from cashboxes c where id = p_cashbox_id;
    IF p_is_deleted is true THEN
    result := json_build_object('code','error','text','Данная касса отключена / удалена!');
      return next;
    return;
 -- Check last check time, if less than 5 mins disregard
    elseif p_last_check_time > current_timestamp - interval '1 minutes' then
          result := json_build_object('code','error','text','Проверка накладных слишком часто');
      return next;
    return;
end if;


    -- Check last check time, if less than 5 mins disregard
    
 
 -- Update existing record
 UPDATE cashboxes
  SET version = p_cashbox_vers,
   updatetime = current_timestamp
    WHERE id = p_cashbox_id;
  
 
   SELECT 
     
       json_build_object('code','success','text','',
   'invoices', json_agg(json_build_object(
      			 'invoice', i.invoicenumber,'type_message',i."type",'altinvoice', '1','invoice_date',to_char(i.invoicedate,'DD.MM.YYYY')
      			 )order by invoicenumber)) 
			 INTO result 
		  FROM invoices i
			  INNER JOIN points p on (p.id = i.stockto)	
			  WHERE i.stockto in (
			  SELECT max(s.stock) 
	        FROM points p
		        LEFT JOIN pointset s on (s.point = p.id)
		          WHERE p.id=cast(json_object->>'point'	as bigint)
								AND p.company = cast(json_object->>'company' as bigint)
			  )
			  and type=2 
			  and cast(i.invoicedate as date)>=p_date;
   
  /* 
 SELECT json_build_object('code','success','text','',
   'invoices', json_agg(json_build_object('invoice',invoice,'type_message',type_message,'altinvoice',altinvoice,'invoice_date',to_char(coalesce(s.date,current_date),'DD.MM.YYYY'))order by invoice)) INTO result 
        FROM systemmessage s
       WHERE cashbox = cast(json_object->>'cashbox' as bigint);
  */    
      
          --WHERE cashbox = p_cashbox_id;

  --result := json_build_object('code','success','text','','invoice',p_invoice,'type',p_type,'altinvoice',p_altinvoice);

    return next;

EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'internal_error: %', SQLERRM;
  GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
  result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'invoices',json_agg());
   return next;

END;

$$;


ALTER FUNCTION functioncalls.check_messages_export(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 780 (class 1255 OID 49246)
-- Name: companies_change_dop(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.companies_change_dop(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;
p_company_in						 bigint;
  r                			 record;
 p_send_point		 				 bigint  := 0;


BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';	
 
 
 p_text:=cast(trim(json_object->>'company') as varchar);
 
 p_company_in := cast(trim(json_object->>'company') as bigint);
 
 FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM public.companies c
						  LEFT JOIN public.points p on (p.company = c.id) 
							  LEFT JOIN public.cashboxes b on (b.point = p.id)
							    WHERE company = p_company_in 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
			LOOP
				IF p_send_point <> r.point THEN
					p_send_point := r.point;
					-- Создание и заполнение накладной(инвойса)
					-- Виталя добавил тайп инвойса в values, добавил каст creator
					INSERT INTO public.invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
						VALUES(current_date,cast(trim(json_object->>'user') as bigint),'IN_PROCESS',p_company_in,p_send_point,p_send_point,12)
							RETURNING invoicenumber INTO p_invoicenumber;
				END IF;
				-- Формирование системного сообщения для терминалов для обновления справочников
				INSERT INTO public.systemmessage(point,invoice,type_message,cashbox)
					VALUES(r.point,p_invoicenumber,12,r.cashbox);
			END LOOP;
 
 
 

	
    result := json_build_object('code',p_result,'text',p_text);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.companies_change_dop(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 781 (class 1255 OID 49248)
-- Name: companiesrep_det_dop(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.companiesrep_det_dop(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;
p_company_in						 bigint;
  r                			 record;
 p_send_point		 				 bigint  := 0;


BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';	
  
 select json_agg(json_build_object('id',t.id)) into j_object from
(
select distinct(a.object) as id from admincompanies_report_details a

where a.type=cast(trim(json_object->>'type') as int) and a.date=cast(trim(json_object->>'date') as date) 

) t ; 
 
	
    result := json_build_object('code',p_result,'companies',j_object);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.companiesrep_det_dop(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 782 (class 1255 OID 49249)
-- Name: counterparties_managementm(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.counterparties_managementm(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 p_company      			 bigint;
 json_object    			 json;
 counterparties_object json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
 
BEGIN

	-- {"user" : 1, "counterparties" : {"id" : "1", "name" : 50000, "bin" : "100000", "deleted" : false, "email" : "jerk@mail.ru"}}
	-- 1-сотрудник 2-касса 3-точка

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM public.get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  -----
  FOR counterparties_object IN SELECT * FROM json_array_elements((json_object)->'counterparties')
    LOOP 
  -----	

  --SELECT (json_object)->'counterparties' into counterparties_object;

		IF cast(counterparties_object->>'id' as bigint) IS NULL THEN
		  INSERT INTO public.counterparties(name, bin, deleted, company, email)
			  VALUES (trim(counterparties_object->>'name'), trim(counterparties_object->>'bin'), cast(counterparties_object->>'deleted' as boolean),p_company,
								lower(trim(counterparties_object->>'email')))
				  RETURNING id INTO p_id; 
		ELSE
			UPDATE public.counterparties
			  SET name = trim(counterparties_object->>'name'), bin = trim(counterparties_object->>'bin'), deleted = cast(counterparties_object->>'deleted' as boolean),
						email = lower(trim(counterparties_object->>'email'))
				  WHERE id = cast(counterparties_object->>'id' as bigint);
		END IF;
		
		-----
		END LOOP;
		-----

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'counterparties_bin_idx' THEN
		 result := json_build_object('code','exception','text','Контрагент с таким БИН уже заведен в системе!');
	 ELSIF p_check = 'counterparties_name_idx' THEN
		 result := json_build_object('code','exception','text','Контрагент с таким наименованием уже заведен в системе!');
	 ELSE
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;
$$;


ALTER FUNCTION functioncalls.counterparties_managementm(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 783 (class 1255 OID 49250)
-- Name: create_function_call(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.create_function_call(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
c json;
namev text;
begin

--SELECT zapros into namev FROM public.tabl_vuzov where name=inf::json->>'zapros';
SELECT zapros into namev FROM functioncalls.function_calls where name=inf::json->>'zapros';

execute
'SELECT functioncalls.'||namev||'('''||inf||''')'
--'SELECT public.invoice_create_isp('''||inf||''')'
--'SELECT count(*) from invoicelist where invoice=171863 and company=18'
   INTO c;
--invoice_create_isp 

result:=c;

--result:=namev::json;
--result:='{"c":5}'::json;

return next;

END;

$$;


ALTER FUNCTION functioncalls.create_function_call(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 784 (class 1255 OID 49251)
-- Name: first_registration(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.first_registration(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE 
 usr       json;
 company 	 json;
 p_comp_id bigint;
 p_usr_id	 bigint;
 res       json;
 p_error	 varchar;
 p_check	 varchar;
 p_user_id bigint;
 p_general_stock bigint;
p1 bigint;
p2 bigint;
BEGIN

-- {"login" : www, "name" : "Вовчик", "pass" : "qwerty", "iin" : "шифрованная кадабра", "company" : {
--    { "name" : "Бублик ИНК", "bin" : "шифрованная кадабра", "address" : "адрес!", "head" : "кадабра", "head_iin" : "кадабра", "accountant" : "кадабра", 
--		    "accountant_iin" : "кадабра", "gcoea" : "1011", "certificatenum" : "123", "certificateseries" : "321", "certificatedate" : "2019-01-01"}
-- }}

  SELECT (inf)::json into usr;

	SELECT (usr)->>'company1' into company;


      -------16.05.2023
     
      if usr->>'comp_id' is not NULL then
      SELECT setval('companies_id_seq', cast(usr->>'comp_id' as integer)-1) into p1 ;
      end if;
      if usr->>'erp_user_id' is not NULL then
      SELECT setval('erp_users_id_seq', cast(usr->>'erp_user_id' as integer)-1) into p2;
      end if;
      -------16.05.2023



	  INSERT INTO companies(name,bin,address,head,head_iin,accountant,accountant_iin,status,gcoea,certificatenum,certificateseries,certificatedate
	  ------06.02.2023
	  ,partner_id
	  ------06.02.2023
	  )
	    VALUES(trim(company->>'name'),trim(company->>'bin'),trim(company->>'address'),trim(company->>'head'),trim(company->>'head_iin'),trim(company->>'accountant'),
                     trim(company->>'accountant_iin'),'ACTIVE',company->>'gcoea',cast(NULLIF(trim(company->>'certificatenum'),'') as integer),
										 cast(NULLIF(trim(company->>'certificateseries'),'') as integer),to_date(trim(company->>'certificatedate'),'YYYY-MM-DD')
										 
	------06.02.2023
	  ,cast(NULLIF(trim(company->>'partner_id'),'') as integer)
	  ------06.02.2023									 
										 )
		    RETURNING id INTO p_comp_id;

	  INSERT INTO erp_users(login,name,pass,iin,company,status)
	    VALUES(lower(trim(usr->>'login')),trim(usr->>'name'),usr->>'pass',trim(usr->>'iin'),p_comp_id,'ACTIVE')
			  RETURNING id INTO p_user_id;

		-- Добавляем в роль руководителя
		INSERT INTO user2roles
		  VALUES(p_user_id,1);

    INSERT INTO points(name,company,status,point_type,is_minus,address)
	    VALUES('Центральный склад',p_comp_id,'ACTIVE',0,false,trim(company->>'address'))
				RETURNING id INTO p_general_stock;
		-- По настоянию Кудрата (считаем центральный склад торговой точкой)
		INSERT INTO pointset(point,stock)
			VALUES(p_general_stock,p_general_stock);

  result := json_build_object('code','success','text',p_comp_id);
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
   IF p_check = 'erpusr_iin_idx' THEN
		 result := json_build_object('code','error','text','Пользователь с таким ИИН уже существует в системе!');
	 ELSIF p_check = 'company_bin_idx' THEN
		 result := json_build_object('code','error','text','Компания с таким БИН уже зарегистрирована в системе!');
	 ELSIF p_check = 'erpusr_log_idx' THEN
		 result := json_build_object('code','error','text','Пользователь с таким логином уже существует в системе!');
   ELSE
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;$$;


ALTER FUNCTION functioncalls.first_registration(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 785 (class 1255 OID 49252)
-- Name: goods_update(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.goods_update(addinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
	p_move 				   				json;
	units_result_min 				float8;
  p_minus					 				boolean;
	p_invoicenumber	 				bigint;
	p_invoicedate						date;
	p_company				 				bigint;
	p_code					 				varchar;
	p_text					 				varchar;
	p_error					 				varchar;
	p_status				 				varchar;
  p_stockto				 				bigint;
	r      				record;
	attrs_rec 	record;
	z												record;
	func_res					 			record;
  p_invoice_in		 				bigint;
	p_discount_invoice			bigint;
	p_discount_point				bigint;
  p_stockcurrent	 				bigint;
  p_price_old			 				float8;
  p_new_product		 				bigint;
  p_directory_upd		 		  boolean := false;
	p_new_stock			 				bigint;
  p_point_type		 				bigint;
  p_stock_to			 				bigint;
  p_units					 				float8;
  p_store_to			 				bigint;
  p_send_point		 				bigint  := 0;
  p_cashbox_exist  				boolean := false;
  p_result				 				json;
  p_func		 			    		varchar;
	p_invoice_change_prices boolean := false;
	w												record;
	p_new_invoice_dir_upd		bigint;
  p_new_invoice_cha_pri		bigint;
  p_consignment						boolean := false;
	p_categories						bigint;
	p_pieceprice_old			 	float8;
	p_wholesale_price_old				float4;
	product_object      					json;
	--p_new_attrlist_code		bigint;
	p_stock_in				bigint; 
	c json;
BEGIN
--{"invoice" : "1", "user" : "2"}

   
-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
-- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

  SELECT (addinf)::json into p_move;
		p_invoice_in := cast(p_move->>'invoice' as bigint); 
		SELECT code, text INTO p_code, p_text
      FROM public.get_company(p_move->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

FOR product_object IN SELECT * FROM json_array_elements((p_move)->'stock')
    LOOP 
	
	p_stock_in  := cast(product_object->>'id' as bigint);
	
	update public.invoicelist set purchaseprice=cast(product_object->>'purchaseprice' as double precision),
	                       newprice=cast(product_object->>'newprice' as double precision),
						   units=cast(product_object->>'units' as double precision)  where 
	invoice = p_invoice_in	AND company = p_company  and stock   = p_stock_in;
	
	END LOOP;
	
	execute
'SELECT public.goods_add('''||addinf||''')'
   INTO c;
 
result:=c;

return next;

	 
END;
$$;


ALTER FUNCTION functioncalls.goods_update(addinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 786 (class 1255 OID 49253)
-- Name: invoice_add_excel(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_add_excel(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;
p_company_in						 bigint;
  r                			 record;
 p_send_point		 				 bigint  := 0;


BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';	
 
 /*
  select 
json_agg(json_build_object(


'Category',
c."name" ,
'Name',
ws.productname,
'Code',
ws.code,
'PriceBuy',
pa.purchaseprice,
'PriceSell',
sp.price,
'Units',
ws.units ,
'Brand',
b.brand,
'Nds',
case when ws.taxid = 0 then 'нет' else 'да' end,
'Cnofeacode',
ws.Cnofeacode,
'Piece',
ws.piece,
'PieceInPack',
ws.pieceinpack,
'Unitsprid',
ws.unitsprid
					
				))  into j_object
 */
 
  select 
json_agg(json_build_object(

'Category',
name ,
'Name',
productname,
'Code',
code,
'PriceBuy',
purchaseprice,
'PriceSell',
price,
'Units',
units ,
'Brand',
brand,
'Nds',
nds,
'Cnofeacode',
Cnofeacode,
'Piece',
piece,
'PieceInPack',
pieceinpack,
'Unitsprid',
unitsprid

)) into j_object
from 
(
select
distinct

c."name" ,
ws.productname,
ws.code,
pa.purchaseprice,
sp.price,
ws.units ,
b.brand,
case when ws.taxid = 0 then 'нет' else 'да' end as nds,
ws.Cnofeacode,
ws.piece,
ws.pieceinpack,
ws.unitsprid
					
				
FROM (
          select sum(s.units) as units, max(s.id) as sid, 
            p.id, s.point as point_id, p.category as category_id, p.brand as brand_id,
            p.brand, p."name" as productname, p.code, p.taxid, s.company
         
            ,case when p.piece is true then 'да' else 'нет' end as piece,
         p.pieceinpack as pieceinpack,
        --p.pieceprice as pieceprice,
         p.unitsprid as unitsprid,
         p.Cnofeacode
          from stockcurrent s
            join products p on p.id = s.product and p.deleted = false            
          where s.units <> 0
            GROUP BY p.id, s.point, p.category, p.brand, p."name", p.code, p.taxid, s.company
        ) ws
        join points p on p.id = ws.point_id and p.status = 'ACTIVE'
        join categories c on c.id = ws.category_id and c.deleted = false
        join brands b on b."id" = ws.brand
        join storeprices sp on sp.stock = ws.sid
        join product_accounting pa on pa.company = p_company and pa.product = ws.id and pa.id in (
          select max(id) from product_accounting where company = p_company and product = ws.id
        ) 
        left join "products_barcode" on ws."id" = "products_barcode"."product" and ws."company"="products_barcode"."company"
		 WHERE ws.company = p_company
		 and  p.id=		 
		 case when (cast(trim(json_object->>'point') as bigint) is null) or (cast(trim(json_object->>'point') as bigint)=-1)
         then p.id else cast(trim(json_object->>'point') as bigint) end
         )t 
        ;
 

	
    result := json_build_object('code',p_result,'invexel',j_object);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.invoice_add_excel(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 787 (class 1255 OID 49255)
-- Name: invoice_addatributes(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_addatributes(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
	
	invoice_object   json;
 	p_error					varchar;
 	p_stock_in				bigint;
 	p_code				    varchar;
 	p_text				    varchar;
 	p_company        bigint;
 	p_deleted_cnt		int;
 	p_attrib_in			bigint;
    p_detail_in         bigint;
 	p_status				 	varchar;
 	p_has_product    int;
 	p_is_new_prod    boolean;
 	product_object      					json;
 	p_invoice        bigint;
 	p_categoryid     bigint;
 	p_brandid        bigint;
 	p_detales		  bigint;
 	attr_object      json;
 	result_object    json;
 	p_flagat    boolean;
 	p_flagdt    boolean;
 	p_json_atr  json;
 	p_json_dt   json;
 	attrmass_object json;

 	-- 13.03.2023
 	p_invoice_nomenclature bigint;
 	p_product bigint;
 	p_creator bigint;
 	p_stockfrom bigint;
 	p_stockto bigint;
 	rec record;
 	-- 13.03.2023
	
 	-- 26.06.2023
 	p_attributes_current bigint; 
 	-- 26.06.2023
    p_update_other varchar(3);
   	r record;
    p_inf json;
    p_res json;

BEGIN
	
	SELECT (inf)::json into invoice_object;  

	SELECT code, text INTO p_code, p_text
    	FROM public.get_company(invoice_object->>'user');
    
    IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
      	return next;
	END IF;
	 
	p_invoice = cast(invoice_object->>'invoiceNumber' as bigint);
	p_categoryid = cast(invoice_object->>'categoryid' as bigint);
    p_brandid = cast(invoice_object->>'brandid' as bigint);
    
    -- 13.04.2023
    select creator, stockfrom, stockto into p_creator, p_stockfrom, p_stockto
    	from invoices where invoicenumber = p_invoice and company = p_company; 
    -- 13.04.2023
     
	FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'products')
    LOOP 
	    
		p_flagat=false;
	    p_flagdt=false;
	    -------30.01.2023
	   	
	   	-- 13.04.2023
	   	p_product = cast(product_object->>'productId' as bigint);
	   	p_attributes_current = coalesce(cast(product_object->>'attributes' as bigint),0); -- 26.06.2023
	    -- 13.04.2023
	    
	    SELECT "attributes",detales into p_attrib_in,p_detales  FROM public.invoicelist 
	    	WHERE invoice=p_invoice and stock=p_product 
	   			and "attributes" = p_attributes_current;
	   	
	   	--raise sqlstate 'S0001';
	   		
	   
	  	---------23.02.2023
	    FOR attrmass_object IN SELECT * FROM json_array_elements((invoice_object)->'attributes')
        LOOP
	    ---------23.02.2023
	   	
	    	---если есть добавление
			if invoice_object->>'type'='add' then
	    	-----если есть партийные характеристики
	    	---------23.02.2023    
	    		if attrmass_object->>'at_attribcode' is not null then
	        		select  json_build_object('user',invoice_object->>'user','listcode',p_attrib_in,
	            		'attribcode',attrmass_object->>'at_attribcode','value',attrmass_object->>'at_value') into attr_object;
	    	---------23.02.2023                         
	                              
	            	
	      			select functioncalls.add_attributes_new(attr_object) into result_object;
	     			--raise sqlstate 'S0001';
	      	     
	        		if (p_attrib_in is null) or (p_attrib_in=0)  then
	        			if result_object->>'code'='success' then
	          				p_attrib_in=cast(result_object->>'text' as bigint);
	          				
	           			end if;
	           
	       			end if;
	        		
	       			p_flagat=true;
	       
	      		end if;
	      	
	      		if attrmass_object->>'dt_attribcode' is not null then
	     			select  json_build_object('user',invoice_object->>'user','listcode',p_detales,
	            		'attribcode',attrmass_object->>'dt_attribcode','value',attrmass_object->>'dt_value') into attr_object;
	      		---------23.02.2023
	      		
	            	--if p_detales is not null then raise sqlstate 'S0001'; end if;
	                               
	      			select functioncalls.add_attributes_new(attr_object) into result_object;
	     
	        		--if (p_detales is null) or (p_detales=0) then
	           
	           			if result_object->>'code'='success' then
	            			p_detales=cast(result_object->>'text' as bigint);
	            			--if p_detales is not null then raise sqlstate 'S0001'; end if;
	           			end if;
	           
	       			--end if; 
	       		
	       			p_flagdt=true;
	      
	      		end if;
	   		end if;
	     

	   	END LOOP;
	   	---------23.02.2023
	   
	   
	    select 
        jsonb_agg(
        json_build_object('code',t1.attribute,'name',values,'value',value) 
        ) into p_json_atr
        	from public.attrlist t1 inner join public.attributenames t2 on t1."attribute" =t2.id  where listcode = p_attrib_in;
        
       	select 
        jsonb_agg(
        json_build_object('code',t1.attribute,'name',values,'value',value) 
        ) into p_json_dt
        	from public.attrlist t1 inner join public.attributenames t2 on t1."attribute" =t2.id  where listcode = p_detales;
       
     
     
        update public.invoicelist 
	    set "attributes"=p_attrib_in, detales = p_detales 
	    ,categoryid=case when (p_categoryid=-1) or (p_categoryid is null) then categoryid else p_categoryid end
	    ,brandid=case when (p_brandid=-1) or (p_brandid is null) then brandid else p_brandid end
	   	,attributes_json=case when p_flagat=true then p_json_atr else attributes_json end
	    ,detales_json=case when p_flagdt=true then p_json_dt else detales_json end
	    where invoice = p_invoice and stock = p_product and "attributes" = p_attributes_current;
	  	
	   	
	   
	   	update public.products 
	    set category = case when (p_categoryid=-1) or (p_categoryid is null) then category else p_categoryid end,
	    brand = case when (p_brandid=-1) or (p_brandid is null) then brand else p_brandid end
	    ,"attributes" = case when p_attrib_in is null or p_attrib_in = 0 then "attributes" else p_attrib_in end
	    ,details = case when p_detales is null or p_detales = 0 then details else p_detales end
	    where id = p_product and company = p_company;
	   
	   	-- Рассылка изменений Справочника на все кассы			
		FOR rec IN (
			SELECT p.id as point, b.id as cashbox
				FROM companies c
					LEFT JOIN points p on (p.company = c.id) 
						LEFT JOIN cashboxes b on (b.point = p.id)
							WHERE company = p_company 
								AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									AND p.status = 'ACTIVE'
										AND c.status = 'ACTIVE'
											AND b.deleted = false
												AND b.isengaged = true
													ORDER BY p.id
		)
		LOOP		
			-- Создание и заполнение накладной(инвойса) для обновления справочников
			INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
				VALUES(now(),p_creator,'IN_PROCESS',p_company,rec.point,rec.point,3)
					RETURNING invoicenumber INTO p_invoice_nomenclature;
			
			INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company) 
				VALUES(p_invoice_nomenclature,p_product,0,0,false,false,true,p_company);					
				
			-- Формирование системного сообщения для терминалов для обновления справочников
			INSERT INTO systemmessage(point,invoice,type_message,cashbox)
				VALUES(rec.point,p_invoice_nomenclature,3,rec.cashbox);			
		END LOOP;
		
	END LOOP;
	
	/*{
    	"invoice":178353,
    	"stock":48847,
    	"company":124,
    	"zapros":"update_product_in_invoice"
		}
		*/
	   
	   	--raise sqlstate 'S0001';
	   
	-- Для обновления категории, бренда и постоянных аттрибутов у товаров с одинаковым штрихкодом
	FOR r IN ( 
	SELECT stock FROM 
	(
		SELECT stock, count(*) co
			FROM invoicelist i 
				WHERE invoice = p_invoice AND company = p_company
					GROUP BY stock
	) st
	WHERE co > 1
	)
	LOOP
		p_inf := json_build_object('company',p_company,'invoice',p_invoice,'zapros','product_update_in_invoice','stock',r.stock);
		SELECT functioncalls.update_product_in_invoice(p_inf) INTO p_res;
		IF p_res->>'code' <> 'success' THEN
			raise sqlstate 'S0002';
		END IF;
	END LOOP;
	-- Для обновления категории, бренда и постоянных аттрибутов у товаров с одинаковым штрихкодом
	
    result := json_build_object('code','success','text',p_invoice,'point',p_stockto,
    	'p_details',p_detales, 'p_attributes_current',p_attributes_current);
    return next;

EXCEPTION 

when sqlstate 'S0001' then	
	result := json_build_object('code','error','text','suka','result_object',result_object,
'p_attrib_in',p_attrib_in,'attrs_json',p_json_atr,'p_attributes_current',p_attributes_current);
	return next;
when sqlstate 'S0002' then	
	result := json_build_object('code','error','text','suka','possible error','not updated');
	return next;

WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,
	'attributes_current',p_attributes_current);

   return next;

END;

$$;


ALTER FUNCTION functioncalls.invoice_addatributes(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 578 (class 1255 OID 49257)
-- Name: invoice_addprod_dop(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_addprod_dop(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
    aa                                      record;
    p_company                               bigint;
    invoice_object                          json;
    product_object                          json;
    p_code                                      varchar;
    p_text                                      varchar;
    p_error                                 varchar;
    p_minus                                     boolean;
    p_stockfrom                             bigint;
    units_result_min                        float8;
    p_status                                        varchar;
    p_invoice_in                                    bigint;
    p_currstock_in                              bigint;
    p_is_new_prod                               boolean := false;
    p_count_prod                                    float8 := 0;
    p_check                                         varchar;
    p_amount_in                                 float8;
    p_newprice                              float8;
    p_staticprice                           float8;
    p_attributes_in                         bigint;
    p_attributes_in_json                    json;
    p_attributes_ex                         bigint;
    p_unitsprid                                 bigint;
    p_unitsprid_old                         bigint;
    p_prod_category                         bigint;
    p_prod_taxid                                    bigint;
    p_brand                                         bigint;
    p_bonusrate                                 integer;
    p_prod_cnofea                               varchar;
    p_prod_changes                              boolean := false;
    p_exist_records                         integer := 0;
    p_updateallprodprice_compare boolean;
    p_warning                                       varchar;
    p_category                                      bigint;
    p_count_attr_in                         smallint;
    p_count_attr_ex                         smallint;
    p_nds                                               boolean := false;   
    p_hot                                               integer;
    p_isdelete                                      boolean;
    p_hot_old                                       integer;
    p_isdelete_old                              boolean;
    p_scale                                         bigint;
    p_name                                              varchar;
    p_piece                                         boolean;
    p_pieceinpack                               integer;
    p_pieceprice                                    float8;
    p_piece_old                                 boolean;
    p_pieceinpack_old                       integer;
    p_type                                              integer;
    p_attr                       json := '[]';
    p_faa                                               json;
    attr_items                                  json;
    p_wholesale_price                       float4;
    p_product                                       bigint;
    p_numpor    integer;
    p_details bigint;
    p_details_json json;
 
    --p_attributes bigint;
    p_attributes_in_invoice bigint;
 
BEGIN

    -- OLD { "invoice" : "12", "user" : "1", "product" : {"id" : 111, "amount" : 2, "partnumber" : "W500", "expdate" : "15.10.2018"}}

    /* 
    { "invoice" : "12", "type" : "1", "user" : "1", "scale":0, "stockcurrentfrom" : 
       [{"id" : 111, "amount" : "500", "newprice" : "500", "p_wholesale_price": "450", "attributes" : "12","purchaseprice" : "1", "bonusrate" : 12,
            "code" : "1", "name" : "Бублики", "category" : "12", "taxid" : "0", "brand" : "Apple", "cnofea" : "Пока ХЗ", "SKU":"ХЗ", 
     "reason" : "Потому-что-гладиолус", "updateprice" : false, "type": 1, "unitsprid": 1, "isdelete":false, "hotkey":12, 
     "piece":false, "pieceinpack":0, "pieceprice":0 }]}
    */

    -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED
    -- Типы: 0 - смена цены, 1 - перемещение товара, 2 - добавление товара
    -- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение
    
    -------
    --result := json_build_object('code','success','text','3');
    --return ;
    -------

    SELECT (inf)::json INTO invoice_object;
    
    p_invoice_in := cast(invoice_object->>'invoice' as bigint);
    p_scale := cast(coalesce(nullif(trim(invoice_object->>'scale'),''),'0') as bigint);

    SELECT code, text INTO p_code, p_text
        FROM public.get_company(invoice_object->>'user');
     
    IF p_code = 'success' THEN
        p_company := cast(p_text as bigint);
    ELSE
        result := json_build_object('code',p_code,'text',p_text);
        return next;
        return;
    END IF;
        
    SELECT case when certificatenum is null then false else true end INTO p_nds
        FROM public.companies
            WHERE id = p_company;

    -- Подтягивание склада, с которого будет производится списание
    SELECT stockfrom, status INTO p_stockfrom, p_status
        FROM public.invoices
            WHERE invoicenumber = p_invoice_in
                FOR UPDATE;
            
    IF p_status IN ('ACCEPTED','DECLINE') THEN
        result := json_build_object('code','exception','text','Указанная накладная уже обработана!');
        return next;
        return;
    ELSIF p_status = 'IN_PROCESS' THEN
        result := json_build_object('code','exception','text','Указанная накладная находится в обработке!');
        return next;
        return;
    ELSIF p_status = 'CANCELED' THEN
        result := json_build_object('code','exception','text','Указанная накладная была отменена!');
        return next;
        return;
    END IF;

    --SELECT (invoice_object)->'stockcurrentfrom' into product_object;

    FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'stockcurrentfrom')
    LOOP 
        p_attributes_in := cast(product_object->>'attributes' as bigint);
        --raise sqlstate 'S0010';
        IF EXISTS(SELECT * FROM public.invoicelist WHERE invoice = p_invoice_in AND company = p_company 
            AND stock = cast(product_object->>'id' AS bigint) AND "attributes"= p_attributes_in)
                THEN p_currstock_in := product_object->>'id';   
            
            update public.invoicelist 
                set units = units + 1 
                    where invoice=p_invoice_in and company=p_company 
                        and stock=cast(product_object->>'id' as bigint) 
                            and "attributes" = p_attributes_in;
                        
            
        ELSE          

            p_currstock_in  := cast(product_object->>'id' as bigint);
            
            p_amount_in       := cast(trim(product_object->>'amount') as double precision);
      
            p_category          := coalesce(cast(product_object->>'category' as bigint),0);
            p_unitsprid         := coalesce(cast(product_object->>'unitsprid' as bigint),1);

            p_prod_changes  := false;
            
            p_hot                       := cast(nullif(trim(product_object->>'hotkey'),'') as integer);
            p_isdelete          := cast(coalesce(nullif(trim(product_object->>'isdelete'),''),'false') as boolean);
            
            p_code                  := trim(product_object->>'code');
            p_name                  := trim(product_object->>'name');
            -- Для "распоковываемых товаров"
            p_piece                 := cast(coalesce(nullif(trim(product_object->>'piece'),''),'false') as boolean);
            p_pieceinpack       := case when p_piece then cast(coalesce(product_object->>'pieceinpack','0') as bigint) else 0 end;
            p_pieceprice        := case when p_piece then cast(coalesce(product_object->>'pieceprice','0') as double precision) else 0 end;
            
            --p_attributes_in := cast(product_object->>'attributes' as bigint);
            p_details := cast(product_object->>'details' as bigint);
        
            select attributes into p_attributes_in_invoice
                from invoicelist where stock = p_currstock_in 
                    and company = p_company and invoice = p_invoice_in;
            
-- [{"code":3,"value":"","name":"Цвет"},{"code":2,"value":"","name":"Срок годности"}] -- Пример приходящего значения json
    
        
        --raise sqlstate 'S0010';
    
        IF invoice_object->>'type' = '2' and p_category <> -1 and p_attributes_in <> 0 THEN
            p_attr := product_object->>'attrlist';
            p_attributes_in := 0;
        
         
        
            FOR attr_items IN select * from json_array_elements(cast(product_object->>'attrlist'as json))
            loop
                
                
    if p_attributes_in = 0 then
                        p_attributes_in_json := public.add_attributes(
                            json_build_object(
                                'user',invoice_object->>'user',
                                'attribcode',cast(attr_items->>'code' as bigint),
                                'value',attr_items->>'value'
                            )
                        ); -- Сохраняем партийные характеристики товара
                    else
                        p_attributes_in_json := public.add_attributes(
                            json_build_object(
                                'user',invoice_object->>'user',
                                'attribcode',cast(attr_items->>'code' as bigint),
                                'value',attr_items->>'value',
                                'listcode',p_attributes_in
                            )
                        );
                    end if;
                    if (p_attributes_in_json->>'code' = 'success') then                     
                        if p_attributes_in = 0 then p_attributes_in = cast(p_attributes_in_json->>'text' as bigint); end if;
                    else
                        RAISE SQLSTATE 'S0009';
                    end if;
            END LOOP;
        END IF;
         
            IF p_piece AND p_unitsprid NOT IN (2,16,17) THEN
                RAISE SQLSTATE 'S0007';
            END IF;
            
            -- Проверка на НДС для клиентов не являющихся плательщиками НДС
            IF (product_object->>'taxid')::bigint = 1 AND NOT p_nds THEN
                RAISE SQLSTATE 'S0003';
            END IF;
            
            -- ATTR
            -- Если аттрибут все равно NULL (Потому что attrlist  null), чтобы поле атрибут могло принять значение 
            IF p_attributes_in IS NULL 
                THEN p_attributes_in := 0;
            END IF;
            
            IF (invoice_object->>'type' = '2') THEN
                    SELECT count(*) INTO p_exist_records
                        FROM public.invoicelist
                            WHERE invoice = p_invoice_in
                                AND stock = p_currstock_in
                                    AND attributes = p_attributes_in
                                        AND company = p_company;
            END IF;     

            IF p_currstock_in IS NULL THEN

                -- Проверка по коду
                
                SELECT COUNT(code) INTO p_count_prod
                  FROM public.products
                      WHERE code = p_code
                          AND company = p_company
                                AND deleted is FALSE; --OR company = 0;
                IF p_count_prod > 0 THEN
                  result := json_build_object('code','exception','text','Товар с таким кодом уже существует в системе! ('||p_code||')');
                    return next;
                    return;
                END IF;
                
                -- Проверка по имени
                                
                SELECT COUNT(code) INTO p_count_prod
                  FROM public.products
                      WHERE name = p_name
                          AND company = p_company
                                AND deleted is FALSE;
                IF p_count_prod > 0 THEN
                  result := json_build_object('code','exception','text','Товар с таким наименованием уже существует в системе! ('||p_name||')');
                    return next;
                    return;
                END IF;
                
                -- Подтягивание бонуса, если есть у категории товаров
                SELECT coalesce(bonusrate,0) INTO p_bonusrate
                    FROM public.categories
                        WHERE id = p_category;      
                
                -- Проверка наличия дубля кода в данной накладной
                SELECT id INTO p_currstock_in
                    FROM public.products_temp p
                        LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
                            WHERE p.company = p_company
                                AND p.code = p_code;
                IF FOUND THEN
                    RAISE SQLSTATE 'S0005';
                END IF;
                
                -- Проверка наличия дубля имени в данной накладной
                SELECT id INTO p_currstock_in
                    FROM public.products_temp p
                        LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
                            WHERE p.company = p_company
                                AND p.name = p_name;
                IF FOUND THEN
                    RAISE SQLSTATE 'S0006';
                END IF;             
                
                -- Добавление в темповую таблицу
                INSERT INTO public.products_temp(code,name,category,taxid,brand,cnofeacode,company,bonusrate,type,unitsprid,isdiscount, piece,pieceinpack,attributes_json)
                    VALUES(p_code,p_name,p_category,cast(product_object->>'taxid' as bigint),
                                 cast(coalesce(trim(product_object->>'brand'),'0') as bigint),trim(product_object->>'cnofea'),p_company,p_bonusrate,
                                cast(coalesce(trim(product_object->>'type'),'0') as integer),p_unitsprid,case when p_category = -1 then false else true end,
                                p_piece,p_pieceinpack,p_attr::json)
                        RETURNING id INTO p_currstock_in;

                p_is_new_prod := true;  

            ELSE    
                IF (invoice_object->>'type' <> '1') THEN
                    --flipflop
                    SELECT category, taxid, cnofeacode, coalesce(brand,0), bonusrate, unitsprid, deleted, piece, pieceinpack, type INTO p_prod_category, p_prod_taxid, p_prod_cnofea, p_brand, p_bonusrate, 
                                    p_unitsprid_old, p_isdelete_old, p_piece_old, p_pieceinpack_old, p_type
                        FROM public.products
                            WHERE id = p_currstock_in;
                    -- Проверка на добавление сертификатов
                    /*IF p_type = 1 THEN
                        RAISE SQLSTATE 'S0008';
                    END IF; */  
                    -- Проверка на изменение значений в справочнике продуктов
                    IF (p_prod_category <> cast(product_object->>'category' as bigint)) or (p_prod_taxid <> cast(product_object->>'taxid' as bigint)) or 
                        (coalesce(p_prod_cnofea,'') <> (coalesce(trim(product_object->>'cnofea'),''))) or (p_brand <> cast(coalesce(trim(product_object->>'brand'),'0') as bigint)) /*or (p_bonusrate <> 
                        cast(product_object->>'bonusrate' as bigint))*/ or (p_unitsprid_old <> p_unitsprid) or (p_isdelete_old <> p_isdelete) or (p_piece <> p_piece_old) or 
                        (p_pieceinpack <> p_pieceinpack_old) THEN
                        IF (p_prod_category = -1 AND p_prod_taxid = cast(product_object->>'taxid' as bigint)/*НДС можно менять для весовых товаров*/)THEN
                            RAISE SQLSTATE 'S0004';
                        END IF;
                        p_is_new_prod  := true; 
                        p_prod_changes := true;
                    ELSE
                        p_is_new_prod := false;
                    END IF;
                END IF;
            END IF;

        
        
        
            -- Проверять только при перемещении\списании

            IF invoice_object->>'type' NOT IN ('2','0') THEN

              -- Проверка на нулевой остаток
        SELECT units - p_amount_in INTO units_result_min
                FROM public.stockcurrent
                    WHERE id = p_currstock_in
                            AND company = p_company;
              IF /*NOT p_minus AND*/ round(units_result_min::numeric,3) < 0 THEN
              result := json_build_object('code','exception','text','Остаток на складе не должен быть меньше 0!');
                return next;
                return;
                ELSIF units_result_min IS NULL THEN
                    result := json_build_object('code','exception','text','Запись склада не была идентифицирована!');
                return next;
                return;
        END IF;
       
    
   
          ELSIF invoice_object->>'type' = '2' THEN

              SELECT updateallprodprice INTO p_updateallprodprice_compare
                  FROM public.invoicelist
                      WHERE invoice = p_invoice_in
                          AND stock = p_currstock_in
                                AND company = p_company;
                IF cast(product_object->>'updateprice' as boolean) AND p_updateallprodprice_compare THEN
                  RAISE SQLSTATE 'S0001';  
                ELSIF cast(product_object->>'updateprice' as boolean) THEN
                    p_warning := 'Был добавлен товар с признаком обновления на всех точках вне зависимости 
                                                        от атрибутов, в списке уже есть данный товар - цена продажи будет изменена при обработке!';
                ELSIF p_updateallprodprice_compare THEN
                    p_warning := 'В связи с тем, что в накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости 
                                                        от атрибутов - цена продажи будет изменена при обработке на указанную ранее!';
                END IF;

            END IF;

            
                -- Проверка набора атрибутов (только добавление) проверяется на дублирование.
                
                IF (p_attributes_in <> '0' AND p_attributes_in IS NOT NULL) AND invoice_object->>'type' = '2' THEN                  
                    SELECT count(listcode) INTO p_count_attr_in
                        FROM public.attrlist a
                            WHERE company = p_company
                                AND listcode = p_attributes_in;
                    FOR aa IN (
                            SELECT attributes as attr
                                FROM public.stockcurrent
                                    WHERE company = p_company
                                        AND product = p_currstock_in
                                            AND point = p_stockfrom
                                                AND attributes <> 0
                                                --ORDER BY attributes
                        UNION
                            SELECT attributes as attr
                                FROM public.invoicelist
                                    WHERE invoice = p_invoice_in
                                        AND company = p_company
                                            AND stock = p_currstock_in
                                                AND attributes <> 0
                                                    ORDER BY attr                    
                    )
                    LOOP        
                        SELECT count(a2.listcode), a2.listcode INTO p_count_attr_ex, p_attributes_ex
                            FROM public.attrlist a
                                INNER JOIN public.attrlist a2 on (a2.attribute = a.attribute and a2.value = a.value and a2.company = a.company and a2.listcode = aa.attr and a2.istemp = false)
                                    WHERE a.company = p_company
                                        AND a.listcode = p_attributes_in
                                            GROUP BY a2.listcode;
                        IF p_count_attr_ex = p_count_attr_in THEN
                            p_attributes_in := p_attributes_ex;
                            EXIT;
                        END IF;                 
                    END LOOP;
                    
                    -- Доработка (если сначала добавили атрибуты, а потом убрали)
                    SELECT count(*) INTO p_count_attr_ex
                        FROM public.attrlist
                            WHERE listcode = p_attributes_in;
                    IF p_count_attr_ex = 0 THEN
                        p_attributes_in := 0;
                    END IF;
                END IF;
                
                --flipflop
                
                -- Извлекаем продукт из стока для сравнения по предельным ценам
                SELECT product INTO p_product FROM public.stockcurrent WHERE id =  p_currstock_in;
                
                --условие для подтягивания цены из таблицы со статичными ценами для соответстующих товаров
                p_newprice = cast(trim(product_object->>'newprice') as double precision);
              IF p_is_new_prod = false THEN
                    select s.price into p_staticprice 
                        from public.product_static_prices s
                            inner join public.products p on p.id = s.product and p.isstaticprice = true 
                        where s.company = p_company and s.product = p_currstock_in;
                    IF p_staticprice is not null and p_staticprice < p_newprice THEN
                        RAISE SQLSTATE 'S0002';  
                    END IF;
                END IF;
                --flipflop
                
                p_wholesale_price = coalesce(cast(product_object->>'wholesale_price' as double precision),0);
                
             ------
             select coalesce(max(numpor),0)+1 into p_numpor from public.invoicelist where invoice=p_invoice_in and company=p_company 
             and stock<>p_currstock_in ;
             ------
            
            --- 09.03.2023
             if p_details = 0 then
                p_details_json = cast('[]' as json);
            else
                select
                    jsonb_agg(json_build_object('code',al."attribute",'name',an.values,'value',al.value))
                into p_details_json
                from attrlist al
                inner join attributenames an    
                on al.attribute = an.id 
                group by al.listcode 
                having(al.listcode=p_details);

            end if;
            --- 09.03.2023
                
              INSERT INTO public.invoicelist(invoice,stock,units,newprice,attributes,purchaseprice,newprod,sku,comments,prodchanges,updateallprodprice,company,hotkey,"scale",pieceprice,attributes_json,wholesale_price
                                     ----
                                     ,numpor
                                     ---- 
                                     -- 06.03.2023
                                     ,detales
                                     ,detales_json) 
                                     -- 06.03.2023
                                     
                                     
              VALUES(p_invoice_in,p_currstock_in,p_amount_in,p_newprice,
                   p_attributes_in, cast(trim(product_object->>'purchaseprice') as double precision),p_is_new_prod,trim(product_object->>'SKU'), --NEW CODE
                        trim(product_object->>'reason'), case when p_prod_changes then cast(product_object->>'category' as varchar) ||','||cast(product_object->>'taxid' as varchar) 
                            ||','|| cast(trim(coalesce(product_object->>'cnofea','')) as varchar)||','||cast(coalesce(trim(product_object->>'brand'),'0') as varchar)||','||p_bonusrate::varchar
                            ||','||p_unitsprid::varchar||','||p_isdelete::varchar||','||p_piece::varchar||','||p_pieceinpack::varchar
                            else null end, cast(product_object->>'updateprice' as boolean), p_company, p_hot, p_scale, p_pieceprice,p_attr::json,p_wholesale_price
                       ----
                      ,coalesce(p_numpor,1) 
                       ---- 
                      ,coalesce(p_details,0)
                      ,p_details_json
                      );
            --END IF;
            

            IF p_attributes_in <> '0' AND p_attributes_in IS NOT NULL THEN
                UPDATE public.attrlist 
                    SET istemp = false
                        WHERE listcode = p_attributes_in
                            AND company = p_company;
            END IF;

        -----
        END IF;
        -----
            
        END LOOP;
    

    result := json_build_object('code','success','text',p_currstock_in,'note',p_warning);
    return next;

EXCEPTION
     WHEN SQLSTATE 'S0001' THEN
        result := json_build_object('code','exception','text','В накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов!');
        return next;
     WHEN SQLSTATE 'S0002' THEN
        result := json_build_object('code','exception','text','Цена данного товара превышает предельную цену!');
        return next;
     WHEN SQLSTATE 'S0003' THEN
        result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
        return next;    
     WHEN SQLSTATE 'S0004' THEN
        result := json_build_object('code','exception','text','Нельзя изменять товар категории "Весовые товары"!');
        return next;        
     WHEN SQLSTATE 'S0005' THEN
        result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким штрих-кодом!');
        return next;
     WHEN SQLSTATE 'S0006' THEN
        result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким наименованием!');
        return next;    
     WHEN SQLSTATE 'S0007' THEN
        result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
        return next;
     WHEN SQLSTATE 'S0008' THEN
        result := json_build_object('code','exception','text','Для добавления сертификатов перейдите во вкладку "Подарочные сертификаты"!');
        return next;                
    WHEN SQLSTATE 'S0009' THEN
        result := json_build_object('code','exception','text','Ошибка при сохранении патрийных характеристик!');
        return next;
    WHEN SQLSTATE 'S0010' THEN
        result := json_build_object('code','exception','text','Ошибка!','attributes',p_attributes_in);
        return next;
    
     WHEN OTHERS THEN
       RAISE NOTICE 'internal_error: %', SQLERRM;
         GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
         IF p_check = 'invoicelist_pkey' THEN
           result := json_build_object('code','exception','text','Данный товар уже добавлен в накладную!','attribute',p_attributes_in);
       ELSIF p_check = 'prod_name_temp_idx' THEN 
           result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким наименованием ожидает обработки! Требуется сначала обработать активную накладную!');
       ELSIF p_check = 'prod_code_temp_idx' THEN 
           result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким кодом ожидает обработки! Требуется сначала обработать активную накладную!');
       ELSE
         result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
       END IF;

     return next;

END;
$$;


ALTER FUNCTION functioncalls.invoice_addprod_dop(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 579 (class 1255 OID 49259)
-- Name: invoice_addproduct_dop(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_addproduct_dop(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												integer;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id bigint;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json; 
 p_details bigint; -- 06.03.2023

BEGIN

 SELECT (inf)::json into invoice_object; 

	p_invoice_in := cast(invoice_object->>'invoice' as bigint);
	p_barcode := invoice_object->>'barcode';
	
  SELECT code, text INTO p_code, p_text
	FROM public.get_company(invoice_object->>'user');
  
	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
    return next;
		return;
	END IF;
	

SELECT 	 
      
	  
		
		products."attributes" as attributes,
		products.details,

		
      case when "brands"."brand" is not null then "brands"."id" else 0 end as brand,
	  case when "categories"."name" is not null then "categories"."id" else null end as category,
	  "products"."cnofeacode",
	  p_barcode as "code", 
	  "products"."id",
	  (select pa.purchaseprice
        from public.product_accounting as pa
        where pa.company = "products".company
          and pa.product = "products"."id"
          and pa."date" = (
            select max("date") 
            from public.product_accounting
            where company = "products".company
              and product = "products"."id") limit 1) as lastpurchaseprice,
	  "products"."name",
	   case when "storeprices"."price" is null then
	   (
	   (select pa.purchaseprice
        from public.product_accounting as pa
        where pa.company = "products".company
          and pa.product = "products"."id"
          and pa."date" = (
            select max("date") 
            from public.product_accounting
            where company = "products".company
              and product = "products"."id")  limit 1)
			  +
	(
		(select pa.purchaseprice
        from public.product_accounting as pa
        where pa.company = "products".company
          and pa.product = "products"."id"
          and pa."date" = (
            select max("date") 
            from public.product_accounting
            where company = "products".company
              and product = "products"."id")  limit 1)
		* m.rate
	)/100
	)	   
	   else "storeprices"."price" end as newprice,
	  "products"."piece",
	  "products"."pieceinpack",
	  "storeprices"."pieceprice",
	  (select pa.purchaseprice
        from public.product_accounting as pa
        where pa.company = "products".company
          and pa.product = "products"."id"
          and pa."date" = (
            select max("date") 
            from public.product_accounting
            where company = "products".company
              and product = "products"."id")  limit 1) as purchaseprice ,
	 "product_static_prices"."price" as "staticprice",		  
	   null as sku,
	   "products"."taxid",
	   "products"."unitsprid",
	   0 as updateprice,
	   --'[]' 
	    (select
					jsonb_agg(json_build_object('code',al."attribute",'name',an.values,'value',al.value))
				
				from attrlist al
				inner join attributenames an	
				on al.attribute = an.id 
				group by al.listcode 
				having(al.listcode=products."attributes")
				)
	   as attrlist,
	   "storeprices"."wholesale_price"
	   into p_attributes, p_details,p_brand,p_category,p_prod_cnofea,p_code,p_id,p_lastpurchaseprice,
	   p_name,p_newprice,p_piece,p_pieceinpack,p_pieceprice,p_purchaseprice,p_staticprice,p_sku,p_taxid,p_unitsprid,
	   p_updateprice,p_attrlist,p_wholesale_price
	   

    FROM public."products" 
    left join public."stockcurrent" on "stockcurrent"."product" = "products"."id" and "stockcurrent"."company" = "products"."company" 
    left join public."categories" on "categories"."id" = "products"."category" 
    left join public."storeprices" on "storeprices"."stock" = "stockcurrent"."id" and "storeprices"."company" = "stockcurrent"."company" 
    left join public."brands" on "brands"."id" = "products"."brand" 
    left join public."margin_plan" as "m" on "m"."object" = "products"."id" and "m"."type" = 1 and "m"."company" = "products"."company" and "m"."active" = true
    left join public."unit_spr" on "unit_spr"."id" = "products"."unitsprid" 
    left join public."product_static_prices" on "products"."id" = "product_static_prices"."product" and "product_static_prices"."company" = "products"."company" 
    left join public."products_barcode" on "products"."id" = "products_barcode"."product" and "products"."company"="products_barcode"."company"
   

    WHERE

    

      ("products"."code" = p_barcode
         or "products_barcode"."barcode"=p_barcode
	  )
	  
     

      and "products"."deleted" = false
      and "products"."company" = p_company
      and products.category <> -1
	  limit 1;

IF (p_id is null) THEN

result := json_build_object('code','exception','text','Товар не существует с таким штрих кодом!');
			    return next;
				
ELSE

	   
	   
c:= json_build_object(
	'amount',
  p_amount_in,
 'attributes',
 invoice_object->>'attributes',
 'attrlist',
  cast(invoice_object->>'attrlist' as json),
 'brand',
 p_brand,
 'category',
 p_category,
 'cnofea',
 p_prod_cnofea,
 'code',
p_code,
 'id',
 p_id,
 'staticprice',
 p_staticprice,
 'lastpurchaseprice',
 p_lastpurchaseprice,
 'name',
 p_name,
 'newprice',
 p_newprice,
 'piece',
 p_piece,
 'pieceinpack',
 p_pieceinpack,
 'pieceprice',
 p_pieceprice,
 'purchaseprice',
 p_purchaseprice,
 'sku',
 p_sku,
 'taxid',
 p_taxid,
 'unitsprid',
 p_unitsprid,
 'updateprice',
 p_updateprice,
 'wholesale_price',
 p_wholesale_price,
 -- 06.03.2023
 'details',
 p_details
 -- 06.03.2023
 
	  );
     
	
	select functioncalls.invoice_addprod_dop(json_build_object('user',invoice_object->>'user','invoice',invoice_object->>'invoice','type', invoice_object->>'type','stockcurrentfrom', 
		json_build_array(c))) into product_object;
		
	
	result := json_build_object('code','success','text',product_object,
'attributes',invoice_object->>'attributes','attrlist',cast(invoice_object->>'attrlist' as json));
	/*
	result := json_build_object('code','success','text',product_object,
'attributes',invoice_object->>'attributes', 'attrlist',cast(invoice_object->>'attrlist' as json),
'json_build_array',json_build_array(c));
	*/
    return next;
END IF;  

END;

$$;


ALTER FUNCTION functioncalls.invoice_addproduct_dop(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 584 (class 1255 OID 49261)
-- Name: invoice_create_isp(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_create_isp(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	p_invoice_in            bigint;
	invoice_object          json;
 	p_code				    varchar;
 	p_text				    varchar;
 	p_company               bigint;
 	p_invoicenumber         bigint;
 	product_object      	json;
 	p_attributes_in		 	bigint;
 	col1                    int;
 	attr_items    			json;
	invoice_create_response	json;
 	p_numpor                integer;
 	-- 06.01.2023
 	p_units                 boolean;
 	p_price                 boolean;
 	p_point                 bigint;
 	-- 06.01.2023
 	r                       record;

BEGIN
	
	-- inf : {"invoice":178533,"user":126,"price_checkbox":false,"units_checkbox":false}
	SELECT (inf)::json INTO invoice_object; 

	p_invoice_in := cast(invoice_object->>'invoice' as bigint);    
	
 	SELECT code, text INTO p_code, p_text
		FROM public.get_company(invoice_object->>'user');
  
	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
    	return NEXT;
		return;
	END IF;	

 	p_price := cast(invoice_object->>'price_checkbox' as boolean);
 	p_units := cast(invoice_object->>'units_checkbox' as boolean);
 
 
 	SELECT public.invoice_create(inf) INTO invoice_create_response;
 
 	p_invoicenumber := cast(invoice_create_response->>'text' as bigint);
 
 	SELECT stockfrom INTO p_point FROM invoices 
		WHERE invoicenumber = p_invoice_in AND company = p_company LIMIT 1;

 
	/*
 	INSERT INTO invoices(altnumber,invoicedate,creator,status,company,stockfrom,stockto,type,counterparty,isweight,"scale")
  	select altnumber,invoicedate,creator,'FORMATION',company,stockfrom,stockto,type,counterparty,isweight,"scale" 
	from invoices where invoicenumber=p_invoice_in and company=p_company
	RETURNING invoicenumber INTO p_invoicenumber;
	*/

	
	
	/*
	SELECT count(*) INTO col1 
		FROM public.invoicelist WHERE invoice = p_invoice_in 
			AND company = p_company AND json_array_length(attributes_json)>0;

 	IF col1>0 THEN

   		INSERT INTO public.attributelistcode(id,company)
			VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
				RETURNING id INTO p_attributes_in;

   		FOR  product_object  IN select attributes_json from public.invoicelist where invoice=p_invoice_in and company=p_company
   		LOOP 
			IF json_array_length(product_object)>0 THEN
	    		FOR attr_items IN select * from json_array_elements(product_object)
				LOOP
					if not exists(select * from public.attrlist where 
						listcode=p_attributes_in and  attribute=cast(attr_items->>'code'as bigint)
							and company=p_company) then
						INSERT INTO public.attrlist(listcode,value,attribute,istemp,company)
							VALUES(p_attributes_in,attr_items->>'value',cast(attr_items->>'code'as bigint),false,p_company);
				
					end if;
				END LOOP;
      		END IF;
    	END LOOP;
 	END IF; 
 
 
 	INSERT INTO public.invoicelist(
		invoice, stock, attributes, units, newprice, purchaseprice, newprod, sku, stockto, delusr, comments, prodchanges, updateallprodprice, 
		company, hotkey, scale, delete, pieceprice, oldprice, attributes_json, wholesale_price
 		----07.09.2022
	 	,numpor
	 	----07.09.2022
	 )
	SELECT p_invoicenumber, stock, (case when attributes>0 then p_attributes_in else attributes end) , 
	
	-- 06.01.2023
	case when p_units then 0
	else units end, 
	
	case when p_price then coalesce(tt.price,0)
	else newprice end,
	--units, newprice, 
	-- 06.01.2023
	
	
	
	purchaseprice, newprod, sku, stockto, delusr, comments, prodchanges, updateallprodprice, company, hotkey, scale, delete, pieceprice, oldprice, 
	attributes_json, wholesale_price
	----07.09.2022
	 ,numpor
	 ----07.09.2022
	FROM public.invoicelist 
	
	-- 06.01.2023
	left join 
	(
	select s.id, s.product, s.attributes as attr, sp.price 
	from stockcurrent s
	left join storeprices sp
	on s.id = sp.stock
	where s.company = p_company and s.point = p_point
	) tt

	on tt.product = public.invoicelist.stock 
	and tt.attr = public.invoicelist.attributes
	-- 06.01.2023
	
	where invoice=p_invoice_in and company=p_company;
	*/
	
	FOR r IN (SELECT l.*, i.stockto, st.price
		FROM invoicelist l
			INNER JOIN invoices i ON i.invoicenumber = l.invoice
			LEFT JOIN stockcurrent s ON s.product = l.stock and s."attributes" = l.attributes
			AND s.company = l.company AND s.point = p_point
			INNER JOIN storeprices st ON st.stock = s.id
			WHERE i.invoicenumber = p_invoice_in and l.company = p_company
			ORDER BY l.id)
	LOOP 
		INSERT INTO invoicelist 
		(invoice, stock, attributes, units, newprice, purchaseprice, newprod, sku, 
		stockto, delusr, "comments", prodchanges, updateallprodprice, company, hotkey,  
		"scale", "delete", pieceprice, oldprice, attributes_json, wholesale_price, numpor, 
		detales, detales_json, categoryid, brandid)
		VALUES
		(p_invoicenumber, r.stock, r.attributes, case when p_units then 0 else r.units end, 
		case when p_price then r.price else r.newprice end, r.purchaseprice, r.newprod, r.sku, 
		r.stockto, r.delusr, r."comments", r.prodchanges, r.updateallprodprice, r.company, r.hotkey,  
		r."scale", r."delete", r.pieceprice, r.oldprice, r.attributes_json, r.wholesale_price, r.numpor, 
		r.detales, r.detales_json, r.categoryid, r.brandid);
	
	END LOOP;
	
  	result := json_build_object('code','success','text',p_invoicenumber);
 	return next;

END;

$$;


ALTER FUNCTION functioncalls.invoice_create_isp(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 788 (class 1255 OID 49263)
-- Name: invoice_delprodm(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_delprodm(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	
 invoice_object   json;
 p_error					varchar;
 p_stock_in				bigint;
 p_code				    varchar;
 p_text				    varchar;
 p_company        bigint;
 p_deleted_cnt		int;
 p_attrib_in			bigint;
 p_status				 	varchar;
 p_has_product    int;
 p_is_new_prod    boolean;
 product_object      					json;
 p_attribute bigint;
 p_attributes jsonb;

BEGIN

	-- { "invoice" : "1", "user" : "1", "stock" : "12", "attributes" : "12"}
	/*
	{
        "invoice": 1,
        "user" : 1,
    	"stock": [{"id": "1", "attributes":"1"}],
    	"zapros":"invoice_delprodm"
 
	}
	*/
  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
  -- Типы: 0 - смена цены, 1 - перемещение товара, 2 - добавление товара
  -- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

	SELECT (inf)::json into invoice_object;  

		SELECT code, text INTO p_code, p_text
      FROM public.get_company(invoice_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'stock')
    LOOP 
	
		p_stock_in  := cast(product_object->>'id' as bigint);
		p_attrib_in := cast(coalesce(product_object->>'attributes','0') as bigint);
		
		SELECT i.status INTO p_status
		  FROM public.invoices i
				WHERE i.invoicenumber = cast(invoice_object->>'invoice' as bigint)
					FOR UPDATE;
		IF p_status = 'ACCEPTED' THEN
		  result := json_build_object('code','exception','text','Данная накладная(инвойс) уже была обработана! Удаление невозможно!');
      return next;
		  return;
		ELSIF p_status = 'IN_PROCESS' THEN
			result := json_build_object('code','exception','text','Данная накладная(инвойс) уже обрабатывается! Удаление невозможно!');
      return next;
		  return;
		ELSIF p_status = 'CANCELED' THEN
			result := json_build_object('code','exception','text','Данная накладная(инвойс) уже была отменена! Удаление невозможно!');
      return next;
		  return;
		END IF;
		
		
			WITH deleted AS (				
					DELETE FROM public.invoicelist
					WHERE stock = p_stock_in
						AND invoice = cast(invoice_object->>'invoice' as bigint)
							AND "attributes" = p_attrib_in 
								AND company = p_company
			IS TRUE RETURNING *) SELECT count(*) into p_deleted_cnt FROM deleted;
			
			if p_deleted_cnt = 0 then -- если товар с атрибутом не найден, тогда удаляем товар без атрибута
				DELETE FROM public.invoicelist
				WHERE stock = p_stock_in
					AND invoice = cast(invoice_object->>'invoice' as bigint)
						AND company = p_company;
			end if;
			
		
			WITH deleted AS (
				DELETE FROM public.products_temp
					WHERE id = p_stock_in
						AND company = p_company
						 and "attributes" = p_attrib_in
			IS TRUE RETURNING *) SELECT count(*) into p_deleted_cnt FROM deleted;
			
			if p_deleted_cnt > 0 then -- если товар с атрибутом не найден, тогда удаляем товар без атрибута	
				

				
				DELETE FROM public.invoicelist
				WHERE stock = p_stock_in
					AND invoice = cast(invoice_object->>'invoice' as bigint)
						AND company = p_company;
			end if;

	
	END LOOP;
	
    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;

$$;


ALTER FUNCTION functioncalls.invoice_delprodm(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 789 (class 1255 OID 49264)
-- Name: invoice_details(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_details(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

json_object json;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 
  

BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
	 select 
jsonb_build_object(

'brand',
"brands"."brand",
'brandid',
--"brands"."id" ,
"invoicelist"."brandid" ,
'categoryid',
--"categories"."id" ,
"invoicelist"."categoryid",
'category',
"categories"."name" ,


'newprice',
"invoicelist"."newprice",
'wholesale_price',
"invoicelist"."wholesale_price",
'purchaseprice',
coalesce(co.purchaseprice,invoicelist.purchaseprice) ,
'code',
coalesce(products.code,products_temp.code),
'name',
coalesce(products.name,products_temp.name) ,
'cnofeacode',
coalesce(products.cnofeacode, products_temp.cnofeacode),
'id',
coalesce(products.id, products_temp.id) ,
'taxid',
coalesce(split_part(invoicelist.prodchanges, ',', 2)::integer,products.taxid, products_temp.taxid) ,
'bonusrate',
coalesce(products.bonusrate, products_temp.bonusrate) ,
'updateallprodprice',
coalesce(invoicelist.updateallprodprice,true) ,
'unitsprid',
coalesce(coalesce(products.unitsprid,products_temp.unitsprid),1) ,
'attributescaption',
(case when attrviewtable.attributesCaption is null then '[]'::jsonb else attrviewtable.attributesCaption end),
'attributesArray',
array(select a.attribute||'|'||a.value||'|'||a.listcode||'|'||n.values
from attrlist a 
left join attributenames n on (n.id = a.attribute) where a.listcode = invoicelist.attributes
and a.company = invoicelist.company) ,
'attributes',
"invoicelist"."attributes", 
'unitspr_name',
"unit_spr"."name" ,
'detales',
invoicelist.detales,
'detalescaption',
(case when detalviewtable.attributesCaption is null then '[]'::jsonb else detalviewtable.attributesCaption end)

) into invoice_object

from "invoices" left join "invoicelist" on "invoicelist"."invoice" = "invoices"."invoicenumber" and 
"invoicelist"."company" = "invoices"."company" left join "products_temp" on "products_temp"."id" = "invoicelist"."stock" 
and "products_temp"."company" = "invoicelist"."company" left join "products" on "products"."id" = "invoicelist"."stock" and
"products"."company" = "invoicelist"."company" left join "unit_spr" on "unit_spr"."id" = "products"."unitsprid" or
"unit_spr"."id" = "products_temp"."unitsprid" 

--left join "categories" on "categories"."id" = "products"."category" or "categories"."id" = "products_temp"."category" 
--left join "brands" on "brands"."id" = "products"."brand" or "brands"."id" = "products_temp"."brand" 
left join "categories" on "categories"."id" = "invoicelist"."categoryid" 
left join "brands" on "brands"."id" = "invoicelist"."brandid" 

left join (select min(sp.purchaseprice) as purchaseprice, "sp"."company", 
"sp"."point", "sp"."product", "sp"."attributes" from "stockcurrent_part" as "sp" where "sp"."date" 
= (select min("sp2"."date") from "stockcurrent_part" as "sp2" where sp2.company = sp.company and sp2.point = sp.point 
and sp2.product = sp.product and sp2.attributes = sp.attributes and "sp2"."units" > 0) 
and "sp"."units" > 0 and "sp"."company" = p_company group by "sp"."company", "sp"."point", "sp"."product", "sp"."attributes") 
as "co" on "co"."company" = "invoices"."company" and "co"."point" = "invoices"."stockto" 
and "co"."product" = "invoicelist"."stock" and "co"."attributes" = "invoicelist"."attributes" 
left join (select 
     jsonb_agg(jsonb_build_object('attribute_id',attrlist.attribute, 
      'attribute_name', attributenames.values, 'attribute_value', attrlist.value,
      'attribute_listcode', attrlist.listcode, 'attribute_format', attributenames.format)) AS attributesCaption, 
      "attrlist"."listcode" from "attrlist" inner join "attributenames" on "attributenames"."id" = "attrlist"."attribute"
      group by "attrlist"."listcode") as "attrviewtable"
      on "attrviewtable"."listcode" = "invoicelist"."attributes"
left join (select 
     jsonb_agg(jsonb_build_object('attribute_id',attrlist.attribute, 
      'attribute_name', attributenames.values, 'attribute_value', attrlist.value,
      'attribute_listcode', attrlist.listcode, 'attribute_format', attributenames.format)) AS attributesCaption, 
      "attrlist"."listcode" from "attrlist" inner join "attributenames" on "attributenames"."id" = "attrlist"."attribute"
      group by "attrlist"."listcode") as "detalviewtable"
      on "detalviewtable"."listcode" = "invoicelist"."detales"      
where "invoices"."invoicenumber" = cast(trim(json_object->>'invoiceNumber') as bigint) and "invoicelist"."stock" = cast(trim(json_object->>'productId') as bigint) and "invoicelist"."company" = p_company limit 1;
	 


    result:=invoice_object; 
   

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.invoice_details(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 790 (class 1255 OID 49265)
-- Name: invoice_from_nomenclature(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_from_nomenclature(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

	p_invoice bigint;
    p_barcode varchar(20);
	p_product bigint;
    p_attributes bigint;
    p_details bigint;
    p_company bigint;
    p_code varchar;
    p_text varchar;
    p_error varchar;
    p_attributes_json json;
    p_details_json json;
    p_count smallint := 0;
    p_type smallint;
    p_numpor int;
	


BEGIN
	
	p_barcode := cast(inf->>'barcode' as varchar(20));
    p_type := cast(inf->>'type' as smallint) ;
	p_invoice := cast(inf->>'invoice' as bigint);

	
	select company into p_company from invoices
	where type = p_type and invoicenumber = p_invoice;

	
	select id,attributes,details
	into p_product,p_attributes,p_details
	from products
	where code = p_barcode
	and company = p_company and not deleted;
	
   
   if p_invoice is null then
   	raise sqlstate 'S0001';
   end if;
  
  if p_barcode is null then
  	raise sqlstate 'S0006';
  end if;
 
   if p_type is null then
  	raise sqlstate 'S0007';
  end if;
  
  if p_product is null then
   	raise sqlstate 'S0002';
   end if;
  
  if p_attributes is null or p_details is null then
   	raise sqlstate 'S0003';
   end if;
  
  if p_company is null then
   	raise sqlstate 'S0004';
   end if;
  
  
  if p_attributes = 0 then
  	p_attributes_json = cast('[]' as json);
  else
  	select
	jsonb_agg(json_build_object('code',al."attribute",'name',an.values,'value',al.value))
	into p_attributes_json
	from attrlist al
	inner join attributenames an	
	on al.attribute = an.id 	
	group by al.listcode 
	having(al.listcode=p_attributes);

  end if;
 
 if p_details = 0 then
 	p_details_json = cast('[]' as json);
 else
	select
	jsonb_agg(json_build_object('code',al."attribute",'name',an.values,'value',al.value))
	into p_details_json
	from attrlist al
	inner join attributenames an	
	on al.attribute = an.id 
	group by al.listcode 
	having(al.listcode=p_details);

 end if;

    select count(*) into p_count
    from invoicelist i
    where invoice = p_invoice and stock = p_product and company = p_company and "attributes" = p_attributes;
   
   if p_count > 0 then
   	raise sqlstate 'S0005';
   end if;
  
  select count(*) into p_numpor 
  from invoicelist i 
  where invoice = p_invoice and company = p_company;

	
	INSERT INTO invoicelist 
		(invoice,stock,units,newprice,purchaseprice,newprod,delusr,updateallprodprice,company,scale,delete,wholesale_price,
		"attributes",attributes_json,detales,detales_json,numpor)
			VALUES
				(p_invoice,p_product,0,0,0,true,false,true,p_company,0,false,0,p_attributes,p_attributes_json,p_details,p_details_json,p_numpor+1);
	
	res := json_build_object('code','success','text',p_company);
 	return next;
	
	exception
	when sqlstate 'S0001' then
		res := json_build_object('code','error','text','Пустая накладная!');
		return;
	when sqlstate 'S0002' then
		res := json_build_object('code','error','text','Пустой продукт!');
		return;
	when sqlstate 'S0003' then
		res := json_build_object('code','error','text','Пустой атрибут!');
		return;
	when sqlstate 'S0004' then
		res := json_build_object('code','error','text','Пустая компания!');
		return;
	
	when sqlstate 'S0005' then
		res := json_build_object('code','error','text','Данный товар уже имеется в накладной!');
		return;
	
	when sqlstate 'S0006' then 
		res := json_build_object('code','error','text','Пустой штрих-код!');
		return;
	
	when sqlstate 'S0007' then
		res := json_build_object('code','error','text','Пустой тип!');
		return;
	
	
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 res := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

 

END;

$$;


ALTER FUNCTION functioncalls.invoice_from_nomenclature(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 791 (class 1255 OID 49266)
-- Name: invoice_product_addnew(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_product_addnew(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

-- Сервис вызывается для добавления товара в накладную при приемке и редактировании. Не подойдет для списания, перемещения и т.д
DECLARE

	aa															record;
	p_company           						bigint;
	invoice_object      						json;
	product_object      						json;
	p_code				       						varchar;
	p_text				       						varchar;
	p_error			       							varchar;
	p_stockfrom		  	 							bigint;
	p_status					   						varchar;
	p_invoice_in				 						bigint;
	p_product_id			 						bigint;
	p_is_new_prod			 							boolean := false;
	p_check						 							varchar;
	p_amount_in 			   						float4;
	p_newprice 			   							float4;
	p_staticprice		   							float4;
	p_attributes_in		 							bigint;
	p_attributes_ex									bigint;
	p_unitsprid				 							bigint;
	p_unitsprid_old		 							bigint;
	p_prod_category		 							bigint;
	p_prod_taxid		 		 						bigint;
	p_brand													bigint;
	p_bonusrate											integer;
	p_prod_cnofea			 							varchar;
	p_prod_changes			 						boolean := false;
	p_exist_records		 							integer := 0;
	p_updateallprodprice_compare 		boolean;
	p_warning												varchar;
	p_category											bigint;
	p_count_attr_in									smallint;
	p_count_attr_ex									smallint;
	p_nds														boolean := false;	
	p_hot														integer;
	p_isdelete											boolean;
	p_isdelete_old									boolean;
	p_scale													bigint;
	p_name													varchar;
	p_piece													boolean;
	p_pieceinpack										integer;
	p_pieceprice										float4;
	p_piece_old											boolean;
	p_pieceinpack_old								integer;
	p_type													integer;
	attr_items    									json;
	product_count 									int;
	product_dopcount 									int;
	product_spr_attributes 					bigint;
	attrlist_count 									int;
	p_wholesale_price								float4;
	func_res					 							record;
	p_numpor    integer;
    
    -------26.01.2023
    p_detal_in		 							bigint;
    detal_items    									json;
    detallist_count 									int;
    p_brandp													bigint;
    -------26.01.2023

 
BEGIN
	
  -- { "invoice" : "12", "type" : "1", "user" : "1", "scale":0, "stockcurrentfrom" : 
  --   [{"id" : 111, "amount" : "500", "newprice" : "500", "wholesale_price":"400", "attributes" : "12","purchaseprice" : "1", "bonusrate" : 12,
	--		"code" : "1", "name" : "Бублики", "category" : "12", "taxid" : "0", "brand" : "Apple", "cnofea" : "Пока ХЗ", "SKU":"ХЗ", "reason" : "Потому-что-гладиолус", "updateprice" : false, "type": 1, "unitsprid": 1, "isdelete":false, "hotkey":12,     "piece":false, "pieceinpack":0, "pieceprice":0 }]}

  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED

	SELECT (inf)::json into invoice_object;

	p_invoice_in := cast(invoice_object->>'invoice' as bigint);
	p_scale			 := cast(coalesce(nullif(trim(invoice_object->>'scale'),''),'0') as bigint);

  SELECT code, text INTO p_code, p_text
	FROM public.get_company(invoice_object->>'user');
  
	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
    return next;
		return;
	END IF;
		
	SELECT case when certificatenum is null then false else true end INTO p_nds
	FROM public.companies
	WHERE id = p_company;

	-- Подтягивание склада, с которого будет производится списание
	SELECT stockfrom, status INTO p_stockfrom, p_status
	FROM public.invoices
	WHERE invoicenumber = p_invoice_in
	FOR UPDATE;
		
	IF p_status IN ('ACCEPTED','DECLINE') THEN
		result := json_build_object('code','exception','text','Указанная накладная уже обработана!');
		return next;
		return;
  ELSIF p_status = 'IN_PROCESS' THEN
		result := json_build_object('code','exception','text','Указанная накладная находится в обработке!');
		return next;
		return;
	ELSIF p_status = 'CANCELED' THEN
		result := json_build_object('code','exception','text','Указанная накладная была отменена!');
		return next;
		return;
	END IF;

	FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'stockcurrentfrom')
  LOOP 
		
		p_product_id  := cast(product_object->>'id' as bigint);
		p_amount_in		  := cast(trim(product_object->>'amount') as double precision);
        p_category			:= coalesce(cast(product_object->>'category' as bigint),0);
   
        ----- 
        p_brandp= coalesce(cast(product_object->>'brand' as bigint),0);
        ------	
   
        p_unitsprid			:= coalesce(cast(product_object->>'unitsprid' as bigint),1);
		p_prod_changes  := false;
		p_hot						:= cast(nullif(trim(product_object->>'hotkey'),'') as integer);
		p_isdelete			:= cast(coalesce(nullif(trim(product_object->>'isdelete'),''),'false') as boolean);
		p_code					:= trim(product_object->>'code');
		p_name					:= trim(product_object->>'name');
		-- Для "распоковываемых товаров"
		p_piece					:= cast(coalesce(nullif(trim(product_object->>'piece'),''),'false') as boolean);
		p_pieceinpack		:= case when p_piece then cast(coalesce(product_object->>'pieceinpack','0') as bigint) else 0 end;
		p_pieceprice		:= case when p_piece then cast(coalesce(product_object->>'pieceprice','0') as double precision) else 0 end;
		p_attributes_in := cast(product_object->>'attributes' as bigint);
	
	    -------26.01.2023
	    p_detal_in := cast(product_object->>'detales' as bigint);
	    -------26.01.2023
	
			
		IF p_piece AND p_unitsprid NOT IN (2,16,17) THEN
			RAISE SQLSTATE 'S0007';
		END IF;
			
		-- Проверка на НДС для клиентов не являющихся плательщиками НДС
		IF (product_object->>'taxid')::bigint = 1 AND NOT p_nds THEN
			RAISE SQLSTATE 'S0003';
		END IF;
			
			-- Пример приходящего значения json
			-- [{"code":3,"value":"","name":"Цвет"},{"code":2,"value":"","name":"Срок годности"}] 

		-- Если аттрибут все равно NULL (Потому что attrlist  null), чтобы поле атрибут могло принять значение 
		IF p_attributes_in IS NULL 
			THEN p_attributes_in := 0;
		END IF;
			
		SELECT count(*) INTO p_exist_records
			FROM public.invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND attributes = p_attributes_in
							AND company = p_company;
			
		-- необходимо проверить на дублирование по имени все новые товары.
		
		
		SELECT COUNT(*) INTO product_count FROM public.products where code = p_code and company = p_company and deleted = false;
		
		---14.07.2022
		SELECT COUNT(*) INTO product_dopcount FROM public.products_barcode where barcode = p_code and company = p_company and product = p_product_id;
		IF product_dopcount = 0 THEN
		---14.07.2022
		
			IF product_count = 0 THEN
				SELECT COUNT(*) INTO product_count FROM public.products where "lower"(name) = "lower"(p_name) and company = p_company and deleted = false;
					IF product_count > 0 THEN
				  		RAISE SQLSTATE 'S0010';
					END IF;
			END IF;
		
		---14.07.2022
		END IF;
		---14.07.2022
	
		-- 23.03.202
		IF product_dopcount > 0 THEN
			--RAISE SQLSTATE 'S0010';
			product_count := 1;
		END IF;
	    -- 23.03.2023
			
		-- Если атрибуты удалены, тогда обнуляем лискод
		IF p_attributes_in > 0 THEN
			SELECT count(*) into attrlist_count from public.attrlist where listcode = p_attributes_in;
			IF attrlist_count = 0 THEN
				p_attributes_in := 0;
			END IF;
		END IF;
		
		-------26.01.2023
	
	    IF p_detal_in > 0 THEN
			SELECT count(*) into detallist_count from public.attrlist where listcode = p_detal_in;
			IF detallist_count = 0 THEN
				p_detal_in := 0;
			END IF;
		END IF;
	
	    -------26.01.2023
		
		IF p_attributes_in > 0 THEN
			IF product_count > 0 THEN
				-- Если товар в справочнике существует, и добавились атрибуты, надо проверить входящий листкод с листкодом в справочнике.
				-- Если совпадает, тогда надо сгенерить новый листкод.
				SELECT attributes INTO product_spr_attributes FROM public.products WHERE code = p_code AND company = p_company;
				IF (product_spr_attributes = p_attributes_in) THEN
					INSERT INTO public.attributelistcode(id,company)
					VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
					RETURNING id INTO p_attributes_in;
				END IF;
			END IF;
			
			DELETE FROM public.attrlist WHERE listcode = p_attributes_in;
			-- [{code: 123, value: "белый", name: "цвет"}, {code: 122, value: "2.0", name: "Объем"}]
			FOR attr_items IN select * from json_array_elements(cast(product_object->>'attrlist'as json))
			LOOP
				INSERT INTO public.attrlist(listcode,value,attribute,istemp,company)
				VALUES(p_attributes_in,attr_items->>'value',cast(attr_items->>'code'as bigint),true,p_company);
			END LOOP;
		END IF;
			
	    -------26.01.2023
	    IF p_detal_in > 0 THEN
			IF product_count > 0 THEN
				-- Если товар в справочнике существует, и добавились атрибуты, надо проверить входящий листкод с листкодом в справочнике.
				-- Если совпадает, тогда надо сгенерить новый листкод.
				SELECT details INTO product_spr_attributes FROM public.products WHERE code = p_code AND company = p_company;
				IF (product_spr_attributes = p_detal_in) THEN
					INSERT INTO public.attributelistcode(id,company)
					VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
					RETURNING id INTO p_detal_in;
				END IF;
			END IF;
			
			DELETE FROM public.attrlist WHERE listcode = p_detal_in;
			-- [{code: 123, value: "белый", name: "цвет"}, {code: 122, value: "2.0", name: "Объем"}]
			FOR detal_items IN select * from json_array_elements(cast(product_object->>'detallist'as json))
			LOOP
				INSERT INTO public.attrlist(listcode,value,attribute,istemp,company)
				VALUES(p_detal_in,detal_items->>'value',cast(detal_items->>'code'as bigint),true,p_company);
			END LOOP;
		END IF;	
	    -------26.01.2023
	
	
		
		IF product_count = 0 THEN -- new product
				
			-- Подтягивание бонуса, если есть у категории товаров
			SELECT coalesce(bonusrate,0) INTO p_bonusrate
				FROM public.categories
					WHERE id = p_category;		
				
			-- Проверка наличия дубля кода в данной накладной
			SELECT id INTO p_product_id
				FROM public.products_temp p
					LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.code = p_code
								AND p."attributes" = p_attributes_in;
			
			IF FOUND THEN
				RAISE SQLSTATE 'S0005';
			END IF;
				
			-- Проверка наличия дубля имени в данной накладной
			SELECT id INTO p_product_id
				FROM public.products_temp p
					LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.name = p_name
								AND p."attributes" = p_attributes_in;
				
				IF FOUND THEN
					RAISE SQLSTATE 'S0006';
				END IF;				
				
			-- Добавление в темповую таблицу
			INSERT INTO public.products_temp
				(code,name,category,taxid,brand,cnofeacode,company,bonusrate,type,unitsprid,isdiscount, 
				piece,pieceinpack,attributes_json,attributes)
			VALUES(p_code,p_name,p_category,cast(product_object->>'taxid' as bigint),
				cast(coalesce(trim(product_object->>'brand'),'0') as bigint),trim(product_object->>'cnofea'),p_company,p_bonusrate,
				cast(coalesce(trim(product_object->>'type'),'0') as integer),p_unitsprid,case when p_category = -1 then false else true end,
				p_piece,p_pieceinpack,cast(product_object->>'attrlist' as json),p_attributes_in)
				RETURNING id INTO p_product_id;
			
			p_is_new_prod := true;	

		ELSE
			p_is_new_prod := false;
			--flipflop
			SELECT category, taxid, cnofeacode, coalesce(brand,0), bonusrate, unitsprid, deleted, piece, pieceinpack, type 
				INTO p_prod_category, p_prod_taxid, p_prod_cnofea, p_brand, p_bonusrate, 
					p_unitsprid_old, p_isdelete_old, p_piece_old, p_pieceinpack_old, p_type
						FROM public.products
							WHERE id = p_product_id;
						
			-- Проверка на изменение значений в справочнике продуктов
			IF (p_prod_category <> cast(product_object->>'category' as bigint)) or 
			(p_prod_taxid <> cast(product_object->>'taxid' as bigint)) or 
			(coalesce(p_prod_cnofea,'') <> (coalesce(trim(product_object->>'cnofea'),''))) or (p_brand <> cast(coalesce(trim(product_object->>'brand'),'0') as bigint)) or 
			(p_unitsprid_old <> p_unitsprid) or 
			(p_isdelete_old <> p_isdelete) or 
			(p_piece <> p_piece_old) or 
			(p_pieceinpack <> p_pieceinpack_old) THEN
				
				/*НДС можно менять для весовых товаров*/
				IF (p_prod_category = -1 AND p_prod_taxid = cast(product_object->>'taxid' as bigint))	THEN
					RAISE SQLSTATE 'S0004';
				END IF;					
				
				p_prod_changes := true;
			ELSE
				p_prod_changes := false;
			END IF;
						
		END IF;

			
		SELECT updateallprodprice INTO p_updateallprodprice_compare
			FROM public.invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND company = p_company
							AND attributes = p_attributes_in;
		
		IF cast(product_object->>'updateprice' as boolean) AND p_updateallprodprice_compare THEN
			RAISE SQLSTATE 'S0001';  
		ELSIF cast(product_object->>'updateprice' as boolean) THEN
			p_warning := 'Был добавлен товар с признаком обновления на всех точках вне зависимости от атрибутов, в списке уже есть данный товар - цена продажи будет изменена при обработке!';
		ELSIF p_updateallprodprice_compare THEN
			p_warning := 'В связи с тем, что в накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов - цена продажи будет изменена при обработке на указанную ранее!';
		END IF;

		
		-- Проверка набора атрибутов (только добавление) проверяется на дублирование.
		IF (p_attributes_in <> '0' AND p_attributes_in IS NOT NULL) THEN					
			SELECT count(listcode) INTO p_count_attr_in
				FROM public.attrlist a
					WHERE company = p_company
						AND listcode = p_attributes_in;
			
			FOR aa IN (
				SELECT attributes as attr
					FROM public.stockcurrent
						WHERE company = p_company
							AND product = p_product_id
								AND point = p_stockfrom
									AND attributes <> 0
				UNION
				SELECT attributes as attr
					FROM public.invoicelist
						WHERE invoice = p_invoice_in
							AND company = p_company
								AND stock = p_product_id
									AND attributes <> 0
										ORDER BY attr					 
			)
			LOOP		
				SELECT count(a2.listcode), a2.listcode INTO p_count_attr_ex, p_attributes_ex
					FROM public.attrlist a
						INNER JOIN public.attrlist a2 on (a2.attribute = a.attribute and a2.value = a.value and a2.company = a.company and a2.listcode = aa.attr and a2.istemp = false)
							WHERE a.company = p_company
								AND a.listcode = p_attributes_in
									GROUP BY a2.listcode;
				
				IF p_count_attr_ex = p_count_attr_in THEN
					p_attributes_in := p_attributes_ex;
					EXIT;
				END IF;					
			END LOOP;
					
		END IF;
				
		-- flipflop
		-- условие для подтягивания цены из таблицы со статичными ценами для соответстующих товаров
		p_newprice = cast(trim(product_object->>'newprice') as double precision);
		
		IF p_is_new_prod = false THEN
			SELECT s.price INTO p_staticprice 
				FROM public.product_static_prices s
					INNER JOIN public.products p ON p.id = s.product AND p.isstaticprice = true 
						WHERE s.company = p_company and s.product = p_product_id;
		
			IF p_staticprice is not null and p_staticprice < p_newprice THEN
				RAISE SQLSTATE 'S0002';  
			END IF;
		END IF;
				
		-- p_wholesale_price = cast(coalesce(product_object->>'wholesale_price',0) as double precision);
		p_wholesale_price = coalesce(cast(product_object->>'wholesale_price' as double precision),0);
		
		 ------07.09.2022
			 select max(numpor)+1 into p_numpor from public.invoicelist where invoice=p_invoice_in and company=p_company 
			 and stock<>p_product_id ;
			 ------07.09.2022

		--flipflop
		INSERT INTO public.invoicelist
		(invoice,stock,units,newprice,attributes,purchaseprice,newprod,sku,comments,prodchanges,updateallprodprice,company,hotkey,"scale",pieceprice,attributes_json,wholesale_price
		------07.09.2022
							,numpor 		  
						------07.09.2022
		-------26.01.2023
		,detales
		,detales_json
		,categoryid
		,brandid
		-------26.01.2023					
		)
		VALUES(p_invoice_in,p_product_id,p_amount_in,p_newprice, p_attributes_in, cast(trim(product_object->>'purchaseprice') as double precision),p_is_new_prod,trim(product_object->>'SKU'), --	NEW CODE
		trim(product_object->>'reason'), case when p_prod_changes then cast(product_object->>'category' as varchar) ||','||cast(product_object->>'taxid' as varchar) 
		||','|| cast(trim(coalesce(product_object->>'cnofea','')) as varchar)||','||cast(coalesce(trim(product_object->>'brand'),'0') as varchar)||','||p_bonusrate::varchar
		||','||p_unitsprid::varchar||','||p_isdelete::varchar||','||p_piece::varchar||','||p_pieceinpack::varchar
		else null end, cast(product_object->>'updateprice' as boolean), p_company, p_hot, p_scale, p_pieceprice,cast(product_object->>'attrlist' as json),p_wholesale_price
		------07.09.2022
					   ,coalesce(p_numpor,1) 
					------07.09.2022
		-------26.01.2023
		,p_detal_in
		,cast(product_object->>'detallist' as json)	
		,p_category
		,p_brandp
		-------26.01.2023					  
			  );
		
		IF p_attributes_in <> '0' AND p_attributes_in IS NOT NULL THEN
			UPDATE public.attrlist 
				SET istemp = false
					WHERE listcode = p_attributes_in
						AND company = p_company;
		END IF;

	END LOOP;

	update invoicelist
	set detales = p_detal_in
	where stock = p_product_id;
	

  result := json_build_object('code','success','text',p_product_id,'note',p_warning);
  return next;
		
	EXCEPTION
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','В накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','exception','text','Цена данного товара превышает предельную цену!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
			return next;	
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','exception','text','Нельзя изменять товар категории "Весовые товары"!');
			return next;		
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким штрих-кодом!');
			return next;
		WHEN SQLSTATE 'S0006' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким наименованием!');
			return next;	
		WHEN SQLSTATE 'S0007' THEN
			result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
			return next;
		WHEN SQLSTATE 'S0008' THEN
			result := json_build_object('code','exception','text','Для добавления сертификатов перейдите во вкладку "Подарочные сертификаты"!');
			return next;				
		WHEN SQLSTATE 'S0009' THEN
			result := json_build_object('code','exception','text','Ошибка при сохранении партийных характеристик!');
			return next;
		WHEN SQLSTATE 'S0010' THEN
			result := json_build_object('code','exception','text','В системе уже присутствует товар с таким наименованием!');
			return next;
	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			IF p_check = 'invoicelist_pkey' THEN
				result := json_build_object('code','exception','text','Данный товар уже добавлен в накладную!');
			ELSIF p_check = 'prod_name_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким наименованием ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSIF p_check = 'prod_code_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким кодом ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSE
				result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			END IF;

    return next;
		
END;
$$;


ALTER FUNCTION functioncalls.invoice_product_addnew(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 585 (class 1255 OID 57424)
-- Name: invoice_product_addnew_test(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_product_addnew_test(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

-- Сервис вызывается для добавления товара в накладную при приемке и редактировании. Не подойдет для списания, перемещения и т.д
DECLARE

	aa															record;
	p_company           						bigint;
	invoice_object      						json;
	product_object      						json;
	p_code				       						varchar;
	p_text				       						varchar;
	p_error			       							varchar;
	p_stockfrom		  	 							bigint;
	p_status					   						varchar;
	p_invoice_in				 						bigint;
	p_product_id			 						bigint;
	p_is_new_prod			 							boolean := false;
	p_check						 							varchar;
	p_amount_in 			   						float4;
	p_newprice 			   							float4;
	p_staticprice		   							float4;
	p_attributes_in		 							bigint;
	p_attributes_ex									bigint;
	p_unitsprid				 							bigint;
	p_unitsprid_old		 							bigint;
	p_prod_category		 							bigint;
	p_prod_taxid		 		 						bigint;
	p_brand													bigint;
	p_bonusrate											integer;
	p_prod_cnofea			 							varchar;
	p_prod_changes			 						boolean := false;
	p_exist_records		 							integer := 0;
	p_updateallprodprice_compare 		boolean;
	p_warning												varchar;
	p_category											bigint;
	p_count_attr_in									smallint;
	p_count_attr_ex									smallint;
	p_nds														boolean := false;	
	p_hot														integer;
	p_isdelete											boolean;
	p_isdelete_old									boolean;
	p_scale													bigint;
	p_name													varchar;
	p_piece													boolean;
	p_pieceinpack										integer;
	p_pieceprice										float4;
	p_piece_old											boolean;
	p_pieceinpack_old								integer;
	p_type													integer;
	attr_items    									json;
	product_count 									int;
	product_dopcount 									int;
	product_spr_attributes 					bigint;
	attrlist_count 									int;
	p_wholesale_price								float4;
	func_res					 							record;
	p_numpor    integer;
    
    -------26.01.2023
    p_detal_in		 							bigint;
    detal_items    									json;
    detallist_count 									int;
    p_brandp													bigint;
    -------26.01.2023

 
BEGIN
	
  -- { "invoice" : "12", "type" : "1", "user" : "1", "scale":0, "stockcurrentfrom" : 
  --   [{"id" : 111, "amount" : "500", "newprice" : "500", "wholesale_price":"400", "attributes" : "12","purchaseprice" : "1", "bonusrate" : 12,
	--		"code" : "1", "name" : "Бублики", "category" : "12", "taxid" : "0", "brand" : "Apple", "cnofea" : "Пока ХЗ", "SKU":"ХЗ", "reason" : "Потому-что-гладиолус", "updateprice" : false, "type": 1, "unitsprid": 1, "isdelete":false, "hotkey":12,     "piece":false, "pieceinpack":0, "pieceprice":0 }]}

  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED

	SELECT ('{"user":"42","invoice":"208","type":"2","zapros":"invoice_product_addnew","stockcurrentfrom":[{"id":"114","amount":"2","lastpurchaseprice":0,"newprice":200,"piece":false,"pieceinpack":0,"purchaseprice":100,"updateprice":false,"attributes":"0","attrlist":[],"wholesale_price":0,"invoicelist_id":234}]}')::json into invoice_object;
	

	p_invoice_in := cast(invoice_object->>'invoice' as bigint);
	p_scale			 := cast(coalesce(nullif(trim(invoice_object->>'scale'),''),'0') as bigint);

  SELECT code, text INTO p_code, p_text
	FROM public.get_company(invoice_object->>'user');
  
	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
    return next;
		return;
	END IF;
		
	SELECT case when certificatenum is null then false else true end INTO p_nds
	FROM public.companies
	WHERE id = p_company;

	-- Подтягивание склада, с которого будет производится списание
	SELECT stockfrom, status INTO p_stockfrom, p_status
	FROM public.invoices
	WHERE invoicenumber = p_invoice_in
	FOR UPDATE;
		
	IF p_status IN ('ACCEPTED','DECLINE') THEN
		result := json_build_object('code','exception','text','Указанная накладная уже обработана!');
		return next;
		return;
  ELSIF p_status = 'IN_PROCESS' THEN
		result := json_build_object('code','exception','text','Указанная накладная находится в обработке!');
		return next;
		return;
	ELSIF p_status = 'CANCELED' THEN
		result := json_build_object('code','exception','text','Указанная накладная была отменена!');
		return next;
		return;
	END IF;

	FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'stockcurrentfrom')
  LOOP 
		
		p_product_id  := cast(product_object->>'id' as bigint);
		p_amount_in		  := cast(trim(product_object->>'amount') as double precision);
        p_category			:= coalesce(cast(product_object->>'category' as bigint),0);
   
        ----- 
        p_brandp= coalesce(cast(product_object->>'brand' as bigint),0);
        ------	
   
        p_unitsprid			:= coalesce(cast(product_object->>'unitsprid' as bigint),1);
		p_prod_changes  := false;
		p_hot						:= cast(nullif(trim(product_object->>'hotkey'),'') as integer);
		p_isdelete			:= cast(coalesce(nullif(trim(product_object->>'isdelete'),''),'false') as boolean);
		p_code					:= trim(product_object->>'code');
		p_name					:= trim(product_object->>'name');
		-- Для "распоковываемых товаров"
		p_piece					:= cast(coalesce(nullif(trim(product_object->>'piece'),''),'false') as boolean);
		p_pieceinpack		:= case when p_piece then cast(coalesce(product_object->>'pieceinpack','0') as bigint) else 0 end;
		p_pieceprice		:= case when p_piece then cast(coalesce(product_object->>'pieceprice','0') as double precision) else 0 end;
		p_attributes_in := cast(product_object->>'attributes' as bigint);
	
	    -------26.01.2023
	    p_detal_in := cast(product_object->>'detales' as bigint);
	    -------26.01.2023
	
			
		IF p_piece AND p_unitsprid NOT IN (2,16,17) THEN
			RAISE SQLSTATE 'S0007';
		END IF;
			
		-- Проверка на НДС для клиентов не являющихся плательщиками НДС
		IF (product_object->>'taxid')::bigint = 1 AND NOT p_nds THEN
			RAISE SQLSTATE 'S0003';
		END IF;
			
			-- Пример приходящего значения json
			-- [{"code":3,"value":"","name":"Цвет"},{"code":2,"value":"","name":"Срок годности"}] 

		-- Если аттрибут все равно NULL (Потому что attrlist  null), чтобы поле атрибут могло принять значение 
		IF p_attributes_in IS NULL 
			THEN p_attributes_in := 0;
		END IF;
			
		SELECT count(*) INTO p_exist_records
			FROM public.invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND attributes = p_attributes_in
							AND company = p_company;
			
		-- необходимо проверить на дублирование по имени все новые товары.
		
		
		SELECT COUNT(*) INTO product_count FROM public.products where code = p_code and company = p_company and deleted = false;
		
		---14.07.2022
		SELECT COUNT(*) INTO product_dopcount FROM public.products_barcode where barcode = p_code and company = p_company and product = p_product_id;
		IF product_dopcount = 0 THEN
		---14.07.2022
		
			IF product_count = 0 THEN
				SELECT COUNT(*) INTO product_count FROM public.products where "lower"(name) = "lower"(p_name) and company = p_company and deleted = false;
					IF product_count > 0 THEN
				  		RAISE SQLSTATE 'S0010';
					END IF;
			END IF;
		
		---14.07.2022
		END IF;
		---14.07.2022
	
		-- 23.03.202
		IF product_dopcount > 0 THEN
			--RAISE SQLSTATE 'S0010';
			product_count := 1;
		END IF;
	    -- 23.03.2023
			
		-- Если атрибуты удалены, тогда обнуляем лискод
		IF p_attributes_in > 0 THEN
			SELECT count(*) into attrlist_count from public.attrlist where listcode = p_attributes_in;
			IF attrlist_count = 0 THEN
				p_attributes_in := 0;
			END IF;
		END IF;
		
		-------26.01.2023
	
	    IF p_detal_in > 0 THEN
			SELECT count(*) into detallist_count from public.attrlist where listcode = p_detal_in;
			IF detallist_count = 0 THEN
				p_detal_in := 0;
			END IF;
		END IF;
	
	    -------26.01.2023
		
		IF p_attributes_in > 0 THEN
			IF product_count > 0 THEN
				-- Если товар в справочнике существует, и добавились атрибуты, надо проверить входящий листкод с листкодом в справочнике.
				-- Если совпадает, тогда надо сгенерить новый листкод.
				SELECT attributes INTO product_spr_attributes FROM public.products WHERE code = p_code AND company = p_company;
				IF (product_spr_attributes = p_attributes_in) THEN
					INSERT INTO public.attributelistcode(id,company)
					VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
					RETURNING id INTO p_attributes_in;
				END IF;
			END IF;
			
			DELETE FROM public.attrlist WHERE listcode = p_attributes_in;
			-- [{code: 123, value: "белый", name: "цвет"}, {code: 122, value: "2.0", name: "Объем"}]
			FOR attr_items IN select * from json_array_elements(cast(product_object->>'attrlist'as json))
			LOOP
				INSERT INTO public.attrlist(listcode,value,attribute,istemp,company)
				VALUES(p_attributes_in,attr_items->>'value',cast(attr_items->>'code'as bigint),true,p_company);
			END LOOP;
		END IF;
			
	    -------26.01.2023
	    IF p_detal_in > 0 THEN
			IF product_count > 0 THEN
				-- Если товар в справочнике существует, и добавились атрибуты, надо проверить входящий листкод с листкодом в справочнике.
				-- Если совпадает, тогда надо сгенерить новый листкод.
				SELECT details INTO product_spr_attributes FROM public.products WHERE code = p_code AND company = p_company;
				IF (product_spr_attributes = p_detal_in) THEN
					INSERT INTO public.attributelistcode(id,company)
					VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
					RETURNING id INTO p_detal_in;
				END IF;
			END IF;
			
			DELETE FROM public.attrlist WHERE listcode = p_detal_in;
			-- [{code: 123, value: "белый", name: "цвет"}, {code: 122, value: "2.0", name: "Объем"}]
			FOR detal_items IN select * from json_array_elements(cast(product_object->>'detallist'as json))
			LOOP
				INSERT INTO public.attrlist(listcode,value,attribute,istemp,company)
				VALUES(p_detal_in,detal_items->>'value',cast(detal_items->>'code'as bigint),true,p_company);
			END LOOP;
		END IF;	
	    -------26.01.2023
	
	
		
		IF product_count = 0 THEN -- new product
				
			-- Подтягивание бонуса, если есть у категории товаров
			SELECT coalesce(bonusrate,0) INTO p_bonusrate
				FROM public.categories
					WHERE id = p_category;		
				
			-- Проверка наличия дубля кода в данной накладной
			SELECT id INTO p_product_id
				FROM public.products_temp p
					LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.code = p_code
								AND p."attributes" = p_attributes_in;
			
			IF FOUND THEN
				RAISE SQLSTATE 'S0005';
			END IF;
				
			-- Проверка наличия дубля имени в данной накладной
			SELECT id INTO p_product_id
				FROM public.products_temp p
					LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.name = p_name
								AND p."attributes" = p_attributes_in;
				
				IF FOUND THEN
					RAISE SQLSTATE 'S0006';
				END IF;				
				
			-- Добавление в темповую таблицу
			INSERT INTO public.products_temp
				(code,name,category,taxid,brand,cnofeacode,company,bonusrate,type,unitsprid,isdiscount, 
				piece,pieceinpack,attributes_json,attributes)
			VALUES(p_code,p_name,p_category,cast(product_object->>'taxid' as bigint),
				cast(coalesce(trim(product_object->>'brand'),'0') as bigint),trim(product_object->>'cnofea'),p_company,p_bonusrate,
				cast(coalesce(trim(product_object->>'type'),'0') as integer),p_unitsprid,case when p_category = -1 then false else true end,
				p_piece,p_pieceinpack,cast(product_object->>'attrlist' as json),p_attributes_in)
				RETURNING id INTO p_product_id;
			
			p_is_new_prod := true;	

		ELSE
			p_is_new_prod := false;
			--flipflop
			SELECT category, taxid, cnofeacode, coalesce(brand,0), bonusrate, unitsprid, deleted, piece, pieceinpack, type 
				INTO p_prod_category, p_prod_taxid, p_prod_cnofea, p_brand, p_bonusrate, 
					p_unitsprid_old, p_isdelete_old, p_piece_old, p_pieceinpack_old, p_type
						FROM public.products
							WHERE id = p_product_id;
						
			-- Проверка на изменение значений в справочнике продуктов
			IF (p_prod_category <> cast(product_object->>'category' as bigint)) or 
			(p_prod_taxid <> cast(product_object->>'taxid' as bigint)) or 
			(coalesce(p_prod_cnofea,'') <> (coalesce(trim(product_object->>'cnofea'),''))) or (p_brand <> cast(coalesce(trim(product_object->>'brand'),'0') as bigint)) or 
			(p_unitsprid_old <> p_unitsprid) or 
			(p_isdelete_old <> p_isdelete) or 
			(p_piece <> p_piece_old) or 
			(p_pieceinpack <> p_pieceinpack_old) THEN
				
				/*НДС можно менять для весовых товаров*/
				IF (p_prod_category = -1 AND p_prod_taxid = cast(product_object->>'taxid' as bigint))	THEN
					RAISE SQLSTATE 'S0004';
				END IF;					
				
				p_prod_changes := true;
			ELSE
				p_prod_changes := false;
			END IF;
						
		END IF;

			
		SELECT updateallprodprice INTO p_updateallprodprice_compare
			FROM public.invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND company = p_company
							AND attributes = p_attributes_in;
		
		IF cast(product_object->>'updateprice' as boolean) AND p_updateallprodprice_compare THEN
			RAISE SQLSTATE 'S0001';  
		ELSIF cast(product_object->>'updateprice' as boolean) THEN
			p_warning := 'Был добавлен товар с признаком обновления на всех точках вне зависимости от атрибутов, в списке уже есть данный товар - цена продажи будет изменена при обработке!';
		ELSIF p_updateallprodprice_compare THEN
			p_warning := 'В связи с тем, что в накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов - цена продажи будет изменена при обработке на указанную ранее!';
		END IF;

		
		-- Проверка набора атрибутов (только добавление) проверяется на дублирование.
		IF (p_attributes_in <> '0' AND p_attributes_in IS NOT NULL) THEN					
			SELECT count(listcode) INTO p_count_attr_in
				FROM public.attrlist a
					WHERE company = p_company
						AND listcode = p_attributes_in;
			
			FOR aa IN (
				SELECT attributes as attr
					FROM public.stockcurrent
						WHERE company = p_company
							AND product = p_product_id
								AND point = p_stockfrom
									AND attributes <> 0
				UNION
				SELECT attributes as attr
					FROM public.invoicelist
						WHERE invoice = p_invoice_in
							AND company = p_company
								AND stock = p_product_id
									AND attributes <> 0
										ORDER BY attr					 
			)
			LOOP		
				SELECT count(a2.listcode), a2.listcode INTO p_count_attr_ex, p_attributes_ex
					FROM public.attrlist a
						INNER JOIN public.attrlist a2 on (a2.attribute = a.attribute and a2.value = a.value and a2.company = a.company and a2.listcode = aa.attr and a2.istemp = false)
							WHERE a.company = p_company
								AND a.listcode = p_attributes_in
									GROUP BY a2.listcode;
				
				IF p_count_attr_ex = p_count_attr_in THEN
					p_attributes_in := p_attributes_ex;
					EXIT;
				END IF;					
			END LOOP;
					
		END IF;
				
		-- flipflop
		-- условие для подтягивания цены из таблицы со статичными ценами для соответстующих товаров
		p_newprice = cast(trim(product_object->>'newprice') as double precision);
		
		IF p_is_new_prod = false THEN
			SELECT s.price INTO p_staticprice 
				FROM public.product_static_prices s
					INNER JOIN public.products p ON p.id = s.product AND p.isstaticprice = true 
						WHERE s.company = p_company and s.product = p_product_id;
		
			IF p_staticprice is not null and p_staticprice < p_newprice THEN
				RAISE SQLSTATE 'S0002';  
			END IF;
		END IF;
				
		-- p_wholesale_price = cast(coalesce(product_object->>'wholesale_price',0) as double precision);
		p_wholesale_price = coalesce(cast(product_object->>'wholesale_price' as double precision),0);
		
		 ------07.09.2022
			 select max(numpor)+1 into p_numpor from public.invoicelist where invoice=p_invoice_in and company=p_company 
			 and stock<>p_product_id ;
			 ------07.09.2022

		--flipflop
		INSERT INTO public.invoicelist
		(invoice,stock,units,newprice,attributes,purchaseprice,newprod,sku,comments,prodchanges,updateallprodprice,company,hotkey,"scale",pieceprice,attributes_json,wholesale_price
		------07.09.2022
							,numpor 		  
						------07.09.2022
		-------26.01.2023
		,detales
		,detales_json
		,categoryid
		,brandid
		-------26.01.2023					
		)
		VALUES(p_invoice_in,p_product_id,p_amount_in,p_newprice, p_attributes_in, cast(trim(product_object->>'purchaseprice') as double precision),p_is_new_prod,trim(product_object->>'SKU'), --	NEW CODE
		trim(product_object->>'reason'), case when p_prod_changes then cast(product_object->>'category' as varchar) ||','||cast(product_object->>'taxid' as varchar) 
		||','|| cast(trim(coalesce(product_object->>'cnofea','')) as varchar)||','||cast(coalesce(trim(product_object->>'brand'),'0') as varchar)||','||p_bonusrate::varchar
		||','||p_unitsprid::varchar||','||p_isdelete::varchar||','||p_piece::varchar||','||p_pieceinpack::varchar
		else null end, cast(product_object->>'updateprice' as boolean), p_company, p_hot, p_scale, p_pieceprice,cast(product_object->>'attrlist' as json),p_wholesale_price
		------07.09.2022
					   ,coalesce(p_numpor,1) 
					------07.09.2022
		-------26.01.2023
		,p_detal_in
		,cast(product_object->>'detallist' as json)	
		,p_category
		,p_brandp
		-------26.01.2023					  
			  );
		
		IF p_attributes_in <> '0' AND p_attributes_in IS NOT NULL THEN
			UPDATE public.attrlist 
				SET istemp = false
					WHERE listcode = p_attributes_in
						AND company = p_company;
		END IF;

	END LOOP;

	update invoicelist
	set detales = p_detal_in
	where stock = p_product_id;
	

  result := json_build_object('code','success','text',p_product_id,'note',p_warning);
  return next;
		
	EXCEPTION
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','В накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','exception','text','Цена данного товара превышает предельную цену!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
			return next;	
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','exception','text','Нельзя изменять товар категории "Весовые товары"!');
			return next;		
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким штрих-кодом!');
			return next;
		WHEN SQLSTATE 'S0006' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким наименованием!');
			return next;	
		WHEN SQLSTATE 'S0007' THEN
			result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
			return next;
		WHEN SQLSTATE 'S0008' THEN
			result := json_build_object('code','exception','text','Для добавления сертификатов перейдите во вкладку "Подарочные сертификаты"!');
			return next;				
		WHEN SQLSTATE 'S0009' THEN
			result := json_build_object('code','exception','text','Ошибка при сохранении партийных характеристик!');
			return next;
		WHEN SQLSTATE 'S0010' THEN
			result := json_build_object('code','exception','text','В системе уже присутствует товар с таким наименованием!');
			return next;
	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			IF p_check = 'invoicelist_pkey' THEN
				result := json_build_object('code','exception','text','Данный товар уже добавлен в накладную!');
			ELSIF p_check = 'prod_name_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким наименованием ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSIF p_check = 'prod_code_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким кодом ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSE
				result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			END IF;

    return next;
		
END;
$$;


ALTER FUNCTION functioncalls.invoice_product_addnew_test(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 792 (class 1255 OID 49268)
-- Name: invoice_product_up(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_product_up(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

-- Сервис вызывается для добавления товара в накладную при приемке и редактировании. Не подойдет для списания, перемещения и т.д
DECLARE

	aa															record;
	p_company           						bigint;
	invoice_object      						json;
	product_object      						json;
	p_code				       						varchar;
	p_text				       						varchar;
	p_error			       							varchar;
	p_stockfrom		  	 							bigint;
	p_status					   						varchar;
	p_invoice_in				 						bigint;
	p_product_id			 						bigint;
	p_is_new_prod			 							boolean := false;
	p_check						 							varchar;
	p_amount_in 			   						float4;
	p_newprice 			   							float4;
	p_staticprice		   							float4;
	p_attributes_in		 							bigint;
	p_attributes_ex									bigint;
	p_unitsprid				 							bigint;
	p_unitsprid_old		 							bigint;
	p_prod_category		 							bigint;
	p_prod_taxid		 		 						bigint;
	p_brand													bigint;
	p_bonusrate											integer;
	p_prod_cnofea			 							varchar;
	p_prod_changes			 						boolean := false;
	p_exist_records		 							integer := 0;
	p_updateallprodprice_compare 		boolean;
	p_warning												varchar;
	p_category											bigint;
	p_count_attr_in									smallint;
	p_count_attr_ex									smallint;
	p_nds														boolean := false;	
	p_hot														integer;
	p_isdelete											boolean;
	p_isdelete_old									boolean;
	p_scale													bigint;
	p_name													varchar;
	p_piece													boolean;
	p_pieceinpack										integer;
	p_pieceprice										float4;
	p_piece_old											boolean;
	p_pieceinpack_old								integer;
	p_type													integer;
	attr_items    									json;
	product_count 									int;
	product_dopcount 									int;
	product_spr_attributes 					bigint;
	attrlist_count 									int;
	p_wholesale_price								float4;
	func_res					 							record;
	p_numpor    integer;
	p_name_nov													varchar;
    product_jnov                     json;
	
	
BEGIN
	
  -- { "invoice" : "12", "type" : "1", "user" : "1", "scale":0, "stockcurrentfrom" : 
  --   [{"id" : 111, "amount" : "500", "newprice" : "500", "wholesale_price":"400", "attributes" : "12","purchaseprice" : "1", "bonusrate" : 12,
	--		"code" : "1", "name" : "Бублики", "category" : "12", "taxid" : "0", "brand" : "Apple", "cnofea" : "Пока ХЗ", "SKU":"ХЗ", "reason" : "Потому-что-гладиолус", "updateprice" : false, "type": 1, "unitsprid": 1, "isdelete":false, "hotkey":12,     "piece":false, "pieceinpack":0, "pieceprice":0 }]}

  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED

	SELECT (inf)::json into invoice_object;

	p_invoice_in := cast(invoice_object->>'invoice' as bigint);
	p_scale			 := cast(coalesce(nullif(trim(invoice_object->>'scale'),''),'0') as bigint);

  SELECT code, text INTO p_code, p_text
	FROM public.get_company(invoice_object->>'user');
  
	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
    return next;
		return;
	END IF;
		
	SELECT case when certificatenum is null then false else true end INTO p_nds
	FROM public.companies
	WHERE id = p_company;

	-- Подтягивание склада, с которого будет производится списание
	SELECT stockfrom, status INTO p_stockfrom, p_status
	FROM public.invoices
	WHERE invoicenumber = p_invoice_in
	FOR UPDATE;
		
	IF p_status IN ('ACCEPTED','DECLINE') THEN
		result := json_build_object('code','exception','text','Указанная накладная уже обработана!');
		return next;
		return;
  ELSIF p_status = 'IN_PROCESS' THEN
		result := json_build_object('code','exception','text','Указанная накладная находится в обработке!');
		return next;
		return;
	ELSIF p_status = 'CANCELED' THEN
		result := json_build_object('code','exception','text','Указанная накладная была отменена!');
		return next;
		return;
	END IF;

	FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'stockcurrentfrom')
  LOOP 
		
		p_product_id  := cast(product_object->>'id' as bigint);
		p_amount_in		  := cast(trim(product_object->>'amount') as double precision);
    p_category			:= coalesce(cast(product_object->>'category' as bigint),0);
		p_unitsprid			:= coalesce(cast(product_object->>'unitsprid' as bigint),1);
		p_prod_changes  := false;
		p_hot						:= cast(nullif(trim(product_object->>'hotkey'),'') as integer);
		p_isdelete			:= cast(coalesce(nullif(trim(product_object->>'isdelete'),''),'false') as boolean);
		p_code					:= trim(product_object->>'code');
		p_name					:= trim(product_object->>'name');
		-- Для "распоковываемых товаров"
		p_piece					:= cast(coalesce(nullif(trim(product_object->>'piece'),''),'false') as boolean);
		p_pieceinpack		:= case when p_piece then cast(coalesce(product_object->>'pieceinpack','0') as bigint) else 0 end;
		p_pieceprice		:= case when p_piece then cast(coalesce(product_object->>'pieceprice','0') as double precision) else 0 end;
		p_attributes_in := cast(product_object->>'attributes' as bigint);
		
		
		----09.09.2022
		 select public.invoice_delprod(json_build_object(
			       'user',invoice_object->>'user',
				   'invoice',invoice_object->>'invoice',
			       'stock',p_product_id,
			       'attributes',coalesce(p_attributes_in,0) 
		 )
							   ) into product_jnov;		
		----09.09.2022
		
			
		IF p_piece AND p_unitsprid NOT IN (2,16,17) THEN
			RAISE SQLSTATE 'S0007';
		END IF;
			
		-- Проверка на НДС для клиентов не являющихся плательщиками НДС
		IF (product_object->>'taxid')::bigint = 1 AND NOT p_nds THEN
			RAISE SQLSTATE 'S0003';
		END IF;
			
			-- Пример приходящего значения json
			-- [{"code":3,"value":"","name":"Цвет"},{"code":2,"value":"","name":"Срок годности"}] 

		-- Если аттрибут все равно NULL (Потому что attrlist  null), чтобы поле атрибут могло принять значение 
		IF p_attributes_in IS NULL 
			THEN p_attributes_in := 0;
		END IF;
			
		SELECT count(*) INTO p_exist_records
			FROM public.invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND attributes = p_attributes_in
							AND company = p_company;
			
		-- необходимо проверить на дублирование по имени все новые товары.
		
		
		SELECT COUNT(*) INTO product_count FROM public.products where code = p_code and company = p_company and deleted = false;
		
		---14.07.2022
		SELECT COUNT(*) INTO product_dopcount FROM public.products_barcode where barcode = p_code and company = p_company and product = p_product_id;
		IF product_dopcount = 0 THEN
		---14.07.2022
		
		IF product_count = 0 THEN
			SELECT COUNT(*) INTO product_count FROM public.products where "lower"(name) = "lower"(p_name) and company = p_company and deleted = false;
				IF product_count > 0 THEN
				  RAISE SQLSTATE 'S0010';
				
				END IF;
		END IF;
		
		---14.07.2022
		END IF;
		---14.07.2022
			
		-- Если атрибуты удалены, тогда обнуляем лискод
		IF p_attributes_in > 0 THEN
			SELECT count(*) into attrlist_count from public.attrlist where listcode = p_attributes_in;
			IF attrlist_count = 0 THEN
				p_attributes_in := 0;
			END IF;
		END IF;
		
		
		
		IF p_attributes_in > 0 THEN
			IF product_count > 0 THEN
				-- Если товар в справочнике существует, и добавились атрибуты, надо проверить входящий листкод с листкодом в справочнике.
				-- Если совпадает, тогда надо сгенерить новый листкод.
				SELECT attributes INTO product_spr_attributes FROM public.products WHERE code = p_code AND company = p_company;
				IF (product_spr_attributes = p_attributes_in) THEN
					INSERT INTO public.attributelistcode(id,company)
					VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
					RETURNING id INTO p_attributes_in;
				END IF;
			END IF;
			
			DELETE FROM public.attrlist WHERE listcode = p_attributes_in;
			-- [{code: 123, value: "белый", name: "цвет"}, {code: 122, value: "2.0", name: "Объем"}]
			FOR attr_items IN select * from json_array_elements(cast(product_object->>'attrlist'as json))
			LOOP
				INSERT INTO public.attrlist(listcode,value,attribute,istemp,company)
				VALUES(p_attributes_in,attr_items->>'value',cast(attr_items->>'code'as bigint),true,p_company);
			END LOOP;
		END IF;
			
		
		IF product_count = 0 THEN -- new product
				
			-- Подтягивание бонуса, если есть у категории товаров
			SELECT coalesce(bonusrate,0) INTO p_bonusrate
				FROM public.categories
					WHERE id = p_category;		
				
			-- Проверка наличия дубля кода в данной накладной
			SELECT id INTO p_product_id
				FROM public.products_temp p
					LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.code = p_code
								AND p."attributes" = p_attributes_in;
			
			IF FOUND THEN
				RAISE SQLSTATE 'S0005';
			END IF;
				
			-- Проверка наличия дубля имени в данной накладной
			SELECT id INTO p_product_id
				FROM public.products_temp p
					LEFT JOIN public.invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.name = p_name
								AND p."attributes" = p_attributes_in;
				
				IF FOUND THEN
					RAISE SQLSTATE 'S0006';
				END IF;				
				
			-- Добавление в темповую таблицу
			INSERT INTO public.products_temp
				(code,name,category,taxid,brand,cnofeacode,company,bonusrate,type,unitsprid,isdiscount, 
				piece,pieceinpack,attributes_json,attributes)
			VALUES(p_code,p_name,p_category,cast(product_object->>'taxid' as bigint),
				cast(coalesce(trim(product_object->>'brand'),'0') as bigint),trim(product_object->>'cnofea'),p_company,p_bonusrate,
				cast(coalesce(trim(product_object->>'type'),'0') as integer),p_unitsprid,case when p_category = -1 then false else true end,
				p_piece,p_pieceinpack,cast(product_object->>'attrlist' as json),p_attributes_in)
				RETURNING id INTO p_product_id;
			
			p_is_new_prod := true;	

		ELSE
			p_is_new_prod := false;
			--flipflop
			SELECT category, taxid, cnofeacode, coalesce(brand,0), bonusrate, unitsprid, deleted, piece, pieceinpack, type 
				INTO p_prod_category, p_prod_taxid, p_prod_cnofea, p_brand, p_bonusrate, 
					p_unitsprid_old, p_isdelete_old, p_piece_old, p_pieceinpack_old, p_type
						FROM public.products
							WHERE id = p_product_id;
						
			-- Проверка на изменение значений в справочнике продуктов
			IF (p_prod_category <> cast(product_object->>'category' as bigint)) or 
			(p_prod_taxid <> cast(product_object->>'taxid' as bigint)) or 
			(coalesce(p_prod_cnofea,'') <> (coalesce(trim(product_object->>'cnofea'),''))) or (p_brand <> cast(coalesce(trim(product_object->>'brand'),'0') as bigint)) or 
			(p_unitsprid_old <> p_unitsprid) or 
			(p_isdelete_old <> p_isdelete) or 
			(p_piece <> p_piece_old) or 
			(p_pieceinpack <> p_pieceinpack_old) THEN
				
				/*НДС можно менять для весовых товаров*/
				IF (p_prod_category = -1 AND p_prod_taxid = cast(product_object->>'taxid' as bigint))	THEN
					RAISE SQLSTATE 'S0004';
				END IF;					
				
				p_prod_changes := true;
			ELSE
				p_prod_changes := false;
			END IF;
						
		END IF;

			
		SELECT updateallprodprice INTO p_updateallprodprice_compare
			FROM public.invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND company = p_company
							AND attributes = p_attributes_in;
		
		IF cast(product_object->>'updateprice' as boolean) AND p_updateallprodprice_compare THEN
			RAISE SQLSTATE 'S0001';  
		ELSIF cast(product_object->>'updateprice' as boolean) THEN
			p_warning := 'Был добавлен товар с признаком обновления на всех точках вне зависимости от атрибутов, в списке уже есть данный товар - цена продажи будет изменена при обработке!';
		ELSIF p_updateallprodprice_compare THEN
			p_warning := 'В связи с тем, что в накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов - цена продажи будет изменена при обработке на указанную ранее!';
		END IF;

		
		-- Проверка набора атрибутов (только добавление) проверяется на дублирование.
		IF (p_attributes_in <> '0' AND p_attributes_in IS NOT NULL) THEN					
			SELECT count(listcode) INTO p_count_attr_in
				FROM public.attrlist a
					WHERE company = p_company
						AND listcode = p_attributes_in;
			
			FOR aa IN (
				SELECT attributes as attr
					FROM public.stockcurrent
						WHERE company = p_company
							AND product = p_product_id
								AND point = p_stockfrom
									AND attributes <> 0
				UNION
				SELECT attributes as attr
					FROM public.invoicelist
						WHERE invoice = p_invoice_in
							AND company = p_company
								AND stock = p_product_id
									AND attributes <> 0
										ORDER BY attr					 
			)
			LOOP		
				SELECT count(a2.listcode), a2.listcode INTO p_count_attr_ex, p_attributes_ex
					FROM public.attrlist a
						INNER JOIN public.attrlist a2 on (a2.attribute = a.attribute and a2.value = a.value and a2.company = a.company and a2.listcode = aa.attr and a2.istemp = false)
							WHERE a.company = p_company
								AND a.listcode = p_attributes_in
									GROUP BY a2.listcode;
				
				IF p_count_attr_ex = p_count_attr_in THEN
					p_attributes_in := p_attributes_ex;
					EXIT;
				END IF;					
			END LOOP;
					
		END IF;
				
		-- flipflop
		-- условие для подтягивания цены из таблицы со статичными ценами для соответстующих товаров
		p_newprice = cast(trim(product_object->>'newprice') as double precision);
		
		IF p_is_new_prod = false THEN
			SELECT s.price INTO p_staticprice 
				FROM public.product_static_prices s
					INNER JOIN public.products p ON p.id = s.product AND p.isstaticprice = true 
						WHERE s.company = p_company and s.product = p_product_id;
		
			IF p_staticprice is not null and p_staticprice < p_newprice THEN
				RAISE SQLSTATE 'S0002';  
			END IF;
		END IF;
				
		-- p_wholesale_price = cast(coalesce(product_object->>'wholesale_price',0) as double precision);
		p_wholesale_price = coalesce(cast(product_object->>'wholesale_price' as double precision),0);
		
		 ------07.09.2022
			 select max(numpor)+1 into p_numpor from public.invoicelist where invoice=p_invoice_in and company=p_company 
			 and stock<>p_product_id ;
			 ------07.09.2022

		--flipflop
		INSERT INTO public.invoicelist
		(invoice,stock,units,newprice,attributes,purchaseprice,newprod,sku,comments,prodchanges,updateallprodprice,company,hotkey,"scale",pieceprice,attributes_json,wholesale_price
		------07.09.2022
							,numpor 		  
						------07.09.2022
		)
		VALUES(p_invoice_in,p_product_id,p_amount_in,p_newprice, p_attributes_in, cast(trim(product_object->>'purchaseprice') as double precision),p_is_new_prod,trim(product_object->>'SKU'), --	NEW CODE
		trim(product_object->>'reason'), case when p_prod_changes then cast(product_object->>'category' as varchar) ||','||cast(product_object->>'taxid' as varchar) 
		||','|| cast(trim(coalesce(product_object->>'cnofea','')) as varchar)||','||cast(coalesce(trim(product_object->>'brand'),'0') as varchar)||','||p_bonusrate::varchar
		||','||p_unitsprid::varchar||','||p_isdelete::varchar||','||p_piece::varchar||','||p_pieceinpack::varchar
		else null end, cast(product_object->>'updateprice' as boolean), p_company, p_hot, p_scale, p_pieceprice,cast(product_object->>'attrlist' as json),p_wholesale_price
		------07.09.2022
					   ,coalesce(p_numpor,1) 
					------07.09.2022	  
			  );
			  
		----09.09.2022
		select max(name) into p_name_nov  from public.products p1 left join public.products_barcode p2 on (p1.id=p2.product and p1.company=p2.company)
        where (p1.code=p_code or p2.barcode=p_code) and p1.company=p_company;
		
		if (p_name_nov is not null and trim(p_name_nov)<>trim(p_name)) then
		  
		  update public.products set name=p_name where 
		  id=(select max(p1.id)  from public.products p1 left join public.products_barcode p2 on (p1.id=p2.product and p1.company=p2.company)
        where (p1.code=p_code or p2.barcode=p_code) and p1.company=p_company);
		  
		end if;
		
		select max(name) into p_name_nov  from public.products_temp p1 
		where p1.code=p_code and p1.company=p_company;
		
		if (p_name_nov is not null and trim(p_name_nov)<>trim(p_name)) then
		  
		  update public.products_temp set name=p_name where 
		  id=(select max(id) into p_name_nov  from public.products_temp p1 
		where p1.code=p_code and p1.company=p_company);
		  
		end if;
		
		----09.09.2022
		
		IF p_attributes_in <> '0' AND p_attributes_in IS NOT NULL THEN
			UPDATE public.attrlist 
				SET istemp = false
					WHERE listcode = p_attributes_in
						AND company = p_company;
		END IF;

	END LOOP;

  result := json_build_object('code','success','text',p_product_id,'note',p_warning);
  return next;
		
	EXCEPTION
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','В накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','exception','text','Цена данного товара превышает предельную цену!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
			return next;	
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','exception','text','Нельзя изменять товар категории "Весовые товары"!');
			return next;		
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким штрих-кодом!');
			return next;
		WHEN SQLSTATE 'S0006' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким наименованием!');
			return next;	
		WHEN SQLSTATE 'S0007' THEN
			result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
			return next;
		WHEN SQLSTATE 'S0008' THEN
			result := json_build_object('code','exception','text','Для добавления сертификатов перейдите во вкладку "Подарочные сертификаты"!');
			return next;				
		WHEN SQLSTATE 'S0009' THEN
			result := json_build_object('code','exception','text','Ошибка при сохранении партийных характеристик!');
			return next;
		WHEN SQLSTATE 'S0010' THEN
			result := json_build_object('code','exception','text','В системе уже присутствует товар с таким наименованием!');
			return next;
	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			IF p_check = 'invoicelist_pkey' THEN
				result := json_build_object('code','exception','text','Данный товар уже добавлен в накладную!');
			ELSIF p_check = 'prod_name_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким наименованием ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSIF p_check = 'prod_code_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким кодом ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSE
				result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			END IF;

    return next;
		
END;
$$;


ALTER FUNCTION functioncalls.invoice_product_up(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 793 (class 1255 OID 49270)
-- Name: invoice_product_update(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.invoice_product_update(addinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
	p_move 				   				json;
	units_result_min 				float8;
  p_minus					 				boolean;
	p_invoicenumber	 				bigint;
	p_invoicedate						date;
	p_company				 				bigint;
	p_code					 				varchar;
	p_text					 				varchar;
	p_error					 				varchar;
	p_status				 				varchar;
  p_stockto				 				bigint;
	r      				record;
	attrs_rec 	record;
	z												record;
	func_res					 			record;
  p_invoice_in		 				bigint;
	p_discount_invoice			bigint;
	p_discount_point				bigint;
  p_stockcurrent	 				bigint;
  p_price_old			 				float8;
  p_new_product		 				bigint;
  p_directory_upd		 		  boolean := false;
	p_new_stock			 				bigint;
  p_point_type		 				bigint;
  p_stock_to			 				bigint;
  p_units					 				float8;
  p_store_to			 				bigint;
  p_send_point		 				bigint  := 0;
  p_cashbox_exist  				boolean := false;
  p_result				 				json;
  p_func		 			    		varchar;
	p_invoice_change_prices boolean := false;
	w												record;
	p_new_invoice_dir_upd		bigint;
  p_new_invoice_cha_pri		bigint;
  p_consignment						boolean := false;
	p_categories						bigint;
	p_pieceprice_old			 	float8;
	p_wholesale_price				float4;
	product_object      					json;
	--p_new_attrlist_code		bigint;
	p_stock_in				bigint; 
	p_all smallint;
	c json;
    p_attributes bigint;
   p_id bigint;
  p_pos int;
 p_id2 bigint;
p_pos2 int;
p_previous int;

BEGIN
--{"invoice" : "1", "user" : "2"}

   
-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
-- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

  SELECT (addinf)::json into p_move;
		p_invoice_in := coalesce(cast(p_move->>'invoice' as bigint),0); 
		SELECT code, text INTO p_code, p_text
      FROM public.get_company(p_move->>'user');
    IF p_code = 'success' THEN
	    p_company := coalesce(cast(p_text as bigint),0);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

	  product_object := p_move->>'stock' ;
	  p_all := cast(p_move->>'all' as smallint);
	 
	
	p_stock_in  := coalesce(cast(product_object->>'id' as bigint),0);
    p_attributes  := coalesce(cast(product_object->>'attributes' as bigint),0);
   
   if p_invoice_in = 0 then
   	raise sqlstate 'S0001';
   end if;
  
  if p_company = 0 then
   	raise sqlstate 'S0002';
   end if;
	
  /*
   if p_stock_in = 0 then
   	raise sqlstate 'S0003';
   end if;
	*/
	update public.invoicelist set 
	--purchaseprice=cast(product_object->>'purchaseprice' as double precision),
	--newprice=cast(product_object->>'newprice' as double precision),
	--units=cast(product_object->>'units' as double precision)
	/*
	purchaseprice=
	case when 
	product_object->>'purchaseprice' is null then purchaseprice else 
	cast(product_object->>'purchaseprice' as double precision) end,
	newprice=
	case when 
	product_object->>'newprice' is null then newprice else
	cast(product_object->>'newprice' as double precision) end,
	units=
	case when
	product_object->>'units' is null then units else
	cast(product_object->>'units' as double precision) end
	*/
	purchaseprice=
	case when 
	trim(product_object->>'key')<>'purchaseprice' then purchaseprice else 
	cast(product_object->>'value' as double precision) end,
	newprice=
	case when 
	trim(product_object->>'key')<>'newprice'  then newprice else
	cast(product_object->>'value' as double precision) end,
	units=
	case when
	trim(product_object->>'key')<>'units'  then units else
	cast(product_object->>'value' as double precision) end,
	updateallprodprice = 
	case when 
	trim(product_object->>'key')<>'updateallprodprice'  then updateallprodprice else
	cast(product_object->>'value' as boolean) end,
	wholesale_price = 
	case when 
	trim(product_object->>'key')<>'wholesale_price'  then wholesale_price else
	cast(product_object->>'value' as double precision) end
	
	
	
	where 
	invoice = p_invoice_in	AND company = p_company  and stock = p_stock_in and "attributes" = p_attributes;

	if p_all = 1 then
		update invoicelist 
		set updateallprodprice = true
		where invoice = p_invoice_in and company = p_company;
	end if;

	if p_all = 0 then 
		update invoicelist 
		set updateallprodprice = false
		where invoice = p_invoice_in and company = p_company;
	end if;

	if trim(product_object->>'key')='numpor' then 
	p_pos := cast(product_object->>'value' as bigint);
	
	if p_pos is null then
		raise sqlstate 'S0004';
	else
		p_pos := p_pos + 1;
	end if;
	
	
	select numpor, id
	into p_previous, p_id
	from invoicelist 
	where invoice = p_invoice_in 
	and stock = p_stock_in
	and "attributes" = p_attributes
	and company = p_company;

	if p_previous is null then
		raise sqlstate 'S0005';
	end if;

	select id, numpor
	into p_id2, p_pos2
	from invoicelist i 
	where invoice = p_invoice_in
	and company = p_company
	and numpor = p_pos;
	
	update invoicelist 
	set numpor = p_pos
	where id = p_id;

	update invoicelist 
	set numpor = p_previous
	where id = p_id2;

	end if;

	result:=json_build_object('code',p_code,'text',p_text);

return next;

EXCEPTION
WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Пустая накладная!');
		 return next;
WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Пустая компания!');
		 return next;
WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error','text','Пустой продукт!');
		 return next;
WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','Пустая позиция!');
		 return next;
WHEN SQLSTATE 'S0005' THEN
		 result := json_build_object('code','error','text','Предыдущая позиция пуста!');
		 return next;
		
WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;
	 
END;
$$;


ALTER FUNCTION functioncalls.invoice_product_update(addinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 794 (class 1255 OID 49272)
-- Name: rep_exp_date(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.rep_exp_date(in_array json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

declare 
  r record;
  ch0date date;
	ch3Date date;
  ch6Date date;
	ch9Date date;
  ch12Date date;
	json_object0 json;
  json_object3 json;
  json_object6 json;
	json_object9 json;
  json_object12 json;
	json_arr0 jsonb;
  json_arr3 jsonb;
  json_arr6 jsonb;
	json_arr9 jsonb;
  json_arr12 jsonb;
  p_error varchar;
 json_arrf jsonb;
chfDate date;
json_objectf json;

p_company      			 bigint;
 json_object    			 json;
 counterparties_object json;
 p_code				  			 varchar;
 p_text				  			 varchar;
j_object    			 json;
--20230808 by ab fix wrong point selection (pointid vs stockid in pointset)
p_point					bigint;
p_warehouse				bigint;
--20230808 by ab fix wrong point selection (pointid vs stockid in pointset)
  
BEGIN
	
	ch0Date = current_date;
  ch3Date = to_date(to_char(CURRENT_DATE+90,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  ch6Date = to_date(to_char(CURRENT_DATE+180,'yyyy-mm-dd'),'yyyy-mm-dd') ;
	ch9Date = to_date(to_char(CURRENT_DATE+270,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  ch12Date = to_date(to_char(CURRENT_DATE+360,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  if (in_array->>'day' is not null and trim(in_array->>'day')<>'') then
   chfDate = to_date(to_char(CURRENT_DATE+cast(trim(in_array->>'day') as int),'yyyy-mm-dd'),'yyyy-mm-dd') ;
  end if;
  
 if (in_array->>'company' is not null and trim(in_array->>'company')<>'') then
 
 p_company= cast(trim(in_array->>'company') as bigint);
 else
  SELECT code, text INTO p_code, p_text
      FROM public.get_company(in_array->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code','no_data_found','text', '');
      return next;
		  return;
	  END IF;  
	
 end if;	 

--20230808 by ab fix wrong point selection (pointid vs stockid in pointset)
if (in_array->>'point' is not null and trim(in_array->>'point')<>'') then
  	p_point = cast(trim(in_array->>'point') as bigint);
  	-- take care of strange case when two CENTRAL WAREHOUSES in test db, and one of them i absent from pointset
  	if exists (select 1 from public.pointset where point = p_point) then
	  	select stock into p_warehouse 
  			from public.pointset
  				where point = p_point;
  		else p_warehouse := p_point;
  	end if;
else p_point := null;
end if;
--20230808 by ab fix wrong point selection (pointid vs stockid in pointset)
  
  for r in (
    select  po.name point, p.code, p."name", s.units, a."value" as dt 
      from products p, stockcurrent s, attrlist a , points po
    where
      s.company =p_company and
      p.id = s.product and 
      p.company = s.company and
      --20230808 by ab fix wrong point selection (pointid vs stockid in pointset)
      s.point = (case when p_point is null then s.point else p_warehouse end) and
      --s.point = (case when in_array->>'point' is null or trim(in_array->>'point')='' 
      --then s.point else cast(trim(in_array->>'point') as bigint) end ) and
      --20230808 by ab fix wrong point selection (pointid vs stockid in pointset)
      po.id=s.point and
      
      s."attributes" = a.listcode and
      a."attribute" = 2
			and s.units > 0
      GROUP BY p.code, p."name", s.units, a."value",po.name
			order by a."value"
  )loop
    begin     
	    
	   ------	   
	  if (in_array->>'day' is not null and trim(in_array->>'day')<>'') then
     
	  
	     if date(r.dt) < chfDate then
        SELECT row_to_json(r) into json_objectf;
      
        if json_arrf is null then select jsonb_build_array(json_objectf) into json_arrf;
        else json_arrf = json_arrf||json_objectf::jsonb;
        end if;
        end if;
	  
      end if;
	   -----
	    
				
			if date(r.dt) < ch0Date then
        SELECT row_to_json(r) into json_object0;
      
        if json_arr0 is null then select jsonb_build_array(json_object0) into json_arr0;
        else json_arr0 = json_arr0||json_object0::jsonb;
        end if;
      end if;
      
			if date(r.dt) < ch3Date and date(r.dt) >= ch0Date then
 				SELECT row_to_json(r) into json_object3;
        
        if json_arr3 is null then select jsonb_build_array(json_object3) into json_arr3;
        else json_arr3 = json_arr3||json_object3::jsonb;
        end if;
      end if;
      
      if date(r.dt) <= ch6Date and date(r.dt) > ch3Date then
        SELECT row_to_json(r) into json_object6;
      
        if json_arr6 is null then select jsonb_build_array(json_object6) into json_arr6;
        else json_arr6 = json_arr6||json_object6::jsonb;
        end if;
      end if;
			
			if date(r.dt) <= ch9Date and date(r.dt) > ch6Date then
        SELECT row_to_json(r) into json_object9;
      
        if json_arr9 is null then select jsonb_build_array(json_object9) into json_arr9;
        else json_arr9 = json_arr9||json_object9::jsonb;
        end if;
      end if;
      
      if date(r.dt) >= ch9Date and date(r.dt) < ch12Date then
        SELECT row_to_json(r) into json_object12;
        
        if json_arr12 is null then select jsonb_build_array(json_object12) into json_arr12;
        else json_arr12 = json_arr12||json_object12::jsonb;
        end if;
      end if;
      
    EXCEPTION
      when OTHERS then null;
    end;  
  end loop;
  
  
  if json_arr3 is not null or json_arr6 is not null or json_arr9 is not null or json_arr12 is not null 
  or json_arrf  is not null
  then 
  
  /* 
  result := json_build_object('code','sucess','text', '','array0',json_arr0,'array3',json_arr3,'array6',json_arr6, 'array9',json_arr9, 'array12',json_arr12
   , 'arrayf',json_arrf
    );
   */
  j_object=json_build_object('array0',json_arr0,'array3',json_arr3,'array6',json_arr6, 'array9',json_arr9, 'array12',json_arr12
   , 'arrayf',json_arrf);
  result := json_build_object('code','success','text', j_object);
  else 
    --20230814 addres 500 error when product is not found in warehouse <
    --result := json_build_object('code','no_data_found','text', '');
    result := json_build_object('code','success','text', 'no_data_found');
	--20230814 addres 500 error when product is not found in warehouse >
	
	
  END if;
  return next;
  

  EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;
  

END; $$;


ALTER FUNCTION functioncalls.rep_exp_date(in_array json, OUT result json) OWNER TO postgres;

--
-- TOC entry 795 (class 1255 OID 49274)
-- Name: soldrep_dop(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.soldrep_dop(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;
p_company_in						 bigint;
  r                			 record;
 p_send_point		 				 bigint  := 0;


BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';
 
 --pv='15,18';
 
 execute
--pv:=
'select json_agg(
json_build_object(
        ''soldsum'', soldsum,
		''soldcount'', soldcount,
		''soldavg'', soldavg,
		''returnsum'', returnsum,
		''returncount'', returncount,
		''returnavg'', returnavg,
		''cashpay'', cashpay,
		''countcashpay'', countcashpay,
		''cardpay'', cardpay,
		''countcardpay'', countcardpay,
		''debitpay'', debitpay,
		''countdebitpay'', countdebitpay,
		''bonuspay'', bonuspay,
		''discount'', discount,
		''debtpay'', debtpay,
		''countdebtpay'', countdebtpay,
		''date'', date,
		''avgcashpay'', avgcashpay,
		''avgcardpay'', avgcardpay,
		''avgdebitpay'', avgdebitpay,
		''avgdebtpay'', avgdebtpay
		) 
)
from 
(
select 

sum(t1.soldsum) as soldsum,
		sum(t1.soldcount) as soldcount,
		sum(t1.soldavg) as soldavg,
		sum(t1.returnsum) as returnsum,
		sum(t1.returncount) as returncount,
		sum(t1.returnavg) as returnavg,
		sum(t1.cashpay) as cashpay,
		sum(t1.countcashpay) as countcashpay,
		sum(t1.cardpay) as cardpay,
		sum(t1.countcardpay) as countcardpay,
		sum(t1.debitpay) as debitpay,
		sum(t1.countdebitpay) as countdebitpay,
		sum(t1.bonuspay) as bonuspay,
		sum(t1.discount) as discount,
		sum(t1.debtpay) as debtpay,
		sum(t1.countdebtpay) as countdebtpay,
		to_char(t1.date,''YYYY-MM-DD'') as date,
		round((sum(t1.cashpay))/(case sum(t1.countcashpay) when 0 then 1 else sum(t1.countcashpay) end),2) as avgcashpay,
		round((sum(t1.cardpay))/(case sum(t1.countcardpay) when 0 then 1 else sum(t1.countcardpay) end),2) as avgcardpay,
		round((sum(t1.debitpay))/(case sum(t1.countdebitpay) when 0 then 1 else sum(t1.countdebitpay) end),2) as avgdebitpay,
		round((sum(t1.debtpay))/(case sum(t1.countdebtpay) when 0 then 1 else sum(t1.countdebtpay) end),2) as avgdebtpay
from (
select  
 

                        case tickettype when 0 then round(sum(price)::numeric,2) else 0 end as soldsum,
						case tickettype when 0 then count(*) else 0 end as soldcount,
						case tickettype when 0 then round(avg(price)::numeric,2) else 0 end as soldavg,
						case tickettype when 1 then round(sum(-price)::numeric,2) else 0 end as returnsum,
						case tickettype when 1 then count(*) else 0 end as returncount,
						case tickettype when 1 then round(avg(-price)::numeric,2) else 0 end as returnavg,					
						round(sum(cashpay)::numeric,2) as cashpay,
						coalesce(sum(case when tickettype = 0 and cashpay <> 0 then 1 when tickettype = 1 and cashpay <> 0 then -1 else null end),0) as countcashpay,
						round(sum(cardpay)::numeric,2) as cardpay,
						coalesce(sum(case when tickettype = 0 and cardpay <> 0 then 1 when tickettype = 1 and cardpay <> 0 then -1 else null end),0) as countcardpay,
						round(sum(debitpay)::numeric,2) as debitpay,
						coalesce(sum(case when tickettype = 0 and debitpay <> 0 then 1 when tickettype = 1 and debitpay <> 0 then -1 else null end),0) as countdebitpay,
						round(sum(debtpay)::numeric,2) as debtpay,
						coalesce(sum(case when tickettype = 0 and debtpay <> 0 then 1 when tickettype = 1 and debtpay <> 0 then -1 else null end),0) as countdebtpay,
						case tickettype when 0 then round(sum(bonuspay)::numeric,2) else round(sum(-bonuspay)::numeric,2) end as bonuspay,
						case tickettype when 0 then round(sum(discount + detailsdiscount)::numeric,2) else round(sum(-discount + (-detailsdiscount))::numeric,2) end as discount,
						date::date as date

from transactions as t
--left join companies on (t.company= companies.id)
where  t.company not in (0, 2, 17, 49, 37)
		and t.id not in(168105, 168106, 168107, 168108, 168109, 168110, 168111, 168112, 168113, 168114) 
		and cast (t.date as date) between '''|| cast(trim(json_object->>'dateFrom') as date)||''' and '''||cast(trim(json_object->>'dateTo') as date) ||
		''' and  t.company in ( '||
		--pv
		(trim(json_object->>'comp'))
		||')
		
		group by t.tickettype,t.date::date
		)t1
		group by t1.date::date order by t1.date::date
)t2	; '
--'SELECT public.invoice_create_isp('''||inf||''')'
--'SELECT count(*) from invoicelist where invoice=171863 and company=18'
   into j_object;
  
 /*
 pv:=' ''15'' , ''18'' ';
 --pv:='15,18';
  
select 
json_build_object(
        'soldsum', soldsum,
		'soldcount', soldcount,
		'soldavg', soldavg,
		'returnsum', returnsum,
		'returncount', returncount,
		'returnavg', returnavg,
		'cashpay', cashpay,
		'countcashpay', countcashpay,
		'cardpay', cardpay,
		'countcardpay', countcardpay,
		'debitpay', debitpay,
		'countdebitpay', countdebitpay,
		'bonuspay', bonuspay,
		'discount', discount,
		'debtpay', debtpay,
		'countdebtpay', countdebtpay,
		'date', date,
		'avgcashpay', avgcashpay,
		'avgcardpay', avgcardpay,
		'avgdebitpay', avgdebitpay,
		'avgdebtpay', avgdebtpay
		) into j_object

from 
(
select 
--*
sum(t1.soldsum) as soldsum,
		sum(t1.soldcount) as soldcount,
		sum(t1.soldavg) as soldavg,
		sum(t1.returnsum) as returnsum,
		sum(t1.returncount) as returncount,
		sum(t1.returnavg) as returnavg,
		sum(t1.cashpay) as cashpay,
		sum(t1.countcashpay) as countcashpay,
		sum(t1.cardpay) as cardpay,
		sum(t1.countcardpay) as countcardpay,
		sum(t1.debitpay) as debitpay,
		sum(t1.countdebitpay) as countdebitpay,
		sum(t1.bonuspay) as bonuspay,
		sum(t1.discount) as discount,
		sum(t1.debtpay) as debtpay,
		sum(t1.countdebtpay) as countdebtpay,
		to_char(t1.date,'YYYY-MM-DD') as date,
		round((sum(t1.cashpay))/(case sum(t1.countcashpay) when 0 then 1 else sum(t1.countcashpay) end),2) as avgcashpay,
		round((sum(t1.cardpay))/(case sum(t1.countcardpay) when 0 then 1 else sum(t1.countcardpay) end),2) as avgcardpay,
		round((sum(t1.debitpay))/(case sum(t1.countdebitpay) when 0 then 1 else sum(t1.countdebitpay) end),2) as avgdebitpay,
		round((sum(t1.debtpay))/(case sum(t1.countdebtpay) when 0 then 1 else sum(t1.countdebtpay) end),2) as avgdebtpay
from (
select  
--* 

                        case tickettype when 0 then round(sum(price)::numeric,2) else 0 end as soldsum,
						case tickettype when 0 then count(*) else 0 end as soldcount,
						case tickettype when 0 then round(avg(price)::numeric,2) else 0 end as soldavg,
						case tickettype when 1 then round(sum(-price)::numeric,2) else 0 end as returnsum,
						case tickettype when 1 then count(*) else 0 end as returncount,
						case tickettype when 1 then round(avg(-price)::numeric,2) else 0 end as returnavg,					
						round(sum(cashpay)::numeric,2) as cashpay,
						coalesce(sum(case when tickettype = 0 and cashpay <> 0 then 1 when tickettype = 1 and cashpay <> 0 then -1 else null end),0) as countcashpay,
						round(sum(cardpay)::numeric,2) as cardpay,
						coalesce(sum(case when tickettype = 0 and cardpay <> 0 then 1 when tickettype = 1 and cardpay <> 0 then -1 else null end),0) as countcardpay,
						round(sum(debitpay)::numeric,2) as debitpay,
						coalesce(sum(case when tickettype = 0 and debitpay <> 0 then 1 when tickettype = 1 and debitpay <> 0 then -1 else null end),0) as countdebitpay,
						round(sum(debtpay)::numeric,2) as debtpay,
						coalesce(sum(case when tickettype = 0 and debtpay <> 0 then 1 when tickettype = 1 and debtpay <> 0 then -1 else null end),0) as countdebtpay,
						case tickettype when 0 then round(sum(bonuspay)::numeric,2) else round(sum(-bonuspay)::numeric,2) end as bonuspay,
						case tickettype when 0 then round(sum(discount + detailsdiscount)::numeric,2) else round(sum(-discount + (-detailsdiscount))::numeric,2) end as discount,
						date::date as date

from transactions as t
left join companies on (t.company= companies.id)
where  t.company not in (0, 2, 17, 49, 37)
		and t.id not in(168105, 168106, 168107, 168108, 168109, 168110, 168111, 168112, 168113, 168114) 
		and cast (t.date as date) between cast(trim(json_object->>'dateFrom') as date) and cast(trim(json_object->>'dateTo') as date)
		--and  t.company  in (15, 18)
		--and  t.company  in (trim(json_object->>'company'))
		--and  cast(t.company as varchar) in (select pv)
		--and  t.company in (SELECT foo FROM regexp_split_to_table(pv, ',') AS foo)
		and  cast(t.company as varchar) in (SELECT foo FROM regexp_split_to_table(pv, ',') AS foo)
		--and  cast(t.company as varchar) in (array_to_string(string_to_array(pv, ','),','))
		--and  t.company  in (array_to_string(string_to_array(pv, ','),','))
		--and  cast(t.company as varchar) in ('15', '18')
		group by t.tickettype,t.date::date
		)t1
		group by t1.date::date order by t1.date::date
)t2	; 

*/
 
--j_object:='{"id":"'||pv||'"}';
	
    result := json_build_object('code',p_result,'soldrep',j_object);
--result := json_build_object('code',p_result,'soldrep',pv);
   -- result := json_build_object('code',p_result,'soldrep',json_object->>'comp');

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.soldrep_dop(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 796 (class 1255 OID 49276)
-- Name: stock_edit(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.stock_edit(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;

 p_counterparty       bigint; 
p_point       bigint; 

BEGIN

 SELECT (inf)::json into json_object;

--20230807 by ab remove /*
--/*
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	--*/
--20230807 by ab remove /*
	 
  p_result:='success';	
  p_text:=cast(json_object->>'product' as bigint);


-------
if cast(trim(json_object->>'mnogo') as integer)=1 then

    FOR product_object IN SELECT * FROM json_array_elements((json_object)->'obj')
    loop
	    
	    ------
	    
	     if cast(trim(json_object->>'oper') as integer)=4 then
	     
	     if exists(select * from public.stock_minmax where 
	     point=cast(trim(product_object->>'point') as bigint) 
	     and 
	     product=cast(trim(product_object->>'product') as bigint)
	     ) then 
	     
	     UPDATE public.stock_minmax
SET  mincount=case when (cast(trim(product_object->>'mincount') as bigint) is null) or (cast(trim(product_object->>'mincount') as bigint)=-1)
then mincount else cast(trim(product_object->>'mincount') as bigint) end,
maxcount= case when  (cast(trim(product_object->>'maxcount') as bigint) is null) or (cast(trim(product_object->>'maxcount') as bigint)=-1)
then maxcount else cast(trim(product_object->>'maxcount') as bigint) end 
,enabled= case when  cast(trim(product_object->>'enabled') as boolean) is null
then enabled else cast(trim(product_object->>'enabled') as boolean) end
WHERE point=cast(trim(product_object->>'point') as bigint) and  product=cast(trim(product_object->>'product') as bigint);

	     
	     else

INSERT INTO public.stock_minmax
(point, product, mincount, maxcount,enabled)
VALUES(cast(trim(product_object->>'point') as bigint), cast(trim(product_object->>'product') as bigint),
cast(trim(product_object->>'mincount') as bigint), cast(trim(product_object->>'maxcount') as bigint)
, cast(trim(product_object->>'enabled') as boolean)
);

end if;

end if;
	    
	    ------
	    
	    
	    if cast(trim(json_object->>'oper') as integer)=2 then

INSERT INTO public.stock_minmax
(point, product, mincount, maxcount,enabled)
VALUES(cast(trim(product_object->>'point') as bigint), cast(trim(product_object->>'product') as bigint),
cast(trim(product_object->>'mincount') as bigint), cast(trim(product_object->>'maxcount') as bigint)
, cast(trim(product_object->>'enabled') as boolean)
);

end if;
	  
    if cast(trim(json_object->>'oper') as integer)=3 then

UPDATE public.stock_minmax
SET  mincount=case when (cast(trim(product_object->>'mincount') as bigint) is null) or (cast(trim(product_object->>'mincount') as bigint)=-1)
then mincount else cast(trim(product_object->>'mincount') as bigint) end,
maxcount= case when  (cast(trim(product_object->>'maxcount') as bigint) is null) or (cast(trim(product_object->>'maxcount') as bigint)=-1)
then maxcount else cast(trim(product_object->>'maxcount') as bigint) end 
,enabled= case when  cast(trim(product_object->>'enabled') as boolean) is null
then enabled else cast(trim(product_object->>'enabled') as boolean) end
WHERE point=cast(trim(product_object->>'point') as bigint) and  product=cast(trim(product_object->>'product') as bigint);

end if;

    	
    END loop;
   
   else
 
 if cast(trim(json_object->>'oper') as integer)=1 then
 SELECT json_agg(
json_build_object('point',point,'product', product,'mincount', mincount,'maxcount', maxcount,'id', id,'enabled',enabled)) into j_object
FROM public.stock_minmax where point=cast(trim(json_object->>'point') as bigint);
end if;
 

---------


	    
	     if cast(trim(json_object->>'oper') as integer)=9 then
	     
	     if exists(select * from public.stock_minmax where 
	     point=cast(trim(json_object->>'point') as bigint) 
	     and 
	     product=cast(trim(json_object->>'product') as bigint)
	     ) then 
	     
	     UPDATE public.stock_minmax
SET  mincount=case when (cast(trim(json_object->>'mincount') as bigint) is null) or (cast(trim(json_object->>'mincount') as bigint)=-1)
then mincount else cast(trim(json_object->>'mincount') as bigint) end,
maxcount= case when  (cast(trim(json_object->>'maxcount') as bigint) is null) or (cast(trim(json_object->>'maxcount') as bigint)=-1)
then maxcount else cast(trim(json_object->>'maxcount') as bigint) end 
,enabled= case when  cast(trim(json_object->>'enabled') as boolean) is null
then enabled else cast(trim(json_object->>'enabled') as boolean) end
WHERE point=cast(trim(json_object->>'point') as bigint) and  product=cast(trim(json_object->>'product') as bigint);

	     
	     else

INSERT INTO public.stock_minmax
(point, product, mincount, maxcount,enabled)
VALUES(cast(trim(json_object->>'point') as bigint), cast(trim(json_object->>'product') as bigint),
cast(trim(json_object->>'mincount') as bigint), cast(trim(json_object->>'maxcount') as bigint)
, cast(trim(json_object->>'enabled') as boolean)
);

end if;

end if;
	    
	 

---------

if cast(trim(json_object->>'oper') as integer)=8 then
--20230807 by ab fix pointname and stockname
SELECT json_agg(
json_build_object('point',p.id,'product', pr.id,'mincount', mincount,'maxcount', maxcount,'id', s.id,'enabled',enabled
,'pointname',po2.name
,'stockname',p.name
)) into j_object
FROM public.products pr 
	left join public.points p on (pr.company=p.company)
	left join public.pointset ps on (p.id = ps.stock)
	left join public.points po2 on (ps.point = po2.id)
	left join public.stock_minmax s on (pr.id=s.product and p.id=s.point) 
where pr.id=cast(trim(json_object->>'product') as bigint)
      and p.point_type=1
      --20230807 by ab
      and p.status = 'ACTIVE'
      and p.company = p_company
      --20230807 by ab
;




/* SELECT json_agg(
json_build_object('point',p.id,'product', p2.id,'mincount', mincount,'maxcount', maxcount,'id', s.id,'enabled',enabled
,'pointname',p.name
,'stockname',p.name
)) into j_object
FROM public.products p2 left join public.points p on (p2.company=p.company)  left join public.stock_minmax s on (p2.id=s.product and p.id=s.point) 
where p2.id=cast(trim(json_object->>'product') as bigint)
      and p.point_type=1
      --20230807 by ab
      and p.status = 'ACTIVE'
      and p.company = p_company
      --20230807 by ab
;
*/


/*
SELECT json_agg(
json_build_object('point',point,'product', product,'mincount', mincount,'maxcount', maxcount,'id', id,'enabled',enabled)) into j_object
FROM public.stock_minmax where product=cast(trim(json_object->>'product') as bigint);
*/

end if;

if cast(trim(json_object->>'oper') as integer)=7 then
 SELECT json_agg(
json_build_object('point',point,'product', product,'mincount', mincount,'maxcount', maxcount,'id', s.id,'enabled',enabled)) into j_object
FROM public.stock_minmax s inner join public.points p on (s.point=p.id) 
where p.company=cast(trim(json_object->>'company') as bigint) 
;
end if;

if cast(trim(json_object->>'oper') as integer)=2 then

INSERT INTO public.stock_minmax
(point, product, mincount, maxcount,enabled)
VALUES(cast(trim(json_object->>'point') as bigint), cast(trim(json_object->>'product') as bigint),
cast(trim(json_object->>'mincount') as bigint), cast(trim(json_object->>'maxcount') as bigint)
, cast(trim(json_object->>'enabled') as boolean)
);

end if;


if cast(trim(json_object->>'oper') as integer)=3 then

UPDATE public.stock_minmax
SET  mincount=case when (cast(trim(json_object->>'mincount') as bigint) is null) or (cast(trim(json_object->>'mincount') as bigint)=-1)
then mincount else cast(trim(json_object->>'mincount') as bigint) end,
maxcount= case when  (cast(trim(json_object->>'maxcount') as bigint) is null) or (cast(trim(json_object->>'maxcount') as bigint)=-1)
then maxcount else cast(trim(json_object->>'maxcount') as bigint) end 
,enabled= case when  cast(trim(json_object->>'enabled') as boolean) is null
then enabled else cast(trim(json_object->>'enabled') as boolean) end
WHERE point=cast(trim(json_object->>'point') as bigint) and  product=cast(trim(json_object->>'product') as bigint);
--categoryid=case when (p_categoryid=-1) or (p_categoryid is null) then categoryid else p_categoryid end
end if;


if cast(trim(json_object->>'oper') as integer)=4 then
DELETE FROM public.stock_minmax
WHERE id=cast(trim(json_object->>'id') as bigint);
end if;

-----
if cast(trim(json_object->>'oper') as integer)=5 then

p_counterparty := cast(trim(json_object->>'counterparty') as bigint);
p_point:= cast(trim(json_object->>'point') as bigint);

select 
json_agg(
json_build_object(
'mincount',col2,'pointname',col4,'code',col6,'product',col8,'units',col10,'stockname',col12,
'brand',col14,'category',col16,'attributes',col18,'attributesCaption',col20,'details',col22,'detailsCaption',col24,'counterparty',col26
,'maxcount', col27,'order',COALESCE(col27,0)-COALESCE(col10,0)
)) 
into j_object
from
(
select 
distinct 
'mincount' col1,s.mincount col2, 
'pointname' col3,
--20230807 by ab fix pointname vs stockname
po2.name col4,
--20230807 by ab fix pointname vs stockname
'code' col5,code col6,
'product' col7,p2.name col8,
'units' col9,s2.units col10,
'stockname' col11,p.name col12,
'brand' col13,b.brand col14,
'category' col15,c.name col16,
'attributes' col17,p2."attributes" col18,
'attributesCaption' col19,array_to_string(array(select n.values||': '||a.value from attrlist a left join attributenames n on (n.id = a.attribute) where a.listcode = p2.attributes and a.company = p2.company),', ') col20,
'details' col21,p2.details col22,
'detailsCaption' col23,array_to_string(array(select n.values||': '||a.value from attrlist a left join attributenames n on (n.id = a.attribute) where a.listcode = p2.details and a.company = p2.company),', ') col24
,'counterparty' col25
,
(
select max(cp.name) from counterparties cp 
           where cp.id in 
           (
           case when p_counterparty is null then
max(counterparty)
else 
           p_counterparty
           end
)
)
/*
(
select max(cp.name) from counterparties cp 
           where cp.id in 
           (
           case when p_counterparty is null then
(select max(c2p.counterparty) from counterparty2product c2p where c2p.company = p.company and c2p.product = p2.id)
else 
           p_counterparty
           end
)
) 
*/
col26
,s.maxcount col27
 
from 
public.points p 
inner join public.stock_minmax s on (p.id=s.point)
                       inner join 
                       public.products p2 
                       on (s.product=p2.id and p.company=p2.company)
                       --left join public.stockcurrent s2 on ( p.company=s2.company and s.product=s2.product)
                       /*
                       left join 
                       (SELECT s.stock as id,p1.id  as point,p4.name,p4.point_type, p1."name" pointname,p1.status  
	        FROM points p1
		        LEFT JOIN pointset s on (s.point = p1.id)
		        left join points p4 on (s.stock=p4.id)
		                 ) p3 on (p3.point=p.id) 
                       */
                       left join 
                       
                       (
          select sum(units)
          --20230807 by ab
          --coalesce(sum(units),0) 
          --20230807 by ab
          as units, product,company,point             
          from stockcurrent 
            GROUP BY product,company,point
        ) s2 on ( p.company=s2.company and s.product=s2.product and p.id =s2.point)
        --left join public.stock_minmax s on (p3.id=s.point)
                       /*
                       left join 
                       
                       (
          select sum(units) as units, product,company,point             
          from stockcurrent 
            GROUP BY product,company,point
        ) s2 on ( p.company=s2.company and s.product=s2.product 
        --and p.id=s2.point
        )
                        
                       
                       left join 
                       public.points
                       
                       p3 on (p3.id=s2.point)
                       */
                       
                       left join brands b on b.id = p2.brand      
                       left join categories c on c.id = p2.category 
                       
                       left join (select counterparty,company,product from counterparty2product) c2p 
                       on (c2p.company = p.company and c2p.product = p2.id
                       and c2p.counterparty =(case when p_counterparty is null then c2p.counterparty else p_counterparty end)
                      )
                    --20230807 by ab fix pointname vs stockname
	                left join public.pointset ps on (p.id = ps.stock)
					left join public.points po2 on (ps.point = po2.id)
                       
--20230807 by ab
--where p.company= cast(trim(json_object->>'company') as bigint) 
where p.company= p_company
/*
and s2.point in (SELECT max(s.stock) 
	        FROM points p1
		        LEFT JOIN pointset s on (s.point = p1.id)
		                 WHERE p1.id=p.id) 
*/		                 
		          and p.status = 'ACTIVE'
		           --20230807 by ab enable mincount check
		          and s.mincount is not null
		          and (s2.units <= s.mincount or s2.units is null)
		          and s.enabled=true 
		         
		           
		          and exists (
      select 1 from counterparty2product c2p where 
       c2p.company = p2.company and c2p.product = p2.id 
       and c2p.counterparty =(case when p_counterparty is null then c2p.counterparty else p_counterparty end
      )
      )
      
      and p.id=(case when p_point is null then p.id else p_point end)
      
      and p2.deleted = false
      and p.point_type=1
      
       group by s.mincount,p.name,
code,
--20230807 by ab pointname vs stockname fix
po2.name,
p2.name,
s2.units,
p.name,
b.brand,
c.name,
p2."attributes",
array_to_string(array(select n.values||': '||a.value from attrlist a left join attributenames n on (n.id = a.attribute) where a.listcode = p2.attributes and a.company = p2.company),', '),

p2.details
,
array_to_string(array(select n.values||': '||a.value from attrlist a left join attributenames n on (n.id = a.attribute) where a.listcode = p2.details and a.company = p2.company),', ')
,s.maxcount
      )t1
      
/*
select 
json_agg(
json_build_object(
'mincount',s.mincount, 
'pointname',p."name",
'code',code,
'product',p2.name,
'units',s2.units,
'stockname',p3.name,
'brand',b.brand,
'category',c.name,
'attributes',p2."attributes",
'attributesCaption',array_to_string(array(select n.values||': '||a.value from attrlist a left join attributenames n on (n.id = a.attribute) where a.listcode = p2.attributes and a.company = p2.company),', '),
'details',p2.details,
'detailsCaption',array_to_string(array(select n.values||': '||a.value from attrlist a left join attributenames n on (n.id = a.attribute) where a.listcode = p2.details and a.company = p2.company),', ')
,'counterparty'
,
(
select max(cp.name) from counterparties cp 
           where cp.id in 
           (
           case when p_counterparty is null then
(select max(c2p.counterparty) from counterparty2product c2p where c2p.company = p.company and c2p.product = p2.id)
else 
           p_counterparty
           end
)
)

)  
) into j_object
from public.points p inner join public.stock_minmax s on (p.id=s.point)
                       inner join public.products p2 on (s.product=p2.id)
                       left join public.stockcurrent s2 on ( p.company=s2.company and s.product=s2.product)
                       left join public.points p3 on (p3.id=s2.point)
                       left join brands b on b.id = p2.brand      
                       left join categories c on c.id = p2.category 
where p.company= cast(trim(json_object->>'company') as bigint) and s2.point in (SELECT max(s.stock) 
	        FROM points p1
		        LEFT JOIN pointset s on (s.point = p1.id)
		                 WHERE p1.id=p.id) 
		          and p.status = 'ACTIVE'
		          and s2.units <s.mincount and s.enabled=true 
		         
		           
		          and exists (
      select 1 from counterparty2product c2p where 
       c2p.company = p.company and c2p.product = p2.id 
       and c2p.counterparty =(case when p_counterparty is null then c2p.counterparty else p_counterparty end
      )
      )
      
      and p.id=(case when p_point is null then p.id else p_point end)
  */    
		          ;
end if;		         
-----
 


    

end if;
------




	
    result := json_build_object('code',p_result,'text',p_text,'stock',j_object);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.stock_edit(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 797 (class 1255 OID 49278)
-- Name: stock_export(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.stock_export(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;
p_company_in						 bigint;
  r                			 record;
 p_send_point		 				 bigint  := 0;


BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  	 
  p_result:='success';	
 
 /*
  select 
json_agg(json_build_object(


'Category',
c."name" ,
'Name',
ws.productname,
'Code',
ws.code,
'PriceBuy',
pa.purchaseprice,
'PriceSell',
sp.price,
'Units',
ws.units ,
'Brand',
b.brand,
'Nds',
case when ws.taxid = 0 then 'нет' else 'да' end,
'Cnofeacode',
ws.Cnofeacode,
'Piece',
ws.piece,
'PieceInPack',
ws.pieceinpack,
'Unitsprid',
ws.unitsprid
					
				))  into j_object
 */
 
  select 
json_agg(json_build_object(

'Category',
name ,
'Name',
productname,
'Code',
code,
'PriceBuy',
purchaseprice,
'PriceSell',
price,
'Units',
units ,
'Brand',
brand,
'Nds',
nds,
'Cnofeacode',
Cnofeacode,
'Piece',
piece,
'PieceInPack',
pieceinpack,
'Unitsprid',
unitsprid

)) into j_object
from 
(
select
distinct

c."name" ,
ws.productname,
ws.code,
pa.purchaseprice,
sp.price,
ws.units ,
b.brand,
case when ws.taxid = 0 then 'нет' else 'да' end as nds,
ws.Cnofeacode,
ws.piece,
ws.pieceinpack,
ws.unitsprid
					
				
FROM (
          select sum(s.units) as units, max(s.id) as sid, 
            p.id, s.point as point_id, p.category as category_id, p.brand as brand_id,
            p.brand, p."name" as productname, p.code, p.taxid, s.company
         
            ,case when p.piece is true then 'да' else 'нет' end as piece,
         p.pieceinpack as pieceinpack,
        --p.pieceprice as pieceprice,
         p.unitsprid as unitsprid,
         p.Cnofeacode
          from stockcurrent s
            join products p on p.id = s.product and p.deleted = false            
          where s.units <> 0
            GROUP BY p.id, s.point, p.category, p.brand, p."name", p.code, p.taxid, s.company
        ) ws
        join points p on p.id = ws.point_id and p.status = 'ACTIVE'
        join categories c on c.id = ws.category_id and c.deleted = false
        join brands b on b."id" = ws.brand
        join storeprices sp on sp.stock = ws.sid
        join product_accounting pa on pa.company = p_company and pa.product = ws.id and pa.id in (
          select max(id) from product_accounting where company = p_company and product = ws.id
        ) 
        left join "products_barcode" on ws."id" = "products_barcode"."product" and ws."company"="products_barcode"."company"
		 WHERE ws.company = p_company
		 and  p.id=		 
		 case when (cast(trim(json_object->>'point') as bigint) is null) or (cast(trim(json_object->>'point') as bigint)=-1)
         then p.id else cast(trim(json_object->>'point') as bigint) end
         )t 
        ;
 

	
    result := json_build_object('code',p_result,'invexel',j_object);
    

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.stock_export(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 798 (class 1255 OID 49280)
-- Name: udalm_dan(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.udalm_dan(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

p_invoice_in				 						bigint;
invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_company       bigint;
 p_invoicenumber bigint;
 product_object      						json;
 p_attributes_in		 							bigint;
 
 col1 int;
 attr_items    									json;
 p_barcode				   varchar;
 
 c json;
 
 
 
 
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8:= 0;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												varchar;
 p_attr                       json := '[]';
 p_faa 												json;

 p_wholesale_price						float4;
 p_product										bigint;
 p_attributes				   varchar;
 p_id varchar;
 p_lastpurchaseprice varchar;

 p_purchaseprice varchar;
 p_sku varchar;
 p_taxid varchar;
 p_updateprice varchar;
 p_attrlist json;
 json_object    			 json;
 j_object    			 json;
 pv  varchar;
 cashboxusr_object json;
 p_cashbox_usr		 bigint;
 p_erp_usr		 		 bigint;
 p_result				   varchar;

  

BEGIN

 SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM public.get_company(json_object->>'user');
			IF p_code = 'success' THEN
			
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		
	
  ------28.11.2022	 
  p_result:='success';	
 ------28.11.2022

  p_type := json_object->>'type';
  
 
  
    FOR j_object IN SELECT * FROM json_array_elements((json_object)->p_type)
    LOOP 
    	 
    IF p_type='customers' THEN
	
	 select public.customers_management(json_build_object('user',json_object->>'user',p_type, 
		j_object)) into product_object;
		
	ELSIF p_type='scale' THEN
	
	  select public.scales_management(json_build_object('user',json_object->>'user',p_type, 
		j_object)) into product_object;
	
	ELSIF p_type='cashboxusr' THEN
	
	  --select cashboxusr_management(json_build_object('user',json_object->>'user',p_type, 
      --		j_object)) into product_object;
	  
	
		
    p_cashbox_usr := cast(j_object->>'id' as bigint);
	
	--result := json_build_object('code','success','text',j_object);
    --return next;
   
    UPDATE public.cashbox_users 
			  SET 
			  deleted = case j_object->>'deleted' when '1' then true else false end
			  WHERE id = p_cashbox_usr;
			  
	ELSIF p_type='erpuser' THEN		  
   		
	p_erp_usr := cast(j_object->>'id' as bigint);
	
	UPDATE public.erp_users
			  SET  status = j_object->>'status'
				  WHERE id = p_erp_usr;
				  
	ELSIF p_type='plan' THEN
	
	  select public.plan_management(json_build_object('user',json_object->>'user',p_type, 
		j_object)) into product_object;	
		
		
	ELSIF p_type='revision' THEN
	
	delete from public.revision_temp where product = cast(j_object->>'product' as bigint) 
	   and revisionnumber = cast(j_object->>'revnumber' as bigint) and "user" = cast(json_object->>'user' as bigint)
	   and "attributes" = cast(j_object->>'attributes' as bigint)
	;
	   
    ------28.11.2022

    ELSIF p_type='revisionnumber' THEN
	
	  select public.revisionlist_delete(json_build_object('admin',json_object->>'user',p_type, 
		j_object->p_type)) into product_object;
	
	p_text := product_object->>'text'
	--json_build_object('admin',json_object->>'user',p_type, 
	--	j_object->p_type)
	;
    p_result:=product_object->>'code';	
    ------28.11.2022
	   
		
	END IF;	
	 
	    
	END LOOP;	
	

	------28.11.2022
	--result := json_build_object('code','success','text',p_text);
    result := json_build_object('code',p_result,'text',p_text);
    ------28.11.2022

    return next;
 

END;

$$;


ALTER FUNCTION functioncalls.udalm_dan(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 799 (class 1255 OID 49281)
-- Name: update_product_in_invoice(json); Type: FUNCTION; Schema: functioncalls; Owner: postgres
--

CREATE FUNCTION functioncalls.update_product_in_invoice(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

-- Сервис вызывается для добавления товара в накладную при приемке и редактировании. Не подойдет для списания, перемещения и т.д
DECLARE

	r 						record;
    l                       record; 
	p_company				bigint;
	p_text				    varchar;
	p_error			       	varchar;
	p_check                 varchar;
	
    p_invoice				bigint;
    p_stock                 bigint;
   	invoice_object      	json;
	p_brand					bigint;
	p_category				bigint;
	p_attributes            bigint;
    p_details               bigint;
   
    p_attributes_json       jsonb := '[]';
    p_details_json          jsonb := '[]';
    
    
    p_details_item          jsonb;
    p_attributes_item       jsonb;
    
   
    p_stocks                jsonb = '[]';
    p_stock_item            text;
   
    p_attributes_new        bigint;
    p_attributes_in_invoice bigint;
    
    p_attribcode            bigint;
    p_value                 text;
   
    p_attributes_object     json;
    p_user                  bigint;
    p_attributes_invoice    bigint;
  
   
BEGIN
	
	-- {"invoice":1,"product":1,"company":1}
  	
	SELECT (inf)::json into invoice_object;
    p_invoice := coalesce(cast(invoice_object->>'invoice' as bigint),0);
    p_company := coalesce(cast(invoice_object->>'company' as bigint),0);
    p_stock := coalesce(cast(invoice_object->>'stock' as bigint),0);
   
    if p_invoice = 0 then
    	raise sqlstate 'S0001';
    end if;
   
    if p_company = 0 then
    	raise sqlstate 'S0002';
    end if;
	
    if p_stock = 0 then
    	raise sqlstate 'S0003';
    end if;
   
    -- Берем значения из номенклатуры для обновления накладной
   	select brand, category, attributes, details
   		into p_brand, p_category, p_attributes, p_details
   			from products where id = p_stock and company = p_company;
   	
   	-- Для обновления постоянных характеристик
   	for r in (select a.listcode, a.attribute, an.values, a.value 	
   		from attrlist a inner join attributenames an
		on a."attribute" = an.id where a.listcode = p_details)
	loop 
		p_details_item := json_build_object('code',r.attribute,'name',r.values,'value',r.value);
	    p_details_json := p_details_json || p_details_item;
	end loop;

	update invoicelist
	set brandid = p_brand, categoryid = p_category,
		detales = p_details, detales_json = p_details_json
	where stock = p_stock and invoice = p_invoice;

	/*
	-- Для обновления партийных характеристик
	select attributes into p_attributes from products where id = p_stock;
	select id into p_user from erp_users where company = p_company limit 1;
	
	select attribute, value into p_attribcode, p_value from attrlist where listcode = p_attributes and company = p_company;
    
	for r in (select * from invoicelist 
    	where stock = p_stock 
    		and company = p_company
    			and invoice = p_invoice
    				order by id)
    loop

	   	p_attributes_object := json_build_object('user',p_user,'listcode',r.attributes,'attribcode',p_attribcode,'value',p_value);
	    p_attributes_invoice := cast(functioncalls.add_attributes_new(p_attributes_object)->>'text' as bigint);
	   
	    -- Для поля "attributes_json" таблицы "invoicelist"
	   	for l in (select a.listcode, a.attribute, an.values, a.value 	
   			from attrlist a inner join attributenames an
				on a."attribute" = an.id where a.listcode = p_attributes_invoice
				)
		loop 
			p_attributes_item := json_build_object('code',l.attribute,'name',l.values,'value',l.value);
	    	p_attributes_json := p_attributes_json || p_attributes_item;
		end loop;

		-- 
	    update invoicelist 
	    set "attributes" = p_attributes_invoice, attributes_json = p_attributes_json
	    where stock = p_stock and "attributes" = r.attributes and invoice = p_invoice;
	    
	    p_attributes_json := '[]';
	end loop;
	-- Для обновления партийных характеристик
   */
  
  	result := json_build_object('code','success','text','ok','stocks',p_stocks);
  	return next;
		
	EXCEPTION
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','Накладная не передана!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','exception','text','Компания не передана!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','exception','text','Товар не передан!');
			return next;	
		
	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			

    return next;
		
END;
$$;


ALTER FUNCTION functioncalls.update_product_in_invoice(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 576 (class 1255 OID 16389)
-- Name: _test1(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public._test1() RETURNS integer
    LANGUAGE plpgsql
    AS $$ declare ipor integer;
                      ipor1 integer;
       begin
       	
	       ipor:=1;
	       ipor1:=3;
	      while ipor1=3 
	      loop
	      	
		      if ipor=3 then
		      ipor1=0;
		     end if;
		      
		  ipor=ipor+1;    
	      end loop;
	      

		
		return ipor1;
	END;
$$;


ALTER FUNCTION public._test1() OWNER TO postgres;

--
-- TOC entry 577 (class 1255 OID 16390)
-- Name: activate_giftcertificates(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.activate_giftcertificates(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       		json;
 p_error           		varchar;
 p_company				 		bigint;
 p_user						 		bigint;
 p_check						 	varchar;
 p_point							bigint;
 p_id									bigint;
 p_cert_summ					float8;
 p_prod								bigint;
 p_trade_point				bigint;
 p_invoice						bigint;
 p_stock							bigint;
 p_date								date;
 p_units_after				float8;
 p_is_ok							boolean;
 p_group							bigint;
 
BEGIN

	/* 
	{"company":"1","user": "1","point":169,"id":12}  
	*/													
	-- status: error/info
	
	SELECT (inf)::json into json_object;
		
		p_company	 		:= cast(json_object->>'company' as bigint);
		p_user 		 		:= cast(json_object->>'user' as bigint);
		-- ID склада
		p_point				:= cast(trim(json_object->>'point') as bigint);
		p_id 					:= cast(trim(json_object->>'id') as bigint);
		
		-- Определяем торговую точку
		if p_point = 0 then
			SELECT min(id) INTO p_point
				FROM points p where p.company = p_company and p.point_type = 1 and p.status = 'ACTIVE';		
		end if;
		SELECT point INTO p_trade_point
		FROM pointset
			WHERE stock = p_point;
		
		-- Проверка на группы сертификатов
		SELECT coalesce(certificate_group,0) INTO p_group
			FROM companies
				WHERE id = p_company;		
	
		SELECT case 
				when (active is false and expiredate is null) or 
						 (active is false and expiredate is not null and selldate is not null and balance <> denomination) 
								then true
				else
								false end INTO p_is_ok
			FROM giftcertificates
				WHERE id = p_id
					AND case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end;
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0001';
		END IF; 	
		IF NOT p_is_ok THEN
			RAISE SQLSTATE 'S0005';
		END IF;
					
		-- Активирование сертификата
		UPDATE giftcertificates
			SET active = true, balance = denomination, expiredate = (current_date + interval '1 month' * period)::date, selldate = current_date
				WHERE id = p_id
					AND case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end
						RETURNING denomination, product INTO p_cert_summ, p_prod;
		
		-- На случай, если активируют сертификат, принадлижащий другой компании в группе (нужно определить товар)
		IF p_group <> 0 THEN
			SELECT id INTO p_prod
				FROM products
					WHERE company = p_company
						AND name like '% '||p_cert_summ
							AND type = 1;
			IF NOT FOUND THEN
				RAISE SQLSTATE 'S0006';
			END IF;
		END IF;
		
		SELECT id INTO p_stock
			FROM stockcurrent
				WHERE point = p_point
					AND product = p_prod
						AND attributes = 0
							AND company = p_company;
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0002';
		END IF;					
		
		-- Уменьшаем количество
		UPDATE stockcurrent				
			SET units = units - 1
				WHERE point = p_point
					AND product = p_prod
						AND attributes = 0
							AND company = p_company
								RETURNING id, units INTO p_stock, p_units_after;
		IF p_units_after < 0 THEN
			RAISE SQLSTATE 'S0003';
		END IF;
		
		-- Уменьшаем количество(парт. учет)
		UPDATE stockcurrent_part				
			SET units = units - 1
				WHERE point = p_point
					AND product = p_prod
						AND attributes = 0
							AND company = p_company
								AND date = (SELECT min(date)
															FROM stockcurrent_part
																WHERE point = p_point
																	AND product = p_prod
																		AND attributes = 0
																			AND company = p_company)
								RETURNING date INTO p_date;
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0004';
		END IF;						
								
		-- Запись в историю событий
		INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
			VALUES(p_company,now(),2,p_id,p_cert_summ,null,p_trade_point,p_group);		
	
		INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate)
			VALUES(now(),'-4',p_point,p_prod,1,p_cert_summ,0,null,p_company,p_cert_summ,p_date);
		 
	result := json_build_object('code','success','text','');
  return next;
		
	EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','error','text','Сертификат не определен!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','error','text','Не найдена запись на складе!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','error','text','На этом складе недостаточное количество сертификатов!');
			return next;
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','error','text','Ошибка партионного учета. Обратитесь к разработчикам!');
			return next;	
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','error','text','Данный сертификат недоступен для продажи!');
			return next;	
		WHEN SQLSTATE 'S0006' THEN
			result := json_build_object('code','error','text','Товар не определен! Пожалуйста, обратитесь в службу поддержки!');
			return next;		
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;

			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);	
			return next; 
			
END;








$$;


ALTER FUNCTION public.activate_giftcertificates(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 580 (class 1255 OID 16392)
-- Name: add_attributes(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_attributes(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object       json;
 p_error           varchar;
 p_attrlist_code	 bigint;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_company         bigint;
BEGIN

	-- {"user" : 1, "listcode" : "1", "attribcode" : "1", "value" : "Гы-гы"}  

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;
		
		-- Так как фронт не справляется(27.01.2021)
		IF cast(json_object->>'attribcode' as bigint) = 2 AND (json_object->>'value') NOT LIKE '____-__-__' THEN
			RAISE SQLSTATE 'S0001';
		END IF;

		IF json_object->>'listcode' IS NULL OR CAST(json_object->>'listcode' as bigint) = 0 THEN
		
		  INSERT INTO attributelistcode(id,company)
			  VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
				  RETURNING id INTO p_attrlist_code;
			
				
			INSERT INTO attrlist(listcode,attribute,value,istemp,company)
			  VALUES(p_attrlist_code,cast(json_object->>'attribcode' as bigint),json_object->>'value',true,p_company);
				
		ELSE
		
			p_attrlist_code := cast(json_object->>'listcode' as bigint);
			
			INSERT INTO attrlist(listcode,attribute,value,istemp,company)
			  VALUES(p_attrlist_code,cast(json_object->>'attribcode' as bigint),json_object->>'value',true,p_company);
			
		END IF;
		
		
			

		result := json_build_object('code','success','text',p_attrlist_code);
    return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Некорректная дата!');
		 return next;
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;















$$;


ALTER FUNCTION public.add_attributes(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 581 (class 1255 OID 16393)
-- Name: add_discount(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_discount(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       		json;
 discount_object	 		json;
 p_error           		varchar;
 p_discount_code	 		bigint;
 p_code				  	 		varchar;
 p_text				  	 		varchar;
 p_company         		bigint;
 p_point					 		bigint;
 r								 		record;
 p_object					 		bigint;
 p_type 					 		smallint;
 p_send_point		 	 		bigint  := 0;
 p_invoice		 		 		bigint;
 p_user						 		bigint;
 p_datefrom				 		date;
 p_dateto					 		date;
 p_discount				 		float4;
 p_discount_id		 		bigint;
 p_pointsall			 		bigint[];
 p_pointslice			 		bigint;
 p_point_discount  		bigint[][];
 p_point_discount_idx int;
 p_count							bigint;
 p_discountsum				boolean;
BEGIN
	-- {"user" : 1, "company" : 1, "discount" : {"object": 1, "type": 1, "point": 1, "datefrom": "2019-12-06", "dateto": "2022-12-06", "discount": 30, "discountsum": false}}  
	
	/* 
		 0	Весь магазин
		 1	Торговая точка
		 2	Категория
		 3	Бренд 
		 4	Товар
	*/
	SELECT (inf)::json into json_object;
		
		 p_company	:= cast(json_object->>'company' as bigint);
		 p_user 		:= cast(json_object->>'user' as bigint);
	
  SELECT (json_object)->'discount' into discount_object;
			
		 p_type 			 := cast(discount_object->>'type' as smallint);  
		 p_object			 := cast(discount_object->>'object' as bigint); 
		 p_point			 := coalesce(cast(discount_object->>'point' as bigint),0);	 
		 p_datefrom		 := to_date(discount_object->>'datefrom','YYYY-MM-DD');
		 p_dateto			 := to_date(discount_object->>'dateto','YYYY-MM-DD');
		 p_discount		 := cast(nullif(discount_object->>'discount','') as double precision);
		 p_discountsum := cast(coalesce(discount_object->>'discountsum','false') as boolean);
		 
		 IF p_discount IS NULL THEN
		   result := json_build_object('code','error','text','Не указана скидка!');
			 return next;
			 return;
		 END IF;
		 
		 SELECT array_agg(p.id ORDER BY p.id) INTO p_pointsall
		   FROM companies c
			   LEFT JOIN points p on (p.company = c.id and p.id = case when p_point = 0 then p.id else p_point end) 
				   WHERE company = p_company 
					   AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
						   AND p.status = 'ACTIVE'
							   AND c.status = 'ACTIVE';
		 
	 FOREACH p_pointslice IN ARRAY p_pointsall
   LOOP
      
		 -- Удаляем предыдущую подобную скидку (Решили, что не надо. На всякий случай оставляю.)
		 /*IF p_type NOT IN (0,1) THEN
			UPDATE discounts
				SET isactive = false
					WHERE company  = p_company
						AND "object" = case when p_type = 0 then p_pointslice else p_object end
						AND "type"   = case when p_type = 0 then 1 else p_type end
						AND point    = p_pointslice
						AND isactive is true
						AND "id" = (SELECT max(id)
													FROM discounts
														WHERE company  = p_company
															AND "object" = case when p_type = 0 then p_pointslice else p_object end
															AND "type"   = case when p_type = 0 then 1 else p_type end
															AND point    = p_pointslice
															AND isactive is true)
																RETURNING id INTO p_discount_id;
		 END IF;*/														
		 
		 INSERT INTO discounts(company,"type","object",point,discount,startdate,expirationdate,isactive,discountsum)
		   VALUES(p_company,case when p_type = 0 then 1 else p_type end,case when p_type = 0 then p_pointslice else p_object end,p_pointslice,p_discount,
										p_datefrom,p_dateto,true,p_discountsum)
			   RETURNING id INTO p_discount_id; 
			
		 -- Собираем массив (точка - скидка) для дальнейшей передачи в инвойс
		 IF p_point_discount IS NULL THEN
			 p_point_discount := array_agg(ARRAY[p_pointslice, p_discount_id]);
		 ELSE
			 p_point_discount := p_point_discount || ARRAY[p_pointslice, p_discount_id];		
		 END IF;
			
	 END LOOP;
		
	-- Обновление на кассах
		FOR r IN (
					SELECT b.point, b.id as cashbox
					  FROM cashboxes b 
						  WHERE b.point = ANY(p_pointsall) 
							  AND b.deleted = false
								  AND b.isengaged = true
										ORDER BY b.point
		  )
		LOOP
			
			IF p_type IN (2,3/*,4*/) THEN
				SELECT count(s.*) INTO p_count
					FROM products p
						LEFT JOIN stockcurrent s on (p.id = s.product and p.company = s.company)
							LEFT JOIN pointset ps on (ps.stock = s.point) 
								WHERE p.company = p_company
									AND ps.point = r.point
									AND ((p.category = p_object and p_type = 2) OR (p.brand = p_object and p_type = 3) OR (p.id = p_object and p_type = 4));				
				IF p_count = 0 THEN
					CONTINUE;
				END IF;
			END IF;
			
			IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,p_user,'IN_PROCESS',p_company,p_send_point,p_send_point,10)
						RETURNING invoicenumber INTO p_invoice;
				
				FOR p_point_discount_idx IN array_lower(p_point_discount, 1)..array_upper(p_point_discount, 1)
				LOOP
					IF p_point_discount[p_point_discount_idx][1] = p_send_point THEN
						INSERT INTO invoicelist(invoice,stock,attributes,company,newprod)
							VALUES(p_invoice, p_point_discount[p_point_discount_idx][2],0,p_company,false);   
					END IF;
				END LOOP;
				
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_send_point,p_invoice,10,r.cashbox);

		END LOOP; 
		---------------------------------------------------------------
		result := json_build_object('code','success','text','');
    return next;
EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;
END;








$$;


ALTER FUNCTION public.add_discount(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 582 (class 1255 OID 16395)
-- Name: add_discountprod(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_discountprod(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	 p_company         		bigint;
	 p_user						 		bigint;
	 json_object       		json;
	 discount_object	 		json;
	 discount_object2	 		json;
	 p_datefrom				 		date;
	 p_dateto					 		date;
	 p_discount				 		float4;
	 p_object					 		bigint;
	 p_point					 		bigint;
	 r										record;
	 p_created_invoices 	json;
	 p_invoicenumber 	 	  bigint;
	 p_discount_id		 		bigint;
	 p_result				   		json;
	 p_code		      	 		varchar;
   p_text		      	 		varchar;
	 p_func		 			   		varchar;
	 p_error		      	 	varchar;
	 p_check 					 		varchar;
BEGIN

	-- {"user" : "1","company" : 1,"datefrom": "2019-12-06", "dateto": "2022-12-06", "discount": 30, "stock" : [{"object" : "1", "point":"1"}]}
	-- {"user": "42", "company": "18", "discount": {"type": 4, "stock": [{"point": "190", "object": 58023}, {"point": "190", "object": 58220}], "dateto": "2020-01-14",
	-- "datefrom": "2020-01-14", "discount": "2"}}

  SELECT (inf)::json into json_object;

	  p_company		:= cast(json_object->>'company' as bigint);
		p_user 			:= cast(json_object->>'user' as bigint);
		
	SELECT (json_object)->'discount' into discount_object2;
		
		p_datefrom	:= to_date(discount_object2->>'datefrom','YYYY-MM-DD');
		p_dateto		:= to_date(discount_object2->>'dateto','YYYY-MM-DD');
		p_discount	:= cast(discount_object2->>'discount' as double precision);

    FOR discount_object	IN SELECT * FROM json_array_elements((discount_object2)->'stock')
    LOOP

      p_object		:= cast(discount_object->>'object' as bigint); 
			p_point		  := coalesce(cast(discount_object->>'point' as bigint),0);

			INSERT INTO discounts(company,"type","object",point,discount,startdate,expirationdate,isactive)
				VALUES(p_company,4,p_object,p_point,p_discount,p_datefrom,p_dateto,true)
			    RETURNING id INTO p_discount_id; 

      IF p_created_invoices->>cast(p_point as text) IS NULL THEN 
			  INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
	        VALUES(now(),p_user,'IN_PROCESS',p_company,p_point,p_point,'10')
		        RETURNING invoicenumber INTO p_invoicenumber;

				-- Для отработки со стороны терминала
        FOR r IN (
							SELECT p.name, c.id
							  FROM points p
								  LEFT JOIN cashboxes c on (c.point = p.id and c.deleted = false and c.isengaged = true)
                    where p.id = p_point
											and p.company = p_company
					)
				LOOP
				
          IF r.id IS NOT NULL THEN
				    INSERT INTO systemmessage(point,invoice,type_message,cashbox)
				      VALUES(p_point,p_invoicenumber,10,r.id);
					ELSE
						SELECT invoice_processing(json_build_object('invoice',p_invoicenumber,'action','ACCEPTED','user',p_user,'system','ERP',
																	'point',p_point,'cashbox','0')) INTO p_result;
						IF p_result->>'code' LIKE '%error%' THEN
						  p_code := p_result->>'code';
						  p_text := p_result->>'text';
						  p_func := 'invoice_processing';
						  RAISE SQLSTATE 'S0001';
						END IF;
					END IF;
				END LOOP;

        IF p_created_invoices IS NULL THEN
					p_created_invoices := json_build_object(p_point,p_invoicenumber);
				ELSE
				  p_created_invoices := p_created_invoices::jsonb||json_build_object(p_point,p_invoicenumber)::jsonb;
				END IF;
      ELSE
				p_invoicenumber := cast(p_created_invoices->>cast(p_point as text) as bigint);
			END IF;
			
			INSERT INTO invoicelist(invoice,stock,attributes,company,newprod)
				VALUES(p_invoicenumber,p_discount_id,0,p_company,false);	
				
    END LOOP;  

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
     return next;
   WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   return next;
END;





$$;


ALTER FUNCTION public.add_discountprod(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 583 (class 1255 OID 16397)
-- Name: add_giftcertificates(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_giftcertificates(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       		json;
 giftcards_object			json;
 allocation_object		json;
 p_error           		varchar;
 p_company				 		bigint;
 p_user						 		bigint;
 p_balance_compare		bigint := 1;
 p_code								varchar;
 p_balance						bigint := 0;
 p_period							smallint;
 p_selldate						date;
 p_status							varchar;
 p_prod								bigint;
 p_id									bigint;
 p_giftcertificates		bigint[];
 p_barcode						varchar;
 p_name								varchar;
 r										record;
 i										record;
 p_send_point		 	 		bigint  := 0;
 p_invoice						bigint;
 p_balance_prod				json := '{}';
 p_new_prod						boolean := false;
 p_active							boolean := false;
 p_result				 			json;
 p_func_code					varchar;
 p_func_text					varchar;
 p_units							integer;
 p_check						 	varchar;
 p_point							bigint := 0;
 p_point_compare			bigint := 1;
 p_counterparty				bigint;
 p_expiredate					date;
 p_new_stock					bigint;
 p_group							bigint;
BEGIN

	/* 
	{"company":"1","user": "1","giftcards": [{"code":"123","balance":5000,"period":3,"selldate":"12.12.2020","status":"ok"}], 
														"allocation": [{"point":141,"balance":5000,"units":2}]}  
	*/													
	-- status: error/info
	
	SELECT (inf)::json into json_object;
		
		 p_company	 		:= cast(json_object->>'company' as bigint);
		 p_user 		 		:= cast(json_object->>'user' as bigint);
		 
		 -- Проверка на группы сертификатов
		SELECT coalesce(certificate_group,0) INTO p_group
			FROM companies
				WHERE id = p_company;	
		 
	-- Обновление количества на складах
	FOR allocation_object IN SELECT * FROM json_array_elements((json_object)->'allocation') ORDER BY cast(value->>'point' as numeric), cast(value->>'balance' as numeric) 		 
	LOOP
		
		p_balance  := cast(regexp_replace(trim(allocation_object->>'balance'), '\D+', '', 'g') as bigint);
		p_units		 := cast(regexp_replace(trim(allocation_object->>'units'), '\D+', '', 'g') as integer);
		p_point		 := cast(trim(allocation_object->>'point') as bigint);
		
		IF p_units IS NULL THEN
			RAISE SQLSTATE 'S0005';
		END IF;
		
		IF (p_point <> p_point_compare) AND p_invoice IS NULL THEN
			p_point_compare := p_point;
		ELSIF (p_point <> p_point_compare) AND p_invoice IS NOT NULL THEN	
			-- Вызов функции, отправляющей инвойс
			SELECT goods_add(json_build_object('user',p_user,'invoice',p_invoice)) INTO p_result;
			IF p_result->>'code' LIKE '%error%' THEN
				p_func_code := p_result->>'code';
				p_func_text := p_result->>'text';
				RAISE SQLSTATE 'S0003';
			END IF;
			-------(Залипуха, чтобы на всех точках был stockid по сертификатам) P.S. Вызываю несколько раз т.к. postgres не могет работать в вложенными функциями
			FOR i IN (SELECT regexp_replace(pr.name, '\D+', '', 'g') as balance, l.stock as prod,p.id as point, ps.point as store
							    FROM invoicelist l
										LEFT JOIN products pr on (pr.company = l.company and pr.id = l.stock)
										LEFT JOIN points p on (p.company = p_company and p.id <> p_point_compare)
								    LEFT JOIN stockcurrent s on (s.point = p.id and s.attributes = 0 and s.company = p.company and s.product = l.stock) 
									  LEFT JOIN pointset ps on (ps.stock = p.id)
									    WHERE l.invoice = p_invoice
												AND l.newprod is true
												AND p.company = p_company 
										    AND p.point_type = '1'
											  AND s.id is null)
			LOOP
				INSERT INTO stockcurrent(point,product,units,attributes,company)
					VALUES(i.point,i.prod,0,0,p_company)
						RETURNING id INTO p_new_stock;
				INSERT INTO storeprices(store,stock,price,company)
					VALUES(i.store,p_new_stock,cast(i.balance as double precision),p_company);
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
					VALUES(p_company,i.point,current_date,i.prod,0,cast(i.balance as double precision),0);
			END LOOP;
			-------
			p_invoice := null;
			p_point_compare := p_point;
		END IF;
		
		-- Проверяем существование такого товара
			SELECT id, code, name INTO p_prod, p_barcode, p_name
				FROM products
					WHERE company = p_company
						AND type = 1
						AND case when p_balance_prod->>cast(p_balance as text) is not null then 
												(id = cast(p_balance_prod->>cast(p_balance as text) as bigint)) 
										 else 
												(name like '% '||p_balance) end;
			IF NOT FOUND THEN
				p_new_prod := true;
				p_prod := null;
				p_barcode := '2'||lpad(nextval('barcode_seq')||'2',12,'0');
				p_name := 'Подарочный сертификат '||p_balance;
			ELSE
		    p_new_prod := false;	
			END IF;
		
		-- Создаем новый инвойс, если еще не создан
		IF p_invoice IS NULL THEN
			IF p_counterparty IS NULL THEN
				SELECT coalesce(min(id),0) INTO p_counterparty
					FROM counterparties
						WHERE company = p_company;
			END IF;		
			-- Создание инвойса для добавления товара
			INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate,counterparty)
				VALUES(p_user,'FORMATION',p_company,p_point,p_point,2,now(),p_counterparty)
					RETURNING invoicenumber INTO p_invoice;
		END IF;			
		
		-- Вызов функции, записывающей позиции в инвойс
    SELECT invoice_addprod(json_build_object('type','2','user',p_user,'invoice',p_invoice,'stockcurrentfrom',json_agg(json_build_object('id',p_prod,'sku',null,
										'code',p_barcode,'name',p_name,'brand',0,'taxid',0,'amount',p_units,'cnofea',null,'category',0,'newprice',p_balance,'attributes',0,'updateprice',false,
												'purchaseprice',p_balance,'type',1)))) INTO p_result;
		IF p_result->>'code' LIKE '%error%' THEN
			p_func_code := p_result->>'code';
			p_func_text := p_result->>'text';
			RAISE SQLSTATE 'S0002';
		END IF;	
		
		-- Подтягиваем данные после создания
		IF p_new_prod THEN
			SELECT id, code, name INTO p_prod, p_barcode, p_name
				FROM products_temp
					WHERE company = p_company
						AND type = 1
						AND name like '% '||p_balance; 			
			IF NOT FOUND THEN
				RAISE SQLSTATE 'S0004';
			END IF;

		END IF;		
		-- Собираем массив (баланс - id товара) для дальнейшей передачи в инвойс
		IF (p_balance_prod IS NULL) OR (p_balance_prod->>cast(p_balance as text) IS NULL) THEN
			p_balance_prod := p_balance_prod::jsonb||json_build_object(p_balance,p_prod)::jsonb;
		END IF;
	END LOOP;

	-- Вызов функции, отправляющей инвойс
  SELECT goods_add(json_build_object('user',p_user,'invoice',p_invoice)) INTO p_result;
	IF p_result->>'code' LIKE '%error%' THEN
		p_func_code := p_result->>'code';
		p_func_text := p_result->>'text';
		RAISE SQLSTATE 'S0003';
	END IF;
			-------(Залипуха, чтобы на всех точках был stockid по сертификатам) P.S. Вызываю несколько раз т.к. postgres не могет работать в вложенными функциями
			FOR i IN (SELECT regexp_replace(pr.name, '\D+', '', 'g') as balance, l.stock as prod,p.id as point, ps.point as store
							    FROM invoicelist l
										LEFT JOIN products pr on (pr.company = l.company and pr.id = l.stock)
										LEFT JOIN points p on (p.company = p_company and p.id <> p_point_compare)
								    LEFT JOIN stockcurrent s on (s.point = p.id and s.attributes = 0 and s.company = p.company and s.product = l.stock) 
									  LEFT JOIN pointset ps on (ps.stock = p.id)
									    WHERE l.invoice = p_invoice
												AND l.newprod is true
												AND p.company = p_company 
										    AND p.point_type = '1'
											  AND s.id is null)
			LOOP
				INSERT INTO stockcurrent(point,product,units,attributes,company)
					VALUES(i.point,i.prod,0,0,p_company)
						RETURNING id INTO p_new_stock;
				INSERT INTO storeprices(store,stock,price,company)
					VALUES(i.store,p_new_stock,cast(i.balance as double precision),p_company);
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
					VALUES(p_company,i.point,current_date,i.prod,0,cast(i.balance as double precision),0);
			END LOOP;
			-------
	
	FOR giftcards_object IN SELECT * FROM json_array_elements((json_object)->'giftcards') ORDER BY cast(value->>'balance' as numeric) 		 
	LOOP
		
		p_code 		 	 	:= trim(giftcards_object->>'code');
		p_balance 	 	:= cast(regexp_replace(trim(giftcards_object->>'balance'), '\D+', '', 'g') as bigint);
		p_period 	 		:= cast(regexp_replace(trim(giftcards_object->>'period'), '\D+', '', 'g') as smallint);
		p_selldate 	 	:= to_date(nullif(trim(giftcards_object->>'selldate'),''),'DD.MM.YYYY');
		p_status			:= lower(trim(giftcards_object->>'status'));
		
		-- Определяем id товара
		IF (p_balance_compare <> p_balance) THEN
			p_balance_compare := p_balance;
			p_prod := cast(p_balance_prod->>cast(p_balance_compare as text) as bigint);
		END IF;	

		IF p_status = 'ok' THEN	
			-- Определение, активен или не активен проданный сертификат
			IF p_selldate IS NOT NULL AND ((p_selldate + cast(p_period||' month' as interval))::date <= current_date) THEN
				p_active := true;
				p_expiredate := (p_selldate + cast(p_period||' month' as interval))::date;
				INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
					VALUES(p_company,now(),2,p_prod,p_balance,null,null,p_group);
			ELSE
				p_active := false;
			END IF;
		
			INSERT INTO giftcertificates(company,product,code,balance,type,expiredate,active,period,denomination,selldate)
				VALUES(p_company,p_prod,p_code,p_balance,1,p_expiredate,p_active,p_period,p_balance,p_selldate)
					RETURNING id INTO p_id;		
					
			INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
				VALUES(p_company,now(),1,p_id,p_balance,null,null,p_group);
				
			p_giftcertificates := p_giftcertificates || ARRAY[p_id];
		
		ELSIF p_status = 'info' THEN	
			UPDATE giftcertificates
				SET expiredate = null, active = false, company = p_company
					WHERE case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end
						AND code = p_code
							RETURNING id INTO p_id;
							
			INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
				VALUES(p_company,now(),5,p_id,p_balance,null,null,p_group);
						
			p_giftcertificates := p_giftcertificates || ARRAY[p_id];
								
		ELSE
			RAISE SQLSTATE 'S0001';
		END IF;
	
	END LOOP;
	
	-- Отправка списка новых сертификатов
	IF p_giftcertificates IS NOT NULL THEN
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id					
		  )
		LOOP
					
			IF p_send_point <> r.point THEN	
			
				p_send_point := r.point;
				
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,p_user,'IN_PROCESS',p_company,p_send_point,p_send_point,11)
						RETURNING invoicenumber INTO p_invoice;
						
				INSERT INTO invoicelist(invoice,stock,attributes,company,newprod) 
					SELECT p_invoice,unnest(a),0,p_company,false
						FROM (select p_giftcertificates as a) certs;	
				
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_send_point,p_invoice,11,r.cashbox);

		END LOOP; 
	END IF;
		 
	result := json_build_object('code','success','text','');
  return next;
		
	EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','error','text','Передан некорректный статус записи! Обратитесь к разработчикам!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code',p_func_code,'text','invoice_addprod: '||p_func_text,'invoice',p_invoice,'prodcode',p_barcode);
			return next; 
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code',p_func_code,'text','goods_add: '||p_func_text,'invoice',p_invoice);
			return next;
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','error','text','Продукт не найден после создания!','invoice',p_invoice);
			return next;
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','error','text','Количество сертификатов не получено!','invoice',p_invoice,'prodcode',p_barcode);
			return next;	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			IF p_check = 'giftcertificates_idx' THEN
				result := json_build_object('code','error','text','Сертификат с кодом "'||p_code||'" существует в базе!(Срок действия еще не истек)');
			ELSIF p_check = 'invoicestockfrom_fk_points' THEN	
				result := json_build_object('code','error','text','Идентификатор склада не определен!');
			ELSE 
				result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			END IF;
			
			return next; 
			
END;








$$;


ALTER FUNCTION public.add_giftcertificates(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 575 (class 1255 OID 32844)
-- Name: add_giftcertificates_prover(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_giftcertificates_prover(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       		json;
 giftcards_object			json;
 allocation_object		json;
 p_error           		varchar;
 p_company				 		bigint;
 p_user						 		bigint;
 p_balance_compare		bigint := 1;
 p_code								varchar;
 p_balance						bigint := 0;
 p_period							smallint;
 p_selldate						date;
 p_status							varchar;
 p_prod								bigint;
 p_id									bigint;
 p_giftcertificates		bigint[];
 p_barcode						varchar;
 p_name								varchar;
 r										record;
 i										record;
 p_send_point		 	 		bigint  := 0;
 p_invoice						bigint;
 p_balance_prod				json := '{}';
 p_new_prod						boolean := false;
 p_active							boolean := false;
 p_result				 			json;
 p_func_code					varchar;
 p_func_text					varchar;
 p_units							integer;
 p_check						 	varchar;
 p_point							bigint := 0;
 p_point_compare			bigint := 1;
 p_counterparty				bigint;
 p_expiredate					date;
 p_new_stock					bigint;
 p_group							bigint;
 p22				bigint;
BEGIN

	/* 
	{"company":"1","user": "1","giftcards": [{"code":"123","balance":5000,"period":3,"selldate":"12.12.2020","status":"ok"}], 
														"allocation": [{"point":141,"balance":5000,"units":2}]}  
	*/													
	-- status: error/info
	
	--SELECT (inf)::json into json_object;

	SELECT ('{"company":"18","user": "42",
"giftcards": [{"code": "2561","balance": 500,"period": 1,"selldate": "16.09.2025","name": "Подарочный сертификат 500",
            "text": "","status": "ok"},
            {"code": "2572","balance": 10100,"period": 4,"selldate": "14.09.2025","name": "Подарочный сертификат 10100",
            "text": "","status": "ok"}],
    "allocation": [{"point": "24","balance": "500","units": 1},
        {"point": "24","balance": "10100","units": 1}]
}' )::json into json_object;
		
		 p_company	 		:= cast(json_object->>'company' as bigint);
		 p_user 		 		:= cast(json_object->>'user' as bigint);
		 
		 -- Проверка на группы сертификатов
		SELECT coalesce(certificate_group,0) INTO p_group
			FROM companies
				WHERE id = p_company;	
		 
	-- Обновление количества на складах
	FOR allocation_object IN SELECT * FROM json_array_elements((json_object)->'allocation') ORDER BY cast(value->>'point' as numeric), cast(value->>'balance' as numeric) 		 
	LOOP
		
		p_balance  := cast(regexp_replace(trim(allocation_object->>'balance'), '\D+', '', 'g') as bigint);
		p_units		 := cast(regexp_replace(trim(allocation_object->>'units'), '\D+', '', 'g') as integer);
		p_point		 := cast(trim(allocation_object->>'point') as bigint);
		
		IF p_units IS NULL THEN
			RAISE SQLSTATE 'S0005';
		END IF;
		
		IF (p_point <> p_point_compare) AND p_invoice IS NULL THEN
			p_point_compare := p_point;
		ELSIF (p_point <> p_point_compare) AND p_invoice IS NOT NULL THEN	
			-- Вызов функции, отправляющей инвойс
			SELECT goods_add(json_build_object('user',p_user,'invoice',p_invoice)) INTO p_result;
			IF p_result->>'code' LIKE '%error%' THEN
				p_func_code := p_result->>'code';
				p_func_text := p_result->>'text';
				RAISE SQLSTATE 'S0003';
			END IF;
			-------(Залипуха, чтобы на всех точках был stockid по сертификатам) P.S. Вызываю несколько раз т.к. postgres не могет работать в вложенными функциями
			FOR i IN (SELECT regexp_replace(pr.name, '\D+', '', 'g') as balance, l.stock as prod,p.id as point, ps.point as store
							    FROM invoicelist l
										LEFT JOIN products pr on (pr.company = l.company and pr.id = l.stock)
										LEFT JOIN points p on (p.company = p_company and p.id <> p_point_compare)
								    LEFT JOIN stockcurrent s on (s.point = p.id and s.attributes = 0 and s.company = p.company and s.product = l.stock) 
									  LEFT JOIN pointset ps on (ps.stock = p.id)
									    WHERE l.invoice = p_invoice
												AND l.newprod is true
												AND p.company = p_company 
										    AND p.point_type = '1'
											  AND s.id is null)
			LOOP
				INSERT INTO stockcurrent(point,product,units,attributes,company)
					VALUES(i.point,i.prod,0,0,p_company)
						RETURNING id INTO p_new_stock;
				INSERT INTO storeprices(store,stock,price,company)
					VALUES(i.store,p_new_stock,cast(i.balance as double precision),p_company);
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
					VALUES(p_company,i.point,current_date,i.prod,0,cast(i.balance as double precision),0);
			END LOOP;
			-------
			p_invoice := null;
			p_point_compare := p_point;
		END IF;
		
		-- Проверяем существование такого товара
			SELECT id, code, name INTO p_prod, p_barcode, p_name
				FROM products
					WHERE company = p_company
						AND type = 1
						AND case when p_balance_prod->>cast(p_balance as text) is not null then 
												(id = cast(p_balance_prod->>cast(p_balance as text) as bigint)) 
										 else 
												(name like '% '||p_balance) end;
			IF NOT FOUND THEN
				p_new_prod := true;
				p_prod := null;
				p_barcode := '2'||lpad(nextval('barcode_seq')||'2',12,'0');
				p_name := 'Подарочный сертификат '||p_balance;
			ELSE
		    p_new_prod := false;	
			END IF;
		
		-- Создаем новый инвойс, если еще не создан
		IF p_invoice IS NULL THEN
			IF p_counterparty IS NULL THEN
				SELECT coalesce(min(id),0) INTO p_counterparty
					FROM counterparties
						WHERE company = p_company;
			END IF;		
			-- Создание инвойса для добавления товара
			INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate,counterparty)
				VALUES(p_user,'FORMATION',p_company,p_point,p_point,2,now(),p_counterparty)
					RETURNING invoicenumber INTO p_invoice;
		END IF;			
		
		-- Вызов функции, записывающей позиции в инвойс
    SELECT invoice_addprod(json_build_object('type','2','user',p_user,'invoice',p_invoice,'stockcurrentfrom',json_agg(json_build_object('id',p_prod,'sku',null,
										'code',p_barcode,'name',p_name,'brand',0,'taxid',0,'amount',p_units,'cnofea',null,'category',0,'newprice',p_balance,'attributes',0,'updateprice',false,
												'purchaseprice',p_balance,'type',1)))) INTO p_result;
		IF p_result->>'code' LIKE '%error%' THEN
			p_func_code := p_result->>'code';
			p_func_text := p_result->>'text';
			RAISE SQLSTATE 'S0002';
		END IF;	
		
		-- Подтягиваем данные после создания
		IF p_new_prod THEN
			SELECT id, code, name INTO p_prod, p_barcode, p_name
				FROM products_temp
					WHERE company = p_company
						AND type = 1
						AND name like '% '||p_balance; 			
			IF NOT FOUND THEN
				RAISE SQLSTATE 'S0004';
			END IF;

		END IF;		
		-- Собираем массив (баланс - id товара) для дальнейшей передачи в инвойс
		IF (p_balance_prod IS NULL) OR (p_balance_prod->>cast(p_balance as text) IS NULL) THEN
			p_balance_prod := p_balance_prod::jsonb||json_build_object(p_balance,p_prod)::jsonb;
		END IF;
	END LOOP;

	-- Вызов функции, отправляющей инвойс
  SELECT goods_add(json_build_object('user',p_user,'invoice',p_invoice)) INTO p_result;
	IF p_result->>'code' LIKE '%error%' THEN
		p_func_code := p_result->>'code';
		p_func_text := p_result->>'text';
		RAISE SQLSTATE 'S0003';
	END IF;
			-------(Залипуха, чтобы на всех точках был stockid по сертификатам) P.S. Вызываю несколько раз т.к. postgres не могет работать в вложенными функциями
			FOR i IN (SELECT regexp_replace(pr.name, '\D+', '', 'g') as balance, l.stock as prod,p.id as point, ps.point as store
							    FROM invoicelist l
										LEFT JOIN products pr on (pr.company = l.company and pr.id = l.stock)
										LEFT JOIN points p on (p.company = p_company and p.id <> p_point_compare)
								    LEFT JOIN stockcurrent s on (s.point = p.id and s.attributes = 0 and s.company = p.company and s.product = l.stock) 
									  LEFT JOIN pointset ps on (ps.stock = p.id)
									    WHERE l.invoice = p_invoice
												AND l.newprod is true
												AND p.company = p_company 
										    AND p.point_type = '1'
											  AND s.id is null)
			LOOP
				INSERT INTO stockcurrent(point,product,units,attributes,company)
					VALUES(i.point,i.prod,0,0,p_company)
						RETURNING id INTO p_new_stock;

                p22:=i.store;
						
				INSERT INTO storeprices(store,stock,price,company)
					VALUES(i.store,p_new_stock,cast(i.balance as double precision),p_company);
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
					VALUES(p_company,i.point,current_date,i.prod,0,cast(i.balance as double precision),0);
			END LOOP;
			-------
	
	FOR giftcards_object IN SELECT * FROM json_array_elements((json_object)->'giftcards') ORDER BY cast(value->>'balance' as numeric) 		 
	LOOP
		
		p_code 		 	 	:= trim(giftcards_object->>'code');
		p_balance 	 	:= cast(regexp_replace(trim(giftcards_object->>'balance'), '\D+', '', 'g') as bigint);
		p_period 	 		:= cast(regexp_replace(trim(giftcards_object->>'period'), '\D+', '', 'g') as smallint);
		p_selldate 	 	:= to_date(nullif(trim(giftcards_object->>'selldate'),''),'DD.MM.YYYY');
		p_status			:= lower(trim(giftcards_object->>'status'));
		
		-- Определяем id товара
		IF (p_balance_compare <> p_balance) THEN
			p_balance_compare := p_balance;
			p_prod := cast(p_balance_prod->>cast(p_balance_compare as text) as bigint);
		END IF;	

		IF p_status = 'ok' THEN	
			-- Определение, активен или не активен проданный сертификат
			IF p_selldate IS NOT NULL AND ((p_selldate + cast(p_period||' month' as interval))::date <= current_date) THEN
				p_active := true;
				p_expiredate := (p_selldate + cast(p_period||' month' as interval))::date;
				INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
					VALUES(p_company,now(),2,p_prod,p_balance,null,null,p_group);
			ELSE
				p_active := false;
			END IF;
		
			INSERT INTO giftcertificates(company,product,code,balance,type,expiredate,active,period,denomination,selldate)
				VALUES(p_company,p_prod,p_code,p_balance,1,p_expiredate,p_active,p_period,p_balance,p_selldate)
					RETURNING id INTO p_id;		
					
			INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
				VALUES(p_company,now(),1,p_id,p_balance,null,null,p_group);
				
			p_giftcertificates := p_giftcertificates || ARRAY[p_id];
		
		ELSIF p_status = 'info' THEN	
			UPDATE giftcertificates
				SET expiredate = null, active = false, company = p_company
					WHERE case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end
						AND code = p_code
							RETURNING id INTO p_id;
							
			INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
				VALUES(p_company,now(),5,p_id,p_balance,null,null,p_group);
						
			p_giftcertificates := p_giftcertificates || ARRAY[p_id];
								
		ELSE
			RAISE SQLSTATE 'S0001';
		END IF;
	
	END LOOP;
	
	-- Отправка списка новых сертификатов
	IF p_giftcertificates IS NOT NULL THEN
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id					
		  )
		LOOP
					
			IF p_send_point <> r.point THEN	
			
				p_send_point := r.point;
				
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,p_user,'IN_PROCESS',p_company,p_send_point,p_send_point,11)
						RETURNING invoicenumber INTO p_invoice;
						
				INSERT INTO invoicelist(invoice,stock,attributes,company,newprod) 
					SELECT p_invoice,unnest(a),0,p_company,false
						FROM (select p_giftcertificates as a) certs;	
				
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_send_point,p_invoice,11,r.cashbox);

		END LOOP; 
	END IF;
		 
	result := json_build_object('code','success','text','');
  return next;
		
	EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','error','text','Передан некорректный статус записи! Обратитесь к разработчикам!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code',p_func_code,'text','invoice_addprod: '||p_func_text,'invoice',p_invoice,'prodcode',p_barcode);
			return next; 
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code',p_func_code,'text','goods_add: '||p_func_text,'invoice',p_invoice);
			return next;
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','error','text','Продукт не найден после создания!','invoice',p_invoice);
			return next;
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','error','text','Количество сертификатов не получено!','invoice',p_invoice,'prodcode',p_barcode);
			return next;	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			IF p_check = 'giftcertificates_idx' THEN
				result := json_build_object('code','error','text','Сертификат с кодом "'||p_code||'" существует в базе!(Срок действия еще не истек)');
			ELSIF p_check = 'invoicestockfrom_fk_points' THEN	
				result := json_build_object('code','error','text','Идентификатор склада не определен!');
			ELSE 
				result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			END IF;
			
			return next; 
			
END;

$$;


ALTER FUNCTION public.add_giftcertificates_prover(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 586 (class 1255 OID 16399)
-- Name: add_margin_plan(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_margin_plan(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
		p_inf json;
		p_error varchar;
		p_id int8;
	BEGIN
		select check_in(inf) into p_inf;
		
		update margin_plan set active = false
		where type = cast(p_inf ->> 'type' as smallint) 
			and object = cast(p_inf ->> 'object' as bigint)
			and company = cast(p_inf ->> 'company' as bigint);
		
		insert into margin_plan(rate,sum,type,object,company)
		values(cast(nullif(p_inf->>'rate','0.0') as double precision),
					cast(nullif(p_inf->>'sum','0.0') as double precision),
					cast(p_inf ->> 'type' as smallint),
					cast(p_inf ->> 'object' as bigint),
					cast(p_inf ->> 'company' as bigint)
		)RETURNING id INTO p_id;
		
		result := json_build_object('code','success','text',p_id);
		
		RETURN NEXT;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'internal_error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		return next;
	END
$$;


ALTER FUNCTION public.add_margin_plan(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 599 (class 1255 OID 16400)
-- Name: add_news(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_news(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object       		json;
 p_error           		varchar;
 p_category				  	int;
 p_header							text;
 p_content				  	text;
 p_date						 		TIMESTAMP;
 p_user								bigint;
 u                    record;
 p_news_id						bigint;
BEGIN
-- { "data" : {"content": "342rewfdsf sdfsd e", "category": 1, "header": "1werew 234", "date": "2019-12-06"}}  
-- Создание новостей для админки.
	SELECT (inf)::json into json_object;

		p_date := TO_TIMESTAMP(json_object->>'date','MM.DD.YYYY HH24:MI:SS');
		p_category := cast(trim(json_object->>'category') as int);
		p_header := cast(trim(json_object->>'header') as text);
		p_content := cast(trim(json_object->>'content') as text);

		p_news_id = nextval('news_id_sequence');

		IF p_date IS NULL THEN
			RAISE SQLSTATE 'S0001';
		ELSIF p_category IS NULL THEN
			RAISE SQLSTATE 'S0002';
		ELSIF p_header IS NULL THEN
			RAISE SQLSTATE 'S0003';
		ELSIF p_content IS NULL THEN
			RAISE SQLSTATE 'S0004';
		END IF;

		INSERT INTO news(id,date,category,header,content)
		VALUES(p_news_id,p_date,p_category,p_header,p_content);
		
		
			FOR u IN (
			-----31.03.2023
			/*
			SELECT id
				FROM erp_users
				WHERE status = 'ACTIVE'
				ORDER BY id
				*/
			SELECT e.id
				FROM erp_users e inner join companies c on (e.company=c.id)
				WHERE e.status = 'ACTIVE' 
				and c.partner_id =( case when json_object->>'partner_id' is null then c.partner_id  
				else  cast(trim(json_object->>'partner_id') as int) end)
				ORDER BY e.id
			-----31.03.2023
		) 
		LOOP
		
			INSERT INTO news_diary(news_id,user_id,flag)
				VALUES (p_news_id, u.id,true);

		END LOOP;
	
		result := json_build_object('code','success','text','Новость успешно создана!');
		return next;
		return;

		EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			 result := json_build_object('code','error','text','Нет даты!');
			 return next;
		WHEN SQLSTATE 'S0002' THEN
			 result := json_build_object('code','error','text','Категория не может быть пустой!');
			 return next; 
		WHEN SQLSTATE 'S0003' THEN
			 result := json_build_object('code','error','text','Заголовок не может быть пустой!');
			 return next; 
		WHEN SQLSTATE 'S0004' THEN
			 result := json_build_object('code','error','text','Текст не может быть пустой');
			 return next;  	
		WHEN OTHERS THEN
			 RAISE NOTICE 'internal_error: %', SQLERRM;
			 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
			 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			 return next;

END;


$$;


ALTER FUNCTION public.add_news(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 600 (class 1255 OID 16401)
-- Name: add_pricelog(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_pricelog() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
BEGIN
  INSERT INTO prices_log 
  (product, price, point, company, type, workdate, userid, counterparty,deleted,wholesale_price)
  SELECT product, price, point, company, type, workdate, userid, counterparty, deleted,wholesale_price
  FROM PRICEs WHERE product = NEW.product and counterparty = NEW.counterparty and company = NEW.company and type = NEW.type;
  RETURN NEW;
END 
$$;


ALTER FUNCTION public.add_pricelog() OWNER TO postgres;

--
-- TOC entry 601 (class 1255 OID 16402)
-- Name: add_products_barcode(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_products_barcode(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	p_error text;
	r record; 
	p_code text;
	p_product bigint;
	p_company bigint;
	p_user bigint;
	p_id bigint := 0;
	p_delete boolean;
	p_status varchar(10):= 'ERROR';
	p_invoice bigint;
	p_stock bigint;
	p_version bigint;
	p_count smallint;
	p_main_code text;

BEGIN
	
	p_product := cast(inf ->> 'product' as bigint);
	p_company := cast(inf ->> 'company' as bigint);
	p_delete := cast(inf ->> 'delete' as boolean);
	p_user := cast(inf ->> 'user' as bigint);
	p_code := inf->>'barcode';
		
	
	IF p_delete IS NULL THEN
		RAISE SQLSTATE 'S0001';
	END IF;
	
	IF p_product IS NULL THEN
		RAISE SQLSTATE 'S0002';
	END IF;
	
	IF p_company IS NULL THEN
		RAISE SQLSTATE 'S0003';
	END IF;
	
	IF p_code IS NULL THEN
			RAISE SQLSTATE 'S0004';
	END IF;
	
	
	
	/*SELECT cb.id cashbox INTO p_, cv."version"
		from cashboxes cb
			left join points po
				on cb.point = po.id
					left join cashbox_version cv
						on cv.cashbox = cb.id
							where po.company = 124;
		*/					
	
	SELECT code INTO p_main_code
		FROM products WHERE id = p_product 
			AND company = p_company;
			
	IF p_delete  THEN
		
		IF p_code = p_main_code THEN
			RAISE SQLSTATE 'S0006';
		END IF;
		
		DELETE FROM products_barcode
			WHERE product = p_product AND barcode = p_code
				;--RETURNING id INTO p_id;
		
		p_status := 'deleted';
		
				-- Рассылка изменений Справочника на все кассы			
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
				FROM companies c
					LEFT JOIN points p on (p.company = c.id) 
						LEFT JOIN cashboxes b on (b.point = p.id)
							--LEFT JOIN cashbox_version cb on (b.id = cb.cashbox)
							WHERE company = p_company 
								AND point_type = '2' --// IN ('0','1') -- На торговую точку 
									AND p.status = 'ACTIVE'
										AND c.status = 'ACTIVE'
											AND b.deleted = false
												AND b.isengaged = true
													--AND cb.version = 3
		)
		LOOP		
	
		--SELECT id INTO p_stock FROM stockcurrent WHERE product = p_product AND company = p_company;
		-- Создание и заполнение накладной(инвойса) для обновления справочников
		INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
			VALUES(now(),p_user,'IN_PROCESS',p_company,r.point,r.point,20)
				RETURNING invoicenumber INTO p_invoice;
					
		INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company,sku) 
			VALUES(p_invoice,p_product,0,0,false,false,true,p_company,p_code);					
		
		-- Формирование системного сообщения для терминалов для обновления справочников
		INSERT INTO systemmessage(point,invoice,type_message,cashbox)
			VALUES(r.point,p_invoice,20,r.cashbox);			

		END LOOP;		
		
	ELSE
	
	
	-- Проверка на наличие такого товара в таблице products_barcode
		SELECT COUNT(*) 
			INTO p_count 
				FROM products_barcode 
					WHERE product = p_product 
						AND barcode = p_main_code 
							AND company = p_company;
		
		IF p_count = 0 then 
			-- Если такого товара нет, то нужно добавить гео в таблицу
			INSERT INTO products_barcode
				(product, barcode, company)
					VALUES
						(p_product,p_main_code,p_company);
			
		END IF;
		
	-- Проверка на наличие такого штрих-кода у компании
		SELECT COUNT(*) INTO p_count FROM products_barcode 
			WHERE barcode = p_code AND company = p_company;
		
		IF p_count > 0 then 
			RAISE SQLSTATE 'S0005';
		ELSE
		
			INSERT INTO products_barcode
				(product,barcode,company)
					VALUES
						(p_product,p_code,p_company)
							RETURNING id INTO p_id;
		
			p_status := 'inserted';
		
			-- Рассылка изменений Справочника на все кассы			
			FOR r IN (
				SELECT p.id as point, b.id as cashbox
					FROM companies c
						LEFT JOIN points p on (p.company = c.id) 
							LEFT JOIN cashboxes b on (b.point = p.id)
								
									WHERE company = p_company 
										AND point_type = '2' --// IN ('0','1') -- На торговую точку 
											AND p.status = 'ACTIVE'
												AND c.status = 'ACTIVE'
													AND b.deleted = false
														AND b.isengaged = true
															
																ORDER BY p.id
			)
			LOOP		
	
			-- Создание и заполнение накладной(инвойса) для обновления справочников
			INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
				VALUES(now(),p_user,'IN_PROCESS',p_company,r.point,r.point,19)
					RETURNING invoicenumber INTO p_invoice;
					
			INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company,sku) 
				VALUES(p_invoice,p_product,0,0,false,false,true,p_company,p_code);					
		
			-- Формирование системного сообщения для терминалов для обновления справочников
			INSERT INTO systemmessage(point,invoice,type_message,cashbox)
				VALUES(r.point,p_invoice,19,r.cashbox);			
					
			END LOOP;		
		END IF;	
	END IF;
	
		

		
			
	
	res = json_build_object('code','success','status',p_status,'id',p_id);
	return next;
	
		
	
EXCEPTION
	WHEN SQLSTATE 'S0001' THEN
		res := json_build_object('code','error','text','Empty deleted!');
		RETURN next;
	WHEN SQLSTATE 'S0002' THEN
		res := json_build_object('code','error','text','Empty product!');
		RETURN next;
	WHEN SQLSTATE 'S0003' THEN
		res := json_build_object('code','error','text','Empty company!');
		RETURN next;
	WHEN SQLSTATE 'S0004' THEN
		res := json_build_object('code','error','text','Empty code!');
		RETURN next;
	WHEN SQLSTATE 'S0005' THEN
		res := json_build_object('code','error','text','Товар с таким штрих-кодом уже существует (у вашей компании)');
		RETURN next;
	WHEN SQLSTATE 'S0006' THEN
		res := json_build_object('code','error','text','Нельзя удалить основной штрих-код!');
		RETURN next;
	WHEN OTHERS THEN
		RAISE NOTICE 'internal error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		res := json_build_object('code','internalerror','text',sqlstate||':'||SQLERRM||':'||p_error,'date',now(),'status',p_status);
		return next;

RETURN;
END;
$$;


ALTER FUNCTION public.add_products_barcode(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 602 (class 1255 OID 16404)
-- Name: add_promotion(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_promotion(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       		 json;
 discount_object	 		 json;
 details_object				 json;
 val_object						 json;
 p_code				  	 		 varchar;
 p_text				  	 		 varchar;
 p_error           		 varchar;
 p_company         		 bigint;
 p_point					 		 bigint;
 p_user						 		 bigint;
 p_condlist						 bigint;
 p_disclist						 bigint;
 p_id									 bigint;
 p_id_details					 smallint;
 p_pointslice			 		 bigint;
 p_pointsall			 		 bigint[];
 p_point_promotion  	 bigint[][];
 r										 record;
 p_send_point		 	 		 bigint  := 0;
 p_invoice		 		 		 bigint;
 p_point_promotion_idx int;
 p_priority						 smallint;
BEGIN

/* { 
    "promotionName":"",
		"point":1,
		"user":1,
		"company":15,
    "startdate":"2019-12-06", 
    "expirationdate":"2019-12-06",
    "if":{ 
        "id":"int_value",
        "values":[ 
            { 
                "id":"int_value",
                "value":"double_value"
            }
        ]
    },
    "then": 
        { 
            "id":1,
            "values":[ 
                { 
                    "id":"int_value",
                    "value":"double_value"
                }
            ]
        }
}  */
	
	-- Основная информация
	SELECT (inf)::json into json_object;
	
		p_company	:= cast(json_object->>'company' as bigint);
		p_user 		:= cast(json_object->>'user' as bigint); 
		p_point		:= cast(json_object->>'point' as bigint);
		
		IF p_point IS NULL THEN
			RAISE SQLSTATE 'S0001';
		ELSIF p_company IS NULL OR p_user IS NULL THEN
			RAISE SQLSTATE 'S0002';
		END IF;
		
		SELECT array_agg(p.id ORDER BY p.id) INTO p_pointsall
		   FROM companies c
			   LEFT JOIN points p on (p.company = c.id and p.id = case when p_point = 0 then p.id else p_point end) 
				   WHERE company = p_company 
					   AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
						   AND p.status = 'ACTIVE'
							   AND c.status = 'ACTIVE';
								 
		FOREACH p_pointslice IN ARRAY p_pointsall
		LOOP						 
			
			SELECT coalesce(max(priority),0) + 1 INTO p_priority
				FROM promotions
					WHERE company = p_company
						AND point = p_pointslice
							AND isactive is true;
							
			INSERT INTO promotions(company,point,name,bdate,edate,isactive,priority)
				VALUES(p_company,p_pointslice,trim(json_object->>'promotionName'),to_date(json_object->>'startdate','YYYY-MM-DD'),to_date(json_object->>'expirationdate','YYYY-MM-DD'),true,p_priority) 
					RETURNING id, condlist, disclist INTO p_id, p_condlist, p_disclist;
	
			-- Данные по условиям
			SELECT (json_object)->'if' into details_object;
	
				p_id_details := cast(details_object->>'id' as smallint);
		
				FOR val_object IN SELECT * FROM json_array_elements((details_object)->'values')   
				LOOP
		
					INSERT INTO promconditions(listcode,type,object,amount,company)
						VALUES(p_condlist,p_id_details,coalesce(cast(val_object->>'id' as bigint),0),cast(val_object->>'value' as double precision),p_company);
	
				END LOOP;
	
			-- Данные по действиям (скидкам)
			SELECT (json_object)->'then' into details_object;
			
				p_id_details := cast(details_object->>'id' as smallint);
	
				FOR val_object IN SELECT * FROM json_array_elements((details_object)->'values')   
				LOOP
		
					INSERT INTO promdiscounts(listcode,type,object,rate,company)
						VALUES(p_disclist,p_id_details,coalesce(cast(val_object->>'id' as bigint),0),cast(val_object->>'value' as smallint),p_company);
		
				END LOOP;	
	
			
			-- Собираем массив (точка - акция) для дальнейшей передачи в инвойс
			IF p_point_promotion IS NULL THEN
				p_point_promotion := array_agg(ARRAY[p_pointslice, p_id]);
			ELSE
				p_point_promotion := p_point_promotion || ARRAY[p_pointslice, p_id];		
			END IF;

		END LOOP;
		
		-- Обновление на кассах
		FOR r IN (
					SELECT b.point, b.id as cashbox
					  FROM cashboxes b 
						  WHERE b.point = ANY(p_pointsall) 
							  AND b.deleted = false
								  AND b.isengaged = true
										ORDER BY b.point
		  )
		LOOP
			
			IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,p_user,'IN_PROCESS',p_company,p_send_point,p_send_point,13)
						RETURNING invoicenumber INTO p_invoice;

				FOR p_point_promotion_idx IN array_lower(p_point_promotion, 1)..array_upper(p_point_promotion, 1)
				LOOP
					IF p_point_promotion[p_point_promotion_idx][1] = p_send_point THEN
						INSERT INTO invoicelist(invoice,stock,attributes,company,newprod)
							VALUES(p_invoice, p_point_promotion[p_point_promotion_idx][2],0,p_company,false);   
					END IF;
				END LOOP;
			END IF;
		
			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_send_point,p_invoice,13,r.cashbox);
			
		END LOOP;
		 
		result := json_build_object('code','success','text','');
    return next;
		
EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Не указана точка применения акции!');
		 return next;
	WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Произошла внутренняя ошибка! Пожалуйста, обратитесь в службу поддержки!');
		 return next;	 
	WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;
END;








$$;


ALTER FUNCTION public.add_promotion(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 603 (class 1255 OID 16406)
-- Name: add_settings(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.add_settings(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
		p_inf json;
		p_settings json;
		p_error varchar;
		p_company int8;
	BEGIN
		--{"settings":[{"name":"","value":""},{"name":"","value":""}]}
		select check_in(inf) into p_inf;
		
		p_company = cast(p_inf ->> 'company' as bigint);
		
		FOR p_settings IN SELECT * FROM json_array_elements((p_inf)->'settings')
		LOOP
			update settings set value = trim(p_settings->>'value') 
			where name = trim(p_settings->>'name') and company = p_company;
			IF NOT FOUND THEN
					INSERT INTO settings(name,value,company)
					VALUES(
						trim(p_settings->>'name'),
						trim(p_settings->>'value'),
						p_company
					);
			END IF;
		END LOOP;
		
		result := json_build_object('code','success','text','');
		
		RETURN NEXT;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'internal_error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		return next;
	END
$$;


ALTER FUNCTION public.add_settings(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 604 (class 1255 OID 16407)
-- Name: attributes_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.attributes_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object    			 json;
 attributes_object 	 	 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_check							 varchar;
 p_id									 bigint; 
 p_sprname						 varchar;
 p_format						 	 varchar;
 p_deleted						 boolean;

BEGIN

	-- {"user": 1, "attributes": {"id": 1, "name": "Цвет", "deleted": "1", "format": "SPR"}}

	SELECT (inf)::json into json_object; 

  SELECT (json_object)->'attributes' into attributes_object;

		p_id		  := cast(trim(attributes_object->>'id') as bigint);
		p_sprname	:= trim(attributes_object->>'name');
		p_format	:= upper(trim(attributes_object->>'format'));
    p_deleted	:= cast(trim(attributes_object->>'deleted') as boolean);
		
		IF p_format NOT IN (SELECT name FROM format) THEN
			result := json_build_object('code','error','text','Некорректный формат!');
			return next;
			return;
		END IF;

		IF p_id IS NOT NULL THEN
		  UPDATE attributenames
			  SET values = p_sprname, deleted = p_deleted, format = p_format
			    WHERE id = p_id;
		ELSE
		  INSERT INTO attributenames(values,deleted,format)
				VALUES (p_sprname,p_deleted,p_format)
					RETURNING id INTO p_id;
		END IF;

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'attributenames_values_idx' THEN
		 result := json_build_object('code','error','text','Такой атрибут уже существует!');
	 ELSE
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;
	 
   return next;

END;$$;


ALTER FUNCTION public.attributes_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 605 (class 1255 OID 16408)
-- Name: attributespr_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.attributespr_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 attributespr_object 	 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
 p_value							 varchar;
 p_value_in						 varchar;
 p_deleted						 boolean;
 p_rowid							 bigint;
 p_attribute					 bigint;
BEGIN

	-- {"user" :1, "attributespr": [{"attribute": 1, "value": "www", "rowid": "1", "deleted": false}]}

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  --SELECT (json_object)->'attributespr' into attributespr_object;
	
	FOR attributespr_object IN SELECT * FROM json_array_elements((json_object)->'attributespr')

  LOOP 

		p_deleted		:= cast(trim(attributespr_object->>'deleted') as boolean);
		p_rowid			:= cast(trim(attributespr_object->>'rowid') as bigint);
		p_attribute	:= cast(trim(attributespr_object->>'attribute') as bigint);
    p_value_in	:= trim(attributespr_object->>'value');

		SELECT value INTO p_value
		  FROM attributespr
			  WHERE attributeid = p_attribute
				  AND id = p_rowid
					  AND company = p_company;

		IF p_rowid IS NOT NULL THEN
		  UPDATE attributespr
			  SET value = p_value_in, deleted = p_deleted
			    WHERE attributeid = p_attribute
						AND id = p_rowid
							AND company = p_company
								RETURNING id INTO p_id;
			IF NOT FOUND THEN
				result := json_build_object('code','error','text','Не указан идентификатор атрибута!');
				return next;
				return;
			END IF;
		ELSE
		  INSERT INTO attributespr(attributeid,value,company)
				VALUES (p_attribute,p_value_in,p_company)
					RETURNING id INTO p_id;
		END IF;
		
		END LOOP;

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'attributespr_values_idx' THEN
		 result := json_build_object('code','error','text','Такое значение уже существует в данном справочнике!');
	 ELSE
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;
	 
   return next;

END;$$;


ALTER FUNCTION public.attributespr_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 606 (class 1255 OID 16409)
-- Name: bonuscards_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.bonuscards_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 customers_object 		 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
 p_group							 bigint;
 p_count							 integer := 0;

BEGIN

	-- {"company" : 1, "bonuscard" : {"id" : "1", "telephone" :, "cardnumber" :, "lastname" :, "firstname" :, "status" : "ACTIVE", "fiz": 1}}

	SELECT (inf)::json into json_object;

		p_company := cast(trim(json_object->>'company') as bigint);
		
		SELECT coalesce(bonus_group,0) INTO p_group
			FROM companies
				WHERE id = p_company;		

  SELECT (json_object)->'bonuscard' into customers_object;
	
		-- Если компания состоит в группе - нужно проверить наличие бонусной записи у всех компаний ("оригинальная" идея Кудрата)
		IF p_group <> 0 THEN
			-- Проверка наличия бонусной записи у других компаний по номеру телефона
			SELECT count(*) INTO p_count
				FROM customers_bonuscards
					WHERE telephone = trim(customers_object->>'telephone')
							AND company IN (SELECT id
																FROM companies
																	WHERE bonus_group = p_group
																    -------28.04.2023
																	and status ='ACTIVE'
																     -------28.04.2023
																	);										
			IF p_count > 0 THEN
				RAISE SQLSTATE 'S0001';
			END IF;
			-- Проверка наличия бонусной записи у других компаний по номеру карты														
			SELECT count(*) INTO p_count
				FROM customers_bonuscards
					WHERE cardnumber = trim(customers_object->>'cardnumber')
							AND company IN (SELECT id
																FROM companies
																	WHERE bonus_group = p_group
																    -------28.04.2023
																	and status ='ACTIVE'
																     -------28.04.2023
																	);															
			IF p_count > 0 THEN
				RAISE SQLSTATE 'S0002';
			END IF;														
		END IF;			

		IF cast(customers_object->>'id' as bigint) IS NULL THEN
			INSERT INTO customers_bonuscards(telephone,cardnumber,lastname,company,firstname,fizid)
				VALUES (trim(customers_object->>'telephone'), trim(customers_object->>'cardnumber'), trim(customers_object->>'lastname'),p_company,
								trim(customers_object->>'firstname'), cast(coalesce(trim(customers_object->>'fiz'),'0') as integer))
					RETURNING id INTO p_id;
		/*ELSE
			UPDATE customers_bonuscards
			  SET telephone = trim(customers_object->>'telephone'), cardnumber = trim(customers_object->>'cardnumber'), 
							lastname = cast(customers_object->>'lastname' as boolean),	firstname = trim(customers_object->>'firstname')
				  WHERE id = cast(customers_object->>'id' as bigint);*/
		ELSE
		  p_id := cast(customers_object->>'id' as bigint);
		END IF;

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Указанный телефон уже зарегистрирован в системе!');
		 return next;
	WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Указанный номер карты уже зарегистрирован в системе!');
		 return next;	 
	WHEN OTHERS THEN
		RAISE NOTICE 'internal_error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		IF p_check = 'bonuscards_cardnumber_idx' THEN
			result := json_build_object('code','error','text','Указанный номер карты уже зарегистрирован в системе!');
		ELSIF p_check = 'bonuscards_tel_idx' THEN
			result := json_build_object('code','error','text','Указанный телефон уже зарегистрирован в системе!');
		ELSE
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		END IF;

		return next;

END;$$;


ALTER FUNCTION public.bonuscards_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 607 (class 1255 OID 16410)
-- Name: brand_binding(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.brand_binding(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 bind_object 		 		 	 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_check							 varchar;
BEGIN

	-- {"user" : 1, "bind" : {"product":1,"brand":2}}

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  SELECT (json_object)->'bind' into bind_object;

		UPDATE products 
		  SET brand = cast(bind_object->>'brand' as bigint)
			  WHERE id = cast(bind_object->>'product' as bigint)
					AND company = p_company;
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0001';
		END IF;			

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Запрещено изменять товары не своей компании!');
		 return next;
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;$$;


ALTER FUNCTION public.brand_binding(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 608 (class 1255 OID 16411)
-- Name: brand_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.brand_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 brand_object 		 		 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
 obj 									 json;
 item 								 json;
 rec									 record;
 
BEGIN

	-- {"user" : 1, "brand" : {"id" : "1", "brand" : "", "manufacturer" : "", "deleted" : false}}

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  SELECT (json_object)->'brand' into brand_object;

		for rec in 
		(select * from json_array_elements(brand_object)) loop
		select row_to_json(rec) into item;
		obj = item::json->>'value';
		
		IF cast(obj->>'id' as bigint) IS NULL THEN
			INSERT INTO brands(brand,manufacturer)
				VALUES (trim(obj->>'brand'), trim(obj->>'manufacturer'))
					RETURNING id INTO p_id;
		ELSE
			UPDATE brands
			  SET brand = trim(obj->>'brand'), manufacturer = trim(obj->>'manufacturer'), 
						  deleted = case when (obj->>'deleted') is null then deleted else cast(obj->>'deleted' as boolean) end
				  WHERE id = cast(obj->>'id' as bigint);
		END IF;
		end loop;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'brands_brandman_idx' THEN
		 result := json_build_object('code','error','text','Указанная связка Брэнд-Производитель уже зарегистрирована в системе!');
	 ELSE
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;$$;


ALTER FUNCTION public.brand_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 609 (class 1255 OID 16412)
-- Name: cashbox_engage(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cashbox_engage(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

	p_error		      	 varchar;

	p_info          	 json;

  p_cashbox					 bigint;

  p_isengaged				 boolean;

BEGIN



  -- {"cashbox":"12"}



  SELECT (inf)::json into p_info;



		p_cashbox := cast(p_info->>'cashbox' as bigint);



		SELECT isengaged INTO p_isengaged

		  FROM cashboxes

			  WHERE id = p_cashbox;

		IF p_isengaged IS NULL THEN

		  result := json_build_object('code','error','text','Касса с таким идентификатором не найдена!');

			return next;

			return;

		ELSIF p_isengaged THEN

			/*result := json_build_object('code','error','text','Эта касса уже занята!');

			return next;

			return;*/

			null;

		END IF;



	  UPDATE cashboxes

      SET isengaged = TRUE

		    WHERE id = p_cashbox;

		

	result := json_build_object('code','success','text','');



  return next;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

	 return next;

END;











$$;


ALTER FUNCTION public.cashbox_engage(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 610 (class 1255 OID 16413)
-- Name: cashbox_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cashbox_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      bigint;
 json_object    json;
 cashbox_object json;
 p_code				  varchar;
 p_text				  varchar;
 p_name_c       integer := 0;
 p_error				varchar;
 p_cashbox_id		bigint;
 p_new_invoice  bigint;
 p_point_in			bigint;
 p_check				varchar;
 p_deleted			boolean;
 p_deleted_in		boolean;
 p_invoice			bigint;
BEGIN

	-- {"user" : 1, "cashbox" : {"id" : "1", "name" : "Касса №1", "amount" : "120000", "point" : "1", "deleted: : "0"}}

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

  SELECT (json_object)->'cashbox' into cashbox_object;

		p_cashbox_id := cast(cashbox_object->>'id' as bigint);
		p_point_in 	 := cast(cashbox_object->>'point' as bigint);
		p_deleted_in := case cashbox_object->>'deleted' when '1' then true else false end;

		SELECT count(b.name) INTO p_name_c
			  FROM cashboxes b	
				  INNER JOIN points p on (p.id = b.point)
					  INNER JOIN companies c on (c.id = p.company and c.id = p_company)
						  WHERE b.name = trim(cashbox_object->>'name')
								AND b.point = p_point_in;
							  --AND b.deleted = false;
    IF p_name_c > 0 AND cashbox_object->>'id' IS NULL THEN
			  result := json_build_object('code','error','text','Касса с таким наименованием уже существует!');
        return next;
		    return;
		END IF;

	  IF p_cashbox_id IS NULL THEN
		  INSERT INTO cashboxes(name,amount,point,deleted,isengaged)
			  VALUES(trim(cashbox_object->>'name'),cast(cashbox_object->>'amount' as double precision),p_point_in,false,false)
				  RETURNING id INTO p_cashbox_id;
		ELSE
			UPDATE cashboxes
			  SET name = trim(cashbox_object->>'name'), amount = cast(cashbox_object->>'amount' as double precision), 
					 point = p_point_in, deleted = p_deleted_in
				  WHERE id = p_cashbox_id;
			-- При восстановлении, на всякий случай, отсылаем в POS признак учета в минус (не робит)
			/*IF p_deleted <> p_deleted_in AND p_deleted = 'CLOSE' THEN
				INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(now(),0,'IN_PROCESS',p_company,p_point_in,p_point_in,9)
						RETURNING invoicenumber INTO p_invoice;
				INSERT INTO systemmessage(point,invoice,type_message,cashbox)
					VALUES(p_point_in,p_invoice,9,p_cashbox_id);
			END IF;*/
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'cashboxes_name_idx' THEN
		 result := json_build_object('code','error','text','Касса с таким наименованием уже существует!');
   ELSE
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;$$;


ALTER FUNCTION public.cashbox_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 611 (class 1255 OID 16414)
-- Name: cashboxusr_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.cashboxusr_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company         bigint;
 json_object       json;
 cashboxusr_object json;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_name_c       	 varchar;
 p_cashbox_usr_c	 bigint;
 p_error           varchar;
 p_point_in				 bigint;
 p_new_invoice     bigint;
 p_cashbox_usr		 bigint;
 p_role_in				 bigint;
 r								 record;
 p_cashbox_exist   boolean := false;
 p_result				   json;
 p_func		 			   varchar;
 p_point_out			 bigint;

BEGIN

	-- {"user" : 1, "cashboxusr" : {"id" : "1", "name" : "Вася Пупкин", "point" : "1", "deleted: : "0", "role" : "Пока ХЗ","iin":"Кадабра", "discount":false, "discountInfo": "1"}}  

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

  SELECT (json_object)->'cashboxusr' into cashboxusr_object;

		p_point_in    := cast(cashboxusr_object->>'point' as bigint);
    p_cashbox_usr := cast(cashboxusr_object->>'id' as bigint);
    p_role_in			:= cast(cashboxusr_object->>'role' as bigint);

		SELECT b.name, b.id, b.point INTO p_name_c, p_cashbox_usr_c, p_point_out
			  FROM cashbox_users b	
				  INNER JOIN points p on (p.id = b.point)
					  INNER JOIN companies c on (c.id = p.company and c.id = p_company)
						  WHERE b.iin = cashboxusr_object->>'iin';
								  --AND b.deleted = false;

    IF p_name_c IS NOT NULL AND (p_cashbox_usr IS NULL OR /*p_name_c <> cashboxusr_object->>'name'*/p_cashbox_usr_c<>p_cashbox_usr) THEN
			  result := json_build_object('code','error','text','Кассовый пользователь с таким ИИН уже существует в системе!');
        return next;
		    return;
		END IF;

	  IF p_cashbox_usr IS NULL THEN
		  INSERT INTO cashbox_users(name,point,deleted,iin,role,discount,discountperc)
			  VALUES(trim(cashboxusr_object->>'name'),p_point_in,false,cashboxusr_object->>'iin',p_role_in,
												case when (cashboxusr_object->>'discount') is null then false else cast(cashboxusr_object->>'discount' as boolean) end,
												case when (cashboxusr_object->>'discountInfo') is null then 0 else cast(cashboxusr_object->>'discountInfo' as double precision) end)
				  RETURNING id INTO p_cashbox_usr;
		ELSE
			UPDATE cashbox_users 
			  SET name = trim(cashboxusr_object->>'name'), point = p_point_in, role = p_role_in,
						  deleted = case cashboxusr_object->>'deleted' when '1' then true else false end, iin = cashboxusr_object->>'iin',
							discount = case when (cashboxusr_object->>'discount') is null then discount else cast(cashboxusr_object->>'discount' as boolean) end,
							discountperc = case when (cashboxusr_object->>'discountInfo') is null then discountperc else cast(cashboxusr_object->>'discountInfo' as double precision) end
				  WHERE id = p_cashbox_usr;
		END IF;

		-- Для обновления на терминале
		INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
		  VALUES(now(),cast(json_object->>'user' as bigint),'IN_PROCESS',p_company,p_point_in,p_point_in,4)
			  RETURNING invoicenumber INTO p_new_invoice;

	  INSERT INTO invoicelist(invoice,stock,attributes,newprod,company)
		  VALUES(p_new_invoice,p_cashbox_usr,0,false,p_company);

		FOR r IN (
					SELECT id
					  FROM cashboxes
						  WHERE point = p_point_in
							  AND deleted = false
								  AND isengaged = true
			)
		LOOP
      p_cashbox_exist := true;
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_point_in,p_new_invoice,4,r.id);
		END LOOP;

		IF NOT p_cashbox_exist THEN
      SELECT invoice_processing(json_build_object('invoice',p_new_invoice,'action','ACCEPTED','user',cast(json_object->>'user' as bigint),'system','ERP',
																	'point',p_point_in,'cashbox','0')) INTO p_result;
			IF p_result->>'code' LIKE '%error%' THEN
		    p_code := p_result->>'code';
			  p_text := p_result->>'text';
        p_func := 'invoice_processing';
        RAISE SQLSTATE 'S0001';
		  END IF;
		END IF;

		-- Удаление пользователя при смене точки
		/*IF p_point_in <> p_point_out THEN
			p_cashbox_exist := false;

		  -- Для обновления на терминале
		  INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
		    VALUES(now(),cast(json_object->>'user' as bigint),'IN_PROCESS',p_company,p_point_out,p_point_out,4)
			    RETURNING invoicenumber INTO p_new_invoice;

	    INSERT INTO invoicelist(invoice,stock,attributes,newprod,delusr,company)
		    VALUES(p_new_invoice,p_cashbox_usr,0,false,true,p_company);

		  FOR r IN (
					  SELECT id
					    FROM cashboxes
						    WHERE point = p_point_out
							    AND deleted = false
								    AND isengaged = true
			  )
		  LOOP

        p_cashbox_exist := true;

		    INSERT INTO systemmessage(point,invoice,type_message,cashbox)
          VALUES(p_point_out,p_new_invoice,4,r.id);

		  END LOOP;


		  IF NOT p_cashbox_exist THEN

        SELECT invoice_processing(json_build_object('invoice',p_new_invoice,'action','ACCEPTED','user',cast(json_object->>'user' as bigint),'system','ERP',
																	'point',p_point_out,'cashbox','0')) INTO p_result;
			  IF p_result->>'code' LIKE '%error%' THEN
		      p_code := p_result->>'code';
			    p_text := p_result->>'text';
          p_func := 'invoice_processing';
          RAISE SQLSTATE 'S0001';
		    END IF;

		  END IF;

		END IF;*/

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION
		 WHEN SQLSTATE 'S0001' THEN 
		   result := json_build_object('code',p_code,'text',p_text,'func',p_func);
       return next;
		 WHEN OTHERS THEN
	     RAISE NOTICE 'internal_error: %', SQLERRM;
	     GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	     result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

       return next;

END;$$;


ALTER FUNCTION public.cashboxusr_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 612 (class 1255 OID 16416)
-- Name: categories_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.categories_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object    			 json;
 category_object 	 	   json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_check							 varchar;
 p_id									 bigint; 
 p_name						 		 varchar;
 p_deleted						 boolean;
 p_company						 bigint;
 p_count							 smallint;
 p_parent 						 bigint := 0;	

BEGIN

	-- {"user": 1, "category": {"id": 1, "name": "Колготки", "deleted": false}}

	SELECT (inf)::json into json_object; 
	
		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;
	
  SELECT (json_object)->'category' into category_object;

		p_id		  := cast(trim(category_object->>'id') as bigint);
		p_name		:= trim(category_object->>'name');
    p_deleted	:= cast(trim(category_object->>'deleted') as boolean);
		p_parent  := coalesce(cast(category_object->>'parent_id' as bigint),0);
		
		IF p_deleted THEN
			UPDATE products
				SET category = p_parent -- если удалили верхний уровень, то привязываем к 0 - без категории.
					WHERE category = p_id
						AND company = p_company;			
		END IF;
		
		IF p_id IS NOT NULL THEN
			IF p_deleted AND p_parent > 0 THEN --если удалили дочерний тогда удаляем физически.
				DELETE FROM categories WHERE id = p_id;
			ELSE
				UPDATE categories
					SET name = p_name, deleted = p_deleted, company = p_company, parentid = p_parent
						WHERE id = p_id;
			END IF;
		ELSE
			-- Проверка наличия такой категории
			SELECT count(id) INTO p_count
				FROM categories
					WHERE name = p_name
						AND company IN (p_company,0);
			IF p_count > 0 THEN
				RAISE SQLSTATE 'S0001';
			END IF;
			-- Добавление категории
		  INSERT INTO categories(name,deleted,company,parentid)
				VALUES (p_name,p_deleted,p_company,p_parent)
					RETURNING id INTO p_id;
		END IF;
		
		-- Отвязывание товара от удаленной категории
		IF p_deleted THEN
			UPDATE products
				SET category = 0
					WHERE category = p_id
						AND company = p_company;
		END IF;

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','exception','text','Такая категория уже существует!');
		 return next;
	WHEN OTHERS THEN
		RAISE NOTICE 'internal_error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		IF p_check = 'categories_name_idx' THEN
			result := json_build_object('code','exception','text','Такая категория уже существует!');
		ELSE
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		END IF;
	 
   return next;

END;$$;


ALTER FUNCTION public.categories_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 613 (class 1255 OID 16417)
-- Name: category_binding(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.category_binding(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 bind_object 		 		 	 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_check							 varchar;
BEGIN

	-- {"user" : 1, "bind" : {"product":1,"category":2}}

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  SELECT (json_object)->'bind' into bind_object;

		UPDATE products 
		  SET category = cast(bind_object->>'category' as bigint)
			  WHERE id = cast(bind_object->>'product' as bigint)
					AND company = p_company;
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0001';
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Запрещено изменять товары не своей компании!');
		 return next;
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;$$;


ALTER FUNCTION public.category_binding(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 614 (class 1255 OID 16418)
-- Name: change_discountflag(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.change_discountflag(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	 p_company         		bigint;
	 p_user						 		bigint;
	 p_discount						boolean;
	 p_error		      	 	varchar;
	 p_prodslice			 		bigint;
	 p_invoice						bigint;
	 p_send_point		 			bigint  := 0;
	 json_object					json;
	 json_change					json;
	 json_prod	 					json;
	 r										record;
	 p_prod							  bigint[];
BEGIN

	-- {"user": "42", "company": "18", "discountFlag": {"discount": true, "prod": [123,345]}}
	-- {"user": "42", "company": "18", "discountFlag": {"prod": ["19552"], "discount": true}}

  SELECT (inf)::json into json_object;

	  p_company		:= cast(json_object->>'company' as bigint);
		p_user 			:= cast(json_object->>'user' as bigint);
		
	SELECT (json_object)->'discountFlag' into json_change;
		
		p_discount	   := cast(json_change->>'discount' as boolean);
		p_prod 				 := ARRAY(SELECT json_array_elements_text(json_change->'prod'));
		
    UPDATE products
			SET isdiscount = p_discount
				WHERE company = p_company
					AND id = ANY(p_prod);
									
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		)
		LOOP

			IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления справочников
				INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
					VALUES(p_user,'IN_PROCESS',p_company,r.point,r.point,3,now()) 
						RETURNING invoicenumber INTO p_invoice;					
				-- Помещение всех измененных товаров в инвойс					
				FOREACH p_prodslice IN ARRAY p_prod
				LOOP					
					INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company)
						VALUES(p_invoice,p_prodslice,0,0,false,false,true,p_company);
				END LOOP;					
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(r.point,p_invoice,3,r.cashbox);

		END LOOP;									

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 return next;
	 
END;





$$;


ALTER FUNCTION public.change_discountflag(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 615 (class 1255 OID 16419)
-- Name: change_priority_promotion(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.change_priority_promotion(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       json;
 priority_object	 json;
 p_error           varchar;
 p_company         bigint;
 r								 record;
 p_send_point		 	 bigint  := 0;
 p_invoice		 		 bigint;
 p_user						 bigint;
BEGIN

	-- {"company":1, "user": 1, "priority" : [{"priority" : 1, "id" : 1}]} 

	SELECT (inf)::json into json_object;
		
		 p_company	:= cast(json_object->>'company' as bigint);
		 p_user 		:= cast(json_object->>'user' as bigint);
		 
		 FOR priority_object IN SELECT * FROM json_array_elements((json_object)->'priority')
		 LOOP
		 
		   UPDATE promotions
			   SET priority = cast(priority_object->>'priority' as smallint)
					 WHERE id = cast(priority_object->>'id' as bigint)
					   AND company = p_company;
		 
		 END LOOP;
		 
	-- Обновление на кассах
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
		LOOP
			
			IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,p_user,'IN_PROCESS',p_company,p_send_point,p_send_point,14)
						RETURNING invoicenumber INTO p_invoice;
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_send_point,p_invoice,14,r.cashbox);

		END LOOP;
		---------------------------------------------------------------

		result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;

















$$;


ALTER FUNCTION public.change_priority_promotion(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 616 (class 1255 OID 16420)
-- Name: check_expiration(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_expiration(OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
	r							record;
BEGIN
	
	-- Фиксирование даты и времени последней отработки (Начало выполнения)
	UPDATE jobcheck
		SET last_update_start = clock_timestamp()::timestamp
			WHERE jobname = 'check_expiration';
	
	-- По подарочным сертификатам	
	FOR r IN (
		SELECT id as expid, company as expcompany, balance as expbalance
			FROM giftcertificates
				WHERE active IS TRUE 
					AND expiredate < current_date
	)
	LOOP
		UPDATE giftcertificates
			SET active = false
				WHERE id = r.expid
					AND active IS TRUE;
		-- Запись в историю событий
		INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ)
			VALUES(r.expcompany,now(),4,r.expid,r.expbalance);		
	END LOOP;			
				
	-- Скидки
	UPDATE discounts
		SET isactive = false
			WHERE isactive IS TRUE 
				and expirationdate < current_date;
				
	-- Акции
	UPDATE promotions
		SET isactive = false, priority = 0
			WHERE isactive IS TRUE 
				and edate < current_date;		
				
	-- Купоны	
	FOR r IN (
		SELECT id,company	
		  FROM coupons
				WHERE active IS TRUE
					AND expire < current_date
	)
	LOOP
		UPDATE coupons
			SET active = false
				WHERE active IS TRUE 
					AND expire < current_date;			
		-- Запись в историю событий			 
		INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
			VALUES(r.company,now(),3,r.id,null);		
	END LOOP;				
				
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'check_expiration';			
	
  result := json_build_object('code','success','text','','date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION public.check_expiration(OUT result json) OWNER TO postgres;

--
-- TOC entry 617 (class 1255 OID 16421)
-- Name: check_in(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_in(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
		p_inf text;
	BEGIN	
		p_inf := inf::text;
		p_inf := replace(p_inf,'admin','');
		p_inf := replace(p_inf,'or','');
		p_inf := replace(p_inf,'collate','');
		p_inf := replace(p_inf,'drop','');
		p_inf := replace(p_inf,'and','');
		p_inf := replace(p_inf,'OR','');
		p_inf := replace(p_inf,'COLLATE','');
		p_inf := replace(p_inf,'DROP','');
		p_inf := replace(p_inf,'AND','');
		p_inf := replace(p_inf,'union','');
		p_inf := replace(p_inf,'UNION','');
		p_inf := replace(p_inf,'/*','');
		p_inf := replace(p_inf,'*/','');
		p_inf := replace(p_inf,'//','');
		p_inf := replace(p_inf,'#','');
		p_inf := replace(p_inf,'--','');
		p_inf := replace(p_inf,';','');
		p_inf := replace(p_inf,'||','');	
		
		result := p_inf::json;
		
		RETURN NEXT;
END
$$;


ALTER FUNCTION public.check_in(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 618 (class 1255 OID 16422)
-- Name: check_messages(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_messages(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
 json_object       json;
 p_error           varchar;
 p_invoice     varchar;
 p_type       varchar;
 p_altinvoice    varchar;
 p_cashbox_vers  varchar;
 p_cashbox_id  bigint;
 p_last_check_time    timestamp;
 p_is_deleted         boolean;

BEGIN

 -- {"cashbox" : "1", "vers" : "20.257"}  
 
 SELECT (inf)::json into json_object;
 
 p_cashbox_id := cast(json_object->>'cashbox' as bigint);
 p_cashbox_vers := cast(json_object->>'vers' as varchar);

    -- Check if cashbox is deleted
    select updatetime, deleted into p_last_check_time, p_is_deleted from cashboxes c where id = p_cashbox_id;
    IF p_is_deleted is true THEN
    result := json_build_object('code','error','text','Данная касса отключена / удалена!');
      return next;
    return;
 -- Check last check time, if less than 5 mins disregard
    elseif p_last_check_time > current_timestamp - interval '1 minutes' then
          result := json_build_object('code','error','text','Проверка накладных слишком часто');
      return next;
    return;
end if;


    -- Check last check time, if less than 5 mins disregard
    
 
 -- Update existing record
 UPDATE cashboxes
  SET version = p_cashbox_vers,
   updatetime = current_timestamp
    WHERE id = p_cashbox_id;
  
 SELECT json_build_object('code','success','text','',
   'invoices', json_agg(json_build_object('invoice',invoice,'type_message',type_message,'altinvoice',altinvoice,'invoice_date',to_char(coalesce(s.date,current_date),'DD.MM.YYYY'))order by invoice)) INTO result 
        FROM systemmessage s
       WHERE cashbox = cast(json_object->>'cashbox' as bigint);
          --WHERE cashbox = p_cashbox_id;

  --result := json_build_object('code','success','text','','invoice',p_invoice,'type',p_type,'altinvoice',p_altinvoice);

    return next;

EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'internal_error: %', SQLERRM;
  GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
  result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'invoices',json_agg());
   return next;

END;

$$;


ALTER FUNCTION public.check_messages(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 619 (class 1255 OID 16423)
-- Name: check_messages_export(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_messages_export(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
 json_object       json;
 p_error           varchar;
 p_invoice     varchar;
 p_type       varchar;
 p_altinvoice    varchar;
 p_cashbox_vers  varchar;
 p_cashbox_id  bigint;
 p_last_check_time    timestamp;
 p_is_deleted         boolean;
 p_date       date;

BEGIN

 -- {"cashbox" : "1", "vers" : "20.257"}  
 
 SELECT (inf)::json into json_object;
 
 p_cashbox_id := cast(json_object->>'cashbox' as bigint);
 p_cashbox_vers := cast(json_object->>'vers' as varchar);
 p_date := cast(json_object->>'date' as date);


    -- Check if cashbox is deleted
    select updatetime, deleted into p_last_check_time, p_is_deleted from cashboxes c where id = p_cashbox_id;
    IF p_is_deleted is true THEN
    result := json_build_object('code','error','text','Данная касса отключена / удалена!');
      return next;
    return;
 -- Check last check time, if less than 5 mins disregard
    elseif p_last_check_time > current_timestamp - interval '1 minutes' then
          result := json_build_object('code','error','text','Проверка накладных слишком часто');
      return next;
    return;
end if;


    -- Check last check time, if less than 5 mins disregard
    
 
 -- Update existing record
 UPDATE cashboxes
  SET version = p_cashbox_vers,
   updatetime = current_timestamp
    WHERE id = p_cashbox_id;
  
 
   SELECT 
     
       json_build_object('code','success','text','',
   'invoices', json_agg(json_build_object(
      			 'invoice', i.invoicenumber,'type_message',i."type", '1',cast(json_object->>'cashbox' as bigint),'invoice_date',to_char(i.invoicedate,'DD.MM.YYYY')
      			 )order by invoicenumber)) 
			 INTO result 
		  FROM invoices i
			  INNER JOIN points p on (p.id = i.stockto)	
			  WHERE i.stockto in (
			  SELECT max(s.stock) 
	        FROM points p
		        LEFT JOIN pointset s on (s.point = p.id)
		          WHERE p.id=json_object->>'point'	
								AND p.company = json_object->>'company'
			  )
			  and type=2 
			  and cast(i.invoicedate as date)>=p_date;
   
  /* 
 SELECT json_build_object('code','success','text','',
   'invoices', json_agg(json_build_object('invoice',invoice,'type_message',type_message,'altinvoice',altinvoice,'invoice_date',to_char(coalesce(s.date,current_date),'DD.MM.YYYY'))order by invoice)) INTO result 
        FROM systemmessage s
       WHERE cashbox = cast(json_object->>'cashbox' as bigint);
  */    
      
          --WHERE cashbox = p_cashbox_id;

  --result := json_build_object('code','success','text','','invoice',p_invoice,'type',p_type,'altinvoice',p_altinvoice);

    return next;

EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE 'internal_error: %', SQLERRM;
  GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
  result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'invoices',json_agg());
   return next;

END;

$$;


ALTER FUNCTION public.check_messages_export(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 620 (class 1255 OID 16424)
-- Name: check_reconciliation(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_reconciliation(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
	p_company				bigint;
	p_point 				bigint;
	p_id 						bigint;
	p_product_id 		bigint;
	p_out_arr 			json;
	p_in_arr 				json;
	p_none 					jsonb := '{"none":[]}';
	p_out_json 			json;
	p_in_json 			json;
	p_stock_units 	numeric;
	p_sale_units 	  numeric;
	p_begin_date		TIMESTAMP;
	p_end_date		  TIMESTAMP;
	p_error					varchar;
	p_user_name 		varchar;
	p_cnt 					int;
 
BEGIN
	-- выполняем сверку.
	-- {"id":17}  
	p_id := cast(inf->>'id' as bigint);
	
	select r.out_data, r.in_data, r.begin_date, r.end_date, r.company, r.point
	into p_out_arr, p_in_arr, p_begin_date, p_end_date, p_company, p_point
		from reconciliation r 
	where r.id = p_id;
	IF NOT FOUND or p_out_arr is null or p_in_arr is null THEN
			RAISE SQLSTATE 'S0001';
	END IF;
	
	select u."name" into p_user_name from erp_users u where u.id = cast(p_out_arr->>'user' as BIGINT);
	
	for p_out_json in SELECT * FROM json_array_elements((p_out_arr)->'out_data')
	loop	
		p_cnt := 0;
		for p_in_json in SELECT * FROM json_array_elements((p_in_arr)->'in_data')
		loop
			if p_out_json->>'code' = p_in_json->>'code' then			
				p_cnt := 1;
				exit;
			end if;
		end loop;
		if p_cnt = 0 then -- не прошедшие
			select sum(s.units), s.product into p_stock_units, p_product_id
				from stockcurrent s, products p 
			where s.company = p_company
				and s.point = p_point
				and p.company = s.company
				and p.id = s.product
				and p.code = p_out_json->>'code'
				GROUP BY s.product;
			IF NOT FOUND or p_stock_units is null THEN
					p_stock_units = 0;
			END IF;
			p_none := jsonb_set(p_none, array['none'], (p_none->'none')||
					json_build_object(
						'name',p_out_json->>'name',
						'code',p_out_json->>'code',
						'stock_units',p_stock_units
					)::jsonb);
		end if;
	end loop;
	result := json_build_object(
		'code','success',
		'begin_date',to_char(p_begin_date,'DD.MM.YYYY HH24.MI.SS'),
		'end_date',to_char(p_end_date,'DD.MM.YYYY HH24.MI.SS'),
		'user_id', p_out_arr->>'user',
		'user_name',p_user_name,
		'none',p_none->'none');
	return next;	
EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','Нет данных по ревизии!');
			return next;
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			return next;	
END$$;


ALTER FUNCTION public.check_reconciliation(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 621 (class 1255 OID 16425)
-- Name: check_usr_data(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.check_usr_data(data character varying, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE 

 info       json;

 p_id		    bigint;

 p_error		varchar;

BEGIN

--{"data" : AKUZMIN, "type" : 1} 1-usr\2-comp\3-cashusr

  

	SELECT (data)::json into info;



  IF info->>'type' = '1' THEN



	  SELECT id INTO p_id

		  FROM erp_users

		    WHERE login = upper(info->>'data');	

	

		IF p_id IS NOT NULL THEN

			result := json_build_object('code','error','text','Пользователь с таким E-Mail уже существует!');

      return next;

		  return;

		END IF;



	ELSIF info->>'type' = '2' THEN



    SELECT id INTO p_id

		  FROM companies

			  WHERE bin = info->>'data';

		

		IF p_id IS NOT NULL THEN

			result := json_build_object('code','error','text','Компания с таким БИН уже зарегистрирована в системе!');

      return next;

		  return;

		END IF;



	ELSIF info->>'type' = '3' THEN



	  SELECT id INTO p_id

		  FROM cashbox_users

			  WHERE name = info->>'data';



    IF p_id IS NOT NULL THEN

			result := json_build_object('code','error','text','Пользователь с таким логином уже существует!');

      return next;

		  return;

		END IF;



  ELSE



		result := json_build_object('code','error','text','Некорректный идентификатор проверки!');

    return next;

		return;



	END IF;



	result := json_build_object('code','success','text','');

  return next;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;







$$;


ALTER FUNCTION public.check_usr_data(data character varying, OUT result json) OWNER TO postgres;

--
-- TOC entry 622 (class 1255 OID 16426)
-- Name: companies_change(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.companies_change(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company     		 			 bigint;
 inf_object     				 json;
 company_object 				 json;
 p_company_in						 bigint;
 p_invoicenumber				 bigint;
 p_code				  				 varchar;
 p_text				  				 varchar;
 p_error			  				 varchar;
 p_certificateseries_new integer;
 p_certificatenum_new	   integer;
 p_certificatedate_new 	 date;
 p_certificateseries_old integer;
 p_certificatenum_old	   integer;
 p_certificatedate_old 	 date;
 p_update								 boolean := false;
 r                			 record;
 p_send_point		 				 bigint  := 0;
 p_wholesale						 boolean := false;
BEGIN

	-- {"user" : 1, "company" : { "id" : 1, "address" : "ул. Пупкина 12", "head" : "Шифр", "head_iin" : "Шифр", "accountant" : "Шифр", "accountant_iin" : "Шифр",
	--			"certificatenum" : "123", "certificateseries" : "321", "certificatedate" : "2019-01-01"}}

	SELECT (inf)::json into inf_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(inf_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

  SELECT (inf_object)->'company' into company_object;

		p_company_in := cast(company_object->>'id' as bigint);

	  IF p_company <> p_company_in THEN
		  result := json_build_object('code','error','text','Нельзя изменять данные чужой компании!');
			return next;
			return;
		END IF;
		
		p_wholesale := cast(company_object->>'wholesale' as BOOLEAN);
		p_certificateseries_new := cast(NULLIF(trim(company_object->>'certificateseries'),'') as integer);
		p_certificatenum_new	  := cast(NULLIF(trim(company_object->>'certificatenum'),'') as integer);
		begin
		p_certificatedate_new 	:= to_date(NULLIF(trim(company_object->>'certificatedate'),''),'YYYY-MM-DD');
		EXCEPTION
			when others then
				p_certificatedate_new 	:= to_date(NULLIF(trim(company_object->>'certificatedate'),''),'DD.MM.YYYY');
		end;
		
		-- Подтягиваем данные для сравнения
		SELECT certificatenum, certificateseries, certificatedate INTO p_certificatenum_old, p_certificateseries_old, p_certificatedate_old
			FROM companies
				WHERE id = p_company_in;
				
		-- Определение, было ли изменение по свидетельству плательщика НДС
		-- Виталя изменил условие or p_certificatenum_old is null
		IF ((p_certificatenum_new <> p_certificatenum_old or p_certificatenum_old is null) and p_certificatenum_new is not null) OR 
		((p_certificateseries_new <> p_certificateseries_old or p_certificateseries_old is null) and p_certificateseries_new is not null) OR
		((p_certificatedate_new <> p_certificatedate_old or p_certificatedate_old is null) and p_certificatedate_new is not null) THEN
			p_update := true;
		END IF;		

		UPDATE companies
		  SET   
						name = case when trim(company_object->>'name') is not null then trim(company_object->>'name') else name end, -- дописано Славой
						address = case when trim(company_object->>'address') is not null then trim(company_object->>'address') else address end, 
					  head = case when trim(company_object->>'head') is not null then trim(company_object->>'head') else head end, 
						head_iin = case when trim(company_object->>'head_iin') is not null then trim(company_object->>'head_iin') else head_iin end, 
						accountant =  case when trim(company_object->>'accountant') is not null then trim(company_object->>'accountant') else accountant end, 
						accountant_iin = case when trim(company_object->>'accountant_iin') is not null then trim(company_object->>'accountant_iin') else accountant_iin end,		
						certificatenum = case when p_update then p_certificatenum_new else certificatenum end,
						certificateseries = case when p_update then p_certificateseries_new else certificateseries end,
						certificatedate = case when p_update then p_certificatedate_new else certificatedate end,
						wholesale = p_wholesale						
			  WHERE id = p_company_in;
		
		-- Обновление данных на кассах
		IF p_update THEN
			FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company_in 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
			LOOP
				IF p_send_point <> r.point THEN
					p_send_point := r.point;
					-- Создание и заполнение накладной(инвойса)
					-- Виталя добавил тайп инвойса в values, добавил каст creator
					INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
						VALUES(current_date,cast(trim(inf_object->>'user') as bigint),'IN_PROCESS',p_company_in,p_send_point,p_send_point,12)
							RETURNING invoicenumber INTO p_invoicenumber;
				END IF;
				-- Формирование системного сообщения для терминалов для обновления справочников
				INSERT INTO systemmessage(point,invoice,type_message,cashbox)
					VALUES(r.point,p_invoicenumber,12,r.cashbox);
			END LOOP;
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;











$$;


ALTER FUNCTION public.companies_change(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 623 (class 1255 OID 16428)
-- Name: companies_changebin(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.companies_changebin(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company     		 			 bigint;
 inf_object     				 json;
 company_object 				 json;
 p_company_in						 bigint;
 p_invoicenumber				 bigint;
 p_code				  				 varchar;
 p_text				  				 varchar;
 p_error			  				 varchar;
 p_certificateseries_new integer;
 p_certificatenum_new	   integer;
 p_certificatedate_new 	 date;
 p_certificateseries_old integer;
 p_certificatenum_old	   integer;
 p_certificatedate_old 	 date;
 p_update								 boolean := false;
 r                			 record;
 p_send_point		 				 bigint  := 0;
 p_wholesale						 boolean := false;
BEGIN

	-- {"user" : 1, "company" : { "id" : 1, "address" : "ул. Пупкина 12", "head" : "Шифр", "head_iin" : "Шифр", "accountant" : "Шифр", "accountant_iin" : "Шифр",
	--			"certificatenum" : "123", "certificateseries" : "321", "certificatedate" : "2019-01-01"}}

	SELECT (inf)::json into inf_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(inf_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

  SELECT (inf_object)->'company' into company_object;

		p_company_in := cast(company_object->>'id' as bigint);

	/*
	  IF p_company <> p_company_in THEN
		  result := json_build_object('code','error','text','Нельзя изменять данные чужой компании!');
			return next;
			return;
		END IF;
		*/
		
		
		

		UPDATE companies
		  SET   
						bin = case when trim(company_object->>'bin') is not null then trim(company_object->>'bin') else bin end		
												
			  WHERE id = p_company_in;
		
		-- Обновление данных на кассах
		

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;











$$;


ALTER FUNCTION public.companies_changebin(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 624 (class 1255 OID 16429)
-- Name: companies_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.companies_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_role         int;
 inf_object     json;
 company_object json;
 p_company_in		bigint;
 p_code				  varchar;
 p_text				  varchar;
 p_error			  varchar;
BEGIN

	-- {"user" : 1, "company" : { "id" : 1, "status" : "ACTIVE"}}
	-- ACTIVE/CLOSE   statuses

	SELECT (inf)::json into inf_object;
		-- Проверка наличия роли "Адмирал-генерал"(Админ)
    SELECT 1 INTO p_role
		  FROM user2roles
			  WHERE "user" = cast(inf_object->>'user' as bigint)
					AND "role" = 0;
					RAISE NOTICE 'p_role: %', p_role;
    IF p_role IS NULL THEN
		  result := json_build_object('code','error','text','У вас недостаточно прав для внесения изменений!');
      return next;
		  return;
	  END IF;

  SELECT (inf_object)->'company' into company_object;

		p_company_in := cast(company_object->>'id' as bigint);
		
		UPDATE companies
		  SET status = upper(trim(company_object->>'status'))
			  WHERE id = p_company_in;
		IF NOT FOUND THEN
			result := json_build_object('code','error','text','Данные по компании не найдены!');
      return next;
		  return;
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;











$$;


ALTER FUNCTION public.companies_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 625 (class 1255 OID 16430)
-- Name: consignment_snapshot(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.consignment_snapshot(OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
BEGIN
	
	-- Фиксирование даты и времени последней отработки (Начало выполнения)
	UPDATE jobcheck
		SET last_update_start = clock_timestamp()::timestamp
			WHERE jobname = 'consignment_snapshot';
			
	-- Фиксирование количества товаров на конец дня (консигнаторы)
	INSERT INTO consignment_snapshots(customer,company,stockid,price,units,invoice,altinvoice,date,unitsincome,discount,snapdate,purchaseprice)
		SELECT t.customer,t.company,t.stockid,t.price,t.units,t.invoice,t.altinvoice,t.date,t.unitsincome,t.discount, current_date - 1, 
								round(coalesce((select coalesce(min(sp.purchaseprice),0)
										from stockcurrent_part as sp 
											where sp.company = s.company
												and sp.point = s.point
												and sp.product = s.product												
												and sp.attributes = s.attributes
												and sp.units > 0
												and sp.date = (select min(sp2.date)
																	from stockcurrent_part as sp2
																		where sp2.company = sp.company
																			and sp2.point = sp.point
																			and sp2.product = sp.product 	
																			and sp2.attributes = sp.attributes
																			and sp2.units > 0)),0)::numeric,2) 
			FROM consignment t
				INNER JOIN stockcurrent s on (s.company = t.company and s.id = t.stockid)
				INNER JOIN companies c on (t.company = c.id)
					WHERE t.units <> 0
						AND c.status = 'ACTIVE';
	
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'consignment_snapshot';

  result := json_build_object('code','success','text','','date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION public.consignment_snapshot(OUT result json) OWNER TO postgres;

--
-- TOC entry 626 (class 1255 OID 16431)
-- Name: counterparties_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.counterparties_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 counterparties_object json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
BEGIN

	-- {"user" : 1, "counterparties" : {"id" : "1", "name" : 50000, "bin" : "100000", "deleted" : false, "email" : "jerk@mail.ru"}}
	-- 1-сотрудник 2-касса 3-точка

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  SELECT (json_object)->'counterparties' into counterparties_object;

		IF cast(counterparties_object->>'id' as bigint) IS NULL THEN
		  INSERT INTO counterparties(name, bin, deleted, company, email)
			  VALUES (trim(counterparties_object->>'name'), trim(counterparties_object->>'bin'), cast(counterparties_object->>'deleted' as boolean),p_company,
								lower(trim(counterparties_object->>'email')))
				  RETURNING id INTO p_id; 
		ELSE
			UPDATE counterparties
			  SET name = trim(counterparties_object->>'name'), bin = trim(counterparties_object->>'bin'), deleted = cast(counterparties_object->>'deleted' as boolean),
						email = lower(trim(counterparties_object->>'email'))
				  WHERE id = cast(counterparties_object->>'id' as bigint);
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'counterparties_bin_idx' THEN
		 result := json_build_object('code','exception','text','Контрагент с таким БИН уже заведен в системе!');
	 ELSIF p_check = 'counterparties_name_idx' THEN
		 result := json_build_object('code','exception','text','Контрагент с таким наименованием уже заведен в системе!');
	 ELSE
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;$$;


ALTER FUNCTION public.counterparties_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 627 (class 1255 OID 16432)
-- Name: coupons_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.coupons_add(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       		json;
 coupons_object	 			json;
 p_error           		varchar;
 p_code				  	 		varchar;
 p_text				  	 		varchar;
 p_company         		bigint;
 p_user								bigint;
 
 p_numberto						varchar;
 p_numberfrom					varchar;
 p_numbertolen				integer;
 p_numberfromlen			integer;
 
 p_discount						float8;
 p_object							bigint;
 p_objtype						integer;
 p_expire							date;
 p_type								integer;
 p_subtype					  integer;
 
 p_result_j						varchar;
 p_id									bigint;
 p_active							boolean;
 
BEGIN
	-- {"user":1,"company":1,"coupons":{"discount":1,"object":1,"objtype":1,"expire":"25.11.2020","type":1,"numberfrom":1,"numberto":3,"subtype":1}}  
	
	/* 						
		 Types(внутр):
						1 - на товар
						2 - на чек	
			
		 Objtypes:
						0 - все
						1 - категория
						2 - бренд
						3 - товар
	*/
	
	SELECT (inf)::json into json_object;
		
		 p_company	:= cast(json_object->>'company' as bigint);
		 p_user 		:= cast(json_object->>'user' as bigint);
	
	SELECT (json_object)->'coupons' into coupons_object;
		 
		 p_numberto			 := trim(coupons_object->>'numberto');
		 p_numberfrom		 := trim(coupons_object->>'numberfrom');
	   p_numberfromlen := length(REGEXP_REPLACE(p_numberfrom,'[[:digit:]]','','g'));
		 p_numbertolen	 := length(REGEXP_REPLACE(p_numberto,'[[:digit:]]','','g'));
		 p_discount			 := cast(trim(coupons_object->>'discount') as double precision);
		 p_object				 :=	cast(trim(coupons_object->>'object') as bigint);
		 p_objtype			 :=	cast(trim(coupons_object->>'objtype') as integer);
		 p_expire				 := to_date(trim(coupons_object->>'expire'),'DD.MM.YYYY');
		 p_type					 := cast(trim(coupons_object->>'type') as integer);
		 p_subtype			 := cast(trim(coupons_object->>'subtype') as integer);
		 
		 IF p_numberto <> p_numberfrom AND (p_numberfromlen <> 0 OR p_numbertolen <> 0) THEN
		   RAISE SQLSTATE 'S0001';	 
		 ELSIF p_numberto IS NULL OR p_numberfrom IS NULL THEN
			 RAISE SQLSTATE 'S0002';
		 END IF;
		 
		 IF p_numberto <> p_numberfrom THEN
			 -- Период
		   FOR coupon_number IN cast(p_numberfrom as integer) .. cast(p_numberto as integer)
       LOOP
				 SELECT active, id INTO p_active, p_id
				   FROM coupons
					   WHERE company = p_company
						   AND "number" = coupon_number::varchar;
				 IF FOUND AND p_active IS FALSE THEN
					 -- Обновление данных, если купон уже был использован
				   UPDATE coupons
					   SET discount = p_discount, "object" = p_object, objtype = p_objtype, expire = p_expire, active = true, "type" = p_type, subtype = p_subtype, company = p_company
						   WHERE id = p_id
							   AND company = p_company;
					 -- Запись в дневник			 
					 INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
					   VALUES(p_company,now(),4,p_id,null);
					 -- Отображение косяков	 
					 /*IF p_result_j IS NULL THEN 
					   p_result_j := json_build_object('number',coupon_number,'text','Купон числится в базе. Его статус будет изменен на "Активен"','status','info'); 
					 ELSE
					   p_result_j := p_result_j ||','|| json_build_object('number',coupon_number,'text','Активный купон с таким номером уже числится в базе!','status','error');
					 END IF;*/ 
				 ELSIF FOUND AND p_active IS TRUE THEN	
					 -- Сбривание, если купон все еще активный
				   IF p_result_j IS NULL THEN 
					   p_result_j := json_build_object('number',coupon_number,'text','Активный купон с таким номером уже числится в базе!','status','error'); 
					 ELSE
					   p_result_j := p_result_j ||','|| json_build_object('number',coupon_number,'text','Активный купон с таким номером уже числится в базе!','status','error');
					 END IF; 
				 ELSE
					 -- Добавление нового купона, если не было найдено инфы
				   INSERT INTO coupons(company,"number",discount,"object",objtype,expire,active,"type",subtype)
		         VALUES(p_company,coupon_number,p_discount,p_object,p_objtype,p_expire,true,p_type,p_subtype)
						   RETURNING id INTO p_id;
					 -- Запись в дневник			 
					 INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
					   VALUES(p_company,now(),1,p_id,null);	 
				 END IF;		 
       END LOOP;
		 ELSE 
			 -- Одиночное добавление
			 SELECT active, id INTO p_active, p_id
				   FROM coupons
					   WHERE company = p_company
						   AND "number" = p_numberfrom;
			 IF FOUND AND p_active IS FALSE THEN
				 -- Обновление данных, если купон уже был использован
			   UPDATE coupons
				   SET discount = p_discount, "object" = p_object, objtype = p_objtype, expire = p_expire, active = true, "type" = p_type, subtype = p_subtype, company = p_company
					   WHERE id = p_id
						   AND company = p_company;
				 -- Запись в дневник			 
				 INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
				   VALUES(p_company,now(),4,p_id,null);	
				 -- Отображение косяков		 
				 /*IF p_result_j IS NULL THEN 
				   p_result_j := json_build_object('number',p_numberfrom,'text','Купон числится в базе. Его статус будет изменен на "Активен"','status','info'); 
				 ELSE
					 p_result_j := p_result_j ||','|| json_build_object('number',p_numberfrom,'text','Активный купон с таким номером уже числится в базе!','status','error');
				 END IF;*/ 
			 ELSIF FOUND AND p_active IS TRUE THEN	
				 -- Сбривание, если купон все еще активный
				 IF p_result_j IS NULL THEN 
				   p_result_j := json_build_object('number',p_numberfrom,'text','Активный купон с таким номером уже числится в базе!','status','error'); 
				 ELSE
					 p_result_j := p_result_j ||','|| json_build_object('number',p_numberfrom,'text','Активный купон с таким номером уже числится в базе!','status','error');
				 END IF;
			 ELSE
				 -- Добавление нового купона, если не было найдено инфы
			   INSERT INTO coupons(company,"number",discount,"object",objtype,expire,active,"type",subtype)
		       VALUES(p_company,upper(p_numberfrom),p_discount,p_object,p_objtype,p_expire,true,p_type,p_subtype)
					   RETURNING id INTO p_id; 
				 -- Запись в дневник			 
				 INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
				   VALUES(p_company,now(),1,p_id,null);	 
		   END IF;		  
		   
		 END IF;	 
		 
		 p_result_j := '['||p_result_j||']';
		 
		---------------------------------------------------------------
		result := json_build_object('code','success','text',p_result_j::json);
    return next;
		
EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
			 result := json_build_object('code','error','text','Номера купонов с символами запрещено заводить диапазоном!');
			 return next;	
	 WHEN SQLSTATE 'S0002' THEN
			 result := json_build_object('code','error','text','Не указан номер(а) купона!');
			 return next;		 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
     return next;
END;








$$;


ALTER FUNCTION public.coupons_add(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 628 (class 1255 OID 16434)
-- Name: create_invoice_workorder(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_invoice_workorder(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
-- Сервис вызывается для добавления товара в накладную при приемке и редактировании. Не подойдет для списания, перемещения и т.д
DECLARE

	attr														record;
	p_company           						bigint;
	invoice_object      						json;
	p_code				       						varchar;
	p_text				       						varchar;
	p_error			       							varchar;
	p_status					   						varchar;
	p_product			 									bigint;
	p_is_new_prod			 							boolean := false;
	p_check						 							varchar;
	p_attributes		 								bigint;
	p_unitsprid				 							bigint;
	p_brand													bigint;
	p_bonusrate											integer;
	p_prod_changes			 						boolean := false;
	p_exist_records		 							integer := 0;
	p_warning												varchar;
	p_category											bigint;
	p_hot														integer;
	p_isdelete											boolean;
	p_scale													bigint;
	p_name													varchar;
	p_piece													boolean;
	p_pieceinpack										integer;
	p_pieceprice										float4;
	p_wholesale_price								float4;
	p_point 												bigint;
	r 															record;
	p_invoice 											bigint;
	p_user													bigint;
	p_workorder_number							varchar;
	p_workorder_id 									bigint;
	p_purchaseprice									float8;
	p_tax														bigint;
	p_cnofea												varchar;
	p_attr													jsonb;
	p_counterparty									bigint;
	p_cashbox 											bigint;
	p_point_sell 										bigint;
	p_stockcurrent									bigint;
	p_new_stock											bigint;
	func_res												record;
	rec															record;
	p_point_type										smallint;
	p_cashbox_exist									boolean := 	false;
	p_result 												json;
	p_func													varchar;
	p_invoicedate										date;
	p_stockto												bigint;
	p_consignment										boolean := false;
	r2															record;
	p_part                          bigint;
	p_accepted_units								float8;
	
	p_attr_json											json;
	p_attr_json_other								json;
	p_attributes_other							bigint;
	
BEGIN
	
	/*{"workorder_number":3,"user":42,"company":18}*/
	
	SELECT (inf)::json into invoice_object;
	
	-- Приходящий номер заказ-наряда
	p_workorder_id := invoice_object->>'workorder_id';
	p_counterparty := invoice_object->>'counterparty';
	
	IF p_workorder_id IS NULL THEN
		raise sqlstate 'S0001';
	END IF;
	
	IF p_counterparty IS NULL THEN
		raise sqlstate 'S0002';
	END IF;

	
	-- Извлечение данных из таблицы заказ-наряда для дальнейшей работы
	SELECT company, point, userid
		INTO p_company, p_point, p_user -- p_point - склад
			FROM workorder 
				WHERE "id" = p_workorder_id AND status in (upper('approved'),upper('part')); --?
	
	-- Если нет такого заказ-наряда
	IF NOT FOUND THEN
		raise sqlstate 'S0003'; 
	END IF;
	
	
	-- Пользователь и компания
	p_user = cast(invoice_object->>'user' as bigint);
	p_company = cast(invoice_object->>'company' as bigint);
	
	-- Создание накладной по добавлению товара
	INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate,counterparty) 
		VALUES(p_user,'FORMATION',p_company,p_point,p_point,2,current_date,p_counterparty) 
			RETURNING invoicenumber INTO p_invoice;

	-- Для проверки статуса
	SELECT i.status, i.stockto, po.point_type, po.consignment, i.invoicedate 
		INTO p_status, p_stockto, p_point_type, p_consignment, p_invoicedate
		  FROM invoices i
			  INNER JOIN points po ON po.id = i.stockto
			    WHERE i.invoicenumber = p_invoice;
	
	-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED -- ? return return next
	IF p_status IN ('ACCEPTED','DECLINE') THEN
		result := json_build_object('code','exception','text','Указанная накладная уже обработана!');
		return next;
		return;
  ELSIF p_status = 'IN_PROCESS' THEN
		result := json_build_object('code','exception','text','Указанная накладная находится в обработке!');
		return next;
		return;
	ELSIF p_status = 'CANCELED' THEN
		result := json_build_object('code','exception','text','Указанная накладная была отменена!');
		return next;
		return;
	END IF;
	
	-- Поиск данных по ид заказ-наряда в таблице workorder_details
	FOR r IN (SELECT * FROM workorder_details WHERE workorder_id = p_workorder_id AND counterparty = p_counterparty)
  LOOP 
		
		p_product  := r.product;
		p_attributes := r.attributes;
		p_purchaseprice := r.purchaseprice;
		p_wholesale_price := r.wholesale_price;
		p_accepted_units := r.accepted_units;
		
		IF p_accepted_units IS NULL THEN 
			p_accepted_units = r.units;
		END IF;
		
		IF p_wholesale_price IS NULL THEN 
			p_wholesale_price = 0;
		END IF;
	
		
		SELECT code, name, category, unitsprid, deleted, cnofeacode, -- Основные параметры
			piece, pieceinpack, -- Для "распаковываемых товаров"
				taxid -- Проверка на НДС для клиентов не являющихся плательщиками НДС
					INTO p_code, p_name, p_category, p_unitsprid, p_isdelete, p_cnofea, p_piece, p_pieceinpack, p_tax
						FROM products where id = p_product;
		
		-- Для весовых товаров
		SELECT hotkey, "scale" into p_hot, p_scale FROM pluproducts_scale where product = p_product and company = p_company;
		
		-- Цена продукта
		SELECT pieceprice into p_pieceprice	FROM storeprices where stock 	= p_product; -- vernemsa
		
		p_prod_changes  := false; 
		
		-- Для поля attributes_json таблицы invoicelist 
		UPDATE attrlist
			SET istemp = false
				WHERE listcode = p_attributes; 
				
		p_attr := '[]';
		FOR attr IN (SELECT al.listcode, al.attribute, an.values,  al.value, al.company, al.istemp
			FROM attrlist al
				INNER JOIN attributenames an
					ON al.attribute = an.id
						WHERE al.listcode = p_attributes)
		LOOP
				p_attr := p_attr || json_build_object('Аттрибут',attr.values,'Значение',attr.value)::jsonb;
		END LOOP;
		
		-- Проверка на наличие повторной записи в накладной
		SELECT count(*) INTO p_exist_records -- ?
			FROM invoicelist
				WHERE invoice = p_invoice
					AND stock = p_product
						AND attributes = p_attributes
							AND company = p_company;
							
		IF p_exist_records > 0 THEN
			raise sqlstate 'S0004'; 
		END IF;
		
		SELECT point INTO p_point_sell FROM pointset WHERE stock = p_point; -- Торговая точка
		SELECT id INTO p_cashbox FROM cashboxes WHERE point = p_point_sell; -- Касса для торговой точки
		
		
		
		
		INSERT INTO invoicelist
			(invoice,stock,units,newprice,attributes,purchaseprice,newprod,prodchanges,updateallprodprice,company,hotkey,"scale",pieceprice,attributes_json,wholesale_price)
				VALUES(p_invoice,p_product,p_accepted_units,r.price, coalesce(r.attributes,0), p_purchaseprice,p_is_new_prod,
					case when p_prod_changes then p_category ||','||p_tax
						||','|| coalesce(p_cnofea,'')||','||cast(coalesce(p_brand,'0') as varchar)||','||p_bonusrate::varchar
							||','||p_unitsprid::varchar||','||p_isdelete::varchar||','||p_piece::varchar||','||p_pieceinpack::varchar
								else null end, true, p_company, p_hot, coalesce(p_scale,0), p_pieceprice,p_attr,p_wholesale_price);
	
	END LOOP;
	
	-- Проставление соответствующего статуса
	UPDATE workorder_details
		SET status = 'ACCEPTED'
			WHERE workorder_id = p_workorder_id AND counterparty = p_counterparty;
	
	
	SELECT count(*) INTO p_part
		FROM workorder_details 
			WHERE workorder_id = p_workorder_id AND status IS NULL;
	
	IF p_part = 0 THEN
		UPDATE workorder
			SET status = 'ACCEPTED', accept_user = p_user, accept_date = CURRENT_TIMESTAMP
				WHERE id = p_workorder_id;
	ELSE
		UPDATE workorder
			SET status = 'PART'
				WHERE id = p_workorder_id;
	END IF;
	
	

	
	FOR r2 IN ( SELECT coalesce(p.id,null) id,l.units,l.newprice,l.attributes as attr,l.purchaseprice,l.newprod,l.prodchanges,l.updateallprodprice, 
								coalesce(p.unitsprid,null) unitsprid, l.hotkey, l."scale", coalesce(l.pieceprice,0) as pieceprice
									FROM invoicelist l 
										LEFT JOIN products p on (p.id = l.stock and p.company = l.company)
											WHERE l.invoice = p_invoice
												AND l.company = p_company) 
	LOOP
		
		-- Добавляем товар на склад	
		SELECT s.id  INTO p_stockcurrent
			FROM stockcurrent s
				LEFT JOIN storeprices s2 on (s2.stock = s.id  and s2.company = s.company)
					LEFT JOIN products p on (p.id = s.product and p.company = s.company)
						WHERE s.point = p_point
							AND s.product = r2.id
								AND s.attributes = r2.attr
									AND s.company = p_company;						

			-- Проверка на наличие такой записи
		IF p_stockcurrent IS NULL THEN
			IF p_point_type = 0 OR p_consignment THEN
			
				INSERT INTO stockcurrent(point,product,units,attributes,company,hotkey,"scale")
					VALUES(p_stockto,r2.id,r2.units,r2.attr,p_company,r2.hotkey,r2."scale")
						RETURNING id INTO p_new_stock;
				
				INSERT INTO storeprices(store,stock,price,company,pieceprice)
					VALUES(coalesce(p_point_sell,p_point),p_new_stock,r2.newprice,p_company,r2.pieceprice);
			
			ELSE
				INSERT INTO stockcurrent(point,product,units,attributes,company,hotkey,"scale")
					VALUES(p_stockto,r2.id,0,r2.attr,p_company,r2.hotkey,r2."scale")
						RETURNING id INTO p_new_stock;
			
				INSERT INTO storeprices(store,stock,price,company,pieceprice)
					VALUES(coalesce(p_point_sell,p_point),p_new_stock,r2.newprice,p_company,r2.pieceprice);
			END IF;	
		
		ELSE
			
			IF p_point_type = 0 OR p_consignment THEN
				UPDATE stockcurrent
					SET units = units + r2.units
						WHERE point = p_point	
							AND product = r2.id
								AND attributes = r2.attr
									AND company = p_company;
			END IF;
		END IF;
	
		-- Для добавления на склад
		UPDATE invoicelist
			SET stockto = coalesce(p_stockcurrent,p_new_stock)
				WHERE stock = r2.id
					AND attributes = r2.attr
						AND invoice = p_invoice
							AND company = p_company;

	END LOOP;

	
	-- Если добавление не на центральный склад - высылаем уведомление в POS
  IF p_point_type = 0 OR p_consignment THEN
	  UPDATE invoices
	    SET status = 'ACCEPTED', approver = p_user, system = 'ERP', approvedate = now()
		    WHERE invoices.invoicenumber = p_invoice
					AND invoices.company = p_company;
  ELSE
		UPDATE invoices
	    SET status = 'IN_PROCESS'
		    WHERE invoices.invoicenumber = p_invoice
					AND invoices.company = p_company;
		-- Рассылка по кассам
		FOR r IN (
				SELECT id
				  FROM cashboxes
					  WHERE point = coalesce(p_point_sell,p_stockto)
						  AND deleted = false
							  AND isengaged = true
	  )
		LOOP
			p_cashbox_exist := true;
	    INSERT INTO systemmessage(point,invoice,type_message,cashbox,"date")
        VALUES(coalesce(p_point_sell,p_point),p_invoice,2,r.id,p_invoicedate);	
		END LOOP;
		-- Проверка наличия привязанных касс к точке, если касс нет - автоматическое подтверждение и добавление
		IF NOT p_cashbox_exist THEN
      SELECT invoice_processing(json_build_object('invoice',p_invoice,'action','ACCEPTED','user',p_user,'system','ERP',
																	'point',coalesce(p_point_sell,p_point),'cashbox','0')) INTO p_result;
			IF p_result->>'code' LIKE '%error%' THEN
		    p_code := p_result->>'code';
			  p_text := p_result->>'text';
        p_func := 'invoice_processing';
        RAISE SQLSTATE 'S0005';
		  END IF;
		END IF;
	END IF;
	------------------------------------------------------------------------------------------------------------------------------------
  result := json_build_object('code','success','text',p_invoice,'note',p_warning);
  return next;
		
	EXCEPTION
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','Не передан Id заказ-наряда!');
			return next;
		WHEN SQLSTATE 'S0002' THEN 
		 result := json_build_object('code','exception','text','Не передан поставщик!');
     return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','exception','text','Данный заказ-наряд не найден или еще не готов!');
			return next;
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','exception','text','В накладной(инвойсе) уже присутствует данный товар');
			return next;
		WHEN SQLSTATE 'S0005' THEN 
		 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
     return next;
	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
    return next;
		
END;$$;


ALTER FUNCTION public.create_invoice_workorder(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 629 (class 1255 OID 16436)
-- Name: create_mass_fiz_esf(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_mass_fiz_esf(esfdata json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_esfdata   		 			  json;
	p_error 	  		 			  varchar;	
	p_esf_json				 		  text;
	p_esf_prod						  text;
	p_name      		 			  varchar;
	p_bin   				 			  varchar;
	p_company				 			  varchar;
	p_address				 			  varchar;
  p_user_status    			  varchar;
	p_company_status 			  varchar;
	p_company_id		 			  bigint;
	p_certificatenum		    integer;
	p_date					 			  date;
	p_totalNdsAmount			  varchar;
	p_totalPriceWithTax		  varchar;
	p_totalPriceWithoutTax  varchar;
	p_esf_id							  bigint[];
	r											  record;
	i											  record;
	p_count								  numeric;
	p_prod								  boolean := false;
	p_revise							  boolean := false;
	p_rowid								  bigint;
	p_check								  integer := 0;
	p_comma								  varchar(2);

	p_priceWithTax				  float8;
	p_priceWithoutTax			  float8;
	p_ndsAmount						  float8;

	p_total_ndsAmount				float8 := 0;
	p_total_PriceWithTax 		float8 := 0;
	p_total_priceWithoutTax float8 := 0; 
	p_total_ExciseAmount		float8 := 0;

	p_esf_status						varchar;
	--p_esf_date							date;

	p_prod_insert						boolean := false;
	p_nds										boolean := false;

BEGIN

	-- {"date":"29.01.2019", "user" : 41}

  SELECT (esfdata)::json into p_esfdata;

		SELECT u.name, c.bin, c.name, c.address, u.status, c.status, c.id, c.certificatenum INTO p_name, p_bin, p_company, p_address, p_user_status, p_company_status, p_company_id, p_certificatenum
      FROM erp_users u
	      LEFT JOIN companies c on (c.id = u.company)
		      WHERE u.id = cast(p_esfdata->>'user' as bigint);

    IF p_company_id IS NULL THEN
			result := json_build_object('code','exception','text','Компания пользователя не идентифицирована!');
		  return next;
			return;
    ELSIF p_company_status <> 'ACTIVE' THEN
			result := json_build_object('code','exception','text','Компания пользователя не активна!');
			return next;
			return;
	  ELSIF p_user_status <> 'ACTIVE' THEN
			result := json_build_object('code','exception','text','Учетная запись пользователя не активна!');
			return next;
			return;
		END IF;
		
		-- Признак плательщика НДС
		IF p_certificatenum IS NULL THEN
			p_nds := false;
		ELSE
			p_nds := true;
		END IF;

		p_date := to_date(p_esfdata->>'date','DD.MM.YYYY');
		
		IF p_date = current_date THEN
			RAISE SQLSTATE 'S0005';
		END IF;

		-- Определение имеющихся ЭСФ на данную дату
		SELECT array_agg(id) INTO p_esf_id
		  FROM esf
			  WHERE type = 'OUTBOUND'
				  AND status IN ('FORMATION','CREATED','PROCESSING','FAILED')
					AND turnoverdate = p_date
					AND company = p_company_id
          AND custid = 0;

		IF p_esf_id[1] IS NULL THEN
	
		  -- Список товаров для ЭСФ
			FOR r IN (
			  SELECT tb.description,tb.unitCode,tb.ndsRate,/*tb.unitPrice,*/sum(tb.quantity) as quantity,sum(tb.priceWithTax) as priceWithTax,sum(tb.ndsAmount) as ndsAmount,
				    (sum(tb.priceWithTax) - sum(tb.ndsAmount)) as priceWithoutTax, tb.prod, round(((sum(tb.priceWithTax) - sum(tb.ndsAmount))/sum(tb.quantity))::numeric,2) as unitPrice
				  FROM (
						SELECT d.taxrate*100 as ndsRate, pr.cnofeacode as unitCode, pr.name as description, round(sum(d.units)::numeric,3) as quantity, 
								d.price - round((d.price/(d.taxrate+1)*d.taxrate)::numeric,2) - round(((d.bonuspay + d.discount + d.ticketdiscount)/d.units)::numeric,2) as unitPrice, 
								round(sum(d.totalprice-(d.bonuspay+d.discount+d.ticketdiscount))::numeric,2) as priceWithTax, 
								sum(round(((d.totalprice-(d.bonuspay+d.discount+d.ticketdiscount))/(d.taxrate+1)*d.taxrate)::numeric,2)) as ndsAmount, 
								pr.id as prod
							FROM transactions t
								INNER JOIN transaction_details d on (d.transactionid = t.id and d.company = t.company)
								INNER JOIN products pr on (pr.id = d.product)
								INNER JOIN points p on (p.id = t.point and p.company = p_company_id and p.status = 'ACTIVE')
									WHERE t.date::date = p_date
										AND t.tickettype = 0
											AND t.customerid = 0
												AND t.company = p_company_id
													AND t.ofdurl <> 'certificate' --исключаем сертификаты
													AND t.cashbox in(
														select cb.id from cashboxes cb where cb.point = t.point and cb.white = true
													)
													GROUP BY pr.name, pr.cnofeacode, taxrate, d.price, pr.id, d.discount, d.ticketdiscount, d.units, d.bonuspay
							) tb 
					WHERE tb.quantity > 0
						GROUP BY tb.description, tb.unitCode, tb.ndsRate, tb.unitPrice, tb.prod
							ORDER BY tb.description
			)
			LOOP
		
				p_prod   := true;
				p_count  := r.quantity;
				p_revise := false;
				p_check  := p_check + 1;

				-- Подсчет итоговых сумм для каждого ЭСФ
				p_total_ndsAmount 			:= round((p_total_ndsAmount + r.ndsAmount)::numeric,2);
				p_total_PriceWithTax		:= round((p_total_PriceWithTax + r.priceWithTax)::numeric,2);
				p_total_priceWithoutTax := round((p_total_priceWithoutTax + r.priceWithoutTax)::numeric,2);
		
				IF p_check = 1 THEN

					p_comma := '';

					-- Создание записи о ЭСФ
					INSERT INTO esf(turnoverdate,usr,company,custid,seller,lastupdate)
						VALUES(p_date,cast(p_esfdata->>'user' as bigint),p_company_id,0,p_company_id,now())
							RETURNING '{'||id||'}' INTO p_esf_id;

					SELECT rus INTO p_esf_status
						FROM esf_statuses 
						  WHERE code = 'FORMATION';

					-- Формирование json для дальнейшей передачи
					p_esf_json := coalesce(p_esf_json,'')||case when (p_esf_json is null or p_esf_json = '') then '' else ',' end ||
						'{"date":"'||to_char(current_date,'DD.MM.YYYY')||'","invoiceType":"ORDINARY_INVOICE","num":"'||p_esf_id[1]::text||'",
							"turnoverDate":"'||(p_esfdata->>'date')||'","countryCode":"KZ","name":"Физические лица","esfstatus":"FORMATION",
							  "esfstatusname":"'||p_esf_status||'","address":"Розничная торговля","CustomerType":"RETAIL","products":[';

				ELSE
					p_comma := ',';
				END IF;

				FOR i IN (
					SELECT declaration, position, truorigincode, units, unitcode, id as reviseid
						FROM reviselist
							WHERE company = p_company_id
								AND product = r.prod
								AND units > 0
									ORDER BY id
				)
				LOOP

					IF p_prod_insert AND p_count <> 0 THEN
					  p_check  := p_check + 1;
					END IF;

					p_revise      := true;
					p_prod_insert := true;

					IF p_count = 0 THEN
						CONTINUE;
					ELSIF i.units > p_count THEN	
		
						-- Счетчик товара по происхождению
						UPDATE reviselist
							SET units = units - p_count
								WHERE id = i.reviseid;
			
						-- Привязывание товара к ЭСФ
						INSERT INTO esf_details(esfid,description,ndsamount,ndsrate,pricewithtax,pricewithouttax,declaration,numberindeclaration,
														quantity,truorigincode,turnoversize,unitcode,unitprice,company)
						VALUES(p_esf_id[1],r.description,r.ndsAmount,r.ndsRate,r.priceWithTax,r.priceWithoutTax,i.declaration,i.position,
											p_count,i.truorigincode,r.priceWithoutTax,coalesce(i.unitCode,r.unitCode),r.unitPrice,p_company_id)
					  RETURNING rowid INTO p_rowid;
				

						p_esf_prod := coalesce(p_esf_prod,'')||p_comma||'{"catalogtruId":"1","description":'||to_json(r.description)||',"ndsAmount":'||r.ndsAmount||',
							"ndsRate":'||case when p_nds then r.ndsRate::text else 'null' end||', "priceWithTax":'||r.priceWithTax||',"priceWithoutTax":'||r.priceWithoutTax||',
								"productDeclaration":'||to_json(i.declaration)||',"productNumberInDeclaration":"'||coalesce(i.position::text,'')||'", "quantity":'||p_count||',
									  "truOriginCode":"'||i.truorigincode||'","turnoverSize":'||r.priceWithoutTax||',"unitCode":"'||coalesce(coalesce(i.unitCode,r.unitCode),'')||'",
											"unitPrice":'||r.unitPrice||',"edit":"N","rowid":"'||p_rowid||'"}';

						p_count := 0;

					ELSIF (p_count > i.units) OR (p_count = i.units) THEN

						p_priceWithTax			:= round(((r.priceWithTax/r.quantity)*i.units)::numeric,2);
						p_priceWithoutTax		:= round((r.unitPrice*i.units)::numeric,2);
						p_ndsAmount					:= round(((r.ndsAmount/r.quantity)*i.units)::numeric,2);

						p_count := p_count - i.units;

						UPDATE reviselist
							SET units = 0
								WHERE id = i.reviseid;

						INSERT INTO esf_details(esfid,description,ndsamount,ndsrate,pricewithtax,pricewithouttax,declaration,numberindeclaration,
														quantity,truorigincode,turnoversize,unitcode,unitprice,company)
							VALUES(p_esf_id[1],r.description,p_ndsAmount,r.ndsRate,p_priceWithTax,p_priceWithoutTax,i.declaration,i.position,
											i.units,i.truorigincode,p_priceWithoutTax,coalesce(i.unitCode,r.unitCode),r.unitPrice,p_company_id)
								RETURNING rowid INTO p_rowid;

						p_esf_prod := coalesce(p_esf_prod,'')||p_comma||'{"catalogtruId":"1","description":'||to_json(r.description)||',"ndsAmount":'||p_ndsAmount||',
							"ndsRate":'||case when p_nds then r.ndsRate::text else 'null' end||', "priceWithTax":'||p_priceWithTax||',"priceWithoutTax":'||p_priceWithoutTax||',
								"productDeclaration":'||to_json(i.declaration)||',"productNumberInDeclaration":"'||coalesce(i.position::text,'')||'", "quantity":'||i.units||',
									  "truOriginCode":"'||i.truorigincode||'","turnoverSize":'||p_priceWithoutTax||',"unitCode":"'||coalesce(coalesce(i.unitCode,r.unitCode),'')||'",
											"unitPrice":'||r.unitPrice||',"edit":"N","rowid":"'||p_rowid||'"}';

					END IF;
				END LOOP;
	
				-- На случай, если нет данных из других ЭСФ
				IF NOT p_revise OR p_count > 0 THEN

					p_priceWithTax			:= round(((r.priceWithTax/r.quantity)*p_count)::numeric,2);
					p_priceWithoutTax		:= round((r.unitPrice*p_count)::numeric,2);
					p_ndsAmount					:= round(((r.ndsAmount/r.quantity)*p_count)::numeric,2);

					IF p_prod_insert THEN
					  p_check  := p_check + 1;
						-- И такое бывает
						IF p_check > 1 AND p_comma <> ',' THEN
							p_comma := ',';
						END IF;
					END IF;

					-- Привязывание товара к ЭСФ
					INSERT INTO esf_details(esfid,description,ndsamount,ndsrate,pricewithtax,pricewithouttax,declaration,numberindeclaration,
														quantity,truorigincode,turnoversize,unitcode,unitprice,company)
						VALUES(p_esf_id[1],r.description,p_ndsAmount,r.ndsRate,p_priceWithTax,p_priceWithoutTax,null,null,
											p_count,5,p_priceWithoutTax,COALESCE(r.unitCode,null),r.unitPrice,p_company_id)
							RETURNING rowid INTO p_rowid;

						p_esf_prod := coalesce(p_esf_prod,'')||p_comma||'{"catalogtruId":"1","description":'||to_json(r.description)||',"ndsAmount":'||p_ndsAmount||',
							"ndsRate":'||case when p_nds then r.ndsRate::text else 'null' end||', "priceWithTax":'||p_priceWithTax||',"priceWithoutTax":'||p_priceWithoutTax||',
								"productDeclaration":"","productNumberInDeclaration":"", "quantity":'||p_count||',
									"truOriginCode":"5","turnoverSize":'||p_priceWithoutTax||',"unitCode":"'||COALESCE(r.unitCode,'')||'",  
											"unitPrice":'||r.unitPrice||',"edit":"Y","rowid":"'||p_rowid||'"}';	

				END IF;

				-- Ограничение в 200 позиций (ИС ЭСФ)
				-- UPDATE запас в 5 позиций из-за деклараций, есть вероятность разбивки одного товара на несколько записей из-за разницы в количестве проданного с количество по декларации
				IF p_check > 195 THEN
					p_check := 0;
					p_esf_json := p_esf_json||p_esf_prod||'],"totalExciseAmount":'||round(p_total_ExciseAmount::numeric,2)||',"totalNdsAmount":'||round(p_total_ndsAmount::numeric,2)||',
						"totalPriceWithTax":'||round(p_total_PriceWithTax::numeric,2)||',"totalPriceWithoutTax":'||round(p_total_priceWithoutTax::numeric,2)||',"totalTurnoverSize":'||round(p_total_priceWithoutTax::numeric,2)||'}';
					p_esf_prod := '';

					UPDATE esf
						SET totalndsamount = round(p_total_ndsAmount::numeric,2), totalpricewithtax = round(p_total_PriceWithTax::numeric,2), totalpricewithouttax = round(p_total_priceWithoutTax::numeric,2), 
								totalturnoversize = round(p_total_priceWithoutTax::numeric,2), totalexciseamount = round(p_total_ExciseAmount::numeric,2)
							WHERE id = p_esf_id[1];

					p_total_ndsAmount 			:= 0;
					p_total_PriceWithTax		:= 0;
					p_total_priceWithoutTax := 0;
				END IF;

				p_prod_insert := false;

			END LOOP;
	
			IF NOT p_prod THEN 
				RAISE SQLSTATE 'S0001';
			ELSIF p_esf_prod IS NULL THEN
				RAISE SQLSTATE 'S0002';
			END IF;

	-- Обработки списка товаров для ЭСФ
	/*UPDATE cnofealist
	  SET processed = true, esfid = p_esf_id
		  WHERE company = p_company_id
			  AND date::date = p_date::date
				  AND processed IS NOT TRUE;*/
	
			IF p_check <> 0 THEN

				p_esf_json := p_esf_json||p_esf_prod||'],"totalExciseAmount":'||round(p_total_ExciseAmount::numeric,2)||',"totalNdsAmount":'||round(p_total_ndsAmount::numeric,2)||',
					"totalPriceWithTax":'||round(p_total_PriceWithTax::numeric,2)||',"totalPriceWithoutTax":'||round(p_total_priceWithoutTax::numeric,2)||',"totalTurnoverSize":'||round(p_total_priceWithoutTax::numeric,2)||'}';

				UPDATE esf
					SET totalndsamount = round(p_total_ndsAmount::numeric,2), totalpricewithtax = round(p_total_PriceWithTax::numeric,2), totalpricewithouttax = round(p_total_priceWithoutTax::numeric,2), 
								totalturnoversize = round(p_total_priceWithoutTax::numeric,2), totalexciseamount = round(p_total_ExciseAmount::numeric,2)
						WHERE id = p_esf_id[1];

			END IF;

			p_esf_json := '['||p_esf_json||']';

			result := json_build_object('code','success','text','','details',(p_esf_json::json));

		ELSIF p_esf_id[1] IS NOT NULL THEN
			-- Если есть необработанный ЭСФ
			  UPDATE esf
					SET esfdate = current_date, esfid = null
					  WHERE id = ANY(p_esf_id)
						  AND status IN ('FORMATION','FAILED')
							  AND esfdate <> current_date
									AND company = p_company_id;
			
			SELECT json_build_object('code','success','text','','details',json_agg(json_build_object('num',e.id::text,'date',to_char(e.esfdate,'DD.MM.YYYY'),
			    'name','Физические лица','esfstatus',e.status,'address','Розничная торговля','esfstatusname',s.rus,'countryCode','KZ',
					'invoiceType','ORDINARY_INVOICE','CustomerType','RETAIL','turnoverDate',to_char(e.turnoverdate,'DD.MM.YYYY'),'totalNdsAmount',e.totalndsamount,
					'totalExciseAmount',e.totalexciseamount,'totalPriceWithTax',e.totalpricewithtax,'totalTurnoverSize',e.totalpricewithouttax,'totalPriceWithoutTax',e.totalpricewithouttax,'products', det))) 
						INTO result
				FROM esf e
				  LEFT JOIN (
						SELECT esfid, company, json_agg(json_build_object('edit',case when declaration is null then 'Y' else 'N' end,'rowid',rowid::text,'ndsRate', case when p_nds then ndsrate else null end,
								'quantity',quantity,'unitCode',coalesce(unitcode,''),'ndsAmount',ndsamount,'unitPrice',unitprice,'description',to_json(description),
								'catalogtruId','1','priceWithTax',pricewithtax,'turnoverSize',turnoversize,'truOriginCode',truorigincode::text,'priceWithoutTax',pricewithouttax,
								'productDeclaration',to_json(declaration),'productNumberInDeclaration',coalesce(numberindeclaration::text,''))order by rowid) det
							FROM esf_details
								WHERE esfid = ANY(p_esf_id)
									AND company = p_company_id
										GROUP BY esfid, company
					)d on (d.esfid = e.id and d.company = e.company)
					LEFT JOIN esf_statuses s on (s.code = e.status)
						WHERE e.id = ANY(p_esf_id)
							AND e.company = p_company_id;

		END IF;

		return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code','exception','text','Товары в списке ЭСФ на дату '||p_date||' - отсутствуют!');
     return next;
	 WHEN SQLSTATE 'S0002' THEN 
		 result := json_build_object('code','internal_error','text','Произошла внутренняя ошибка - обратитесь к разработчикам!');
     return next;
	 WHEN SQLSTATE 'S0003' THEN 
		 result := json_build_object('code','exception','text','ЭСФ на весь оборот за '||p_date||' был успешно выставлен. Детали доступны в отчете по ЭСФ.');
     return next;
	 WHEN SQLSTATE 'S0004' THEN 
		 result := json_build_object('code','exception','text','ЭСФ на весь оборот за '||p_date||' был выставлен. Статус от ИС ЭСФ не был получен - требуется перейти в отчет и запросить актуальные статусы.');
     return next;
	 WHEN SQLSTATE 'S0005' THEN 
		 result := json_build_object('code','exception','text','Ограничение системы: ЭСФ нужно отправлять на следующий день от даты оборота! (В течении 15 дней от даты оборота)');
     return next;	 
   WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error/*,'p_esf_json',p_esf_json*/);
		 return next;

END;$$;


ALTER FUNCTION public.create_mass_fiz_esf(esfdata json, OUT result json) OWNER TO postgres;

--
-- TOC entry 630 (class 1255 OID 16438)
-- Name: create_prefix(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_prefix(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE json_object json;

p_company bigint;
p_check varchar;
p_error varchar;
p_prefix int2;

begin
--{"company": 15, "user": "m.asanova", "prefix": 169}
 select
	(data)::json
into
	json_object;

p_company := cast(trim(json_object->>'company') as bigint);
p_prefix := cast(trim(json_object->>'prefix') as int2);

if p_prefix is null then raise sqlstate 'S0001';
elsif p_company is null then raise sqlstate 'S0002';
end if;
	
--Обновить префикс
update companies set productsweight_prefix = p_prefix where id = p_company;

result := json_build_object('code', 'success', 'text', 'Префикс обновлён успешно!');
return next;

exception
when sqlstate 'S0001' then result := json_build_object('code', 'error', 'text', 'Не указан префикс!');
return next;
when sqlstate 'S0002' then result := json_build_object('code', 'error', 'text', 'Не указана компания!');
return next;
when others then raise notice 'internal_error: %',
sqlerrm;

get STACKED diagnostics p_error = PG_EXCEPTION_CONTEXT,
p_check = CONSTRAINT_NAME;

result := json_build_object('code', 'internal_error', 'text', sqlstate || ':' || sqlerrm || ':' || p_error);

return next;
end;

$$;


ALTER FUNCTION public.create_prefix(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 631 (class 1255 OID 16439)
-- Name: create_reconciliation(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.create_reconciliation(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
 json_object       json;
 p_error           varchar;
 p_company	 			 bigint;
 p_point           bigint;
 p_user            bigint;
 p_id			  	     bigint;
 p_begin_date      TIMESTAMP;
 
BEGIN
	-- {"company":17, "point" :245, "user":234, "out_data":[]}  
	SELECT (inf)::json into json_object;
	p_company := cast(json_object->>'company' as bigint);
	p_point := cast(json_object->>'point' as bigint);
	p_user := cast(json_object->>'user' as bigint);
	
	begin
		select id, begin_date into p_id, p_begin_date from reconciliation 
		where company = p_company 
			and point = p_point 
			and date(begin_date) = CURRENT_DATE 
			and status = 0;
			result := json_build_object('code','success','text',p_id,'begin_date',to_char(p_begin_date, 'DD.MM.YYYY HH:MI:SS'));			
	exception
		when OTHERS then null;			
	end;
	if p_id is null then
		insert into reconciliation(company,point,userid,out_data)
			values (p_company,p_point,p_user,json_object)
			RETURNING id, begin_date INTO p_id, p_begin_date;		
			result := json_build_object('code','success','text',p_id,'begin_date',to_char(p_begin_date, 'DD.MM.YYYY HH:MI:SS'));
	end if;
	return next;
--{"code":"success","text":123,"begin_date":"28.04.2021 14:36:01"}
EXCEPTION 
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;
END$$;


ALTER FUNCTION public.create_reconciliation(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 632 (class 1255 OID 16440)
-- Name: customers_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.customers_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 customers_object json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
 p_deleted						 boolean;
 p_name								 varchar;
 p_address						 varchar;
 p_bin								 varchar;
 
BEGIN

	-- {"user" : 1, "customers" : {"id" : "1", "name" : 50000, "bin" : "100000", "deleted" : false, "address" : "ул. Ху###ца № 5"}}
	-- 1-сотрудник 2-касса 3-точка

	SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		
		IF p_company IS NULL THEN
			SELECT code, text INTO p_code, p_text
				FROM get_company(json_object->>'user');
			IF p_code = 'success' THEN
				p_company := cast(p_text as bigint);
			ELSE
				result := json_build_object('code',p_code,'text',p_text);
				return next;
				return;
			END IF;
	  END IF;		

  SELECT (json_object)->'customers' into customers_object;
	
		p_deleted := coalesce(cast(customers_object->>'deleted' as boolean),false);
		p_name		:= trim(customers_object->>'name');
		p_address	:= coalesce(trim(customers_object->>'address'),'Без адреса');
		p_bin			:= trim(customers_object->>'bin');

		IF cast(customers_object->>'id' as bigint) IS NULL THEN
		  INSERT INTO customers(name, bin, deleted, company, address)
			  VALUES (p_name, p_bin, p_deleted, p_company, p_address)
				  RETURNING id INTO p_id; 
		ELSE
			UPDATE customers
			  SET name = p_name, bin = p_bin, deleted = p_deleted, address = p_address
				  WHERE id = cast(customers_object->>'id' as bigint)
						RETURNING id INTO p_id;
			IF NOT FOUND THEN
				RAISE SQLSTATE 'S0001';
			END IF;			
		END IF;

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','error','text','Клиент не найден!');
			return next;
	WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			IF p_check = 'customers_bin_idx' THEN
				result := json_build_object('code','error','text','Клиент с таким БИН уже заведен в системе!');
			ELSIF p_check = 'customers_name_idx' THEN
				result := json_build_object('code','error','text','Клиент с таким наименованием уже заведен в системе!');
			ELSE
				result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			END IF;

   return next;

END;$$;


ALTER FUNCTION public.customers_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 633 (class 1255 OID 16441)
-- Name: debit_transaction_processing(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.debit_transaction_processing(trans json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE

	process 				 json;

  trans 					 json;

	p_error					 varchar;

BEGIN

--{"user" : 1, "status" : "ACCEPTED", "transactions" : [{ "id" : 111}, { "id" : 222}]}



-- STATUSES: IN_PROCESS/ACCEPTED/DECLINE

	

	SELECT (trans)::json into process;

	

-- Проверка на корректность статусов

	IF upper(process->>'status') NOT IN ('IN_PROCESS','ACCEPTED','DECLINE') THEN

		result := json_build_object('code','error','text','Некорректный идентификатор статуса!');

    return next;

		return;

  END IF;



	FOR trans IN SELECT * FROM json_array_elements((process)->'transactions')

  LOOP

	

	  UPDATE transactions

	    SET status = upper(process->>'status')

			  WHERE id = cast(trans->>'id' as bigint);



  END LOOP;

 

	result := json_build_object('code','success','text','');

  return next;

  return;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

	 return next;

END;





$$;


ALTER FUNCTION public.debit_transaction_processing(trans json, OUT result json) OWNER TO postgres;

--
-- TOC entry 634 (class 1255 OID 16442)
-- Name: del_attributes(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.del_attributes(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       json;
 p_error           varchar;
 p_attrlist_code	 bigint;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_company         bigint;
BEGIN

	-- {"user" : 1, "listcode" : "1", "attribcode" : "1"}  

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		DELETE FROM attrlist
		  WHERE listcode = cast(json_object->>'listcode' as bigint)
			  AND attribute = cast(json_object->>'attribcode' as bigint)
					AND company = p_company
				    RETURNING listcode INTO p_attrlist_code;
    IF p_attrlist_code IS NULL THEN
		  result := json_build_object('code','error','text','Удаляемый атрибут не найден!');
			return next;
			return;
		END IF;

		result := json_build_object('code','success','text',p_attrlist_code);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;

















$$;


ALTER FUNCTION public.del_attributes(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 635 (class 1255 OID 16443)
-- Name: del_coupon(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.del_coupon(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       json;
 p_error           varchar;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_company         bigint;
 p_invoice		 		 bigint;
 p_user						 bigint;
 p_id							 bigint;
 
BEGIN

	-- {"user" : 1, "company" : 1, "id" : 1}  

	SELECT (inf)::json into json_object;
		
		 p_company	:= cast(json_object->>'company' as bigint);
		 p_user 		:= cast(json_object->>'user' as bigint);
		 p_id				:= cast(json_object->>'id' as bigint);
		
		UPDATE coupons
			SET active = false
				WHERE id = p_id
					AND company = p_company
						RETURNING id INTO p_id;
    IF p_id IS NULL THEN
		  result := json_build_object('code','error','text','Удаляемый купон не найден!');
			return next;
			return;
		END IF;
		
		-- Запись в дневник			 
		INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
			VALUES(p_company,now(),5,p_id,null);
		
		---------------------------------------------------------------

		result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;

















$$;


ALTER FUNCTION public.del_coupon(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 638 (class 1255 OID 16444)
-- Name: del_discount(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.del_discount(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       json;
 p_error           varchar;
 p_discount_code	 bigint;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_company         bigint;
 r								 record;
 p_send_point		 	 bigint  := 0;
 p_invoice		 		 bigint;
 p_user						 bigint;
 p_id							 bigint;
 p_point					 bigint;
 p_count					 bigint;
 p_type 					 smallint;
 p_object					 bigint;
BEGIN

	-- {"user" : 1, "company" : 1, "id" : 1}  

	SELECT (inf)::json into json_object;
		
		 p_company	:= cast(json_object->>'company' as bigint);
		 p_user 		:= cast(json_object->>'user' as bigint);
		 p_id				:= cast(json_object->>'id' as bigint);
		 
		 RAISE NOTICE 'id: %', p_id;
		
		UPDATE discounts
			SET isactive = false
				WHERE id = p_id
					AND company = p_company
						RETURNING id, point, type, object INTO p_discount_code, p_point, p_type, p_object;
    IF p_discount_code IS NULL THEN
		  result := json_build_object('code','error','text','Удаляемая скидка не найдена!');
			return next;
			return;
		END IF;
		
	-- Обновление на кассах
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id and p.id = case when p_point = 0 then p.id else p_point end) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
		LOOP
			
			IF p_type IN (2,3,4) THEN
				SELECT count(s.*) INTO p_count
					FROM products p
						LEFT JOIN stockcurrent s on (p.id = s.product and p.company = s.company)
							LEFT JOIN pointset ps on (ps.stock = s.point) 
								WHERE p.company = p_company
									AND ps.point = r.point
									AND ((p.category = p_object and p_type = 2) OR (p.brand = p_object and p_type = 3) OR (s.id = p_object and p_type = 4));				
				IF p_count = 0 THEN
					CONTINUE;
				END IF;
			END IF;
			
			IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,p_user,'IN_PROCESS',p_company,p_send_point,p_send_point,10)
						RETURNING invoicenumber INTO p_invoice;
	      INSERT INTO invoicelist(invoice,stock,attributes,company,newprod,delusr)
					VALUES(p_invoice,p_discount_code,0,p_company,false,true);
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_send_point,p_invoice,10,r.cashbox);

		END LOOP;
		---------------------------------------------------------------

		result := json_build_object('code','success','text',p_discount_code);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;

















$$;


ALTER FUNCTION public.del_discount(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 639 (class 1255 OID 16445)
-- Name: del_flag_news(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.del_flag_news(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

 json_object       json;
 p_error           varchar;
 p_news_id				 bigint;
 --p_user_id				 bigint;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_company         bigint;
BEGIN

	-- {"user" : 1, "news_id" : "1"}  

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		DELETE FROM news_diary
		  WHERE news_id = cast(json_object->>'news_id' as bigint)
			  AND user_id = cast(json_object->>'user' as bigint)
				    RETURNING news_id INTO p_news_id;
    IF p_news_id IS NULL THEN
		  result := json_build_object('code','error','text','Удаляемая новость не найдена!');
			return next;
			return;
		END IF;

		result := json_build_object('code','success','text',p_news_id);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;



$$;


ALTER FUNCTION public.del_flag_news(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 640 (class 1255 OID 16446)
-- Name: del_margin_plan(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.del_margin_plan(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
		p_inf json;
		p_error varchar;
	BEGIN
		select check_in(inf) into p_inf;
		
		update margin_plan set active = false
		where id = cast(p_inf ->> 'id' as bigint)
			and company = cast(p_inf ->> 'company' as bigint);
		
		result := json_build_object('code','success','text','');
		
		RETURN NEXT;
	EXCEPTION WHEN OTHERS THEN
		RAISE NOTICE 'internal_error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		return next;
	END
$$;


ALTER FUNCTION public.del_margin_plan(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 641 (class 1255 OID 16447)
-- Name: del_promotion(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.del_promotion(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       json;
 p_error           varchar;
 p_promotion_id	 	 bigint;
 p_company         bigint;
 r								 record;
 p_send_point		 	 bigint  := 0;
 p_invoice		 		 bigint;
 p_user						 bigint;
 p_id							 bigint;
 p_point					 bigint;
BEGIN

	-- {"user" : 1, "company" : 1, "id" : 1}  

	SELECT (inf)::json into json_object;
		
		 p_company	:= cast(json_object->>'company' as bigint);
		 p_user 		:= cast(json_object->>'user' as bigint);
		 p_id				:= cast(json_object->>'id' as bigint);
		
		UPDATE promotions
			SET isactive = false, priority = 0
				WHERE id = p_id
					AND company = p_company
						RETURNING id, point INTO p_promotion_id, p_point;
    IF p_promotion_id IS NULL THEN
		  result := json_build_object('code','error','text','Удаляемая акция не найдена!');
			return next;
			return;
		END IF;
		
	-- Обновление на кассах
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id and p.id = case when p_point = 0 then p.id else p_point end) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
		LOOP
			
			IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,p_user,'IN_PROCESS',p_company,p_send_point,p_send_point,13)
						RETURNING invoicenumber INTO p_invoice;
	      INSERT INTO invoicelist(invoice,stock,attributes,company,newprod,delusr)
					VALUES(p_invoice,p_promotion_id,0,p_company,false,true);
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
        VALUES(p_send_point,p_invoice,13,r.cashbox);

		END LOOP;
		---------------------------------------------------------------

		result := json_build_object('code','success','text',p_promotion_id);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;

















$$;


ALTER FUNCTION public.del_promotion(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 642 (class 1255 OID 16448)
-- Name: del_reconciliation(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.del_reconciliation(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       json;
 p_error           varchar;
 p_code				  	 varchar;
 p_company         bigint;
 p_point  				 bigint;
 p_id							 bigint;
 
BEGIN

	-- {"id":1,"user":234}  

	SELECT (inf)::json into json_object;
		
	p_id := cast(json_object->>'id' as bigint);
	
	UPDATE reconciliation
		SET status = 2, end_date = CURRENT_TIMESTAMP, in_data = json_object
			WHERE id = p_id;
  
	result := json_build_object('code','success','text',p_id);
	return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;

















$$;


ALTER FUNCTION public.del_reconciliation(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 636 (class 1255 OID 16449)
-- Name: delete_news(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.delete_news(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object       		json;
 p_id									bigint;
 p_error           		varchar;
BEGIN
-- {"data" : {"id": "23"}}  
-- Удаление новостей для админки.
	SELECT (inf)::json into json_object;

		p_id := cast(json_object->>'news_id' as bigint);

		IF p_id IS NULL THEN
			RAISE SQLSTATE 'S0001';
		END IF;
	
		DELETE FROM news
			WHERE id=p_id;
		
		DELETE FROM news_diary
			WHERE news_id=p_id;

		result := json_build_object('code','success','text','Новость успешно удалена!');
		return next;
		return;

		EXCEPTION 	
		WHEN SQLSTATE 'S0001' THEN
			 result := json_build_object('code','error','text','ID не может быть пустым!');
			 return next; 	
		WHEN OTHERS THEN
			 RAISE NOTICE 'internal_error: %', SQLERRM;
			 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
			 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			 return next;

END;


$$;


ALTER FUNCTION public.delete_news(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 637 (class 1255 OID 16450)
-- Name: delete_pricelog(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.delete_pricelog() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
INSERT INTO prices_log 
  (product, price, point, company, type, workdate, userid, counterparty,deleted)
  SELECT product, price, point, company, type, workdate, userid, counterparty, deleted
  FROM PRICEs WHERE product = old.product and counterparty = old.counterparty and company = old.company and "type" = old.type;
  RETURN NEW;
end;
$$;


ALTER FUNCTION public.delete_pricelog() OWNER TO postgres;

--
-- TOC entry 644 (class 1255 OID 16451)
-- Name: delete_productweight(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.delete_productweight(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object       		json;
 p_error           		varchar;
 p_id									bigint;
 p_company						bigint;

BEGIN
-- {"user" : 1, "company" : 1, "data" : {"id": 1}}  

	SELECT (inf)::json into json_object;

		p_id := cast(json_object->>'id' as bigint);
		p_company := cast(json_object->>'company' as bigint);
		
		IF p_id IS NULL THEN
			RAISE SQLSTATE 'S0001';
		END IF;
	
		UPDATE products
			SET category=0
			WHERE id=p_id
			AND 	company=p_company;
		

		result := json_build_object('code','success','text','Товар успешно удален из списка весовых!');
		return next;
		return;

		EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			 result := json_build_object('code','error','text','id продукта не может быть пустым!');
			 return next; 	
		WHEN OTHERS THEN
			 RAISE NOTICE 'internal_error: %', SQLERRM;
			 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
			 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			 return next;

END;


$$;


ALTER FUNCTION public.delete_productweight(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 645 (class 1255 OID 16452)
-- Name: detailing_invoice(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.detailing_invoice(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error		      	 varchar;
	p_info          	 json;
  p_invoice_in			 bigint;
	p_type_in					 bigint;
	p_point_in				 bigint;
  p_invoice					 varchar;
	p_status					 varchar;
	p_stock_from		 	 bigint;
	p_stock_to				 bigint;
	p_from_to					 varchar;
	p_company					 bigint;
	p_discount_type		 integer;
BEGIN

  -- {"invoice" : "1", "type" : "2", "point" : "169"}

  SELECT (inf)::json into p_info;
		
		p_invoice_in := cast(p_info->>'invoice' as bigint);
		p_type_in    := cast(p_info->>'type' as bigint);
	  p_point_in	 := cast(p_info->>'point' as bigint);
		
		IF p_type_in = 1 AND p_point_in IS NULL THEN
		  result := json_build_object('code','error','text','Идентификатор торговой точки не был получен!');
      return next;
		  return;
		END IF;
		
		SELECT company INTO p_company
			FROM points
				WHERE id = p_point_in;

		SELECT i.invoicenumber, i.status, p.point, p2.point INTO p_invoice, p_status, p_stock_from, p_stock_to
		  FROM invoices i
			  LEFT JOIN pointset p on (p.stock = i.stockfrom) 
				  LEFT JOIN pointset p2 on (p2.stock = i.stockto)
			      WHERE i.invoicenumber = p_invoice_in
				      AND (type = p_type_in or type = 7)
								AND i.company = p_company; -- Хрень для списания (Да-да, у нас все на костылях)

		/*SELECT invoicenumber, status, stockfrom, stockto INTO p_invoice, p_status, p_stock_from, p_stock_to
		  FROM invoices
			  WHERE invoicenumber = p_invoice_in
				  AND type = p_type_in;*/
		IF p_invoice IS NULL THEN
		  result := json_build_object('code','error','text','Накладная(инвойс) не найдена!');
      return next;
		  return;
		END IF;
		
		-- Только для перемещения, т.к. нужно понять какая точка обращается (с которой перемещают или на которую перемещают)
		IF p_type_in = 1 THEN
		  IF p_point_in = p_stock_from THEN
		    p_from_to := 'from';
		  ELSIF p_point_in = p_stock_to THEN
			  p_from_to := 'to';
		  END IF;
		END IF;

		-- Обновление справочника (был 2)
		--flipflop
    IF p_type_in = 3 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('id',p.id,'code',p.code,'name',p.name,'category',p.category,'unitsprid',p.unitsprid,'taxid',p.taxid,
										'taxrate',t.rate,'brand',p.brand,'bonusrate',p.bonusrate,'cnofeacode',case when p.cnofeacode is null then '' else p.cnofeacode end/*,'company',p.company*/,
												'piece',p.piece,'pieceinpack',p.pieceinpack,'type',p.type,'isdiscount',p.isdiscount,'category_name',c.name
												--20230829 AB modify product delete mechanism <
												--,'delete', l.delete
												--20230829 AB modify product delete mechanism >
												))) INTO result 
			  FROM invoicelist l
				  LEFT JOIN products p ON (p.id = l.stock and p.company = l.company)
					  LEFT JOIN taxes t on (t.id = p.taxid)
							LEFT JOIN categories c on (c.id = p.category and c.company in (0,p.company))
								WHERE l.invoice = p_invoice_in
									--20230901 AB modify by AB fixing update of products by excel table (invoice_addprod, goods_add) <
									--AND l.newprod = true
									AND (l.newprod = true or l.prodchanges is not null)
									--20230901 AB modify by AB fixing update of products by excel table (invoice_addprod, goods_add) >
										AND l.company = p_company;
		-- Обновление количества товара
		ELSEIF p_type_in = 8 THEN
			SELECT json_build_object('code','success','text','','consignment',coalesce(i.isconsignment,false),'detailing',json_agg(json_build_object('id',s.id,'units',s.units,'delete',l.delete))) INTO result
		    FROM invoices i
					LEFT JOIN invoicelist l ON (i.invoicenumber = l.invoice and i.company = l.company)
				  LEFT JOIN stockcurrent s ON (s.id = l.stock and s.company = l.company)
					  WHERE i.invoicenumber = p_invoice_in
							AND i.company = p_company
								GROUP BY coalesce(i.isconsignment,false);
		-- Обновление пользователей кассы
		ELSEIF p_type_in = 4 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('id',p.id,'name',p.name,'deleted',case when l.delusr then true else p.deleted end,'iin',p.iin,'role',p.role,'discount',p.discount,'discountinfo',p.discountperc))) INTO result
		    FROM invoicelist l
				  LEFT JOIN cashbox_users p ON (p.id = l.stock)
					  WHERE l.invoice = p_invoice_in
							AND l.company = p_company;
		-- Обновление категорий товаров
		ELSEIF p_type_in = 5 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('id',p.id,'name',p.name,'deleted',p.deleted,'parentid',parentid))) INTO result
		    FROM invoicelist l
				  LEFT JOIN categories p ON (p.id = l.stock and p.company = l.company)
					  WHERE l.invoice = p_invoice_in
							AND l.company = p_company;
		ELSIF p_type_in IS NULL THEN
		  result := json_build_object('code','error','text','Не указан номер накладной(инвойса) или ее тип!');
      return next;
		  return;
		-- Перемещение товара
		ELSIF p_type_in in (1,2) THEN
				SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('stockid',
					case p_from_to when 'from' then i.stock else i.stockto end,
					'new_units',i.units,
					'units',case when p_from_to='from' then s2.units 
							 when p_from_to='to' and p_status='IN_PROCESS' then s.units+i.units 
							 when p_from_to='to' and p_status='ACCEPTED' then s.units 
               when p_from_to is null and p_status='IN_PROCESS' then s.units+i.units 
							 when p_from_to is null and p_status='ACCEPTED' then s.units
							 else s.units end,'newprice',
					case p_from_to when 'from' then	pr.price else	i.newprice end,'prodid',coalesce(s.product,s2.product),'prodname',coalesce(p.name,p2.name),
							  'pieceprice',case p_from_to when 'from' then pr.pieceprice else	i.pieceprice end,'pieceinpack',coalesce(p.pieceinpack,p2.pieceinpack),
								'listcode',i.attributes,'attributes', attributeslist,
							'wholesale_price',i.wholesale_price
							----12.06.2023
							,'napravl',p_from_to
							----12.06.2023							
							))) INTO result
			    FROM invoicelist i 
					  LEFT JOIN (
						  SELECT l.listcode,json_agg(json_build_object('attributeid',l.attribute,'attributename',n.values,'value',case when n.format = 'DATE' and l.value like '____-__-__'
																																																													then  to_char(to_Date(l.value,'YYYY-MM-DD'),'DD.MM.YYYY')
																																																													else l.value end)) attributeslist
							  FROM attrlist l
								  LEFT JOIN attributenames n on (n.id = l.attribute)
										AND l.company = p_company
											GROUP BY l.listcode
						) l on l.listcode = i.attributes
						LEFT JOIN stockcurrent s on (s.id = i.stockto and s.company = i.company)
						LEFT JOIN stockcurrent s2 on (s2.id = i.stock and s2.company = i.company)
						LEFT JOIN storeprices pr on (pr.stock = i.stock and pr.company = i.company)
						  LEFT JOIN products p on (p.id = s.product and p.company = s.company)
							LEFT JOIN products p2 on (p2.id = s2.product and p2.company = s2.company)
						    WHERE i.invoice = p_invoice_in
									AND i.company = p_company;
		-- Обновление цены
    ELSIF p_type_in = 0 THEN
		  SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('stockid',l.stock,'units',l.units,'newprice',l.newprice,'prodid',
									p.id,'attributes',s.attributes,'pieceprice',l.pieceprice,
							'wholesale_price',l.wholesale_price))) INTO result 
	      FROM invoicelist l
				  LEFT JOIN stockcurrent s on (s.id = l.stock and s.company = l.company)
					  LEFT JOIN products p on (p.id = s.product and p.company = s.company)
			        WHERE l.invoice = p_invoice_in
								AND l.company = p_company;
		-- Обновление признака учета в минус
		ELSEIF p_type_in = 9 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('isminus',p.is_minus))) INTO result 
	      FROM invoices i
				  LEFT JOIN points p on (p.id = i.stockto and i.company = p.company)
			        WHERE i.invoicenumber = p_invoice_in
							  AND p.id = p_point_in;
		-- Обновление скидок (для POS'а отправляем только 2 типа, 1-точка, 2-товар)
		ELSEIF p_type_in = 10 THEN
			-- Определяем тип скидки
			SELECT d.type INTO p_discount_type
				FROM invoicelist l
					LEFT JOIN discounts d on (d.id = l.stock and d.company = l.company)
						WHERE l.invoice = p_invoice_in
							  AND l.company = p_company;
			-- Точка					
			IF p_discount_type = 1 THEN					
				SELECT json_build_object('code','success','text','','detailing',
						json_agg(json_build_object('id',d.id,'type',1,'object',d.object,'discount',d.discount,'startdate',to_char(d.startdate,'DD.MM.YYYY'),'expirationdate',to_char(d.expirationdate,'DD.MM.YYYY'),
								'delete',l.delusr,'discountsum',d.discountsum/*,'products',json_agg('')*/))) INTO result 
	        FROM invoicelist l
						LEFT JOIN discounts d on (d.id = l.stock and d.company = l.company /*and d.isactive is true*/)
			        WHERE l.invoice = p_invoice_in
							  AND l.company = p_company;
			-- Категория					
			ELSIF p_discount_type = 2 THEN										
				SELECT json_build_object('code','success','text','','detailing',json_agg(p.prod)) INTO result
					FROM (
								SELECT json_build_object('id',d.id,'type',2, 'discount',d.discount, 'category', d.object,
								'startdate', to_char(d.startdate,'DD.MM.YYYY'), 'expirationdate', to_char(d.expirationdate,'DD.MM.YYYY'),
								'delete',l.delusr,'discountsum',d.discountsum,'products', json_agg(json_build_object('id',s.id))) as prod
									FROM invoicelist l
										LEFT JOIN discounts d on (d.id = l.stock and d.company = l.company /*and d.isactive is true*/)
											LEFT JOIN products p on (d.company = p.company and p.category = d.object)
												LEFT JOIN stockcurrent s on (p.company = s.company and p.id = s.product)
													LEFT JOIN pointset ps on (ps.stock = s.point)
														WHERE l.invoice = p_invoice_in
															AND l.company = p_company
															AND ps.point = p_point_in
																GROUP BY d.id, d.type, d.discount, d.object, to_char(d.startdate,'DD.MM.YYYY'), to_char(d.expirationdate,'DD.MM.YYYY'), l.delusr
					) p;						
			-- Бренд							
			ELSIF p_discount_type = 3 THEN		
				SELECT json_build_object('code','success','text','','detailing',json_agg(p.prod)) INTO result
					FROM (
								SELECT json_build_object('id',d.id,'type',2, 'discount',d.discount, 'startdate', to_char(d.startdate,'DD.MM.YYYY'), 'expirationdate', 
														to_char(d.expirationdate,'DD.MM.YYYY'),'delete',l.delusr,'discountsum',d.discountsum,'products', json_agg(json_build_object('id',s.id))) as prod
									FROM invoicelist l
										LEFT JOIN discounts d on (d.id = l.stock and d.company = l.company /*and d.isactive is true*/)
											LEFT JOIN products p on (d.company = p.company and p.brand = d.object)
												LEFT JOIN stockcurrent s on (p.company = s.company and p.id = s.product)
													LEFT JOIN pointset ps on (ps.stock = s.point)
														WHERE l.invoice = p_invoice_in
															AND l.company = p_company
															AND ps.point = p_point_in
																GROUP BY d.id, d.type, d.discount, to_char(d.startdate,'DD.MM.YYYY'), to_char(d.expirationdate,'DD.MM.YYYY'), l.delusr
					) p;															
			-- Товар							
			ELSIF p_discount_type = 4 THEN 				
				SELECT json_build_object('code','success','text','','detailing',json_agg(p.prod)) INTO result
					FROM (
								SELECT json_build_object('id',d.id,'type',2, 'discount',d.discount, 'startdate', to_char(d.startdate,'DD.MM.YYYY'), 'expirationdate', 
														to_char(d.expirationdate,'DD.MM.YYYY'),'delete',l.delusr,'discountsum',d.discountsum,'products', json_agg(json_build_object('id',s.id))) as prod
									FROM invoicelist l
										LEFT JOIN discounts d on (d.id = l.stock and d.company = l.company /*and d.isactive is true*/)
											LEFT JOIN stockcurrent s on (d.company = s.company and d.object = s.id)
												LEFT JOIN pointset ps on (ps.stock = s.point)
													WHERE l.invoice = p_invoice_in
														AND l.company = p_company
															AND ps.point = p_point_in
																GROUP BY d.id, d.type, d.discount, to_char(d.startdate,'DD.MM.YYYY'), to_char(d.expirationdate,'DD.MM.YYYY'), l.delusr
					) p;
			END IF;
		-- Передача диапазона сертификатов
		ELSEIF p_type_in = 11 THEN	
			SELECT json_build_object('code','success','text','','detailing',json_agg(d.cert)) INTO result
				FROM (
					SELECT json_build_object('product', g.product, 'stockid', s.id, 'cert', json_agg(json_build_object('code',g.code))) as cert
						FROM invoicelist l
							LEFT JOIN giftcertificates g ON (g.id = l.stock and g.company = l.company)
								LEFT JOIN stockcurrent s ON (g.company = s.company and g.product = s.product)
									LEFT JOIN pointset ps on (ps.stock = s.point)
										WHERE l.invoice = p_invoice_in
											AND l.company = p_company
												AND ps.point = p_point_in
													GROUP BY g.product, s.id
				) d; 
		-- Передача информации по свидетельству плательщика НДС
		ELSEIF p_type_in = 12 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('ndsinfo',coalesce(c.certificateseries||' '||c.certificatenum|| 
					case when c.certificatedate is not null then ' от '||to_char(certificatedate,'DD.MM.YYYY') else '' end,'')))) INTO result 
				FROM invoices i
					LEFT JOIN companies c on (i.company = c.id)
						WHERE i.invoicenumber = p_invoice_in
							AND i.company = p_company;
		-- Передача информации по акциям
		ELSEIF p_type_in = 13 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(p.prom)) INTO result
				FROM (
					SELECT json_build_object('id',pr.id,'name',pr.name,'delete',l.delusr,'startdate',to_char(pr.bdate,'DD.MM.YYYY'),'expirationdate',to_char(pr.edate,'DD.MM.YYYY'),'if',i."if",
																'then',e."then",'priority',pr.priority) AS prom
						FROM invoicelist l
							INNER JOIN promotions pr on (pr.id = l.stock and pr.company = l.company)
							INNER JOIN points as p on (p.id = pr.point and pr.company = p.company)
							INNER JOIN (SELECT c.listcode, json_build_object('id', c.type, 'values', json_agg(json_build_object('id',c.object,'value',c.amount))) as "if"
														FROM invoicelist l
															INNER JOIN promotions pr on (pr.id = l.stock and pr.company = l.company)
															INNER JOIN promconditions c on (pr.company = c.company and pr.condlist = c.listcode)
																WHERE l.invoice = p_invoice_in
																	AND l.company = p_company
																		GROUP BY c.listcode, c.type) as i on (i.listcode = pr.condlist)
							INNER JOIN (SELECT pd.listcode, json_build_object('id', pd.type, 'values', json_agg(json_build_object('id',pd.object,'value',pd.rate))) as "then"
														FROM invoicelist l
															INNER JOIN promotions pr on (pr.id = l.stock and pr.company = l.company)
															INNER JOIN promdiscounts pd on (pr.company = pd.company and pr.disclist = pd.listcode)
																WHERE l.invoice = p_invoice_in
																	AND l.company = p_company
																		GROUP BY pd.listcode, pd.type) as e on (e.listcode = pr.disclist)
								WHERE l.invoice = p_invoice_in
									AND l.company = p_company
										--GROUP BY pr.id, pr.name, i."if", l.delusr						
				) p;
		-- Обновление приоритетов по акциям
		ELSEIF p_type_in = 14 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('id',p.id,'priority',p.priority))) INTO result 
	      FROM invoices i
				  LEFT JOIN promotions p on (p.point = i.stockto and i.company = p.company)
			        WHERE i.invoicenumber = p_invoice_in
								AND i.company = p_company
									AND p.isactive is true
										AND p.edate >= current_date;
		-- Обновление формата чека
		ELSEIF p_type_in = 15 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(p.json)) INTO result 
	      FROM invoices i
				  LEFT JOIN ticket_format p on (i.company = p.company and i.stockfrom = p.point)
			        WHERE i.invoicenumber = p_invoice_in
								AND i.company = p_company;
		-- Обновление скидок по срокам годности
		ELSEIF p_type_in = 18 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('id',d.id,'period_from',d.from,'period_to',d.to,'period_type',d.type,
									'rate',d.discount,'deleted',d.deleted))) INTO result 
	      FROM invoicelist l
				  LEFT JOIN expdate_discount d on (d.id = l.stock and d.company = l.company)
			        WHERE l.invoice = p_invoice_in
								AND l.company = p_company;						
	  END IF;
		-- Обновление справочника штрих-кодов (обновление)
		IF p_type_in = 19 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('prodID',pb.product,'barCode',pb.barcode))) INTO result
				FROM invoicelist l
					LEFT JOIN products_barcode pb ON (pb.product = l.stock and pb.company = l.company)
						WHERE l.invoice = p_invoice_in
							AND l.company = p_company
								GROUP BY pb.id
									ORDER BY pb.id DESC
										FETCH FIRST ROW ONLY;							
	  END IF;
		-- Обновление справочника штрих-кодов (удаление)
		IF p_type_in = 20 THEN
			SELECT json_build_object('code','success','text','','detailing',json_agg(json_build_object('prodID',l.stock,'barCode',l.sku))) INTO result
				FROM invoicelist l
					LEFT JOIN products_barcode pb ON (pb.barcode = l.sku and pb.company = l.company)
						WHERE l.invoice = p_invoice_in
							AND l.company = p_company;							
		END IF;


	IF result IS NULL THEN
	  result := json_build_object('code','error','text','По данному номеру накладной(инвойса) и типу не существует списка изменений!');
	END IF;

  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 return next;
END;



$$;


ALTER FUNCTION public.detailing_invoice(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 646 (class 1255 OID 16454)
-- Name: entity2char(text); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.entity2char(t text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
declare
    r record;
begin
    for r in
        select distinct ce.ch, ce.name
        from
            character_entity ce
            inner join (
                select name[1] "name"
                from regexp_matches(t, '&([A-Za-z]+?);', 'g') r(name)
            ) s on ce.name = s.name
    loop
        t := replace(t, '&' || r.name || ';', r.ch);
    end loop;

    for r in
        select distinct
            hex[1] hex,
            ('x' || repeat('0', 8 - length(hex[1])) || hex[1])::bit(32)::int codepoint
        from regexp_matches(t, '&#x([0-9a-f]{1,8}?);', 'gi') s(hex)
    loop
        t := regexp_replace(t, '&#x' || r.hex || ';', chr(r.codepoint), 'gi');
    end loop;

    for r in
        select distinct
            chr(codepoint[1]::int) ch,
            codepoint[1] codepoint
        from regexp_matches(t, '&#([0-9]{1,10}?);', 'g') s(codepoint)
    loop
        t := replace(t, '&#' || r.codepoint || ';', r.ch);
    end loop;

    return t;
end;
$$;


ALTER FUNCTION public.entity2char(t text) OWNER TO postgres;

--
-- TOC entry 647 (class 1255 OID 16455)
-- Name: erpusr_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.erpusr_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 p_company         bigint;
 json_object       json;
 erpusr_object     json;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_name_c       	 varchar;
 p_erp_usr_c	 		 bigint;
 p_error           varchar;
 p_erp_usr		 		 bigint;
 p_check					 varchar;
 p_roles					 json;
 p_cashbox_exist   boolean := false;

BEGIN

	-- {"user" : 1, "erpusr" : {"id" : "1", "login" : "bubka@mail.ru", "name" : "Вася Пупкин", "pass" : "Кадабра", "iin: : "Кадабра", "status" : "ACTIVE", "roles" : [{"id":"1"}]}}  
	-- Статусы: ACTIVE, DISMISS, BLOCKED

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

  SELECT (json_object)->'erpusr' into erpusr_object;

    p_erp_usr := cast(erpusr_object->>'id' as bigint);

    SELECT u.name, u.id INTO p_name_c, p_erp_usr_c
			FROM erp_users u	
				LEFT JOIN companies c on (c.id = u.company)
					WHERE c.id = p_company
					  AND u.iin = erpusr_object->>'iin'
						  AND u.status = 'ACTIVE';
    IF p_erp_usr_c IS NOT NULL AND (p_erp_usr IS NULL OR /*p_name_c <> erpusr_object->>'name'*/p_erp_usr_c<>p_erp_usr) THEN
			  result := json_build_object('code','error','text','Пользователь ERP с таким ИИН уже существует в системе!');
        return next;
		    return;
		END IF;
		
		IF lower(erpusr_object->>'login') = 'demo' THEN
			result := json_build_object('code','error','text','Для пользователя "Demo" внесение изменений запрещено!');
      return next;
		  return;
		END IF;

	  IF p_erp_usr IS NULL THEN
			INSERT INTO erp_users(login,name,pass,iin,company,status)
	      VALUES(lower(erpusr_object->>'login'),erpusr_object->>'name',erpusr_object->>'pass',erpusr_object->>'iin',p_company,'ACTIVE')
				  RETURNING id INTO p_erp_usr;
		ELSIF erpusr_object->>'pass' IS NOT NULL THEN
			UPDATE erp_users
			  SET name = erpusr_object->>'name', pass = erpusr_object->>'pass', iin = erpusr_object->>'iin' , status = erpusr_object->>'status'
				  WHERE id = p_erp_usr;
		ELSE
			UPDATE erp_users 
			  SET name = erpusr_object->>'name', iin = erpusr_object->>'iin', status = erpusr_object->>'status'
				  WHERE id = p_erp_usr;
		END IF;

		-- Очищаем список ролей перед записью нового списка
		DELETE FROM user2roles u
		  WHERE u.user = p_erp_usr;	

		-- Запись новых ролей
		FOR p_roles IN SELECT * FROM json_array_elements((erpusr_object)->'roles')
		LOOP
		  INSERT INTO user2roles
			  VALUES(p_erp_usr,cast(p_roles->>'id' as bigint));
		END LOOP;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'erpusr_log_idx' THEN
		 result := json_build_object('code','error','text','Пользователь с таким логином уже существует в системе!');

	 /*ELSIF p_check = 'user2roles_fk_roles' THEN

		 result := json_build_object('code','error','text','Возникли проблемы с привязыванием ролей, попробуйте позднее!');

   ELSIF p_check = 'user2roles_fk_users' THEN  

		 result := json_build_object('code','error','text','Такого пользователя не существует в системе!');	*/

   ELSE
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;













$$;


ALTER FUNCTION public.erpusr_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 648 (class 1255 OID 16457)
-- Name: esf_delete(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.esf_delete(esfdata json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE	 
	p_error							  varchar;
	p_esfdata							json;
	p_revising						json;
	p_code								varchar;
  p_text								varchar;
	p_esf									json;
	p_check								varchar;
	i											record;
	p_company							bigint;
	p_esfnum							bigint;	

BEGIN

/*
	{"user":"41", "company": 18, "esf":"876"} 
*/

  SELECT (esfdata)::json into p_esfdata;

		p_company := cast(trim(p_esfdata->>'company') as bigint);	
		p_esfnum  := cast(trim(p_esfdata->>'esf') as bigint);

		UPDATE esf
		  SET status = 'DELETED', lastupdate = now()
			  WHERE id = p_esfnum
					and company = p_company;
		IF NOT FOUND THEN
		  result := json_build_object('code','error','text','ЭСФ не найден!');
      return next;
		  return;
		END IF;
	
		FOR i IN (
			SELECT p.id as id, ed.declaration as dec, ed.numberindeclaration as num, ed.quantity as quantity 
				FROM esf e
					INNER JOIN esf_details ed on (ed.esfid = e.id and ed.company = e.company)
				  INNER JOIN products p on (p.name = ed.description and p.company = p_company)
					INNER JOIN reviselist r on (r.product = p.id and r.declaration = ed.declaration and r.position = ed.numberindeclaration)
						WHERE e.id = p_esfnum
							AND e.company = p_company
							AND e.type = 'OUTBOUND'
							AND ed.manual = false
				) 
		LOOP
				UPDATE reviselist
					SET units = units + i.quantity
						WHERE product = i.id
							AND declaration = i.dec
							AND position = i.num
							 AND company = p_company;
		END LOOP;

		DELETE from esf_details
		  WHERE esfid = p_esfnum
				AND company = p_company;

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
   WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;

	   result := json_build_object('code','internal_error','text', SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;$$;


ALTER FUNCTION public.esf_delete(esfdata json, OUT result json) OWNER TO postgres;

--
-- TOC entry 649 (class 1255 OID 16458)
-- Name: esf_details_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.esf_details_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

 p_company      			 bigint;
 json_object    			 json;
 details_object 			 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
 p_esf								 bigint;
 p_del								 varchar(2);
 p_numberindeclaration varchar;--bigint;
 p_truorigincode			 integer;
BEGIN

	-- {"user":1,"esf_details":{"rowid":"1","esfid":"5512","description":"Huggies Elite Soft (4) 8-14 кг №19 шт","ndsamount":"789,11",
	--  "ndsrate":"12","pricewithtax":"7350","pricewithouttax":"6562.5","productDeclaration":"55301/280717/0044564","productNumberInDeclaration":"2","quantity":"4",
	--  "tnvedname":"БИОЛОГИЧЕСКИ АКТИВНАЯ ДОБАВКА К ПИЩЕ: ПРОФЛЕКС / PROFLEX, РАСТВОР ПИТЬЕВОЙ ВО ФЛАКОНАХ ПО 25 МЛ, ПО 14 ФЛАКОНОВ В ПАЧКЕ КАРТОННОЙ",
	--	"truorigincode":"5","unitcode":"4818500000","unitnomenclature":"796","unitprice":"2187,5","delete":"N"}}

  --{"user":1,"esf_details":[{"rowid":"1","esfid":"5512","unitcode":"4818500000","declaration":"55301/280717/0044564","numberindeclaration":"1","truorigincode":"5"}]}

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  --SELECT (json_object)->'esf_details' into details_object;
	FOR details_object IN SELECT * FROM json_array_elements((json_object)->'esf_details')

  LOOP

		p_id  := cast(trim(details_object->>'rowid') as bigint);
		p_esf := cast(trim(details_object->>'esfid') as bigint);
		p_del := trim(details_object->>'delete');
		p_numberindeclaration := /*cast(*/trim(details_object->>'numberindeclaration') /*as bigint)*/;
		p_truorigincode := cast(details_object->>'truorigincode' as integer);
		
		IF p_esf IS NULL /*AND p_del = 'N'*/ THEN
			RAISE SQLSTATE 'S0001';
		ELSIF p_id IS NULL THEN
			RAISE SQLSTATE 'S0002';
		ELSIF p_del = 'Y' AND p_id IS NULL THEN
			RAISE SQLSTATE 'S0003';
		ELSIF p_truorigincode NOT IN (SELECT id FROM origincodes) OR p_truorigincode IS NULL THEN
			RAISE SQLSTATE 'S0004';
		ELSIF p_del = 'Y' AND p_id IS NOT NULL THEN
		  DELETE FROM esf_details
			  WHERE rowid = p_id
				  AND esfid = p_esf
						AND company = p_company;
		END IF;

		/*IF cast(details_object->>'rowid' as bigint) IS NULL THEN
			INSERT INTO esf_details(esfid,description,ndsamount,ndsrate,pricewithtax,pricewithouttax,declaration,numberindeclaration,quantity,tnvedname,
                          truorigincode,turnoversize,unitcode,unitnomenclature,unitprice,manual)
				VALUES(cast(details_object->>'esfid' as bigint),details_object->>'description',cast(details_object->>'ndsamount' as double precision),
							 cast(details_object->>'ndsrate' as double precision),cast(details_object->>'pricewithtax' as double precision),
							 cast(details_object->>'pricewithouttax' as double precision),details_object->>'productDeclaration',cast(details_object->>'productNumberInDeclaration' as bigint),
							 cast(details_object->>'quantity' as double precision),details_object->>'tnvedname',cast(details_object->>'truorigincode' as integer),
							 cast(details_object->>'pricewithouttax' as double precision),details_object->>'unitcode',cast(details_object->>'unitnomenclature' as bigint),
							 cast(details_object->>'unitprice' as double precision),true)
				  RETURNING rowid INTO p_id;
		ELSE
			
			UPDATE esf_details
			  SET description = details_object->>'description', ndsamount = cast(details_object->>'ndsamount' as double precision), 
						ndsrate = cast(details_object->>'ndsrate' as double precision), pricewithtax = cast(details_object->>'pricewithtax' as double precision), 
						pricewithouttax = cast(details_object->>'pricewithouttax' as double precision), declaration = details_object->>'productDeclaration', 
						numberindeclaration = cast(details_object->>'productNumberInDeclaration' as bigint), quantity = cast(details_object->>'quantity' as double precision), 
						tnvedname = details_object->>'tnvedname', truorigincode = cast(details_object->>'truorigincode' as integer), 
						turnoversize = cast(details_object->>'pricewithouttax' as double precision), unitcode = details_object->>'unitcode',
						unitnomenclature = cast(details_object->>'unitnomenclature' as bigint), unitprice = cast(details_object->>'unitprice' as double precision)
				  WHERE rowid = p_id;
		END IF;
	*/
			UPDATE esf_details
			  SET unitcode = case when (unitcode <> details_object->>'unitcode' or unitcode is null) then details_object->>'unitcode' else unitcode end,
						declaration = case when (declaration <> details_object->>'declaration' or declaration is null) then details_object->>'declaration' else declaration end,
    numberindeclaration = case when (coalesce(numberindeclaration,'0') <> p_numberindeclaration) then nullif(p_numberindeclaration,'0') else numberindeclaration end,
						truorigincode = case when (truorigincode <> p_truorigincode or truorigincode is null) then p_truorigincode else truorigincode end
				  WHERE rowid = p_id
					  AND esfid = p_esf
							AND company = p_company;

	END LOOP;

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Не указан номер ЭСФ!');
		 return next;
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Не указана позиция в ЭСФ!');
		 return next;
	 WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error','text','Для удаления требуется идентификатор записи!');
		 return next;
	 WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','Недопустимый признак происхождения!');
		 return next;
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   return next;

END;













$$;


ALTER FUNCTION public.esf_details_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 650 (class 1255 OID 16460)
-- Name: esf_inbound_acceptance(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.esf_inbound_acceptance(esfdata json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE	 
	p_data										 json;
	p_esf 				    				 json;
  p_esf_prod								 record;
	p_error								  	 varchar;
	p_usr_status				  		 varchar;
  p_comp_status				  		 varchar;
	p_company         				 bigint;
	p_bin											 varchar;
  p_esf_internal_id					 bigint;			
	p_usr											 bigint;
	p_seller_id								 bigint;
	p_seller_bank							 varchar;
	p_seller_iik						   varchar;
	p_seller_certificateseries bigint;
	p_esf_id									 bigint;
  p_check										 varchar;
  p_date										 date;
	p_invoice									 record;
	p_prod_exist							 boolean := false;

	p_var		varchar;
	/*		 
  p_invoiceType							 varchar;
	p_turnoverDate						 date;
  p_deliveryDocDate					 date;
	p_deliveryDocNum					 varchar;

	p_contractDate						 date;
	p_contractNum							 bigint;
	p_hasContract							 boolean;
	p_transportTypeCode				 bigint;
	p_warrant									 bigint;
	p_warrantDate							 date;

	p_seladdress							 varchar;
	p_selbank									 varchar;
	p_selbik									 varchar;
	p_selcertificateNum				 integer;
	p_selcertificateSeries		 integer;
	p_seliik									 varchar;
	p_selkbe									 integer;
	p_selname									 varchar;
	p_seltin									 varchar;*/

BEGIN

/*
	{"user":"41", "esflist":[{"invoiceId":"19794395900239872", "registrationNumber":"ESF-123456789021-20170923-05812896", "date":"12.02.2019", "invoiceType":"ORDINARY_INVOICE", "num":"15", 
	"turnoverDate":"29.01.2019", "countryCode":"KZ", "name":"ИП БРЮС УЭЙН", "address":"г. Астана, ул. ПРОСПЕКТ РАКЫМЖАН КОШКАРБАЕВ, д. 66", "tin":"123456789011", "contractDate":"05.01.2017", 
	"contractNum":"517", "hasContract":"true", "term":"безнал/нал.расчет", "transportTypeCode":"30", "warrant":"112", "warrantDate":"01.09.2017", "seladdress":"г. Астана, ул. ЫКЫЛАС ДУКЕН, д. 38", 
	"selbank":"ДБ АО «Сбербанк»", "selbik":"SABRKZKA", "selcertificateNum":"1399478", "selcertificateSeries":"13788", "seliik":"KZ32914398914BC31725", "selkbe":"17", "selname":"ТОО "АСЕМ-2"", 
	"seltin":"123456789021", "invoiceStatus":"CREATED", "currencyCode":"KZT", "totalExciseAmount":"0", "totalNdsAmount":"597", "totalPriceWithTax":"65572",
	"totalPriceWithoutTax":"64975", "totalTurnoverSize":"64975",
      "products":
		[{"catalogtruId":"1", "description":"Huggies Трусики Для Мальчиков (4) 17 шт 9-14 кг", "ndsAmount":"787.50", "ndsRate":"12",
		  "priceWithTax":"7350", "priceWithoutTax":"6562.5", "productDeclaration":"1111\222\333", "productNumberInDeclaration":"2", "quantity":"3", "unitNomenclature":"796",
		  "truOriginCode":"2", "tnvedName":"Huggies Трусики Для Мальчиков (4) 17 шт 9-14 кг", "turnoverSize":"6562.5", "unitCode":"4818500000", "unitPrice":"2187.5"}]}]}
*/

/*
	{"user":"41", "esflist":[{"invoiceId":"19794395900239872", "registrationNumber":"ESF-123456789021-20170923-05812896", "invoiceStatus":"CREATED"}, "invoiceBody":"Body епт!"]}
*/

  SELECT (esfdata)::json into p_data;

		SELECT c.id, c.bin, c.status, u.status, u.id INTO p_company, p_bin, p_comp_status, p_usr_status, p_usr
      FROM erp_users u
	      INNER JOIN companies c on (c.id = u.company)
		      WHERE u.id = cast(p_data->>'user' as bigint);
		IF p_company IS NULL THEN
			result := json_build_object('code','internal_error','text','Компания пользователя не идентифицирована!');
			return next;
			return;
		ELSIF p_comp_status <> 'ACTIVE' THEN
			result := json_build_object('code','internal_error','text','Компания пользователя не активна!');
			return next;
			return;
		ELSIF p_usr_status <> 'ACTIVE' THEN
			result := json_build_object('code','internal_error','text','Учетная запись пользователя не активна!');
			return next;
			return;
		ELSIF p_bin <> trim(p_data->>'tin') THEN
			result := json_build_object('code','internal_error','text','Полученные ЭСФ адресованы не вашей компании!');
			return next;
			return;
		END IF;

	FOR p_esf IN SELECT * FROM json_array_elements((p_data)->'esflist')
	LOOP

		--BEGIN
		-- Ошибочные лесом (обновляем статусы, если есть ЭСФ)
		IF UPPER(trim(p_esf->>'invoiceStatus')) IN ('FAILED','DRAFT','CANCELED','DELETED','REVOKE','DECLINED') THEN
			UPDATE esf
			  SET status = UPPER(trim(p_esf->>'invoiceStatus'))
				  WHERE esfregnum = trim(p_esf->>'registrationNumber')
					  AND company = p_company;
		  continue;
		-- Статусы предыдущих обновляем(на всякий)
		ELSE
			UPDATE esf
			  SET status = UPPER(trim(p_esf->>'invoiceStatus'))
				  WHERE esfregnum = trim(p_esf->>'registrationNumber')
					  AND company = p_company;
		END IF;

		WITH x(col) AS (SELECT (p_esf->>'invoiceBody')::xml)
      SELECT (xpath('//date/text()', x.col))[1] AS p_date,
						 (xpath('//num/text()', col))[1] AS p_num,
						 (xpath('//invoiceType/text()', col))[1] AS p_invoiceType,
						 (xpath('//turnoverDate/text()', col))[1] AS p_turnoverDate,
						 (xpath('//deliveryDocDate/text()', col))[1] AS p_deliveryDocDate,
						 (xpath('//deliveryDocNum/text()', col))[1] AS p_deliveryDocNum,
						 (xpath('//deliveryTerm/contractDate/text()', col))[1] AS p_contractDate,
						 (xpath('//deliveryTerm/contractNum/text()', col))[1] AS p_contractNum,
						 (xpath('//deliveryTerm/hasContract/text()', col))[1] AS p_hasContract,
						 (xpath('//deliveryTerm/term/text()', col))[1] AS p_term,
						 (xpath('//deliveryTerm/transportTypeCode/text()', col))[1] AS p_transportTypeCode,
						 (xpath('//deliveryTerm/warrant/text()', col))[1] AS p_warrant,
						 (xpath('//deliveryTerm/warrantDate/text()', col))[1] AS p_warrantDate,
						 (xpath('//sellers/seller/address/text()', col))[1] AS p_seladdress,
						 (xpath('//sellers/seller/bank/text()', col))[1] AS p_selbank,
						 (xpath('//sellers/seller/bik/text()', col))[1] AS p_selbik,
						 (xpath('//sellers/seller/certificateNum/text()', col))[1] AS p_selcertificateNum,
						 (xpath('//sellers/seller/certificateSeries/text()', col))[1] AS p_selcertificateSeries,
						 (xpath('//sellers/seller/iik/text()', col))[1] AS p_seliik,
						 (xpath('//sellers/seller/kbe/text()', col))[1] AS p_selkbe,
						 (xpath('//sellers/seller/name/text()', col))[1] AS p_selname,
						 (xpath('//sellers/seller/tin/text()', col))[1] AS p_seltin, 
						 (xpath('//productSet/currencyCode/text()', col))[1] AS p_currencycode, 
						 (xpath('//relatedInvoice/registrationNumber/text()', col))[1] AS p_relatedinvoice ,
	
						 (xpath('//productSet/totalExciseAmount/text()', col))[1] AS p_totalExciseAmount,
						 (xpath('//productSet/totalNdsAmount/text()', col))[1] AS p_totalNdsAmount,
						 (xpath('//productSet/totalPriceWithTax/text()', col))[1] AS p_totalPriceWithTax,
						 (xpath('//productSet/totalPriceWithoutTax/text()', col))[1] AS p_totalPriceWithoutTax,
						 (xpath('//productSet/totalTurnoverSize/text()', col))[1] AS p_totalTurnoverSize INTO p_invoice

				FROM x;
		
		-- Проверка данных поставщика и корректировка - если данных нет
		SELECT id, bank, iik, certificateseries INTO p_seller_id, p_seller_bank, p_seller_iik, p_seller_certificateseries
			FROM counterparties
			  WHERE company = p_company
				  AND bin = trim(p_invoice.p_seltin::varchar);
		IF p_seller_id IS NULL THEN
			-- Добавление контрагента, если такого нет в базе
		  INSERT INTO counterparties(name,bin,deleted,company,address,bank,bik,certificatenum,certificateseries,iik,kbe,country)
			  VALUES(trim(p_invoice.p_selname::varchar),trim(p_invoice.p_seltin::varchar),false,p_company,trim(p_invoice.p_seladdress::varchar),
							 trim(p_invoice.p_selbank::varchar),trim(p_invoice.p_selbik::varchar),cast(trim(p_invoice.p_selcertificateNum::varchar) as bigint),
							 cast(trim(p_invoice.p_selcertificateSeries::varchar) as bigint),trim(p_invoice.p_seliik::varchar),
							 cast(trim(p_invoice.p_selkbe::varchar) as bigint),'KZ')
				  RETURNING id INTO p_seller_id;
		ELSIF (p_seller_bank <> trim(p_invoice.p_selbank::varchar)) OR (p_seller_iik <> trim(p_invoice.p_seliik::varchar)) OR (p_seller_certificateseries <> cast(trim(p_invoice.p_selcertificateSeries::varchar) as bigint)) THEN
			-- Изменение данных контрагента, если что-то поменялось
			UPDATE counterparties
			  SET address = trim(p_invoice.p_seladdress::varchar), bank = trim(p_invoice.p_selbank::varchar), bik = trim(p_invoice.p_selbik::varchar), 
						certificatenum = cast(trim(p_invoice.p_selcertificateNum::varchar) as bigint), 
						certificateseries = cast(trim(p_invoice.p_selcertificateSeries::varchar) as bigint), iik = trim(p_invoice.p_seliik::varchar), 
						kbe = cast(trim(p_invoice.p_selkbe::varchar) as bigint)
				  WHERE id = p_seller_id;
		END IF;

		-- Создание записи о ЭСФ
	  INSERT INTO esf(esfid,esfregnum,esfdate,type,subtype,turnoverdate,usr,company,status,revise,currencycode,contractdate,contractnum,
                      hascontract,term,transporttypecode,warrant,warrantdate,custid,seller,relationesregnum,deliverydocnum,deliverydocdate,esfaccountingnumber,
											totalndsamount,totalpricewithtax,totalpricewithouttax,totalturnoversize,totalexciseamount)
	    SELECT cast(p_esf->>'invoiceId' as bigint),trim(p_esf->>'registrationNumber'),to_date(p_invoice.p_date::varchar,'DD.MM.YYYY'),'INBOUND',
							trim(p_invoice.p_invoiceType::varchar),to_date(nullif(p_invoice.p_turnoverDate::varchar,''),'DD.MM.YYYY'),p_usr,p_company,
							trim(p_esf->>'invoiceStatus'),false,trim(p_invoice.p_currencycode::varchar),to_date(nullif(p_invoice.p_contractDate::varchar,''),'DD.MM.YYYY'),
							nullif(trim(p_invoice.p_contractNum::varchar),''),cast(nullif(p_invoice.p_hasContract::varchar,'') as boolean), 
							nullif(trim(p_invoice.p_term::varchar),''),cast(nullif(trim(p_invoice.p_transportTypeCode::varchar),'')as bigint),
							cast(nullif(trim(p_invoice.p_warrant::varchar),'')as bigint),to_date(nullif(p_invoice.p_warrantDate::varchar,''),'DD.MM.YYYY'),
							p_company, p_seller_id,nullif(trim(p_invoice.p_relatedinvoice::varchar),''),nullif(trim(p_invoice.p_deliveryDocNum::varchar),''),
							to_date(p_invoice.p_deliveryDocDate::varchar,'DD.MM.YYYY'),cast(p_invoice.p_num::varchar as bigint),
							cast(p_invoice.p_totalNdsAmount::varchar as double precision),cast(p_invoice.p_totalPriceWithTax::varchar as double precision),
							cast(p_invoice.p_totalPriceWithoutTax::varchar as double precision),cast(p_invoice.p_totalTurnoverSize::varchar as double precision),
							cast(p_invoice.p_totalExciseAmount::varchar as double precision)
				WHERE NOT EXISTS (select 1 from esf where company = p_company and esfregnum = trim(p_esf->>'registrationNumber'))
		    RETURNING id INTO p_esf_id;
		
		-- Значит запись уже есть
		IF p_esf_id IS NULL THEN
		  continue;
		END IF;

		p_prod_exist := false;
		
	  FOR p_esf_prod IN (
					SELECT
					  (xpath('//description/text()', col))[1] AS p_description,
						(xpath('//ndsAmount/text()', col))[1] AS p_ndsAmount,
						(xpath('//ndsRate/text()', col))[1] AS p_ndsRate,
						(xpath('//priceWithTax/text()', col))[1] AS p_priceWithTax,
						(xpath('//priceWithoutTax/text()', col))[1] AS p_priceWithoutTax,
						(xpath('//productDeclaration/text()', col))[1] AS p_productDeclaration,
						(xpath('//productNumberInDeclaration/text()', col))[1] AS p_productNumberInDeclaration,
						(xpath('//quantity/text()', col))[1] AS p_quantity,
						(xpath('//tnvedName/text()', col))[1] AS p_tnvedName,
						(xpath('//truOriginCode/text()', col))[1] AS p_truOriginCode,
						(xpath('//turnoverSize/text()', col))[1] AS p_turnoverSize,
						(xpath('//unitCode/text()', col))[1] AS p_unitCode,
						(xpath('//unitNomenclature/text()', col))[1] AS p_unitNomenclature,
						(xpath('//unitPrice/text()', col))[1] AS p_unitPrice
							FROM (
								SELECT unnest(xpath('//productSet/products/product',(p_esf->>'invoiceBody')::xml)) AS col 
							) t
			)
		LOOP

			/*IF p_esf_prod.p_productDeclaration IS NULL THEN
			  p_esf_prod.p_productDeclaration         := '-'; 
				p_esf_prod.p_productNumberInDeclaration := 0;
			END IF;*/

			p_prod_exist := true;

		  INSERT INTO esf_details (esfid,description,ndsamount,ndsrate,pricewithtax,pricewithouttax,declaration,numberindeclaration,quantity,tnvedname,
                                 truorigincode,turnoversize,unitcode,unitnomenclature,unitprice,company)
			  VALUES(p_esf_id,trim(p_esf_prod.p_description::varchar),cast(p_esf_prod.p_ndsAmount::varchar as double precision),
					cast(p_esf_prod.p_ndsRate::varchar as double precision),cast(p_esf_prod.p_priceWithTax::varchar as double precision),
					cast(p_esf_prod.p_priceWithoutTax::varchar as double precision),trim(p_esf_prod.p_productDeclaration::varchar),
					/*cast(*/trim(p_esf_prod.p_productNumberInDeclaration::varchar) /*as bigint)*/,cast(p_esf_prod.p_quantity::varchar as double precision),
					trim(p_esf_prod.p_tnvedName::varchar),cast(p_esf_prod.p_truOriginCode::varchar as integer),
					cast(p_esf_prod.p_turnoverSize::varchar as double precision),trim(p_esf_prod.p_unitCode::varchar),
					trim(p_esf_prod.p_unitNomenclature::varchar),cast(p_esf_prod.p_unitPrice::varchar as double precision),p_company);

		END LOOP;

		IF NOT p_prod_exist THEN
			RAISE SQLSTATE 'S0001';
		END IF;

    /*EXCEPTION 
		 WHEN SQLSTATE 'S0001' THEN 
		   result := json_build_object('code','internal_error','text','Товары в списке не найдены! ('||trim(p_esf->>'registrationNumber')||')');
		   return next;
			 return;
		 WHEN OTHERS THEN
				GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
				--Если уже есть счет-фактура с таким рег номером - просто игнорим
				IF p_check = 'esf_esfregnum_idx' THEN
					continue;
				ELSE
					result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
					return next;
					return;
				END IF;

	END;*/

	END LOOP;

  result := json_build_object('code','success','text',p_var);
  return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code','internal_error','text','Товары в списке не найдены! ('||trim(p_esf->>'registrationNumber')||')');
		 return next;
   WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;$$;


ALTER FUNCTION public.esf_inbound_acceptance(esfdata json, OUT result json) OWNER TO postgres;

--
-- TOC entry 651 (class 1255 OID 16462)
-- Name: esf_list_for_revising(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.esf_list_for_revising(revdata json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE	 
	p_error							  varchar;
	p_revdata							json;
	p_code								varchar;
	p_text								varchar;
	p_company							bigint;
  p_esfid							  bigint;
	p_json								text;
	r											record;
	p_stock								bigint;
	p_count								integer;
	p_invoices						text;
	p_invoices_manual			int[];
	p_description					varchar;
	p_invoices_count			integer;
	p_prod_name						varchar;
BEGIN

/*
	{"user":"41", "esfid":"15", "invoices":[{"id":7306},{"id":7307}]}
*/

  SELECT (revdata)::json into p_revdata;

		p_esfid := cast(revdata->>'esfid' as bigint);

	  SELECT code, text INTO p_code, p_text
      FROM get_company(revdata->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		-- Для вручную указанных накладных
		IF (revdata->>'invoices') IS NOT NULL THEN

			p_invoices := revdata->>'invoices';

			SELECT array_agg(cast(d.elem->>'id' as bigint)) INTO p_invoices_manual 
			  FROM json_array_elements((revdata)->'invoices') as d(elem);

			p_invoices_count := array_length(p_invoices_manual, 1);

		END IF;

	  FOR r IN (SELECT ed.description,ed.ndsamount,ed.ndsrate,ed.pricewithtax,ed.pricewithouttax,ed.declaration,ed.numberindeclaration,ed.quantity,
							  ed.tnvedname,ed.truorigincode,ed.turnoversize,ed.unitcode,ed.unitnomenclature,ed.unitprice,ed.rowid,e.deliverydocnum
							  FROM esf e
								  LEFT JOIN esf_details ed on (ed.esfid = e.id and ed.company = e.company)
									-- LEFT JOIN invoices i on (i.altnumber = e.deliverydocnum)
									-- LEFT JOIN invoicelist il on (il.invoice = i.invoicenumber il.company = i.company and ((il.purchaseprice * il.units) = ed.pricewithtax))
									  WHERE e.id =  p_esfid
											AND e.company = p_company
										    ORDER BY ed.declaration, ed.description
		)
		LOOP

			IF p_invoices IS NULL THEN
			  SELECT json_agg(json_build_object('id',i.invoicenumber)) INTO p_invoices
				  FROM invoices i
					  WHERE i.altnumber = r.deliverydocnum
						  AND i.company = p_company
							  AND i.type = 2;
			END IF;

			-- Для вручную указанных накладных
		  IF (revdata->>'invoices') IS NOT NULL THEN
				SELECT max(il.stock), count(il.stock) INTO p_stock, p_count
			    FROM invoices i
				    LEFT JOIN invoicelist il on (il.invoice = i.invoicenumber and il.company = i.company and ((il.purchaseprice * il.units) = r.pricewithtax))
					    WHERE il.stock IS NOT NULL
								AND i.invoicenumber = ANY(p_invoices_manual)
								AND i.company = p_company;
				IF p_count <= p_invoices_count THEN
				  p_count := 1;
				END IF;
			ELSE
			  SELECT max(il.stock), count(il.stock) INTO p_stock, p_count
			    FROM invoices i
				    LEFT JOIN invoicelist il on (il.invoice = i.invoicenumber and il.company = i.company and ((il.purchaseprice * il.units) = r.pricewithtax))
					    WHERE i.altnumber = r.deliverydocnum
						    AND il.stock IS NOT NULL
								AND i.company = p_company;
			END IF;

			  SELECT name INTO p_prod_name
			    FROM products
				    WHERE id = p_stock;

			  p_json := coalesce(p_json,'')||case when (p_json is null or p_json = '') then '' else ',' end||'{"description":'||to_json(r.description)||
								',"ndsamount":'||coalesce(r.ndsamount::text,'null')||',"ndsrate":'||coalesce(r.ndsrate::text,'null')||',"pricewithtax":'||r.pricewithtax||
								',"pricewithouttax":'||r.pricewithouttax||',"declaration":'||coalesce(to_json(r.declaration),'null')||',"numberindeclaration":'||REPLACE(coalesce(r.numberindeclaration::text,'null'),'/','.')||
								',"quantity":'||coalesce(r.quantity::text,'null')||',"tnvedname":'||coalesce(to_json(r.tnvedname),'null')||',"truorigincode":'||r.truorigincode||',"turnoversize":'||r.turnoversize||
								',"unitcode":'||coalesce('"'||r.unitcode||'"','null')||',"unitnomenclature":'||coalesce('"'||r.unitnomenclature::text||'"','null')||',"unitprice":'||coalesce(r.unitprice::text,'null')||',"rowid":'||r.rowid||
								',"stock":'||case p_count when 1 then p_stock::text else 'null' end||',"name":'||case p_count when 1 then to_json(p_prod_name) else 'null' end||'}';

		END LOOP;

		IF p_json IS NULL THEN
		  result := json_build_object('code','error','text','Не удалось подтянуть данные по данному ЭСФ - обратитесь к разработчикам!');
			return next;
			return;
		END IF;

		result := json_build_object('code','success','text',('['||p_json||']')::json,'invoices',p_invoices::json);
		return next;

EXCEPTION 
   WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;






$$;


ALTER FUNCTION public.esf_list_for_revising(revdata json, OUT result json) OWNER TO postgres;

--
-- TOC entry 652 (class 1255 OID 16464)
-- Name: esf_revising(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.esf_revising(revdata json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE	 
	p_error							  varchar;
	p_revdata							json;
	p_revising						json;
	p_code								varchar;
	p_text								varchar;
	p_company							bigint;
  p_esfid							  bigint;
	p_units								float8;
	p_count								integer := 0;
	p_revise							boolean;
	p_revise_relation     boolean;
	p_relation_esfnum			varchar;
BEGIN

/*
	{"user":"41", "esfid":"15", "revising":[{"id":"1","declaration":"55301/280717/0044564","pos":"6","origincode":"4","units":"5","unitcode":"3306100000"}]}
*/

  SELECT (revdata)::json into p_revdata;

		p_esfid := cast(revdata->>'esfid' as bigint);

	  SELECT code, text INTO p_code, p_text
      FROM get_company(revdata->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		-- Проверка на случай повторного обращения
		SELECT e.revise, e.relationesregnum, e2.revise INTO p_revise, p_relation_esfnum, p_revise_relation
		  FROM esf e
				LEFT JOIN esf e2 on (e2.esfregnum = e.relationesregnum and e2.company = p_company)
			    WHERE e.company = p_company
				    AND e.id = p_esfid;
		IF p_revise THEN
		  result := json_build_object('code','error','text','Сверка ЭСФ №'||p_esfid||' уже произведена!');
			return next;
			return;
		ELSIF (p_relation_esfnum IS NOT NULL AND (NOT p_revise_relation OR p_revise_relation IS NULL)) THEN
			result := json_build_object('code','error','text','Сначала нужно обработать предыдущий связанный ЭСФ - '||p_relation_esfnum||'!');
			return next;
			return;
		END IF;

		FOR p_revising IN SELECT * FROM json_array_elements((p_revdata)->'revising')
		LOOP

				p_units := cast(p_revising->>'units' as double precision);
			
				-- Записываем только при наличии данных о декларации
				IF trim(p_revising->>'declaration') IS NOT NULL THEN		
		      INSERT INTO reviselist(product,declaration,position,truorigincode,units,company,"user",esfid,unitcode)
			      VALUES(cast(p_revising->>'id' as bigint),trim(p_revising->>'declaration'),/*cast*/trim(p_revising->>'pos' /*as integer*/),cast(p_revising->>'origincode' as integer),
								     p_units,p_company,cast(revdata->>'user' as bigint),p_esfid,trim(p_revising->>'unitcode'))
					ON CONFLICT (product,declaration,company)
					DO UPDATE
					  SET units = reviselist.units + p_units
						  WHERE reviselist.product = cast(p_revising->>'id' as bigint)
							  AND reviselist.declaration = trim(p_revising->>'declaration')
								  AND reviselist.company = p_company;
				 END IF;

				 p_count := p_count + 1;

		END LOOP;
		
		/*
		IF p_count = 0 THEN
		   result := json_build_object('code','internal_error','text','Информация по товарам не найдена!');
			 return next;
			 return;
		END IF;
		*/

		UPDATE esf
		  SET revise = true
			  WHERE company = p_company
				  AND id = p_esfid;

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
   WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;






$$;


ALTER FUNCTION public.esf_revising(revdata json, OUT result json) OWNER TO postgres;

--
-- TOC entry 653 (class 1255 OID 16465)
-- Name: esf_update_status(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.esf_update_status(esfdata json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE	 
	p_error							  varchar;
	p_esfdata							json;
	p_revising						json;
	p_code								varchar;
  p_text								varchar;
	p_esf									json;
	p_notfound					  varchar;
	p_check								varchar;
	i											record;
	p_company							bigint;
	p_esfnum							bigint;	
	p_old_status					varchar;
	p_esfid								bigint;
	p_reason							varchar;
	p_status							varchar;

BEGIN

/*
	{"user":"41","statuses":[{"esfnum":"41", "status":"CREATED", "esfid":"123123123123", "reason":"NDS_RATE_FOR_NOT_NDS_PAYER", "esfregnum":"ESF-123456789021-20170923-05812896"}]} 
*/

  SELECT (esfdata)::json into p_esfdata;

		SELECT code, text INTO p_code, p_text
      FROM get_company(p_esfdata->>'user');
    IF p_code = 'success' THEN
	    p_company := p_text;
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		FOR p_esf IN SELECT * FROM json_array_elements((p_esfdata)->'statuses')
		LOOP

			p_esfnum := cast(trim(p_esf->>'esfnum') as bigint);
			p_esfid	 := cast(p_esf->>'esfid' as bigint);
			-- Ебланы поменяли код статуса (21.12.2020)
			p_status := case when upper(trim(p_esf->>'status')) in ('IN_PROCESSING','IN_QUEUE') then 'PROCESSING' else upper(trim(p_esf->>'status')) end;

			SELECT status INTO p_old_status
				FROM esf
			    WHERE id = p_esfnum;
			
			-- На всякий случай. Периодически вместо кода ошибки присылают сам текст ошибки.
			SELECT code INTO p_reason 
				FROM esf_errors
					WHERE rus = trim(p_esf->>'reason');
			IF p_reason IS NULL THEN
				p_reason := trim(p_esf->>'reason');
			END IF;

			UPDATE esf 
				SET status = p_status, lastupdate = now(), esfid = case when (esfid <> p_esfid or esfid is null) then p_esfid else esfid end,
							reason = p_reason, esfregnum = case when esfregnum is null then trim(p_esf->>'esfregnum') else esfregnum end
					WHERE id = p_esfnum;
			--Если запись не найдена - формируем сообщение с внутренними ID ЭСФ
			IF NOT FOUND THEN
				CASE WHEN p_notfound IS NULL THEN
					p_notfound := p_esfnum;
				ELSE
					p_notfound := p_notfound||', '||p_esfnum;
				END CASE;
			END IF;

			--Если статус "Ошибочный" - возврат значения счетчика
			/*IF (upper(trim(p_esf->>'status')) = 'FAILED' AND upper(trim(p_esf->>'status')) <> p_old_status) THEN
			  FOR i IN (
				  SELECT p.id as id, ed.declaration as dec, ed.numberindeclaration as num, ed.quantity as quantity 
					  FROM esf e
						  INNER JOIN esf_details ed on (ed.esfid = e.id and ed.company = e.company)
							INNER JOIN products p on (p.name = ed.description and p.company = p_company)
							INNER JOIN reviselist r on (r.product = p.id and r.declaration = ed.declaration and r.position = ed.numberindeclaration)
								WHERE e.id = p_esfnum
									AND e.company = p_company
									AND e.type = 'OUTBOUND'
									AND ed.manual = false
				) 
				LOOP
				  UPDATE reviselist
					  SET units = units + i.quantity
						  WHERE product = i.id
							  AND declaration = i.dec
								AND position = i.num
							  AND company = p_company;
				END LOOP;
			END IF;*/

		END LOOP;

	IF p_notfound IS NOT NULL THEN
	  RAISE SQLSTATE 'S0001';
	END IF;

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code','error','text','Статусы не были обновлены! Ненайденные внутренние номера ЭСФ: '||p_notfound);
     return next;
   WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 IF p_check = 'esf_fk_status' THEN
		   result := json_build_object('code','error','text','Получен некорректный статус ЭСФ! Пожалуйста, обратитесь в службу поддержки!');
	   ELSIF p_check = 'esf_fk_reason' THEN 
		   result := json_build_object('code','error','text','Получена необъявленная ошибка ЭСФ! Пожалуйста, обратитесь в службу поддержки!');
	   ELSE
	     result := json_build_object('code','internal_error','text', SQLSTATE||':'||SQLERRM||':'||p_error);
	   END IF;

		 return next;

END;$$;


ALTER FUNCTION public.esf_update_status(esfdata json, OUT result json) OWNER TO postgres;

--
-- TOC entry 654 (class 1255 OID 16467)
-- Name: execute_reconciliation(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.execute_reconciliation(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
	p_company				bigint;
	p_point 				bigint;
	p_id 						bigint;
	p_product_id 		bigint;
	p_out_arr 			json;
	p_in_arr 				json;
	p_result 				jsonb := '{"result":[]}';
	p_none 					jsonb := '{"none":[]}';
	p_out_json 			json;
	p_in_json 			json;
	p_stock_units 	numeric;
	p_sale_units 	  numeric;
	p_begin_date		TIMESTAMP;
	p_end_date		  TIMESTAMP;
	p_error					varchar;
	p_user_name 		varchar;
	p_cnt 					int;
 
BEGIN
	-- выполняем сверку.
	-- {"id":17}  
	p_id := cast(inf->>'id' as bigint);
	
	select r.out_data, r.in_data, r.begin_date, r.end_date, r.company, r.point
	into p_out_arr, p_in_arr, p_begin_date, p_end_date, p_company, p_point
		from reconciliation r 
	where r.id = p_id;
	IF NOT FOUND or p_out_arr is null or p_in_arr is null THEN
			RAISE SQLSTATE 'S0001';
	END IF;
	
	select u."name" into p_user_name from erp_users u where u.id = cast(p_out_arr->>'user' as BIGINT);
	
	for p_out_json in SELECT * FROM json_array_elements((p_out_arr)->'out_data')
	loop	
		p_cnt := 0;
		for p_in_json in SELECT * FROM json_array_elements((p_in_arr)->'in_data')
		loop
			if p_out_json->>'code' = p_in_json->>'code' then
			
				select sum(s.units), s.product into p_stock_units, p_product_id
					from stockcurrent s, products p 
				where s.company = p_company
					and s.point = p_point
					and p.company = s.company
					and p.id = s.product
					and p.code = p_out_json->>'code'
					GROUP BY s.product;
				IF NOT FOUND or p_stock_units is null THEN
						exit;
				END IF;	
				
				select sum(d.units) into p_sale_units
					from transactions t, transaction_details d, products p
				where t.company = p_company
					and t.point = p_point				
					and t."date" > p_begin_date
					and d.transactionid = t.id
					and d.product = p.id
					and p.company = t.company
					and p.code = p_out_json->>'code';
				IF NOT FOUND or p_sale_units is null THEN
						p_sale_units := 0;
				END IF;
			
				p_result := jsonb_set(p_result, array['result'], (p_result->'result')||
					json_build_object(
						'product_id',p_product_id,
						'name',p_out_json->>'name',
						'code',p_out_json->>'code',
						'tsd_units',p_in_json->>'units',
						'stock_units',p_stock_units,
						'sale_units', p_sale_units
					)::jsonb);
				p_cnt := 1;
				exit;
			end if;
		end loop;
		if p_cnt = 0 then -- не прошедшие
			select sum(s.units), s.product into p_stock_units, p_product_id
				from stockcurrent s, products p 
			where s.company = p_company
				and s.point = p_point
				and p.company = s.company
				and p.id = s.product
				and p.code = p_out_json->>'code'
				GROUP BY s.product;
			IF NOT FOUND or p_stock_units is null THEN
					p_stock_units = 0;
			END IF;
			p_none := jsonb_set(p_none, array['none'], (p_none->'none')||
					json_build_object(
						'name',p_out_json->>'name',
						'code',p_out_json->>'code',
						'stock_units',p_stock_units
					)::jsonb);
		end if;
	end loop;
	result := json_build_object(
		'code','success',
		'begin_date',to_char(p_begin_date,'DD.MM.YYYY HH24.MI.SS'),
		'end_date',to_char(p_end_date,'DD.MM.YYYY HH24.MI.SS'),
		'user_id', p_out_arr->>'user',
		'user_name',p_user_name,
		'result',p_result->'result',
		'none',p_none->'none');
	update reconciliation set "result" = execute_reconciliation.result::json, status = 1, end_date = CURRENT_TIMESTAMP
		where id = p_id;
	return next;	
EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','Нет данных по ревизии!');
			return next;
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			return next;	
END$$;


ALTER FUNCTION public.execute_reconciliation(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 655 (class 1255 OID 16468)
-- Name: expdatediscount_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.expdatediscount_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 json_object       		json;
 discount_object	 		json;
 p_error           		varchar;
 p_code				  	 		varchar;
 p_text				  	 		varchar;
 p_company         		bigint;
 r								 		record;
 p_id				 					bigint;
 p_type 					 		smallint;
 p_invoice		 		 		bigint;
 p_user						 		bigint;
 p_from				 				integer;
 p_to				 					integer;
 p_discount				 		float4;
 
 p_idarray			 			bigint[];
 p_idarrayslice			 	bigint;
 
BEGIN
	-- {"user" : 1, "company" : 1, "expdatediscount" : [{"id": 1, "from": 1, "to": 1, "type": 1, "discount": 30}]}  
	
	/* 
		 1 Дни
		 2 Месяцы
	*/
	SELECT (inf)::json into json_object;
		
		 p_company	:= cast(json_object->>'company' as bigint);
		 p_user 		:= cast(json_object->>'user' as bigint);
	
  -- SELECT (json_object)->'expdatediscount' into discount_object;
	FOR discount_object IN SELECT * FROM json_array_elements((json_object)->'expdatediscount')   
	LOOP
			
		 p_type 		:= cast(discount_object->>'type' as smallint);  
		 p_id				:= cast(nullif(discount_object->>'id','') as bigint); 

		 p_from			:= cast(nullif(discount_object->>'from','') as integer);
		 p_to				:= cast(nullif(discount_object->>'to','') as integer);
		 p_discount	:= cast(nullif(discount_object->>'discount','') as double precision);
		 
		 IF p_discount IS NULL THEN
			 RAISE SQLSTATE 'S0001';
		 ELSIF p_type NOT IN (1,2) THEN	 
			 RAISE SQLSTATE 'S0002';
		 ELSIF p_from IS NULL OR p_to IS NULL THEN	
			 RAISE SQLSTATE 'S0003';
		 END IF;
		 
		 IF p_id IS NULL THEN
		   INSERT INTO expdate_discount(company,"from","to","type",discount)
			   VALUES(p_company,p_from,p_to,p_type,p_discount)
				   RETURNING "id" INTO p_id;
		 ELSE
			 UPDATE expdate_discount
			   SET deleted = true
				   WHERE "id" = p_id
				     AND company = p_company;
			 IF NOT FOUND THEN
				 RAISE SQLSTATE 'S0004';
			 END IF;
		 END IF;
		 
		 -- Собираем все ID
		 p_idarray := p_idarray || ARRAY[p_id];
		 
  END LOOP;
		 
		 -- Отправка данных на терминалы
		 FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
		 LOOP
		 
		   INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
			   VALUES(now(),p_user,'IN_PROCESS',p_company,r.point,r.point,18)
				   RETURNING invoicenumber INTO p_invoice;  
			 INSERT INTO invoicelist(invoice,stock,attributes,newprod,company)
					SELECT p_invoice,unnest(a),0,false,p_company
						FROM (select p_idarray as a) ids;
			 -- Формирование системного сообщения для терминалов для обновления справочников
		   INSERT INTO systemmessage(point,invoice,type_message,cashbox)
         VALUES(r.point,p_invoice,18,r.cashbox);	 
		 
		 END LOOP;
		
		---------------------------------------------------------------
		result := json_build_object('code','success','text','');
    return next;
		
EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
			 result := json_build_object('code','error','text','Не указана скидка!');
			 return next;
	 WHEN SQLSTATE 'S0002' THEN
			 result := json_build_object('code','error','text','Некорректый тип!');
			 return next;
	 WHEN SQLSTATE 'S0003' THEN
			 result := json_build_object('code','error','text','Некорректый период действия!');
			 return next;
	 WHEN SQLSTATE 'S0004' THEN
			 result := json_build_object('code','error','text','Возникли проблемы при удалении, попробуйте позднее!');
			 return next;		 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
     return next;
END;








$$;


ALTER FUNCTION public.expdatediscount_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 656 (class 1255 OID 16470)
-- Name: find_ticket_vyp(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.find_ticket_vyp(ticket character varying) RETURNS TABLE(ticketn text, name text, organization text)
    LANGUAGE plpgsql
    AS $$
  
    BEGIN
			RETURN QUERY 
			SELECT 
('Билет №'||ticket)::text,(' Выписан '||t2."name"||' '||t2.surname)::text,t3."name"::text
FROM 
app_logs t1 inner join 
app_users t2 on t1.app_users_id=t2."id"
inner join app_organizations t3 on t2.organization_id=t3.id
where    request like '%'
||
(select max(record_locator) from flt_amadeus_integra t3 where t3.document_number=ticket and document_action='ISSUE')
||
'%'  
and 
t1.name='approve book'  and  response like '%Билеты выписаны и будут отправлены Вам на почту в ближайшее время%';
    END;
$$;


ALTER FUNCTION public.find_ticket_vyp(ticket character varying) OWNER TO postgres;

--
-- TOC entry 657 (class 1255 OID 16471)
-- Name: find_ticket_vyp_archiv(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.find_ticket_vyp_archiv(ticket character varying) RETURNS TABLE(ticketn text, name text, organization text)
    LANGUAGE plpgsql
    AS $$
  
    BEGIN
			RETURN QUERY 
			SELECT 
('Билет №'||ticket)::text,(' Выписан '||t2."name"||' '||t2.surname)::text,t3."name"::text
FROM 
app_logs_arhiv t1 inner join 
app_users t2 on t1.app_users_id=t2."id"
inner join app_organizations t3 on t2.organization_id=t3.id
where    request like '%'
||
(select max(record_locator) from flt_amadeus_integra t3 where t3.document_number=ticket and document_action='ISSUE')
||
'%'  
and 
t1.name='approve book'  and  response like '%Билеты выписаны и будут отправлены Вам на почту в ближайшее время%';
    END;
$$;


ALTER FUNCTION public.find_ticket_vyp_archiv(ticket character varying) OWNER TO postgres;

--
-- TOC entry 658 (class 1255 OID 16472)
-- Name: first_registration(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.first_registration(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE 
 usr       json;
 company 	 json;
 p_comp_id bigint;
 p_usr_id	 bigint;
 res       json;
 p_error	 varchar;
 p_check	 varchar;
 p_user_id bigint;
 p_general_stock bigint;
BEGIN

-- {"login" : www, "name" : "Вовчик", "pass" : "qwerty", "iin" : "шифрованная кадабра", "company" : {
--    { "name" : "Бублик ИНК", "bin" : "шифрованная кадабра", "address" : "адрес!", "head" : "кадабра", "head_iin" : "кадабра", "accountant" : "кадабра", 
--		    "accountant_iin" : "кадабра", "gcoea" : "1011", "certificatenum" : "123", "certificateseries" : "321", "certificatedate" : "2019-01-01"}
-- }}

  SELECT (inf)::json into usr;

	SELECT (usr)->>'company' into company;

	  INSERT INTO companies(name,bin,address,head,head_iin,accountant,accountant_iin,status,gcoea,certificatenum,certificateseries,certificatedate
	  
	  ------06.02.2023
	  ,partner_id
	  ------06.02.2023
	  
	  )
	    VALUES(trim(company->>'name'),trim(company->>'bin'),trim(company->>'address'),trim(company->>'head'),trim(company->>'head_iin'),trim(company->>'accountant'),
                     trim(company->>'accountant_iin'),'ACTIVE',company->>'gcoea',cast(NULLIF(trim(company->>'certificatenum'),'') as integer),
										 cast(NULLIF(trim(company->>'certificateseries'),'') as integer),to_date(trim(company->>'certificatedate'),'YYYY-MM-DD')
	  ------06.02.2023
	  ,cast(NULLIF(trim(company->>'partner_id'),'') as integer)
	  ------06.02.2023									 
										 
										 )
		    RETURNING id INTO p_comp_id;

	  INSERT INTO erp_users(login,name,pass,iin,company,status)
	    VALUES(lower(trim(usr->>'login')),trim(usr->>'name'),usr->>'pass',trim(usr->>'iin'),p_comp_id,'ACTIVE')
			  RETURNING id INTO p_user_id;

		-- Добавляем в роль руководителя
		INSERT INTO user2roles
		  VALUES(p_user_id,1);

    INSERT INTO points(name,company,status,point_type,is_minus,address)
	    VALUES('Центральный склад',p_comp_id,'ACTIVE',0,false,trim(company->>'address'))
				RETURNING id INTO p_general_stock;
		-- По настоянию Кудрата (считаем центральный склад торговой точкой)
		INSERT INTO pointset(point,stock)
			VALUES(p_general_stock,p_general_stock);

  result := json_build_object('code','success','text',p_comp_id);
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
   IF p_check = 'erpusr_iin_idx' THEN
		 result := json_build_object('code','error','text','Пользователь с таким ИИН уже существует в системе!');
	 ELSIF p_check = 'company_bin_idx' THEN
		 result := json_build_object('code','error','text','Компания с таким БИН уже зарегистрирована в системе!');
	 ELSIF p_check = 'erpusr_log_idx' THEN
		 result := json_build_object('code','error','text','Пользователь с таким логином уже существует в системе!');
   ELSE
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;$$;


ALTER FUNCTION public.first_registration(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 659 (class 1255 OID 16473)
-- Name: fiz_customers_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.fiz_customers_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 customers_object 		 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
BEGIN

	-- {"company" : 1, "fiz_customers" : {"id" : "1", "telephone" :, "lastname" :, "firstname" :}}

	SELECT (inf)::json into json_object;

		p_company := cast(trim(json_object->>'company') as bigint);

  SELECT (json_object)->'fiz_customers' into customers_object;

		IF cast(customers_object->>'id' as bigint) IS NULL THEN
			INSERT INTO fiz_customers(telephone,lastname,company,firstname)
				VALUES (trim(customers_object->>'telephone'),trim(customers_object->>'lastname'),p_company,trim(customers_object->>'firstname'))
					RETURNING id INTO p_id;
		/*ELSE
			UPDATE customers_bonuscards
			  SET telephone = trim(customers_object->>'telephone'), cardnumber = trim(customers_object->>'cardnumber'), lastname = cast(customers_object->>'lastname' as boolean),
						firstname = trim(customers_object->>'firstname')
				  WHERE id = cast(customers_object->>'id' as bigint);*/
		END IF;

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'debtors_tel_idx' THEN
		 result := json_build_object('code','error','text','Указанный телефон уже зарегистрирован в системе!');
	 ELSE
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;$$;


ALTER FUNCTION public.fiz_customers_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 660 (class 1255 OID 16474)
-- Name: get_catalog(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_catalog(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
	p_error		      	 varchar;
	p_info          	 json;
  p_company_in			 bigint;
	p_type_in					 varchar;
	p_count						 smallint := 0;
  p_point_in				 bigint;
  p_status					 varchar;
	p_group						 bigint;
BEGIN

  -- {"point":"2","type":"products"}
  -- types: products,categories,attributes,stocks,cashboxusers,negacc,cert,discount,promotion

  SELECT (inf)::json into p_info;

		p_point_in   := cast(p_info->>'point' as bigint);

		SELECT company, status INTO p_company_in, p_status
		  FROM points
			  WHERE id = p_point_in;
		IF p_status <> 'ACTIVE' THEN
		  result := json_build_object('code','error','text','Ваша точка не активна!');
			return next;
			return;
		END IF;

    p_type_in		 := lower(p_info->>'type');

		IF p_company_in IS NULL THEN
		  result := json_build_object('code','error','text','Требуется идентификатор компании!');
			return next;
			return;
		ELSE
		  /*SELECT count(id) INTO p_count
			  FROM companies
				  WHERE id = p_company_in
					  AND status = 'ACTIVE';*/
			SELECT count(id), certificate_group INTO p_count, p_group
			  FROM companies
				  WHERE id = p_company_in
					  AND status = 'ACTIVE'
							GROUP BY certificate_group;			
			IF p_count < 1 THEN
			  result := json_build_object('code','error','text','Такой компании либо не существует в системе, либо она больше не активна!');
			  return next;
			  return;
			END IF;
    END IF;

		IF p_type_in NOT IN ('products','categories','attributes','stocks','cashboxusers','negacc','cert','discount','promotion','expdatediscount','tickets','naklexport') THEN
		  result := json_build_object('code','error','text','Неверный идентификатор типа справочника!');
			return next;
			return;
		ELSIF p_type_in = 'products' THEN
		  SELECT json_build_object('code','success','text','','catalog',json_agg(json_build_object('id',p.id,'code',p.code,'name',p.name,'category',p.category,'taxid',p.taxid,'taxrate',t.rate,'brand',p.brand,'bonusrate',p.bonusrate,'type',p.type,'cnofeacode',case when p.cnofeacode is null then '' else p.cnofeacode end,'unitsprid',p.unitsprid,'isdiscount',p.isdiscount,'piece',p.piece,'pieceinpack',p.pieceinpack,'category_name',COALESCE(c.name,''),'deleted',p.deleted, 'extracode',coalesce(b.barcode,array[]::text[]) ))) INTO result
		    FROM products p
				  LEFT JOIN taxes t on (t.id = p.taxid)
						LEFT JOIN categories c on (c.id = p.category and c.company in (0,p.company))
								LEFT JOIN (
								
select pr.id as product, array_agg(pb.barcode) as barcode 
from products pr
left join products_barcode pb
on pr.id = pb.product and pr.company = pb.company
where pr.company = p_company_in and pr.code <> pb.barcode
group by pr.id
							) b
							on p.id = b.product
							WHERE p.company = p_company_in;
								--AND p.deleted is false - не вкоем случае не использовать, т.к. на кассе могут быть сбои.
				      --OR p.company = 0;
------13.07.2023							
					
	ELSIF p_type_in = 'naklexport' then
	 SELECT json_build_object('code','success','text','',
		 'invoices', json_agg(json_build_object(
      			 'invoice', i.invoicenumber,'type_message',i."type",'altinvoice', '1','invoice_date',to_char(i.invoicedate,'DD.MM.YYYY')
      			 )order by invoicenumber)
      			 ) INTO result
		  FROM invoices i
			  INNER JOIN points p on (p.id = i.stockto)	
			  WHERE i.stockto in (
			  SELECT max(s.stock) 
	        FROM points p
		        LEFT JOIN pointset s on (s.point = p.id)
		          WHERE p.id  in 
								(
								SELECT max(c.point)  
	        FROM cashboxes c inner join points p on (c.point=p.id)
		        
		          WHERE c.id=cast(p_info->>'cashbox' as bigint)	
								)
	
								AND p.company in 
								(
								SELECT max(p.company)  
	        FROM cashboxes c inner join points p on (c.point=p.id)
		        
		          WHERE c.id=cast(p_info->>'cashbox' as bigint)		
								)
			  )
			  and type in (1,2) 
			  
			  and cast(i.invoicedate as date)>=cast(p_info->>'date' as date);
	
			  
------13.07.2023							
						
------30.03.2023	
		ELSIF p_type_in = 'tickets' then
		select json_build_object('code','success','text','','catalog',json_agg(col1)) INTO result
from 
(
SELECT 

json_build_object(
'ticketid',t.ticketid,
'ofdnumber', t.ofdnumber ,'ofdurl',t.ofdurl ,'tickettype',t.tickettype ,'customerid',t.customerid,'date',t."date",'shiftnumber',t.shiftnumber,'paymenttype',t.paymenttype
,'price',abs(t.price),'cashbox',cashbox
,'cashboxuser',t.cashboxuser,'paymenttransid',t.paymenttransid,'bonusid',t.bonuscardid,
'bonuspay',abs(t.bonuspay),'bonusadd', t.bonusadd,'cashpay', abs(t.cashpay),'cardpay', abs(t.cardpay),'debitpay', abs(t.debitpay),
'certpay', abs(t.certpay),'discount',abs(t.discount),'markup',abs(t.markup),'debtpay',abs(t.debtpay)
,'fizid',t.fiz_customerid,'debtorid',t.debtorid,'sellerid',t.sellerid,'hash',t.hash,'consignment',t.consignment
,'coupon',
(select json_agg(json_build_object('number', number)) from coupons c where 
c.id in (
select idcoup  from couponsdiary where transactionid =t.id
)
) 
:: varchar
,
'cert',
(select json_agg(json_build_object('code', code)) from giftcertificates where 
id in (
select idcert  from giftcertificatesdiary where transactionid=t.id
)
)
,
'details',
json_agg(json_build_object(
'taxrate',td.taxrate ,
'product',td.product,'units',td.units,'price',td.price  ,'attributes',td.attributes,'bonuspay',abs(td.bonuspay),'bonusadd',abs(td.bonusadd),'bonusrate',abs(td.bonusrate),'discount',abs(td.discount)
,'nds',abs(td.nds),'markup',abs(td.markup),'ticketdiscount',abs(td.ticketdiscount) ,'invoicenumber',td.invoice,'issalebypiece',td.piece,'wholesale',td.wholesale
,'line',td.line,'pieceunits',td.pieceunits
,'total',td.totalprice
,'coupon',
(select json_agg(json_build_object('number', number)) from coupons c where 
c.id in (
select idcoup  from couponsdiary where transactionid =t.id
)
) 
:: varchar
,'cert',
(select json_agg(json_build_object('code', code)) from giftcertificates where 
id in (
select idcert  from giftcertificatesdiary where transactionid=t.id
)
)
,'promotions',
(select json_agg(json_build_object('id',id,'amount',amount)) from transaction_promotions where transactionid=t.id)
:: varchar
))
) as col1
					from transactions t inner join transaction_details td on (t.id=td.transactionid)		
							WHERE t.company = p_company_in and t.point =p_point_in
							and cast(date as date) between cast(p_info->>'date_begin' as date) and cast(p_info->>'date_end' as date)
group  by t.ticketid
,t.ticketid
, t.ofdnumber ,t.ofdurl ,t.tickettype ,t.customerid,t."date",t.shiftnumber,t.paymenttype
,t.price,cashbox
,t.cashboxuser,t.paymenttransid,t.bonuscardid,
t.bonuspay, t.bonusadd, t.cashpay, t.cardpay, t.debitpay,
 t.certpay,t.discount,t.markup,t.debtpay
,t.fiz_customerid,t.debtorid,t.sellerid,t.hash,t.consignment,t.id
) h	;						

		------30.03.2023									
						
		ELSIF p_type_in = 'categories' THEN
		  SELECT json_build_object('code','success','text','','catalog',json_agg(json_build_object('id',id,'name',name,'parentid',parentid))) INTO result
			  FROM categories
				  ORDER BY parentid DESC;
    ELSIF p_type_in = 'attributes' THEN
		  SELECT json_build_object('code','success','text','','catalog',json_agg(json_build_object('id',id,'values',values))) INTO result
			  FROM attributenames;
		ELSIF p_type_in = 'stocks' THEN
			SELECT json_build_object('code','success','text','','catalog',json_agg(json_build_object('stockid',c.id,'product',c.product,'units',c.units,'price',pr.price,'sku',c.sku,'listcode',c.attributes,'attributes', attributeslist,'pieceprice',coalesce(pr.pieceprice,0),'wholesale_price',coalesce(pr.wholesale_price,0)))) INTO result 
			  FROM stockcurrent c
					inner JOIN products on (products.id = c.product and products.deleted = false)
				  LEFT JOIN (
					   SELECT l.listcode,json_agg(json_build_object('attributeid',l.attribute,'attributename',n.values,'value',case when n.format = 'DATE' and l.value like '____-__-__'
																																																													then  to_char(to_Date(l.value,'YYYY-MM-DD'),'DD.MM.YYYY')
																																																													else l.value end)) attributeslist
						    FROM attrlist l
								  LEFT JOIN attributenames n on (n.id = l.attribute)
										AND l.company = p_company_in
											GROUP BY l.listcode
					) l on l.listcode = c.attributes
				LEFT JOIN pointset ps on (ps.stock = c.point)
				  LEFT JOIN points p on (p.id = ps.point and p.company = c.company)
					  LEFT JOIN storeprices pr on (pr.store = p.id and pr.stock = c.id and pr.company = c.company)
					    WHERE p.id = p_point_in
								AND p.company = p_company_in;
		ELSIF p_type_in = 'cashboxusers' THEN
		  SELECT json_build_object('code','success','text','','catalog',json_agg(
			json_build_object('id',u.id,'name',u.name,'role',u.role,'iin',u.iin,'discount',u.discount,'deleted',u.deleted
			-----06.04.2023
			,'discountinfo',u.discountperc 
			-----06.04.2023
			))) INTO result
			  FROM cashbox_users u
				  INNER JOIN points p on (p.id = u.point and p.id = p_point_in and p.status = 'ACTIVE');
		ELSIF p_type_in = 'negacc' THEN
		  SELECT json_build_object('code','success','text','','catalog',json_agg(json_build_object('isminus',is_minus))) INTO result
			  FROM points
				  WHERE id = p_point_in;
		ELSIF p_type_in = 'cert' THEN
			SELECT json_build_object('code','success','text','','catalog',json_agg(p.cert)) INTO result
				FROM (
					SELECT json_build_object('product', g.product, 'stockid', s.id, 'cert', json_agg(json_build_object('code',g.code))) as cert
						FROM giftcertificates g 
							LEFT JOIN stockcurrent s ON (g.company = s.company and g.product = s.product)
								LEFT JOIN pointset ps on (ps.stock = s.point)
									WHERE g.company = p_company_in /*case when p_group = 0 then g.company = p_company_in else g.company IN (SELECT id FROM companies WHERE certificate_group = p_group) end*/
										AND ps.point = p_point_in
											GROUP BY g.product, s.id
				) p;	
		ELSIF p_type_in = 'discount' THEN	
			SELECT json_build_object('code','success','text','','catalog',json_agg(p.prod)) INTO result
					FROM (
								SELECT json_build_object(
								----11.11.2022
								'category',d.object,
								---'category',p2.category,
								----11.11.2022
								'id',d.id,'type',d.type, 'discount',d.discount, 'startdate', to_char(d.startdate,'DD.MM.YYYY'),
								'expirationdate',to_char(d.expirationdate,'DD.MM.YYYY'),'discountsum',d.discountsum,'products', case when d.type <> 1 then 
															json_agg(json_build_object('id',case d.type when 2 then s2.id when 3 then s.id when 4 then s3.id end)) 
														else null end) as prod
									FROM discounts d
										LEFT JOIN products p on (d.company = p.company and p.brand = d.object)
										  LEFT JOIN products p2 on (d.company = p2.company and p2.category = d.object)
												LEFT JOIN stockcurrent s on (p.company = s.company and p.id = s.product)
													LEFT JOIN stockcurrent s2 on (p2.company = s2.company and p2.id = s2.product)
														LEFT JOIN stockcurrent s3 on (d.company = s3.company and d.object = s3.id)
						RIGHT JOIN pointset ps on ((ps.point = d.point and ps.stock = s.point and d.type = 3) OR 
																			(ps.point = d.point and ps.stock = s2.point and d.type = 2) OR 
																			(ps.point = d.point and ps.stock = s3.point and d.type = 4) OR
																			(ps.point = d.point and d.type = 1))
																WHERE d.company = p_company_in
																	AND ps.point = p_point_in
																		AND d.expirationdate >= current_date
																			AND d.isactive is true
																				GROUP BY d.id, d.type, d.discount, to_char(d.startdate,'DD.MM.YYYY'), to_char(d.expirationdate,'DD.MM.YYYY'), d.discountsum
																				----11.11.2022
								                                                ---,p2.category
								                                                ----11.11.2022
					) p;
		ELSIF p_type_in = 'promotion' THEN	
			SELECT json_build_object('code','success','text','','catalog',json_agg(p.prom)) INTO result
				FROM (
					SELECT json_build_object('id',pr.id,'name',pr.name,'startdate',to_char(pr.bdate,'DD.MM.YYYY'),'expirationdate',to_char(pr.edate,'DD.MM.YYYY'),'if',i."if",
																'then',e."then",'priority',pr.priority,'delete',false) AS prom
						FROM promotions pr 
							INNER JOIN points as p on (p.id = pr.point and pr.company = p.company)
							INNER JOIN (SELECT c.listcode, json_build_object('id', c.type, 'values', json_agg(json_build_object('id',c.object,'value',c.amount))) as "if"
														FROM promotions pr 
															INNER JOIN promconditions c on (pr.company = c.company and pr.condlist = c.listcode)
																WHERE pr.company = p_company_in
																	AND pr.point = p_point_in
																		GROUP BY c.listcode, c.type) as i on (i.listcode = pr.condlist)
							INNER JOIN (SELECT pd.listcode, json_build_object('id', pd.type, 'values', json_agg(json_build_object('id',pd.object,'value',pd.rate))) as "then"
														FROM promotions pr 
															INNER JOIN promdiscounts pd on (pr.company = pd.company and pr.disclist = pd.listcode)
																WHERE pr.company = p_company_in
																	AND pr.point = p_point_in
																		GROUP BY pd.listcode, pd.type) as e on (e.listcode = pr.disclist)
								WHERE pr.company = p_company_in
									AND pr.isactive is true
									AND pr.edate >= current_date
									AND pr.point = p_point_in
				) p;
		ELSIF p_type_in = 'expdatediscount' THEN		
			SELECT json_build_object('code','success','text','','catalog',json_agg(json_build_object('id',d.id,'period_from',d.from,'period_to',d.to,'period_type',d.type,
									'rate',d.discount,'deleted',d.deleted))) INTO result 
	      FROM expdate_discount d 
			        WHERE d.company = p_company_in
								AND d.deleted is false;
		END IF;

  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 return next;

END;


$$;


ALTER FUNCTION public.get_catalog(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 661 (class 1255 OID 16476)
-- Name: get_company(character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_company(usr character varying, OUT code character varying, OUT text character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$DECLARE 

 p_company	      bigint;

 p_error		      varchar;

 p_comp_status    varchar;

 p_usr_status			varchar;

BEGIN



	/*SELECT c.id, c.status, u.status INTO p_company, p_comp_status, p_usr_status

		FROM companies c

			LEFT JOIN erp_users u ON (u.company = c.id)

				WHERE u.id = cast(usr as bigint);*/



  SELECT c.id, c.status, u.status INTO p_company, p_comp_status, p_usr_status

    FROM erp_users u

	    LEFT JOIN companies c on (c.id = u.company)

		    WHERE u.id = cast(usr as bigint);



	IF p_company IS NULL THEN

		code := 'error';

		text := 'Компания пользователя не идентифицирована!';

		return next;

  ELSIF p_comp_status <> 'ACTIVE' THEN

		code := 'error';

		text := 'Компания пользователя не активна!';

		return next;

	ELSIF p_usr_status <> 'ACTIVE' THEN

		code := 'error';

		text := 'Учетная запись пользователя не активна!';

		return next;

	ELSE

	  code := 'success';

		text := p_company;

		return next;

  END IF;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 code := 'internal_error';

	 text := SQLSTATE||':'||SQLERRM||':'||p_error;

   return next;

END;









$$;


ALTER FUNCTION public.get_company(usr character varying, OUT code character varying, OUT text character varying) OWNER TO postgres;

--
-- TOC entry 662 (class 1255 OID 16477)
-- Name: get_invoice_details(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_invoice_details(invreq json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error					 varchar;
  p_req						 json;
	p_company				 bigint;
	p_comp_status 	 varchar;
	p_point_status	 varchar;
	p_points				 bigint[];
	p_cashbox_status boolean;
BEGIN

  -- {"cashbox":"41","invoicetype":"1","date":"23.11.2018"}
  -- 1,2,0,7

  SELECT (invreq)::json into p_req;

		SELECT b.deleted, p.status, c.status, c.id, ('{'||p.id||'}')::bigint[] INTO p_cashbox_status, p_point_status, p_comp_status, p_company, p_points
		  FROM cashboxes b
			  LEFT JOIN points p on (p.id = b.point)
				LEFT JOIN companies c on (c.id = p.company)
				  WHERE b.id = cast(p_req->>'cashbox' as bigint);
		IF p_company IS NULL THEN
			result := json_build_object('code','error','text','Компания кассы не идентифицирована!');
			return next;
			return;
    ELSIF p_comp_status <> 'ACTIVE' THEN
			result := json_build_object('code','error','text','Компания кассы не активна!');
			return next;
			return;
		ELSIF p_point_status <> 'ACTIVE' THEN
			result := json_build_object('code','error','text','Точка кассы не активна!');
			return next;
			return;
		ELSIF p_cashbox_status THEN
		  result := json_build_object('code','error','text','Касса не активна!');
			return next;
			return;
		ELSIF cast(p_req->>'invoicetype' as integer) NOT IN (1,2,0,7) THEN
		  result := json_build_object('code','error','text','Неразрешенный тип накладной(инвойса)!');
			return next;
			return;
		END IF;

		-- Подтягиваем все склады точки кассы
		SELECT array_append(p_points, stock) INTO p_points
		 FROM points p
			LEFT JOIN pointset s on (s.point = p.id)
				WHERE p.id = p_points[1]
					AND p.company = p_company;

    SELECT json_build_object('code','success','text','','details',json_agg(json_build_object('invoice',i.invoicenumber,'altnumber',i.altnumber,'product',coalesce(p.name,p2.name),'units',
					case 
						when i.stockfrom = ANY(p_points) and i.type = 1 then ('-'||l.units)::double precision
						else l.units
					end,
				  'attributes',array_to_string(array(select n.values||': '||a.value from attrlist a left join attributenames n on (n.id = a.attribute) where a.listcode = s.attributes 
							and a.company = s.company),', '),
					'newprice',l.newprice,'code',coalesce(p.code,p2.code),'catid',coalesce(c.id,c2.id),'catname',coalesce(c.name,c2.name))ORDER BY i.invoicedate desc)) INTO result
		  FROM invoices i
				LEFT JOIN invoicelist l on (l.invoice = i.invoicenumber and l.company = i.company)
				LEFT JOIN stockcurrent s on (s.id = l.stockto and s.company = l.company)
				LEFT JOIN stockcurrent s2 on (s2.id = l.stock and s2.company = l.company)
				LEFT JOIN products p on (p.id = s.product and p.company = s.company)
				LEFT JOIN products p2 on (p2.id = s2.product and p2.company = s2.company)			
				LEFT JOIN categories c on (c.id = p.category and (p.company = c.company or c.company = 0))
				LEFT JOIN categories c2 on (c2.id = p2.category and (p2.company = c2.company or c2.company = 0))	
			    WHERE i.invoicedate::date = to_date(p_req->>'date','DD.MM.YYYY')
						AND i.company = p_company
						AND i.type = cast(p_req->>'invoicetype' as integer)
						AND (i.stockfrom = ANY(p_points) OR i.stockto = ANY(p_points))
						AND i.status = 'ACCEPTED';
						--  GROUP BY i.invoicenumber, i.invoicedate
								--ORDER BY i.invoicenumber, i.invoicedate desc;

		return next;

EXCEPTION
	 WHEN SQLSTATE '22007' THEN
		 result := json_build_object('code','internal_error','text','Некорректный формат даты!');
		 return next;
	 WHEN SQLSTATE '22008' THEN
		 result := json_build_object('code','internal_error','text','Некорректный формат даты!');	
		 return next;
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

     return next;

END;$$;


ALTER FUNCTION public.get_invoice_details(invreq json, OUT result json) OWNER TO postgres;

--
-- TOC entry 663 (class 1255 OID 16479)
-- Name: get_purchaseprice(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_purchaseprice(transinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error						varchar;
  p_req							json;
	p_company					bigint;
	p_prod						bigint[];
BEGIN

-- { "point":169, "products":[{"id":1},{"id":2}] }

  SELECT (transinf)::json into p_req;
	
		SELECT company INTO p_company
			FROM points
				WHERE id = cast(p_req->>'point' as bigint)
					AND status = 'ACTIVE';
		IF p_company IS NULL THEN
			result := json_build_object('code','error','text','Торговая точка не определена, либо не активна!');
			return next;
			return;
		END IF;

		SELECT array_agg(cast(d.elem->>'id' as bigint)) INTO p_prod 
			  FROM json_array_elements((p_req)->'products') as d(elem);
				
		SELECT json_build_object('code','success','text','','purchaseprice',json_agg(json_build_object('id',p.id,'purchaseprice',coalesce(pa.purchaseprice,0)))) INTO result
			FROM products p
				LEFT JOIN product_accounting pa on (pa.product = p.id and pa.company = p.company and pa.id = (select max(id)
																																																				from product_accounting
																																																					where product = p.id
																																																						and company = p.company))
					WHERE p.id = ANY(p_prod)
							AND p.company = p_company;		
							
			IF result->>'purchaseprice'	is null then
				result := json_build_object('code','error','text','Данные не найдены!');
			END IF;
			
			return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;










$$;


ALTER FUNCTION public.get_purchaseprice(transinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 664 (class 1255 OID 16480)
-- Name: get_transactions(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.get_transactions(transinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error			varchar;
  p_req				json;
  p_begindate timestamp;
  p_enddate		timestamp;
	p_company		bigint;
BEGIN

-- {"cashboxuser":"1","point":"1","tickettype":"1","begin_date":"23.11.2018","end_date":"23.11.2018"}

  SELECT (transinf)::json into p_req;

	p_begindate := /*cast(p_req->>'begin_date' as date);*/ to_date(p_req->>'begin_date','DD.MM.YYYY');
	p_enddate		:= /*cast(p_req->>'end_date' as date);*/	 to_date(p_req->>'end_date','DD.MM.YYYY');
	
	SELECT company INTO p_company
		FROM points
			WHERE id = cast(p_req->>'point' as bigint);

  IF p_enddate < p_begindate THEN
	  result := json_build_object('code','error','text','Конечная дата не должна быть меньше начальной!');
    return next;
		return;
	END IF;

  SELECT json_build_object('code','success','text','','transactions',json_agg(json_build_object('ticketid',t.ticketid,'price',t.price,'cashboxuser',t.cashboxuser,
					  'cashbox',t.cashbox,'paymenttransid',t.paymenttransid,'customerid',coalesce(t.customerid,'0'),'ofdnumber',t.ofdnumber,'ofdurl',t.ofdurl,'date',to_char(t.date,'DD.MM.YYYY HH24:MI:SS'),
                'paymenttype',t.paymenttype,'tickettype',t.tickettype,'cardpay',t.cardpay,'cashpay',t.cashpay,'debitpay',t.debitpay,'bonuspay',t.bonuspay,'bonusadd',t.bonusadd,'certpay',t.certpay,
										'discount',t.discount,'bonuscardid',t.bonuscardid,'sellerid',t.sellerid,'details',det)order by t.ticketid desc)) INTO result
    FROM transactions t
      LEFT JOIN (
		     SELECT d.transactionid, d.company, json_agg(json_build_object('product',d.product,'prodname',p.name,'taxid',p.taxid,'taxrate',tax.rate,'units',d.units,'price',d.price,
										'bonusadd',d.bonusadd,'bonuspay',d.bonuspay,'bonusrate',d.bonusrate,'discount',d.discount,'line',d.line,'attributes',d.attributes)) det
           FROM transactions t2
						 LEFT JOIN transaction_details d on (d.transactionid = t2.id and d.company = t2.company)
					   LEFT JOIN products p on (p.id = d.product and p.company = d.company)
						   LEFT JOIN taxes tax on (tax.id = p.taxid)
								  WHERE t2.cashboxuser = cast(p_req->>'cashboxuser' as bigint)
										AND t2.point = cast(p_req->>'point' as bigint)
										AND t2.tickettype = cast(p_req->>'tickettype' as bigint)
										AND t2.date::date BETWEEN p_begindate AND p_enddate
										AND t2.company = p_company
								 GROUP BY d.transactionid, d.company
		  ) d on (t.id = d.transactionid and t.company = d.company)
	    WHERE t.cashboxuser = cast(p_req->>'cashboxuser' as bigint)
		    AND t.point = cast(p_req->>'point' as bigint)
			    AND t.tickettype = cast(p_req->>'tickettype' as bigint)
				    AND t.date::date BETWEEN p_begindate AND p_enddate
							AND t.company = p_company;   
						
			return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;










$$;


ALTER FUNCTION public.get_transactions(transinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 665 (class 1255 OID 16481)
-- Name: giftcard_acceptance_xls(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.giftcard_acceptance_xls(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company           					bigint;
 p_user												bigint;
 p_error			       					varchar;
 p_check						 					varchar;
 p_giftcards 				    			json;
 p_code												varchar;
 p_balance									  integer;
 p_period											smallint;
 p_selldate										date;
 p_result_j										varchar;
 p_count_j										json;
 p_count											integer := 0;
 p_cert_id										bigint;
 p_reason											smallint;
 p_codepoll										varchar[];
 p_group											bigint;
BEGIN

/*
{"company": 9, "user": "42", "giftcards": [
	{"Code":"12345", "Balance":"5000","Period":"3","Selldate":"11.11.2011"}
 ]
}
*/
-- status: error/info/ok
	
		p_company := cast(trim(inf->>'company') as bigint);
		p_user		:= cast(trim(inf->>'user') as bigint);
		
		-- Проверка на группы сертификатов
		SELECT coalesce(certificate_group,0) INTO p_group
			FROM companies
				WHERE id = p_company;	
		
		IF p_company IS NULL OR p_user IS NULL THEN
			RAISE SQLSTATE 'S0001';
		END IF;
	 
	 FOR p_giftcards IN SELECT * FROM json_array_elements((inf)->'giftcards') ORDER BY cast(regexp_replace(trim(p_giftcards->>'Balance'), '\D+', '', 'g') as numeric)
	 LOOP
			
			p_code 		 	 	:= regexp_replace(trim(p_giftcards->>'Code'), '\D+', '', 'g');
			p_balance 	 	:= cast(regexp_replace(trim(p_giftcards->>'Balance'), '\D+', '', 'g') as integer);
			p_period 	 		:= cast(regexp_replace(trim(p_giftcards->>'Period'), '\D+', '', 'g') as smallint);
			-- Case на всякий случай. Поля с датой и таким же форматом иногда в американском формате отправляются
		  p_selldate 	 	:= case when nullif(trim(p_giftcards->>'Selldate'),'') like '%-%' then 
											   nullif(trim(p_giftcards->>'Selldate'),'')::date 
											 else 
												 to_date(nullif(trim(p_giftcards->>'Selldate'),''),'DD.MM.YYYY') end;
		 	
			-- Избегание лишнего текста
			IF (/*p_code IS NULL AND */p_balance IS NULL AND p_period IS NULL AND p_selldate IS NULL) THEN
				CONTINUE;
			END IF;
			
			-- Борьба с повторяющимися значениями
			IF p_code = ANY(p_codepoll) THEN
				CONTINUE;
			ELSE		
				IF p_codepoll IS NULL THEN
					p_codepoll := array_agg(ARRAY[p_code]);
				ELSE
					p_codepoll := p_codepoll || ARRAY[p_code];		
				END IF;
			END IF;
			
			-- Проверка на пустые обязательные поля
			IF p_code IS NULL THEN		
				IF p_result_j IS NULL THEN
				  p_result_j := json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text','Не указан идентификационный код сертификата!','status','error')::text;
				ELSE
				  p_result_j := p_result_j ||','|| json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text','Не указан идентификационный код сертификата!','status','error')::text;
				END IF;		 
				CONTINUE;
			ELSIF p_balance IS NULL THEN
				IF p_result_j IS NULL THEN
				  p_result_j := json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text','Не указана сумма сертификата!','status','error')::text;
				ELSE
				  p_result_j := p_result_j ||','|| json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text','Не указана сумма сертификата!','status','error')::text;
				END IF;		 
				CONTINUE;
			ELSIF p_period IS NULL THEN
				IF p_result_j IS NULL THEN
				  p_result_j := json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text','Не указан активный период с момента продажи!','status','error')::text;
				ELSE
				  p_result_j := p_result_j ||','|| json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text','Не указан активный период с момента продажи!','status','error')::text;
				END IF;		 
				CONTINUE;
			END IF;
			
			SELECT id INTO p_cert_id
				FROM giftcertificates
					WHERE code = p_code
						AND case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end;
			IF FOUND THEN
				-- Проверка на последний статус. Если он был "Истекший", тогда даем добавить сертификат.
				SELECT coalesce(reason,0) INTO p_reason
					FROM giftcertificatesdiary
						WHERE case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end
							AND idcert = p_cert_id
							AND date = (SELECT max(date)
														FROM giftcertificatesdiary
															WHERE case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end
																AND idcert = p_cert_id);
				IF NOT FOUND THEN
					p_reason := 0;
				END IF;
				
				IF p_result_j IS NULL THEN
				  p_result_j := json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text',
													case when p_reason <> 4 then 
													  'Активный сертификат с таким номером уже числится в базе!' 
													else 
														'Сертификат числится в базе. Его статус будет изменен на "Доступен для продажи"!' 
													end,'status',case when p_reason <> 4 then 'error' else 'info' end)::text;
				ELSE
				  p_result_j := p_result_j ||','|| json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text',
													case when p_reason <> 4 then 
														'Активный сертификат с таким номером уже числится в базе!' 
													else 
														'Сертификат числится в базе. Его статус будет изменен на "Доступен для продажи"!' 
													end,'status',case when p_reason <> 4 then 'error' else 'info' end)::text;
				END IF;		 
				CONTINUE;
			END IF;
			
			-- Чтобы не сували штрихкоды сюда
			IF p_balance > 500000 THEN
				p_reason := -1;
			ELSE
				p_reason := 0;
			END IF;
			
			IF p_result_j IS NULL THEN
				p_result_j := json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text',
													case when p_reason = -1 then 'Некорректный номинал сертификата!' else '' end,'status',
													case when p_reason = -1 then 'error' else 'ok' end)::text;
			ELSE
				p_result_j := p_result_j ||','|| json_build_object('code',p_code,'balance',p_balance,'period',p_period,'selldate',to_char(p_selldate,'DD.MM.YYYY'),
													'name','Подарочный сертификат '||p_balance,'text',
													case when p_reason = -1 then 'Некорректный номинал сертификата!' else '' end,'status',
													case when p_reason = -1 then 'error' else 'ok' end)::text;
			END IF;
	 
	 END LOOP;
	 
	 p_result_j := '['||p_result_j||']';
	 
	 SELECT json_agg(d.det) INTO p_count_j
		 FROM (SELECT json_build_object('balance',value->>'balance','count',count(value->>'balance')) as det
						 FROM json_array_elements(p_result_j::json)
						   WHERE (value->>'status' <> 'error')
							   GROUP BY value->>'balance'
								   ORDER BY cast(value->>'balance' as numeric)) d;						 
	 
	 result := json_build_object('code','success','text',p_result_j::json,'count',p_count_j);
   return next;
	
	 EXCEPTION 
		 WHEN SQLSTATE 'S0001' THEN
			 result := json_build_object('code','error','text','Идентификаторы компании или пользователя не были переданы!');
			 return next; 	  
		 WHEN OTHERS THEN
			 RAISE NOTICE 'internal_error: %', SQLERRM;
			 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			 return next;
		 
END;$$;


ALTER FUNCTION public.giftcard_acceptance_xls(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 666 (class 1255 OID 16483)
-- Name: goods_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.goods_add(addinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	p_move 				   				json;
	units_result_min 				float8;
  p_minus					 				boolean;
	p_invoicenumber	 				bigint;
	p_invoicedate						date;
	p_company				 				bigint;
	p_code					 				varchar;
	p_text					 				varchar;
	p_error					 				varchar;
	p_status				 				varchar;
  p_stockto				 				bigint;
	r      				record;
	attrs_rec 	record;
	z												record;
	func_res					 			record;
  p_invoice_in		 				bigint;
	p_discount_invoice			bigint;
	p_discount_point				bigint;
  p_stockcurrent	 				bigint;
  p_price_old			 				float8;
  p_new_product		 				bigint;
  p_directory_upd		 		  boolean := false;
	p_new_stock			 				bigint;
  p_point_type		 				bigint;
  p_stock_to			 				bigint;
  p_units					 				float8;
  p_store_to			 				bigint;
  p_send_point		 				bigint  := 0;
  p_cashbox_exist  				boolean := false;
  p_result				 				json;
  p_func		 			    		varchar;
	p_invoice_change_prices boolean := false;
	w												record;
	p_new_invoice_dir_upd		bigint;
  p_new_invoice_cha_pri		bigint;
  p_consignment						boolean := false;
	p_categories						bigint;
	p_pieceprice_old			 	float8;
	p_wholesale_price_old				float4;
	--p_new_attrlist_code		bigint;
  -- 20230520: p_scp_units_before - units of stock in stockcurrent_part before transaction / invoice
  -- 20230520: p_scp_units_after - units of stock in stockcurrent_part after transaction / invoice
  -- 20230520: p_sc_units_before - units of stock in stockcurrent before transaction / invoice
  -- 20230520: p_sc_units_after - units of stock in stockcurrent after transaction / invoice
  p_scp_units_before						float8 := 0;
  p_scp_units_after							float8 := 0;
  p_sc_units_before							float8 := 0;
  p_sc_units_after							float8 := 0;
	--p_logging_json 		 json;
BEGIN
--{"invoice" : "1", "user" : "2"}

   
-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
-- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

  SELECT (addinf)::json into p_move;
		p_invoice_in := cast(p_move->>'invoice' as bigint); 
		SELECT code, text INTO p_code, p_text
      FROM get_company(p_move->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		SELECT i.status, i.stockto, p.point_type, p.consignment, i.invoicedate INTO p_status, p_stockto, p_point_type, p_consignment, p_invoicedate
		  FROM invoices i
			  INNER JOIN points p on (p.id = i.stockto)
			    WHERE i.invoicenumber = p_invoice_in
						FOR UPDATE;

		IF p_status = 'ACCEPTED' THEN
		  result := json_build_object('code','exception','text','Данная накладная(инвойс) уже обработана!');
      return next;
		  return;
		ELSIF p_status = 'IN_PROCESS' THEN
			result := json_build_object('code','exception','text','Данная накладная(инвойс) уже обрабатывается!');
      return next;
		  return;
		ELSIF p_status = 'CANCELED' THEN
			result := json_build_object('code','exception','text','Данная накладная(инвойс) была отменена!');
      return next;
		  return;
		END IF;

	FOR r IN (
				SELECT coalesce(p2.id,p.id) id,l.units,l.newprice,l.attributes as attr,
						l.purchaseprice,l.newprod,l.prodchanges,
						l.updateallprodprice, coalesce(p2.unitsprid,p.unitsprid) unitsprid, 
						l.hotkey, l."scale", coalesce(l.pieceprice,0) as pieceprice,
						l.wholesale_price
				FROM invoicelist l 
						LEFT JOIN products p on (p.id = l.stock and p.company = l.company)
							LEFT JOIN products_temp p2 on (p2.id = l.stock and p2.company = l.company)
								WHERE l.invoice = p_invoice_in
									AND l.company = p_company
	  ) 
	LOOP
		-- По типу склада, либо сразу добавляем товар, либо нет
		IF p_point_type = 0 
		
				
		OR p_consignment THEN
			-- Если товар - услуга, значит количество = 0
		  p_units := case when r.unitsprid <> 3 then r.units else 0 end;
		ELSE
			p_units := '0';
      -- Перезаписываем id склада на id точки
			IF p_store_to IS NULL THEN
			  SELECT p.id INTO p_store_to
	        FROM points p
		        LEFT JOIN pointset s on (s.point = p.id)
		          WHERE s.stock = p_stockto
								AND p.company = p_company;
			END IF;
		END IF;

		p_new_product := r.id;	
		
		IF r.newprice IS NULL THEN
			r.newprice := 0;
		END IF;
		
		/*IF r.attr = 0 OR r.attr IS NULL THEN
			p_new_attrlist_code := 0;
		END IF;*/
	

		
		-- Определение наличия такого продукта
		IF r.newprod THEN			
			  INSERT INTO products
			    SELECT id,code,name,category,taxid,image,company,
						cnofeacode,brand,bonusrate,type,isdiscount,
						isstaticprice,unitsprid,deleted,piece,pieceinpack,0,0
					FROM products_temp
					WHERE id = r.id;
		
		          
		            --------------------- New table ------------------------
					--------------------------------------------------------
					---22.07.2022
					--INSERT INTO products_barcode
					INSERT INTO products_barcode(product, barcode, company)
					---22.07.2022
						SELECT id,code,company
							FROM products_temp
								WHERE id = r.id;
					--------------------------------------------------------
					
					
		     			
					
			  -- Удаление из темповой таблицы			
				DELETE FROM products_temp WHERE id = r.id;
		  -- Флаг для рассылки обновлений по справочнику
			IF NOT p_directory_upd THEN
			  p_directory_upd := true;
			END IF;		
		END IF;

	  -- Оставляем записи в журнале перемещений товара (перенесено в invoice_processing, кроме добавления на центральный склад)
		IF p_point_type = 0 OR p_consignment THEN
			-- 20230520 assign p_scp_units_before
			SELECT units
					FROM stockcurrent_part into p_scp_units_before 
					WHERE stockcurrent_part.point = p_stockto
					AND stockcurrent_part.date = current_date
					AND stockcurrent_part.product = p_new_product
					AND stockcurrent_part.attributes = r.attr
					AND stockcurrent_part.company = p_company
					AND stockcurrent_part.purchaseprice = r.purchaseprice;
			-- Партионный учет	
			INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
								VALUES(p_company,p_stockto,current_date,p_new_product,r.attr,r.purchaseprice,r.units)
							ON CONFLICT (company,point,date,product,attributes,purchaseprice)
							DO UPDATE
								SET units = stockcurrent_part.units + r.units
									WHERE stockcurrent_part.point = p_stockto
										AND stockcurrent_part.date = current_date
										AND stockcurrent_part.product = p_new_product
										AND stockcurrent_part.attributes = r.attr
										AND stockcurrent_part.company = p_company
										AND stockcurrent_part.purchaseprice = r.purchaseprice
											-- assign p_scp_units_after
											RETURNING units INTO  p_scp_units_after;
			-- 20230520 logger
			--raise WARNING 'p_scp_units_before = %, p_scp_units_after = %', p_scp_units_before, p_scp_units_after;
			-- Оставляем записи в журнале перемещений товара (перенесено в invoice_processing, кроме добавления на центральный склад)
			INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,pieceprice,scp_units_before,scp_units_after,comments)
		  		VALUES(now(),'1',p_stockto,p_new_product,r.units,r.newprice,r.attr,p_company,r.purchaseprice,current_date,r.pieceprice,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_add, only for central warehouse');
		END IF;

		-- Добавляем товар на склад	
		SELECT s.id, s2.price, p.category, s2.pieceprice, s2.wholesale_price
			INTO p_stockcurrent, p_price_old, p_categories, p_pieceprice_old, p_wholesale_price_old
		FROM stockcurrent s
			LEFT JOIN storeprices s2 on (s2.stock = s.id /*and s2.store = s.point*/ and s2.company = s.company)
			LEFT JOIN products p on (p.id = s.product and p.company = s.company)
				WHERE s.point = p_stockto
					AND s.product = p_new_product
						AND s.attributes = r.attr
							AND s.company = p_company;

		-- Проверка на наличие такой записи
		IF p_stockcurrent IS NULL THEN
		  INSERT INTO stockcurrent(point,product,units,attributes,company,hotkey,"scale")
					  VALUES(p_stockto,p_new_product,p_units,r.attr,p_company,r.hotkey,r."scale")
						  RETURNING id INTO p_new_stock;
			INSERT INTO storeprices(store,stock,price,company,pieceprice,wholesale_price)
			  VALUES(coalesce(p_store_to,p_stockto),p_new_stock,r.newprice,p_company,r.pieceprice,r.wholesale_price);
			 
			-------29.05.2023 
			INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,pieceprice,sc_units_before,sc_units_after,comments)
		  		VALUES(now(),'100',p_stockto,p_new_product,r.units,r.newprice,r.attr,p_company,r.purchaseprice,current_date,r.pieceprice,0,p_units,'stockcurrent insert by goods_add, line 218');
 
			-------29.05.2023
			 
			func_res := utl_changeprice_log(
				comp=>p_company,
				stock=>p_new_stock,
				pr=>r.newprice,pr_old=>null,pprice=>r.pieceprice,pprice_old=>null,inv=>p_invoice_in);	
		ELSE
			IF p_point_type = 0 OR p_consignment then
				-- 20230522 record sc_units_bofore
			  	select units into p_sc_units_before
			  		from stockcurrent
			  			where point = p_stockto	
						  AND product = p_new_product
							  AND attributes = r.attr
									AND company = p_company;
				UPDATE stockcurrent
				  SET units = units + r.units
				    WHERE point = p_stockto	
						  AND product = p_new_product
							  AND attributes = r.attr
									AND company = p_company
										returning units into p_sc_units_after;
			-- 20230522 add mode logging of stockcurrent changes in stockdiary
			INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,pieceprice,sc_units_before,sc_units_after,comments)
		  		VALUES(now(),'100',p_stockto,p_new_product,r.units,r.newprice,r.attr,p_company,r.purchaseprice,current_date,r.pieceprice,p_sc_units_before,p_sc_units_after,'stockcurrent updated by goods_add, line 232');

			END IF;
			-- Проверка на изменение цены
			IF p_price_old <> r.newprice AND r.newprice IS NOT NULL THEN
			  UPDATE storeprices
				  SET price = r.newprice
				    WHERE stock = p_stockcurrent	
						  AND store = coalesce(p_store_to,p_stockto)
								AND company = p_company;
			END IF;
			-- Проверка на изменение штучной цены
			IF p_pieceprice_old <> r.pieceprice AND r.pieceprice IS NOT NULL THEN
			  UPDATE storeprices
				  SET pieceprice = r.pieceprice
				    WHERE stock = p_stockcurrent	
						  AND store = coalesce(p_store_to,p_stockto)
								AND company = p_company;
			END IF;
			-- Проверка на изменение оптовой цены
			IF p_wholesale_price_old <> r.wholesale_price AND r.wholesale_price IS NOT NULL THEN
			  UPDATE storeprices
				  SET wholesale_price = r.wholesale_price
				    WHERE stock = p_stockcurrent	
						  AND store = coalesce(p_store_to,p_stockto)
								AND company = p_company;
			END IF;
			-- Фиксируем изменение цены
			IF (p_price_old <> r.newprice AND r.newprice IS NOT NULL) OR (p_pieceprice_old <> r.pieceprice AND r.pieceprice IS NOT NULL) THEN
				func_res := utl_changeprice_log(
					comp=>p_company,
					stock=>p_stockcurrent,
					pr=>r.newprice,
					pr_old=>p_price_old,
					pprice=>r.pieceprice,
					pprice_old=>p_pieceprice_old,
					inv=>p_invoice_in
				);
			END IF;
			-- Изменения для весового товара
			IF p_categories = -1 THEN
				UPDATE stockcurrent
					SET hotkey = case when hotkey <> r.hotkey then r.hotkey else hotkey end,
							"scale" = case when "scale" <> r."scale" then r."scale" else "scale" end
						WHERE id = p_stockcurrent
							AND company = p_company;
			END IF;
		END IF;

		-- Для добавления на склад
		UPDATE invoicelist
		  SET stockto = coalesce(p_stockcurrent,p_new_stock), newprice = coalesce(r.newprice,p_price_old)
			  WHERE stock = r.id
				  AND attributes = r.attr
					  AND invoice = p_invoice_in
							AND company = p_company;

		-- Таблица для отчетов (с суммой закупа)
		INSERT INTO product_accounting(purchaseprice,product,units,date,attributes,company)
		  VALUES(r.purchaseprice,p_new_product,r.units,now(),r.attr,p_company);

		-- Внесение изменений в справочник товаров, если они есть
		--flipflop
		IF r.prodchanges IS NOT NULL AND not r.newprod then
				--// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) <
		 		-- if we see invoice.prodchanges, that means we need to update nomenclature in all points
				p_directory_upd := true;
				--// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) >
		  UPDATE products
			  SET category = cast(split_part(r.prodchanges, ',', 1) as bigint), taxid = cast(split_part(r.prodchanges, ',', 2) as bigint), 
								cnofeacode = nullif(split_part(r.prodchanges, ',', 3),''), brand = cast(split_part(r.prodchanges, ',', 4) as bigint), 
								bonusrate = cast(split_part(r.prodchanges, ',', 5) as integer),unitsprid = cast(split_part(r.prodchanges, ',', 6) as bigint),
								deleted = cast(split_part(r.prodchanges, ',', 7) as boolean),piece = cast(split_part(r.prodchanges, ',', 8) as boolean), 
								pieceinpack = cast(split_part(r.prodchanges, ',', 9) as integer)
				  WHERE id = p_new_product
						AND company = p_company;
		END IF;

-------------------------- WARNING!
		-- Формирование инвойса по обновлению цен на все товары, независимо от атрибутов (если есть признак)
		IF r.updateallprodprice AND p_store_to IS NOT NULL THEN
		  p_invoice_change_prices := true;
		END IF;
----------------------------------------------------------------------------------------------------------------------------------------

	END LOOP;		

	-- Обновление справочников\цен на всех точках
	-- Если требуется обновить справочники компании в связи с добавлением нового значения
	IF p_directory_upd THEN
		FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
		LOOP

			IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления справочников
	      INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
			    SELECT invoicedate,creator,'IN_PROCESS',company,r.point,r.point,3
				    FROM invoices
						  WHERE invoices.invoicenumber = p_invoice_in
								AND invoices.company = p_company
									RETURNING invoicenumber INTO p_new_invoice_dir_upd;
	      INSERT INTO invoicelist(invoice,stock,units,newprice,attributes,purchaseprice,newprod,
	      --// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) <
	      prodchanges,
	      --// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) >
	      company,wholesale_price)
		      SELECT p_new_invoice_dir_upd,stock,units,newprice,attributes,purchaseprice,newprod,
		      	--// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) <
	      		prodchanges,
	      		--// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) >
		      	company,wholesale_price
			      FROM invoicelist
				      WHERE invoicelist.invoice = p_invoice_in
				      		--// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) <
						    --AND invoicelist.newprod = true
				      		AND (invoicelist.newprod = true or invoicelist.prodchanges is not null)
						    --// 20230901 by AB fixing update of products by excel table (invoice_addprod, goods_add) >
									AND invoicelist.company = p_company;
			END IF;

			-- Формирование системного сообщения для терминалов для обновления справочников
		  INSERT INTO systemmessage(point,invoice,type_message,cashbox,"date")
        VALUES(r.point,p_new_invoice_dir_upd,3,r.cashbox,p_invoicedate);

		END LOOP;
		-- Для сообщения о скидосиках (31.12.2019)
		FOR r IN (
			SELECT distinct d.id, d.point, i.creator
				FROM invoices i
					INNER JOIN invoicelist l ON (i.invoicenumber = l.invoice and i.company = l.company)
						LEFT JOIN products p ON (l.stock = p.id and l.company = p.company)
							LEFT JOIN products_temp p1 ON (l.stock = p1.id and l.company = p1.company)
								INNER JOIN pointset ps on (ps.stock = i.stockto)
									INNER JOIN discounts d ON (((coalesce(p.category,p1.category) = d.object and d.type = 2) OR (p.brand = d.object and d.type = 3) /*OR (p.id = d.object and d.type = 4)*/) AND d.point = ps.point 
																							AND d.expirationdate >= current_date and d.isactive is true)
						WHERE i.invoicenumber = p_invoice_in
							AND l.newprod = true
								AND i.company = p_company
		)
		LOOP
			IF p_discount_point IS NULL THEN
				p_discount_point := r.point;
			END IF;
			IF p_discount_invoice IS NULL THEN
				INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(current_date,r.creator,'IN_PROCESS',p_company,r.point,r.point,10)
						RETURNING invoicenumber INTO p_discount_invoice;
			END IF;		
			INSERT INTO invoicelist(invoice,stock,attributes,company,newprod)
				VALUES(p_discount_invoice, r.id,0,p_company,false);
		END LOOP;	
		IF p_discount_invoice IS NOT NULL THEN
			FOR r IN (
				SELECT p.id as point, b.id as cashbox
					  FROM points p 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE p.company = p_company 
								    AND p.id = p_discount_point
									    AND p.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
			)
			LOOP
				-- Формирование системного сообщения для терминалов для обновления справочников
				INSERT INTO systemmessage(point,invoice,type_message,cashbox,"date")
					VALUES(p_discount_point,p_discount_invoice,10,r.cashbox,p_invoicedate);	
			END LOOP;	
		END IF;		
  END IF;

	-------------------------------------------------------------------------------------------

  select p.point into p_send_point from pointset p where p.stock = p_stockto;
	--p_send_point := 0;

	-- Обновление цен на всех точках (если была проставлена галочка)
  IF p_invoice_change_prices THEN
	  FOR r IN (
					SELECT distinct p2.id as point, b.id as cashbox
					  FROM invoicelist l
						  INNER JOIN stockcurrent s on (s.product = l.stock and s.company = l.company)
							  INNER JOIN pointset p on (p.stock = s.point)
								  INNER JOIN points p2 on (p2.id = p.point and p2.company = s.company)		
									  LEFT JOIN cashboxes b on (b.point = p2.id)
										  WHERE p2.status = 'ACTIVE'
											  AND b.deleted = false
												  AND b.isengaged = true
													  AND l.invoice = p_invoice_in
														  AND l.updateallprodprice is true
																AND l.company = p_company
															    ORDER BY p2.id, b.id
			)
		LOOP

		  IF p_send_point <> r.point THEN
				p_send_point := r.point;
				-- Создание и заполнение накладной(инвойса) для обновления цен
			  INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
			      SELECT invoicedate,creator,'IN_PROCESS',p_company,r.point,r.point,0
				      FROM invoices
						    WHERE invoices.invoicenumber = p_invoice_in
									AND invoices.company = p_company
										RETURNING invoicenumber INTO p_new_invoice_cha_pri;
				INSERT INTO invoicelist(invoice,stock,units,newprice,attributes,newprod,company,pieceprice,wholesale_price)
				     SELECT DISTINCT p_new_invoice_cha_pri,s.id, 0, l.newprice,s.attributes,false,
						 l.company,l.pieceprice,l.wholesale_price
						   FROM invoicelist l
							   INNER JOIN stockcurrent s on (s.product = l.stock and s.company = l.company)
								   INNER JOIN pointset p on (p.stock = s.point)
									   WHERE p.point = p_send_point
										   AND l.updateallprodprice is true
											   AND l.invoice = p_invoice_in
													AND l.company = p_company;
				
				-- Фиксирование изменений цен
				FOR z IN (
					SELECT DISTINCT s.id, l.newprice,l.pieceprice, sp.price, sp.pieceprice as pieceprice_old
						   FROM invoicelist l
							   INNER JOIN stockcurrent s on (s.product = l.stock and s.company = l.company)
								   INNER JOIN pointset p on (p.stock = s.point)
									   INNER JOIN storeprices sp on (sp.stock = s.id and sp.store = p.point and sp.company = s.company)
									     WHERE (p.point = p_send_point AND p.point <> p_stockto)
										     AND l.updateallprodprice is true
											     AND l.invoice = p_invoice_in
													   AND l.company = p_company
				)
				LOOP
					IF z.newprice <> z.price OR coalesce(z.pieceprice,0) <> z.pieceprice_old THEN
						func_res := utl_changeprice_log(
							comp=>p_company,
							stock=>z.id,
							pr=>z.newprice,
							pr_old=>z.price,
							pprice=>coalesce(z.pieceprice,0),
							pprice_old=>z.pieceprice_old,
							inv=>p_invoice_in);
					END IF;	
				END LOOP;

				-- Обновление цен
				UPDATE storeprices SET price = subquery.newprice, pieceprice = subquery.pieceprice, 
					wholesale_price = subquery.wholesale_price
				FROM (
					SELECT s.id, l.newprice, coalesce(l.pieceprice,0) as pieceprice, l.wholesale_price
						FROM invoicelist l
							INNER JOIN stockcurrent s on (s.product = l.stock and s.company = l.company)
								INNER JOIN pointset p on (p.stock = s.point)
									WHERE p.point = p_send_point
										AND l.updateallprodprice is true
											AND l.invoice = p_invoice_in
												AND l.company = p_company
				) AS subquery
					WHERE storeprices.store = p_send_point
						AND storeprices.stock = subquery.id
							AND storeprices.company = p_company;

				-- Формирование системного сообщения для терминалов для обновления цен
				INSERT INTO systemmessage(point,invoice,type_message,cashbox,"date")
				VALUES(r.point,p_new_invoice_cha_pri,0,r.cashbox,p_invoicedate);
			END IF;
		END LOOP;
	END IF;

	--------------------------------------------------------------------------------------------
  
  -- Если добавление не на центральный склад - высылаем уведомление в POS
  IF p_point_type = 0 OR p_consignment THEN
	  UPDATE invoices
	    SET status = 'ACCEPTED', approver = cast(p_move->>'user' as bigint), system = 'ERP', approvedate = now()
		    WHERE invoices.invoicenumber = p_invoice_in
					AND invoices.company = p_company;
  ELSE
		UPDATE invoices
	    SET status = 'IN_PROCESS'
		    WHERE invoices.invoicenumber = p_invoice_in
					AND invoices.company = p_company;
		-- Рассылка по кассам
		FOR r IN (
				SELECT id
				  FROM cashboxes
					  WHERE point = coalesce(p_store_to,p_stockto)
						  AND deleted = false
							  AND isengaged = true
	  )
		LOOP
			p_cashbox_exist := true;
	    INSERT INTO systemmessage(point,invoice,type_message,cashbox,"date")
        VALUES(coalesce(p_store_to,p_stockto),p_invoice_in,2,r.id,p_invoicedate);	
		END LOOP;
		-- Проверка наличия привязанных касс к точке, если касс нет - автоматическое подтверждение и добавление
		IF NOT p_cashbox_exist THEN
      SELECT invoice_processing(json_build_object(
				'invoice',p_invoice_in,
				'action','ACCEPTED',
				'user',cast(p_move->>'user' as bigint),
				'system','ERP',
				'point',coalesce(p_store_to,p_stockto),
				'cashbox','0')) 
			INTO p_result;
			IF p_result->>'code' LIKE '%error%' THEN
		    p_code := p_result->>'code';
			  p_text := p_result->>'text';
        p_func := 'invoice_processing';
        RAISE SQLSTATE 'S0001';
		  END IF;
		END IF;
	END IF;
	
	result := json_build_object('code','success','text','');
	return next;

EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
     return next;
  WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
     return next;
END;
$$;


ALTER FUNCTION public.goods_add(addinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 667 (class 1255 OID 16485)
-- Name: goods_movement(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.goods_movement(movinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	p_move 				     json;
	units_result_min   float8;
  p_minus					   boolean;
	p_invoicenumber	   bigint;
	p_invoicedate			 date;
	p_company				   bigint;
	p_code					   varchar;
	p_text					   varchar;
	p_error					   varchar;
	p_status				   varchar;
	p_pointfrom			   bigint;
  p_pointto				   bigint;
	r                  record;
	g									 record;
  s                  json;
  p_invoice_in		   bigint;
  p_trade_point_to   bigint;
  p_trade_point_from bigint;
	p_altnumber  			 varchar;
	p_stock_to				 bigint;		
	p_price_to				 float8;
  p_price_from			 float8;
	
	p_pieceprice_to		 float8;
  p_pieceprice_from	 float8;
	
  p_cashbox_exist    boolean := false;
  p_func		 			   varchar;
  p_result				   json;
	p_point_type			 smallint;
	p_count						 float8 := 0;
	p_purchase_price	 float8 := 0;
	p_purchase_date	 	 date;
	p_part_exist		 	 boolean := false;
	p_logging_json 		 json;
	func_res					 record;
	p_wholesale_price_from float8;
    p_wholesale_price_to float8;
  --p_units_before						float8 := 0;
  --p_units_after							float8 := 0;
  -- 20230520: p_scp_units_before - units of stock in stockcurrent_part before transaction / invoice
  -- 20230520: p_scp_units_after - units of stock in stockcurrent_part after transaction / invoice
  -- 20230520: p_sc_units_before - units of stock in stockcurrent before transaction / invoice
  -- 20230520: p_sc_units_after - units of stock in stockcurrent after transaction / invoice
  p_scp_units_before						float8 := 0;
  p_scp_units_after							float8 := 0;
  p_sc_units_before							float8 := 0;
  p_sc_units_after							float8 := 0;

BEGIN
--{"invoice" : "1", "user" : "2"}

-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
-- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

  SELECT (movinf)::json into p_move;

		p_invoice_in := cast(p_move->>'invoice' as bigint); 

		SELECT code, text INTO p_code, p_text
      FROM get_company(p_move->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		SELECT status, stockfrom, stockto, altnumber, invoicedate INTO p_status, p_pointfrom, p_pointto, p_altnumber, p_invoicedate
		  FROM invoices
			  WHERE invoicenumber = p_invoice_in
					FOR UPDATE;
					
		IF p_status = 'ACCEPTED' THEN
		  result := json_build_object('code','error','text','Данная накладная(инвойс) уже обработана!');
      return next;
		  return;
		ELSIF p_status = 'IN_PROCESS' THEN
			result := json_build_object('code','error','text','Данная накладная(инвойс) уже обрабатывается!');
      return next;
		  return;
		ELSIF p_status = 'CANCELED' THEN
			result := json_build_object('code','error','text','Данная накладная(инвойс) была отменена!');
      return next;
		  return;
		END IF;			

		-- Рассылка осуществляется по торговым точкам, а не по складам (исключение - перенос на центральный склад)
		SELECT p.id, p.point_type INTO p_trade_point_to, p_point_type
			FROM points p
				LEFT JOIN pointset s on (s.point = p.id)
					WHERE s.stock = p_pointto --or (p.id = p_pointto and p.point_type = 0)
						AND p.company = p_company;
		
		-- Определяем торговую точку, с которой осуществляется перемещение
    SELECT p.id INTO p_trade_point_from
		  FROM points p
		    LEFT JOIN pointset s on (s.point = p.id)
		      WHERE s.stock = p_pointfrom
						AND p.company = p_company;

	FOR r IN (
				SELECT s.id,s.product,l.units as un,l.newprice,i.stockfrom,s.attributes as attr,i.altnumber, l.pieceprice, l.wholesale_price 
				  FROM stockcurrent s
					  LEFT JOIN invoicelist l on (l.stock = s.id and l.company = s.company)
						  LEFT JOIN invoices i on (i.invoicenumber = l.invoice and i.company = l.company)
						    WHERE i.invoicenumber = p_invoice_in
									AND i.company = p_company
	  ) 
	LOOP

		p_part_exist := false;
		p_count := r.un;

  -- Проверка на нулевой остаток
    SELECT units - r.un INTO units_result_min
			FROM stockcurrent
				WHERE id = r.id
					AND company = p_company;
	  IF /*NOT p_minus AND*/ round(units_result_min::numeric,3) < 0 THEN
		  result := json_build_object('code','error','text','Остаток на складе не должен быть меньше 0!');
			return next;
			return;
    END IF;

  -- Уменьшаем количество на складе c которого делаем перемещение (до подтверждения или отмены)
		-- 20210522 assign p_sc_units_before
   	SELECT units INTO p_sc_units_before
			FROM stockcurrent
				WHERE id = r.id
					AND company = p_company;
	UPDATE stockcurrent 
		SET units = units_result_min
		    WHERE id = r.id
					AND company = p_company
					-- 20210522 assign p_sc_units_after
					returning units into p_sc_units_after;

	-- Оставляем записи в журнале перемещений товара
	-- 20230522 enable all stockcurrent logging
    INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,sc_units_before,sc_units_after,comments)
		  VALUES(now(),
		 -----16.06.2023 
		 '-400'
		 -- '-4'
		 -----16.06.2023
		  ,r.stockfrom,r.product,r.un,r.newprice,r.attr,p_invoice_in,p_company,p_sc_units_before,p_sc_units_after,'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301');
			
	-- Пытаемся обнаружить подходящую запись
		SELECT id INTO p_stock_to
		  FROM stockcurrent
			  WHERE point = p_pointto	
				  AND product = r.product
					  AND attributes = r.attr
							AND company = p_company;
  -- Создаем предварительную запись с количеством 0
		IF p_stock_to IS NULL THEN
		  INSERT INTO stockcurrent(point,product,units,attributes,company)
			  VALUES(p_pointto,r.product,'0',r.attr,p_company)
				  RETURNING id INTO p_stock_to;
		END IF;

	-- Проверяем наличие цены на переносимой точке 31.01.2023
	  SELECT price, pieceprice, wholesale_price INTO p_price_to, p_pieceprice_to, p_wholesale_price_to -- 31.03.2023
	    FROM storeprices
				WHERE store = p_trade_point_to
				  AND stock = p_stock_to
						AND company = p_company;
					
	-- Проверяем цену на c переносимой точки
		SELECT price, pieceprice, wholesale_price INTO p_price_from, p_pieceprice_from, p_wholesale_price_from -- 31.03.2023
	    FROM storeprices
				WHERE store = coalesce(p_trade_point_from,p_pointfrom)
				  AND stock = r.id
						AND company = p_company;
		-- обновляем цену на новой точке
		update storeprices set 
			price = coalesce(r.newprice, p_price_from), 
			pieceprice = coalesce(r.pieceprice, p_pieceprice_from),
			wholesale_price = coalesce (r.wholesale_price,p_wholesale_price_from) -- 31.01.2023
		where stock = p_stock_to and company = p_company;
		IF not found then
			-- Предварительная запись по цене на точке
		  INSERT INTO storeprices(store,stock,price,company,pieceprice,wholesale_price)
			VALUES(p_trade_point_to,p_stock_to,coalesce(r.newprice,p_price_from),p_company,coalesce(r.pieceprice,p_pieceprice_from),
			coalesce(r.wholesale_price,p_wholesale_price_from));
			-- Фиксируем появившуюся цену
			func_res := utl_changeprice_log(
				comp=>p_company,
				stock=>p_stock_to,
				pr=>coalesce(r.newprice,p_price_from),
				pr_old=>null,
				pprice=>coalesce(r.pieceprice,p_pieceprice_from),
				pprice_old=>null,
				inv=>p_invoice_in,
				pwholesale_price=>coalesce(r.wholesale_price,p_wholesale_price_from),
				pwholesale_price_old=>null
				);
		end IF;
			
	-- Расчет для партиционного учета (перемещение с точки)
		FOR g IN (
					SELECT date, units, purchaseprice
						FROM stockcurrent_part
							WHERE company = p_company
								AND point = r.stockfrom
									AND product = r.product
										AND attributes = r.attr
											AND units > 0
												ORDER BY date, purchaseprice
		 )
		LOOP
			p_part_exist := true;
			p_purchase_price := g.purchaseprice;
			p_purchase_date	 := g.date;
		-- 20230520 assign p_scp_units_before
		    p_scp_units_before   := coalesce (g.units,0);
					IF p_count = 0 THEN				
						EXIT;					
					ELSIF g.units > p_count THEN		
						UPDATE stockcurrent_part
							SET units = units - p_count
								WHERE product = r.product
									AND attributes =  r.attr
									AND point = r.stockfrom
									AND company = p_company
									AND date = g.date
									AND purchaseprice = g.purchaseprice
									AND units > 0
									-- 20230520 assign p_units_after
								        RETURNING units INTO p_scp_units_after;
						-- Оставляем записи в журнале перемещений товара
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
							VALUES(now(),'-4',r.stockfrom,r.product,p_count,coalesce(r.newprice,case when p_price_to = 0 then null else p_price_to end,p_price_from),r.attr,p_invoice_in,
												p_company,g.purchaseprice,g.date,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_movement, line 228');
						p_count := 0;
					ELSIF (p_count > g.units) OR (p_count = g.units) THEN
						p_count := p_count - g.units;							
						UPDATE stockcurrent_part
							SET units = 0
								WHERE product = r.product
									AND attributes =  r.attr
									AND point = r.stockfrom
									AND company = p_company
									AND date = g.date
									AND purchaseprice = g.purchaseprice
									AND units > 0
								        -- 20230520 calculate p_units_after
								        RETURNING units INTO p_scp_units_after;
						-- Оставляем записи в журнале перемещений товара
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
							VALUES(now(),'-4',r.stockfrom,r.product,g.units,coalesce(r.newprice,case when p_price_to = 0 then null else p_price_to end,p_price_from),r.attr,p_invoice_in,
												p_company,g.purchaseprice,g.date,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_movement, line 246');
					END IF;			
		END LOOP;
		
		-- Для учета минусового значения в партиционном учете
		IF NOT p_part_exist OR p_count > 0 THEN
			-- 20230520 assign p_units_before
			SELECT units INTO p_scp_units_before
					FROM stockcurrent_part
					WHERE product = r.product
						AND attributes =  r.attr
						AND point = r.stockfrom
						AND company = p_company
						AND date = p_purchase_date
						AND purchaseprice = p_purchase_price;
			UPDATE stockcurrent_part
				SET units = units - p_count
					WHERE product = r.product
						AND attributes =  r.attr
						AND point = r.stockfrom
						AND company = p_company
						AND date = p_purchase_date
						AND purchaseprice = p_purchase_price
							-- 20230520 calculate p_units_after
							RETURNING units INTO p_scp_units_after;
			IF NOT FOUND THEN							
				SELECT logging(jsonb_build_object('invoice',p_invoice_in,'company',p_company,'point',r.stockfrom,'product',r.product,'attributes',r.attr,
																									'units',r.un,'diff',p_count,'user',cast(p_move->>'user' as bigint)), 
												 jsonb_build_object('goods_movement',jsonb_build_object('code','error','text','Недостаточно данных для расчета партиционирования!')),'goods_movement','')
														INTO p_logging_json;
			ELSE
				-- Оставляем запись в журнале перемещений товара
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
					VALUES(now(),'-4',r.stockfrom,r.product,p_count,coalesce(r.newprice,case when p_price_to = 0 then null else p_price_to end,p_price_from),r.attr,p_invoice_in,p_company,
										p_purchase_price,p_purchase_date,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_movement, line 280');
			END IF;			
		END IF;	
	
		 -- Записываем stockcurrent id в инвойс(накладную)
		UPDATE invoicelist
		  SET stockto = p_stock_to, newprice = coalesce(r.newprice,case when p_price_to = 0 then null else p_price_to end,p_price_from), purchaseprice = p_purchase_price
			  WHERE invoice = p_invoice_in
				  AND stock = r.id
					  AND attributes = r.attr
							AND company = p_company;

	END LOOP;
	
	-- Для отработки со стороны терминала(если между складами разных торговых точек)
	FOR r IN (
		SELECT id, point
			FROM cashboxes
				WHERE point in (p_trade_point_to,p_trade_point_from)
					AND deleted = false
						AND isengaged = true
	)
	LOOP
		p_cashbox_exist := true;
		INSERT INTO systemmessage(point,invoice,type_message,altinvoice,cashbox,"date")
			VALUES(r.point,p_invoice_in,1,p_altnumber,r.id,p_invoicedate);
	END LOOP;
	
	-- Проверка наличия привязанных касс к точке, если касс нет - автоматическое подтверждение и добавление
	IF NOT p_cashbox_exist THEN
		SELECT invoice_processing(json_build_object('invoice',p_invoice_in,'action','ACCEPTED','user',cast(p_move->>'user' as bigint),'system','ERP',
																										'point',p_trade_point_to,'cashbox','0')) INTO p_result;
		IF p_result->>'code' LIKE '%error%' THEN
			p_code := p_result->>'code';
			p_text := p_result->>'text';
			p_func := 'invoice_processing';
			RAISE SQLSTATE 'S0001';
		END IF;
	ELSE 
		-- Обновление статуса инвойса(накладной)
		UPDATE invoices
			SET status = 'IN_PROCESS'
				WHERE invoicenumber = p_invoice_in
					AND company = p_company;
	END IF;

	result := json_build_object('code','success','text','');
	return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
     return next;
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
     return next;
END;
$$;


ALTER FUNCTION public.goods_movement(movinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 668 (class 1255 OID 16487)
-- Name: goods_sellprice_change(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.goods_sellprice_change(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
	p_error		      	 varchar;
	p_info          	 json;
  p_stocks		    	 json;
  p_code		      	 varchar;
  p_text		      	 varchar;
  p_company       	 bigint;
  p_invoicenumber 	 bigint;
  p_created_invoices json;
  p_stock_in				 bigint;
  p_newprice_in			 float8;
	p_pieceprice_in		 float8;
  p_staticprice			 float8;
  p_price			 			 float8;
  p_curr_price			 float8;
	p_curr_price_piece float8;
	p_charge_point		 bigint;
  p_store_id				 bigint;
  p_attributes			 bigint;
  r                  record;
	func_res					 record;
  p_func		 			   varchar;
  p_result				   json;
	p_check 					 varchar;
	p_is_static_price  boolean := false;
  p_product       	 bigint;
	p_changes					 json;
	p_old_wprice_in		 float8; -- оптовая цена
  p_new_wprice_in		 float8;
BEGIN

	-- OLD {"user" : 1, "newprice" : "760", "product" : "12", "point" : "5"}
  -- OLD 2 {"user" : "1", "changes" : [{"stockid" : "1", "pointid":"1", "newprice" : "500", "pieceprice" : "150"}]}
  -- {"user" : "1", "product" : "18577", "changes" : [{"stockid" : "1", "pointid":"1", "newprice" : "500"}]}
  -- staticprice {"user" : "1", "isstaticprice" : true, "product" : "18577", "price":"500"}
  -- ID склада (торговой точки - было)

  SELECT (inf)::json into p_info;

	  SELECT code, text INTO p_code, p_text
      FROM get_company(p_info->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		p_is_static_price = cast(p_info->>'isstaticprice' as boolean);
		p_product := cast(p_info->>'product' as bigint);
		p_price := cast("replace"(p_info->>'price',',','.') as float8);

		IF p_product is null THEN
		  result := json_build_object('code','error','text','Не указан товар!');
      return next;
		  return;
		END IF;
		
		--если это установка предельной цены достаем масив вс ех записей в стоке и сохраняем данные в таблицу предельных цен
		IF p_is_static_price THEN			
			IF p_price is null THEN
				result := json_build_object('code','error','text','Не указана предельная цена товар!');
				return next;
				return;
			END IF;
			
			select json_agg(json_build_object('stockid',s.id,'pointid',p.point,'newprice',p_price)) into p_changes
				from stockcurrent s
					inner join pointset p on s.point = p.stock
					where s.company = p_company and s.product = p_product
				group by s.product;

			INSERT INTO product_static_prices(company,product,price)
					VALUES(p_company,p_product,p_price)
				ON CONFLICT (company,product)
				DO UPDATE
					SET price = p_price
						WHERE product_static_prices.product = p_product
							AND product_static_prices.company = p_company;

			update products set isstaticprice = true where id = p_product and company = p_company;

		--при обычном изменении цен ищем есть ли товар в списке с предельными ценами
		ELSE
			select s.price into p_staticprice
				from product_static_prices s
				inner join products p on p.id = s.product and p.isstaticprice = true 
					where s.company = p_company and s.product = p_product;
			p_changes = cast(p_info->>'changes' as json);
		END IF;

    FOR p_stocks IN SELECT * FROM json_array_elements(p_changes)--json_array_elements((p_info)->'changes')
    LOOP

      p_stock_in    	:= cast(p_stocks->>'stockid' as bigint); 
			p_newprice_in 	:= cast(p_stocks->>'newprice' as double precision);
      p_store_id			:= cast(p_stocks->>'pointid' as bigint);
			p_pieceprice_in := cast(coalesce(nullif(p_stocks->>'pieceprice',''),'0') as double precision);
			
			p_new_wprice_in := coalesce(cast(p_stocks->>'new_wprice' as double precision),0); --wholesale оптовая цена
			p_old_wprice_in := coalesce(cast(p_stocks->>'old_wprice' as double precision),0);
			
			SELECT price, pieceprice INTO p_curr_price, p_curr_price_piece
			  FROM storeprices
				  WHERE store = p_store_id
					  AND stock = p_stock_in
							AND company = p_company;				
				
			--при установке предельной цены проверяем если текущая цена товара меньше установленной то переходим к следующей итерации
			if p_is_static_price THEN
				/*select price into p_curr_price
			  from storeprices
				  WHERE store = p_store_id
					  AND stock = p_stock_in
							AND company = p_company;*/
				if p_curr_price <= p_newprice_in then
					continue;
				end if;
			--если это обычное изменение цены но у товара есть предельная цена и она меньше той которую пытаются установить выдаем ошибку
			ELSEIF not p_is_static_price and p_staticprice is not null and p_newprice_in > p_staticprice THEN
				RAISE SQLSTATE 'S0002';
			end if;

			-- Меняем сумму продажи на точке
			UPDATE storeprices
			  SET price = p_newprice_in, pieceprice = p_pieceprice_in, wholesale_price = p_new_wprice_in
				  WHERE store = p_store_id
					  AND stock = p_stock_in
							AND company = p_company;

      IF p_created_invoices->>cast(p_stocks->>'pointid' as text) IS NULL THEN 
			  INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
	        VALUES(now(),cast(p_info->>'user' as bigint),'IN_PROCESS',p_company,p_store_id,p_store_id,'0')
		        RETURNING invoicenumber INTO p_invoicenumber;

				-- Для отработки со стороны терминала
        FOR r IN (
						 /*SELECT id
							  FROM cashboxes
								  WHERE point = p_store_id
									  AND deleted = false
										  AND isengaged = true
							SELECT p.name, c.id
							  FROM points p
								  LEFT JOIN cashboxes c on (c.point = p.id)
									  WHERE c.point = p_store_id
										  AND c.deleted = false
											  AND c.isengaged = true*/
							SELECT p.name, c.id
							  FROM points p
								  LEFT JOIN cashboxes c on (c.point = p.id and c.deleted = false and c.isengaged = true)
                    where p.id = p_store_id
											and p.company = p_company
					)
				LOOP
				
          IF r.id IS NOT NULL THEN
				    INSERT INTO systemmessage(point,invoice,type_message,cashbox)
				      VALUES(p_store_id,p_invoicenumber,0,r.id);
					ELSE
						SELECT invoice_processing(json_build_object('invoice',p_invoicenumber,'action','ACCEPTED','user',cast(p_info->>'user' as bigint),'system','ERP',
																	'point',p_store_id,'cashbox','0')) INTO p_result;
						IF p_result->>'code' LIKE '%error%' THEN
						  p_code := p_result->>'code';
						  p_text := p_result->>'text';
						  p_func := 'invoice_processing';
						  RAISE SQLSTATE 'S0001';
						END IF;
					END IF;
				END LOOP;

        IF p_created_invoices IS NULL THEN
					p_created_invoices := json_build_object(p_store_id,p_invoicenumber);
				ELSE
				  p_created_invoices := p_created_invoices::jsonb||json_build_object(p_store_id,p_invoicenumber)::jsonb;
				END IF;
      ELSE
        p_invoicenumber := cast(p_created_invoices->>cast(p_stocks->>'pointid' as text) as bigint);
			END IF;

			SELECT attributes INTO p_attributes
			  FROM stockcurrent
				  WHERE id = p_stock_in
						AND company = p_company;

      INSERT INTO invoicelist(invoice,stock,units,newprice,attributes,newprod,company,pieceprice,wholesale_price)
			  VALUES(p_invoicenumber,p_stock_in,'0',p_newprice_in,p_attributes,false,p_company,p_pieceprice_in,p_new_wprice_in);
				
			-- Фиксируем изменение цены
			IF p_curr_price <> p_newprice_in OR p_curr_price_piece <> p_pieceprice_in THEN
				func_res := utl_changeprice_log(comp=>p_company,stock=>p_stock_in,pr=>p_newprice_in,pr_old=>p_curr_price,pprice=>p_pieceprice_in,pprice_old=>p_curr_price_piece,inv=>p_invoicenumber);
			END IF;	
				
    END LOOP;  

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
     return next;
	 WHEN SQLSTATE 'S0002' THEN 
		 result := json_build_object('code','error','text','Цена на товар превышает');
		 return next;
   WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 IF p_check = 'invoicelist_pkey' THEN
			 result := json_build_object('code','error','text','Несколько записей по одному товару в списке накладной(инвойса)!');
		 ELSE
	     result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 END IF;

	   return next;

END;





$$;


ALTER FUNCTION public.goods_sellprice_change(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 669 (class 1255 OID 16489)
-- Name: goods_staticprice_change(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.goods_staticprice_change(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
	p_error		      	 varchar;
	p_info          	 json;
  p_products	    	 json;
  p_stocks	    	 	 json;
  p_code		      	 varchar;
  p_text		      	 varchar;
  p_company       	 bigint;
  p_invoicenumber 	 bigint;
  p_created_invoices json;
  p_stock_in				 bigint;
  p_newprice_in			 float8;
  p_staticprice			 float8;
  p_price			 			 float8;
  p_curr_price			 float8;
	p_charge_point		 bigint;
  p_store_id				 bigint;
  p_attributes			 bigint;
  r                  record;
  p_func		 			   varchar;
  p_result				   json;
	p_check 					 varchar;
	p_is_static_price  boolean := false;
  p_product       	 bigint;
	p_changes					 json;
BEGIN

  -- {"user" : "1", "changes" : [{"product" : "18577", "price" : "500"}]}

  SELECT (inf)::json into p_info;

	  SELECT code, text INTO p_code, p_text
      FROM get_company(p_info->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;
		
    FOR p_products IN SELECT * FROM json_array_elements((p_info)->'changes')
    LOOP

			p_product := cast(p_products->>'product' as bigint);
			p_price := cast(p_products->>'price' as bigint);

			IF p_price is null THEN
				RAISE SQLSTATE 'S0002';
			END IF;

			IF p_product is null THEN
				RAISE SQLSTATE 'S0003';
			END IF;

			select json_agg(json_build_object('stockid',s.id,'pointid',p.point,'newprice',p_price)) into p_changes
				from stockcurrent s
					inner join pointset p on s.point = p.stock
					where s.company = p_company and s.product = p_product
				group by s.product;

			INSERT INTO product_static_prices(company,product,price)
					VALUES(p_company,p_product,p_price)
				ON CONFLICT (company,product)
				DO UPDATE
					SET price = p_price
						WHERE product_static_prices.product = p_product
							AND product_static_prices.company = p_company;

			update products set isstaticprice = true where id = p_product and company = p_company;

			FOR p_stocks IN SELECT * FROM json_array_elements(p_changes)
			LOOP

				p_stock_in    := cast(p_stocks->>'stockid' as bigint); 
				p_newprice_in := cast(p_stocks->>'newprice' as double precision);
				p_store_id		:= cast(p_stocks->>'pointid' as bigint);

					
				select price into p_curr_price
				from storeprices
					WHERE store = p_store_id
						AND stock = p_stock_in
							AND company = p_company;
				if p_curr_price <= p_newprice_in then
					continue;
				end if;

				-- Меняем сумму продажи на точке
				UPDATE storeprices
					SET price = p_newprice_in
						WHERE store = p_store_id
							AND stock = p_stock_in
								AND company = p_company;

				IF p_created_invoices->>cast(p_stocks->>'pointid' as text) IS NULL THEN 
					INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
						VALUES(now(),cast(p_info->>'user' as bigint),'IN_PROCESS',p_company,p_store_id,p_store_id,'0')
							RETURNING invoicenumber INTO p_invoicenumber;

					-- Для отработки со стороны терминала
					FOR r IN (
								SELECT p.name, c.id
									FROM points p
										LEFT JOIN cashboxes c on (c.point = p.id and c.deleted = false and c.isengaged = true)
											where p.id = p_store_id
												and p.company = p_company
						)
					LOOP
					
						IF r.id IS NOT NULL THEN
							INSERT INTO systemmessage(point,invoice,type_message,cashbox)
								VALUES(p_store_id,p_invoicenumber,0,r.id);
						ELSE
							SELECT invoice_processing(json_build_object('invoice',p_invoicenumber,'action','ACCEPTED','user',cast(p_info->>'user' as bigint),'system','ERP',
																		'point',p_store_id,'cashbox','0')) INTO p_result;
							IF p_result->>'code' LIKE '%error%' THEN
								p_code := p_result->>'code';
								p_text := p_result->>'text';
								p_func := 'invoice_processing';
								RAISE SQLSTATE 'S0001';
							END IF;
						END IF;
					END LOOP;

					IF p_created_invoices IS NULL THEN
						p_created_invoices := json_build_object(p_store_id,p_invoicenumber);
					ELSE
						p_created_invoices := p_created_invoices::jsonb||json_build_object(p_store_id,p_invoicenumber)::jsonb;
					END IF;
				ELSE
					p_invoicenumber := cast(p_created_invoices->>cast(p_stocks->>'pointid' as text) as bigint);
				END IF;

				SELECT attributes INTO p_attributes
					FROM stockcurrent
						WHERE id = p_stock_in
							AND company = p_company;

				INSERT INTO invoicelist(invoice,stock,units,newprice,attributes,newprod,company)
					VALUES(p_invoicenumber,p_stock_in,'0',p_newprice_in,p_attributes,false,p_company);

			END LOOP;  
		
    END LOOP;  

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
     return next;
	 WHEN SQLSTATE 'S0002' THEN 
		 result := json_build_object('code','error','text','Не указана предельная цена товар!');
		 return next;
	 WHEN SQLSTATE 'S0003' THEN 
		 result := json_build_object('code','error','text','Не указан товар!');
		 return next;
   WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 IF p_check = 'invoicelist_pkey' THEN
			 result := json_build_object('code','error','text','Несколько записей по одному товару в списке накладной(инвойса)!');
		 ELSE
	     result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 END IF;

	   return next;

END;





$$;


ALTER FUNCTION public.goods_staticprice_change(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 670 (class 1255 OID 16491)
-- Name: goods_writeoff(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.goods_writeoff(addinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	p_move 				   json;
	p_company				 bigint;
	p_code					 varchar;
	p_text					 varchar;
	p_error					 varchar;
  p_stockto				 bigint;
	r                record;
	g								 record;
  p_invoice_in		 bigint;
	p_invoicedate		 date;
  p_stockcurrent	 bigint;
  p_units					 float8;
  p_store_to			 bigint;
  p_cashbox_exist  boolean := false;
  p_result				 json;
  p_func		 			 varchar;
	p_name_prod			 varchar;
	p_count					 float8 := 0;
-- 20230731 fixing logging of stockcurrent changes in stockdiary
	p_count_4_sc				 float8 := 0;
-- 20230731 fixing logging of stockcurrent changes in stockdiary
	p_part_exist		 boolean := false;
	p_logging_json	 json;
	p_purchase_price float8 := 0;
	p_purchase_date	 date;
	p_status				 varchar;
  -- 20230520: p_scp_units_before - units of stock in stockcurrent_part before transaction / invoice
  -- 20230520: p_scp_units_after - units of stock in stockcurrent_part after transaction / invoice
  -- 20230520: p_sc_units_before - units of stock in stockcurrent before transaction / invoice
  -- 20230520: p_sc_units_after - units of stock in stockcurrent after transaction / invoice
  p_scp_units_before						float8 := 0;
  p_scp_units_after							float8 := 0;
  p_sc_units_before							float8 := 0;
  p_sc_units_after							float8 := 0;
BEGIN
--{"invoice" : "1", "user" : "2"}

-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
-- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

  SELECT (addinf)::json into p_move;

		p_invoice_in := cast(p_move->>'invoice' as bigint); 

		SELECT code, text INTO p_code, p_text
      FROM get_company(p_move->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;
		
		-- Определяем id склада
		SELECT i.stockto, i.status, i.invoicedate INTO p_stockto, p_status, p_invoicedate
		  FROM invoices i
			  WHERE i.invoicenumber = p_invoice_in
					AND i.company = p_company
						FOR UPDATE;
						
		IF p_status = 'ACCEPTED' THEN
		  result := json_build_object('code','error','text','Данная накладная(инвойс) уже обработана!');
      return next;
		  return;
		ELSIF p_status = 'IN_PROCESS' THEN
			result := json_build_object('code','error','text','Данная накладная(инвойс) уже обрабатывается!');
      return next;
		  return;
		ELSIF p_status = 'CANCELED' THEN
			result := json_build_object('code','error','text','Данная накладная(инвойс) была отменена!');
      return next;
		  return;
		END IF;				

	FOR r IN (
				/*SELECT p.id,l.units,l.newprice,l.attributes as attr, l.stock, p.name
				  FROM invoicelist l 
						  LEFT JOIN stockcurrent s on (s.id = l.stock and s.company = l.company)
							  LEFT JOIN products p on (p.id = s.product and p.company = s.company)
							    WHERE l.invoice = p_invoice_in
										AND l.company = p_company*/
				SELECT p.id,l.units,coalesce(l.newprice,pr.price) as newprice,l.attributes as attr, l.stock, p.name
				  FROM invoicelist l 
						  LEFT JOIN stockcurrent s on (s.id = l.stock and s.company = l.company)
							  LEFT JOIN products p on (p.id = s.product and p.company = s.company)
									LEFT JOIN storeprices pr on (pr.company = s.company and pr.stock = s.id)
										WHERE l.invoice = p_invoice_in
											AND l.company = p_company
	  ) 
	LOOP
		p_count			 := r.units;
		p_name_prod  := r.name;
		p_part_exist := false;
		
    -- Перезаписываем id склада на id точки
	  SELECT p.id INTO p_store_to
	    FROM points p
		    LEFT JOIN pointset s on (s.point = p.id)
		      WHERE s.stock = p_stockto
						AND p.company = p_company;
	
		-- Расчет для партиционного учета (перемещение с точки)
		FOR g IN (
					SELECT date, units, purchaseprice
						FROM stockcurrent_part
							WHERE company = p_company
								AND point = p_stockto
									AND product = r.id
										AND attributes = r.attr
											AND units > 0
												ORDER BY date, purchaseprice
		 )
		LOOP
				p_part_exist := true;
				p_purchase_price := g.purchaseprice;
				p_purchase_date	 := g.date;
				-- 20230520 assign p_scp_units_before
				p_scp_units_before := coalesce(g.units,0);
					IF p_count = 0 THEN				
						EXIT;					
					ELSIF g.units > p_count THEN		
						UPDATE stockcurrent_part
							SET units = units - p_count
								WHERE product = r.id
									AND attributes =  r.attr
									AND point = p_stockto
									AND company = p_company
									AND date = g.date
									AND purchaseprice = g.purchaseprice
									AND units > 0
										-- 20230520 assign p_units_after
										RETURNING units INTO p_scp_units_after;
						-- Оставляем записи в журнале перемещений товара
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,
								invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
							VALUES(now(),'-3',p_stockto,r.id,p_count,r.newprice,r.attr,
								p_invoice_in,p_company,g.purchaseprice,g.date,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_writeoff, line 143');
						-- 20230731 fixing logging of stockcurrent changes in stockdiary
								p_count_4_sc := p_count;
						-- 20230731 fixing logging of stockcurrent changes in stockdiary
							p_count := 0;
					ELSIF (p_count > g.units) OR (p_count = g.units) THEN
						p_count := p_count - g.units;							
						UPDATE stockcurrent_part
							SET units = 0
								WHERE product = r.id
									AND attributes =  r.attr
									AND point = p_stockto
									AND company = p_company
									AND date = g.date
									AND purchaseprice = g.purchaseprice
									AND units > 0
										-- 20230520 assign p_units_after
										RETURNING units INTO p_scp_units_after;	
						-- Оставляем записи в журнале перемещений товара
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
							VALUES(now(),'-3',p_stockto,r.id,g.units,r.newprice,r.attr,p_invoice_in,p_company,g.purchaseprice,g.date,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_writeoff, line 163');
					END IF;			
		END LOOP;
			
		-- Для учета минусового значения в партиционном учете
		IF NOT p_part_exist OR p_count > 0 THEN
			-- 20230520 assign p_scp_units_before
			SELECT units into p_scp_units_before
				FROM stockcurrent_part
					WHERE product = r.id
						AND attributes =  r.attr
						AND point = p_stockto
						AND company = p_company
						AND date = p_purchase_date
						AND purchaseprice = p_purchase_price;
			UPDATE stockcurrent_part
				SET units = units - p_count
					WHERE product = r.id
						AND attributes =  r.attr
						AND point = p_stockto
						AND company = p_company
						AND date = p_purchase_date
						AND purchaseprice = p_purchase_price
						-- 20230520 assign p_units_after
							RETURNING units INTO p_scp_units_after;
			IF NOT FOUND THEN							
				SELECT logging(jsonb_build_object('invoice',p_invoice_in,'company',p_company,'point',p_stockto,'product',r.id,'attributes',r.attr,
																									'units',r.units,'diff',p_count,'user',cast(p_move->>'user' as bigint)), 
												 jsonb_build_object('goods_writeoff',jsonb_build_object('code','error','text','Недостаточно данных для расчета партиционирования!')),'goods_writeoff','')
														INTO p_logging_json;
				-- Оставляем запись в журнале перемещений товара
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
					VALUES(now(),'-3',p_stockto,r.id,p_count,r.newprice,r.attr,p_invoice_in,p_company,p_purchase_price,p_purchase_date,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_writeoff, line 195');										
					-- 20230818 further fixing logging of stockcurrent changes in stockdiary
								p_count_4_sc := p_count;
					-- 20230818 further fixing logging of stockcurrent changes in stockdiary
			ELSE
				-- Оставляем запись в журнале перемещений товара
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
					VALUES(now(),'-3',p_stockto,r.id,p_count,r.newprice,r.attr,p_invoice_in,p_company,p_purchase_price,p_purchase_date,p_scp_units_before,p_scp_units_after,'stockcurrent_part updated by goods_writeoff, line 202');
			END IF;			
		END IF;	
	
		-- Убираем со склада списанный товар
		-- 20230522 assign p_sc_units_before
		SELECT units into p_sc_units_before
			FROM stockcurrent 
				where id = r.stock
					AND company = p_company;
		UPDATE stockcurrent
		  SET units = units - r.units
			  WHERE id = r.stock
					AND company = p_company
						RETURNING id, units INTO p_stockcurrent, p_units;
		-- 20230522 assign p_sc_units_after
		p_sc_units_after := p_units;
		-- 20230522 insert into stockdiary new stockcurrent update record
		INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,sc_units_before,sc_units_after,comments)
					VALUES(now(),'-300',p_stockto,r.id,
					-- 20230731 fixing logging of stockcurrent changes in stockdiary
					p_count_4_sc,
					-- 20230731 fixing logging of stockcurrent changes in stockdiary
					r.newprice,r.attr,p_invoice_in,p_company,p_purchase_price,p_purchase_date,p_sc_units_before,p_sc_units_after,'stockcurrent updated by goods_writeoff, line 225');
		-- 20230731 fixing logging of stockcurrent changes in stockdiary
				p_count_4_sc := 0;
		-- 20230731 fixing logging of stockcurrent changes in stockdiary
		IF p_stockcurrent IS NULL THEN
		  RAISE SQLSTATE 'S0002';
		ELSIF round(p_units::numeric,3) < 0 THEN
		  RAISE SQLSTATE 'S0003';
		END IF;

	END LOOP;	
	
	-- Рассылка по кассам
	FOR r IN (
				SELECT id
				  FROM cashboxes
					  WHERE point = p_store_to
						  AND deleted = false
							  AND isengaged = true
	)
	LOOP
	  p_cashbox_exist := true;
	  INSERT INTO systemmessage(point,invoice,type_message,cashbox,"date")
      VALUES(p_store_to,p_invoice_in,1,r.id,p_invoicedate); -- 7 для ERP
	END LOOP;
	-- Проверка наличия привязанных касс к точке, если касс нет - автоматическое подтверждение и добавление
	IF NOT p_cashbox_exist THEN
    SELECT invoice_processing(json_build_object('invoice',p_invoice_in,'action','ACCEPTED','user',cast(p_move->>'user' as bigint),'system','ERP',
															'point',p_store_to,'cashbox','0')) INTO p_result;
	  IF p_result->>'code' LIKE '%error%' THEN
		  p_code := p_result->>'code';
			p_text := p_result->>'text';
      p_func := 'invoice_processing';
      RAISE SQLSTATE 'S0001';
		END IF;
	ELSE
	  UPDATE invoices
			  SET status = 'IN_PROCESS'
				  WHERE invoicenumber = p_invoice_in
						AND company = p_company;
  END IF;
	
	result := json_build_object('code','success','text','');
	return next;

EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN 
		 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
     return next;
	WHEN SQLSTATE 'S0002' THEN 
		 result := json_build_object('code','error','text','Запись склада не определена!','func',p_func);
     return next;
	WHEN SQLSTATE 'S0003' THEN 
		 result := json_build_object('code','error','text','Остаток на складе не должен быть меньше 0!('||p_name_prod||')','func',p_func);
     return next;
  WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
     return next;
END;

$$;


ALTER FUNCTION public.goods_writeoff(addinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 671 (class 1255 OID 16493)
-- Name: import_nomenclature_xls(json, bigint, bigint, bigint, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.import_nomenclature_xls(inf json, company bigint, stock bigint, taxid bigint, counterparty bigint, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 js_row 	 	   		json;
 js_req						json;
 js_res           json;
 js_success       json;
 js_error         json;
 
 p_error							varchar;
 p_check							varchar;
 
 ret_val		VARCHAR;

BEGIN
	-- [{"Category":"GECO", "Code": "1234567890124", "Name": "Тестовый товар 2", "Brand": "RECORD", "PriceBuy":500, "PriceSell":650, "Units":10}]
	-- cpartyid контрагент (0 - не указан)

	FOR js_row IN SELECT * FROM json_array_elements(inf)
	LOOP
		select jsonb_build_object('company',company,'stock',stock,'taxid',taxid,'cpartyid',counterparty,'data',js_row) into js_req;
		
		select * from nomenclature_add(js_req) into js_res;
		
		if (trim(js_res->>'code') = 'success') then
				js_success := json_build_object('text',
					case when (js_success->>'text') is not null 
							then (js_success->>'text')||','||(js_res->>'barcode') 
							else (js_res->>'barcode')
					end);
		else
				js_error := json_build_object('text',
					case when (js_error->>'text') is not null 
							then (js_error->>'text')||','||(js_res->>'barcode')
							else (js_res->>'barcode')
					end);
		end if;		
	END LOOP;
		
		result := json_build_object('code','success','success',js_success,'errors',js_error);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;$$;


ALTER FUNCTION public.import_nomenclature_xls(inf json, company bigint, stock bigint, taxid bigint, counterparty bigint, OUT result json) OWNER TO postgres;

--
-- TOC entry 672 (class 1255 OID 16494)
-- Name: inserttoken(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.inserttoken(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

	p_error 	 varchar;

	p_token		 json;

  p_check		 varchar;

	p_pass		 varchar;

	p_cashbox	 bigint;

BEGIN



	-- {"cashbox" : "12", "token" : "wwwww"}



  SELECT (inf)::json into p_token;



	p_cashbox := cast(p_token->>'cashbox' as bigint);



	IF p_cashbox IS NULL THEN

	  result := json_build_object('code','error','text','Касса не указана!');

		return next;

		return;

	ELSIF p_token->>'token' IS NULL THEN

		result := json_build_object('code','error','text','Токен не указан!');

		return next;

		return;

	END IF;



  DELETE FROM cashboxtoken

	  WHERE cashbox = p_cashbox;

  

  INSERT INTO cashboxtoken(cashbox,token)

	  VALUES (p_cashbox,p_token->>'token')

		  RETURNING token INTO p_pass;



  result := json_build_object('code','success','text',p_pass);

  return next;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT,p_check = CONSTRAINT_NAME;

	 IF p_check = 'pointtoken_fk_point' THEN

	   result := json_build_object('code','error','text','Передаваемой кассы не существует!');

	 ELSIF p_check = 'pointtoken_pkey' THEN

		 result := json_build_object('code','error','text','Запись по данной кассе уже существует!');

	 ELSE

	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

	 END IF;

   return next;

END;$$;


ALTER FUNCTION public.inserttoken(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 673 (class 1255 OID 16495)
-- Name: invoice_add_xls(bigint, bigint, json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_add_xls(invoice bigint, user_id bigint, inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

	js_row      		json;
	js_body					json;
	js_req      		json;
	js_res      		json;
	js_success      json;
  js_error        json;
	js_test 				json;

	p_error					varchar;
	p_check					varchar;
	p_code				  varchar;
	p_text				  varchar;
	
	company_id			BIGINT;
	category_id			BIGINT;
	product_id 			BIGINT;
	brand_id 				BIGINT;
	tax_id 					BIGINT;
	purchaseprice 	DOUBLE PRECISION;
	newprice 				DOUBLE PRECISION;
	surcharge 			DOUBLE PRECISION;
	
BEGIN

	/*
		Units: 15
		Brand: "Бренд"
		Category: "Категория"
		Code: "2000000000942"
		Name: "fhfgh"
		PriceSell: 600
		PriceBuy: 500
		Tax: 0
	*/

	FOR js_row IN SELECT * FROM json_array_elements(inf)
	LOOP		
		
		select cast(company as bigint) into company_id from erp_users where id = cast(user_id as int8);
		
		if company_id is null then
			result := json_build_object('code','internal error','text','Компания пользователя не определена');
      return next;
		  return;
		end if;
		
		purchaseprice := cast(trim(js_row->>'PriceBuy') as double precision);
		newprice := cast(trim(js_row->>'PriceSell') as double precision);
		
		if purchaseprice is null or newprice is null then
			result := json_build_object('code','internal error','text','Не заполнены обязательные параметры');
      return next;
		  return;
		end if;
		
		surcharge := ((newprice-purchaseprice)*100)/purchaseprice;
		
		select c."id" into category_id from categories c where c."name" = trim(js_row->>'Category');		
		
		if category_id is null then
			if trim(js_row->>'Category') is null then
				category_id := 0;
			else
				INSERT INTO categories(name,deleted,company)
				VALUES (trim(js_row->>'Category'),false,company_id)
					RETURNING id INTO category_id;
			end if;
		end if;
		
		select p."id" into product_id from products p where p.code = trim(js_row->>'Code');
		
		if product_id is null then
			if trim(js_row->>'Code') is null or trim(js_row->>'Name') is null then
				result := json_build_object('code','internal error','text','Не заполнены обязательные параметры');
				return next;
				return;
			end if;
		end if;
				
		select b."id" into brand_id from brands b where b.brand = trim(js_row->>'Brand');
		
		if brand_id is null then
			if trim(js_row->>'Brand') is null then
				brand_id := 0;
			else
				INSERT INTO brands(brand,manufacturer)
				VALUES (trim(js_row->>'Brand'), trim(js_row->>'Brand'))
					RETURNING id INTO brand_id;
			end if;
		end if;
		
		tax_id := case when trim(js_row->>'Tax') is not null then 1 else 0 end;
		
		js_body := jsonb_build_object(
			'category',category_id,
			'id',product_id,
			'code', trim(js_row->>'Code'),
			'name', trim(js_row->>'Name'),
			'amount', cast(trim(js_row->>'Amount') as double precision),
			'taxid', tax_id,
			'brand', brand_id,
			'purchaseprice',purchaseprice,
			'newprice',newprice,
			'surcharge',surcharge,
			'attributes',null,
			'sku',null,
			'updateprice',true
		);
				
		select jsonb_build_object(
			'user',user_id,
			'invoice',invoice,
			'type',1,
			'stockcurrentfrom',jsonb_build_array(js_body)) into js_req;
				
		--RAISE NOTICE 'req %', js_req;
		
		SELECT * INTO js_res
      FROM invoice_addprod(js_req);
		
		IF (js_res->>'code') = 'success' THEN
	    js_success := json_build_object('text',
			case when (js_success->>'text') is not null 
					then (js_success->>'text')||','||(js_res->>'text')
					else (js_res->>'text')
			end);
	  ELSE
		  js_error := json_build_object('text',
			case when (js_error->>'text') is not null 
					then (js_error->>'text')||','||(js_res->>'text')
					else (js_res->>'text')
			end);
	  END IF;
		
	END LOOP;
		
		RAISE NOTICE 'req %', js_req;
    result := json_build_object('code','success','success',js_success,'exception',js_error);
    return next;

EXCEPTION
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
     return next;

END;$$;


ALTER FUNCTION public.invoice_add_xls(invoice bigint, user_id bigint, inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 674 (class 1255 OID 16497)
-- Name: invoice_addprod(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_addprod(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE

 aa														record;
 p_company           					bigint;
 invoice_object      					json;
 product_object      					json;
 p_code				       					varchar;
 p_text				       					varchar;
 p_error			       					varchar;
 p_minus				     					boolean;
 p_stockfrom		  	 					bigint;
 units_result_min    					float8;
 p_status					   					varchar;
 p_invoice_in				 					bigint;
 p_currstock_in			 					bigint;
 p_is_new_prod			 					boolean := false;
 p_count_prod				 					float8 := 0;
 p_check						 					varchar;
 p_amount_in 			   					float8;
 p_newprice 			   					float8;
 p_staticprice		   					float8;
 p_attributes_in		 					bigint;
 p_attributes_in_json		 			json;
 p_attributes_ex							bigint;
 p_unitsprid				 					bigint;
 p_unitsprid_old		 					bigint;
 p_prod_category		 					bigint;
 p_prod_taxid		 		 					bigint;
 p_brand											bigint;
 p_bonusrate									integer;
 p_prod_cnofea			 					varchar;
 p_prod_changes			 					boolean := false;
 p_exist_records		 					integer := 0;
 p_updateallprodprice_compare boolean;
 p_warning										varchar;
 p_category										bigint;
 p_count_attr_in							smallint;
 p_count_attr_ex							smallint;
 p_nds												boolean := false;	
 p_hot												integer;
 p_isdelete										boolean;
 p_hot_old										integer;
 p_isdelete_old								boolean;
 p_scale											bigint;
 p_name												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_pieceprice									float8;
 p_piece_old									boolean;
 p_pieceinpack_old						integer;
 p_type												integer;
 p_attr                       json := '[]';
 p_faa 												json;
 attr_items    								json;
 p_wholesale_price						float4;
 p_product										bigint;
 p_numpor    integer;
 
BEGIN

	/*
invoicetypes
1	Перемещение товара
2	Добавление товара
3	Обновление справочника продукции
4	Обновление пользователей кассы
0	Смена цен
5	Обновление категорий
6	Обновление списка атрибутов
7	Списание товара
8	Обновление количества товара
9	Обновление признака учета в минус
10	Обновление скидок
11	Список подарочных сертификатов
12	Передача информации по свидетельству плательщика НДС
13	Обновление акций
14	Обновление приоритетов акций
15	Обновление формата чека
16	Передача на консигнацию
17	Возврат с консигнации
18	Обновление скидок по срокам годности
19	Обновление справочника штрих-кодов
20	Удаление из справочника штрих-кодов
	 */
	
	
	-- OLD { "invoice" : "12", "user" : "1", "product" : {"id" : 111, "amount" : 2, "partnumber" : "W500", "expdate" : "15.10.2018"}}

  -- { "invoice" : "12", "type" : "1", "user" : "1", "scale":0, "stockcurrentfrom" : 
  --   [{"id" : 111, "amount" : "500", "newprice" : "500", "p_wholesale_price": "450", "attributes" : "12","purchaseprice" : "1", "bonusrate" : 12,
	--		"code" : "1", "name" : "Бублики", "category" : "12", "taxid" : "0", "brand" : "Apple", "cnofea" : "Пока ХЗ", "SKU":"ХЗ", "reason" : "Потому-что-гладиолус", "updateprice" : false, "type": 1, "unitsprid": 1, "isdelete":false, "hotkey":12,     "piece":false, "pieceinpack":0, "pieceprice":0 }]}

  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED

  -- Типы: 0 - смена цены, 1 - перемещение товара, 2 - добавление товара

  -- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

	SELECT (inf)::json into invoice_object;

		p_invoice_in := cast(invoice_object->>'invoice' as bigint);
		p_scale			 := cast(coalesce(nullif(trim(invoice_object->>'scale'),''),'0') as bigint);

    SELECT code, text INTO p_code, p_text
      FROM get_company(invoice_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	END IF;
		
	SELECT case when certificatenum is null then false else true end INTO p_nds
		FROM companies
			WHERE id = p_company;

		-- Подтягивание склада, с которого будет производится списание
	SELECT stockfrom, status INTO p_stockfrom, p_status
		 FROM invoices
			WHERE invoicenumber = p_invoice_in
				FOR UPDATE;
	IF p_status IN ('ACCEPTED','DECLINE') THEN
		result := json_build_object('code','exception','text','Указанная накладная уже обработана!');
			return next;
			return;
    ELSIF p_status = 'IN_PROCESS' THEN
			result := json_build_object('code','exception','text','Указанная накладная находится в обработке!');
			return next;
			return;
	ELSIF p_status = 'CANCELED' THEN
			result := json_build_object('code','exception','text','Указанная накладная была отменена!');
			return next;
			return;
	END IF;

    --SELECT (invoice_object)->'stockcurrentfrom' into product_object;

	FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'stockcurrentfrom')
    LOOP 

		p_currstock_in  := cast(product_object->>'id' as bigint);
		p_amount_in		  := cast(trim(product_object->>'amount') as double precision);
		p_category			:= coalesce(cast(product_object->>'category' as bigint),0);
		--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) <
		p_unitsprid			:= coalesce(cast(product_object->>'unitsprid' as bigint),1);
		--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) >
		p_prod_changes  := false;
		p_hot						:= cast(nullif(trim(product_object->>'hotkey'),'') as integer);
		p_isdelete			:= cast(coalesce(nullif(trim(product_object->>'isdelete'),''),'false') as boolean);
		p_code					:= trim(product_object->>'code');
		p_name					:= trim(product_object->>'name');
		-- Для "распоковываемых товаров"
		p_piece					:= cast(coalesce(nullif(trim(product_object->>'piece'),''),'false') as boolean);
		p_pieceinpack		:= case when p_piece then cast(coalesce(product_object->>'pieceinpack','0') as bigint) else 0 end;
		p_pieceprice		:= case when p_piece then cast(coalesce(product_object->>'pieceprice','0') as double precision) else 0 end;
		p_attributes_in := cast(product_object->>'attributes' as bigint);
			
-- [{"code":3,"value":"","name":"Цвет"},{"code":2,"value":"","name":"Срок годности"}] -- Пример приходящего значения json
	
		IF invoice_object->>'type' = '2' and p_category <> -1 and p_attributes_in <> 0 THEN
			p_attr := product_object->>'attrlist';
			p_attributes_in := 0;
			FOR attr_items IN select * from json_array_elements(cast(product_object->>'attrlist'as json))
			LOOP
					if p_attributes_in = 0 then
						p_attributes_in_json := add_attributes(
							json_build_object(
								'user',invoice_object->>'user',
								'attribcode',cast(attr_items->>'code' as bigint),
								'value',attr_items->>'value'
							)
						); -- Сохраняем партийные характеристики товара
					else
						p_attributes_in_json := add_attributes(
							json_build_object(
								'user',invoice_object->>'user',
								'attribcode',cast(attr_items->>'code' as bigint),
								'value',attr_items->>'value',
								'listcode',p_attributes_in
							)
						);
					end if;
					if (p_attributes_in_json->>'code' = 'success') then						
						if p_attributes_in = 0 then p_attributes_in = cast(p_attributes_in_json->>'text' as bigint); end if;
					else
						RAISE SQLSTATE 'S0009';
					end if;
			END LOOP;
		END IF;
		 
		IF p_piece AND p_unitsprid NOT IN (2,16,17) then
		--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) crude temp hack to sort out unitsprid when p_piece is true <
		--p_unitsprid			:= case when not p_piece then coalesce(cast(product_object->>'unitsprid' as bigint),1) else 2 end;
		--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) >
				RAISE SQLSTATE 'S0007';
		END IF;
			
		-- Проверка на НДС для клиентов не являющихся плательщиками НДС
		IF (product_object->>'taxid')::bigint = 1 AND NOT p_nds THEN
			RAISE SQLSTATE 'S0003';
		END IF;
			
		-- Если аттрибут все равно NULL (Потому что attrlist  null), чтобы поле атрибут могло принять значение 
		IF p_attributes_in IS NULL 
			THEN p_attributes_in := 0;
		END IF;
			
		IF (invoice_object->>'type' = '2') THEN
				SELECT count(*) INTO p_exist_records
					FROM invoicelist
						WHERE invoice = p_invoice_in
							AND stock = p_currstock_in
								AND attributes = p_attributes_in
									AND company = p_company;
		END IF;		

		IF p_currstock_in IS NULL THEN
			-- Проверка по коду
			
			SELECT COUNT(code) INTO p_count_prod
				FROM products
					WHERE code = p_code
						AND company = p_company
							AND deleted is FALSE; --OR company = 0;
			IF p_count_prod > 0 THEN
				result := json_build_object('code','exception','text','Товар с таким кодом уже существует в системе! ('||p_code||')');
					return next;
					return;
			END IF;
				
			-- Проверка по имени
								
			SELECT COUNT(code) INTO p_count_prod
				FROM products
					WHERE name = p_name
						AND company = p_company
							AND deleted is FALSE;
				IF p_count_prod > 0 THEN
					result := json_build_object('code','exception','text','Товар с таким наименованием уже существует в системе! ('||p_name||')');
					return next;
					return;
				END IF;
				
				-- Подтягивание бонуса, если есть у категории товаров
				SELECT coalesce(bonusrate,0) INTO p_bonusrate
					FROM categories
						WHERE categories.id = p_category;		
				
				-- Проверка наличия дубля кода в данной накладной
				SELECT p.id INTO p_currstock_in
					FROM products_temp p
						LEFT JOIN invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
							WHERE p.company = p_company
								AND p.code = p_code;
				IF FOUND THEN
					RAISE SQLSTATE 'S0005';
				END IF;
				
				-- Проверка наличия дубля имени в данной накладной
				SELECT p.id INTO p_currstock_in
					FROM products_temp p
						LEFT JOIN invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
							WHERE p.company = p_company
								AND p.name = p_name;
				IF FOUND THEN
					RAISE SQLSTATE 'S0006';
				END IF;				
				
				-- Добавление в темповую таблицу
				INSERT INTO products_temp(code,name,category,taxid,brand,cnofeacode,company,bonusrate,type,unitsprid,isdiscount, piece,pieceinpack,attributes_json)
					VALUES(p_code,p_name,p_category,cast(product_object->>'taxid' as bigint),
								 cast(coalesce(trim(product_object->>'brand'),'0') as bigint),trim(product_object->>'cnofea'),p_company,p_bonusrate,
								cast(coalesce(trim(product_object->>'type'),'0') as integer),p_unitsprid,case when p_category = -1 then false else true end,
								p_piece,p_pieceinpack,p_attr::json)
						RETURNING id INTO p_currstock_in;

				p_is_new_prod := true;	

		ELSE	
			IF (invoice_object->>'type' <> '1') THEN
				--flipflop
				SELECT category, taxid, cnofeacode, coalesce(brand,0), bonusrate, unitsprid, deleted, piece, pieceinpack, type INTO p_prod_category, p_prod_taxid, p_prod_cnofea, p_brand, p_bonusrate, 
					p_unitsprid_old, p_isdelete_old, p_piece_old, p_pieceinpack_old, p_type
						FROM products
							WHERE id = p_currstock_in;
				-- Проверка на добавление сертификатов
				/*IF p_type = 1 THEN
					RAISE SQLSTATE 'S0008';
				END IF;	*/	
				-- Проверка на изменение значений в справочнике продуктов
				IF (p_prod_category <> cast(product_object->>'category' as bigint)) or (p_prod_taxid <> cast(product_object->>'taxid' as bigint)) or 
					(coalesce(p_prod_cnofea,'') <> (coalesce(trim(product_object->>'cnofea'),''))) or (p_brand <> cast(coalesce(trim(product_object->>'brand'),'0') as bigint)) /*or (p_bonusrate <> 
					cast(product_object->>'bonusrate' as bigint))*/ or (p_unitsprid_old <> p_unitsprid) or (p_isdelete_old <> p_isdelete) or (p_piece <> p_piece_old) or 
					(p_pieceinpack <> p_pieceinpack_old) THEN
					IF (p_prod_category = -1 AND p_prod_taxid = cast(product_object->>'taxid' as bigint)/*НДС можно менять для весовых товаров*/)THEN
						RAISE SQLSTATE 'S0004';
					END IF;
					--// 20230901 by AB add update public.products if p_is_new_prod is false and p_prod_changes is true <
					--p_is_new_prod  := true; 
					--// 20230901 by AB add update public.products if p_is_new_prod is false and p_prod_changes is true >
					p_prod_changes := true;
				ELSE
					p_is_new_prod := false;
				END IF;
			END IF;
		END IF;

			-- Проверять только при перемещении\списании

		IF invoice_object->>'type' NOT IN ('2','0') THEN

			  -- Проверка на нулевой остаток
        	SELECT units - p_amount_in INTO units_result_min
				FROM stockcurrent
					WHERE id = p_currstock_in
						AND company = p_company;
			IF /*NOT p_minus AND*/ round(units_result_min::numeric,3) < 0 THEN
		    	result := json_build_object('code','exception','text','Остаток на складе не должен быть меньше 0!');
			    return next;
			    return;
			ELSIF units_result_min IS NULL THEN
				result := json_build_object('code','exception','text','Запись склада не была идентифицирована!');
			    return next;
			    return;
        	END IF;

		ELSIF invoice_object->>'type' = '2' THEN
			SELECT updateallprodprice INTO p_updateallprodprice_compare
				FROM invoicelist
					WHERE invoice = p_invoice_in
						AND stock = p_currstock_in
							AND company = p_company;
			IF cast(product_object->>'updateprice' as boolean) AND p_updateallprodprice_compare THEN
				RAISE SQLSTATE 'S0001';  
			ELSIF cast(product_object->>'updateprice' as boolean) THEN
				p_warning := 'Был добавлен товар с признаком обновления на всех точках вне зависимости 
													от атрибутов, в списке уже есть данный торар - цена продажи будет изменена при обработке!';
			ELSIF p_updateallprodprice_compare THEN
				p_warning := 'В связи с тем, что в накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости 
													от атрибутов - цена продажи будет изменена при обработке на указанную ранее!';
			END IF;

		END IF;

		-- Проверка набора атрибутов (только добавление) проверяется на дублирование.
		IF (p_attributes_in <> '0' AND p_attributes_in IS NOT NULL) AND invoice_object->>'type' = '2' THEN					
			SELECT count(listcode) INTO p_count_attr_in
				FROM attrlist a
					WHERE company = p_company
						AND listcode = p_attributes_in;
			FOR aa IN (
					SELECT attributes as attr
						FROM stockcurrent
							WHERE company = p_company
								AND product = p_currstock_in
									AND point = p_stockfrom
										AND attributes <> 0
										--ORDER BY attributes
					UNION
						SELECT attributes as attr
							FROM invoicelist
								WHERE invoice = p_invoice_in
									AND company = p_company
										AND stock = p_currstock_in
											AND attributes <> 0
												ORDER BY attr					 
			)
			LOOP		
				SELECT count(a2.listcode), a2.listcode INTO p_count_attr_ex, p_attributes_ex
					FROM attrlist a
						INNER JOIN attrlist a2 on (a2.attribute = a.attribute and a2.value = a.value and a2.company = a.company and a2.listcode = aa.attr and a2.istemp = false)
							WHERE a.company = p_company
								AND a.listcode = p_attributes_in
									GROUP BY a2.listcode;
				IF p_count_attr_ex = p_count_attr_in THEN
					p_attributes_in := p_attributes_ex;
					EXIT;
				END IF;					
			END LOOP;
					
					-- Доработка (если сначала добавили атрибуты, а потом убрали)
			SELECT count(*) INTO p_count_attr_ex
				FROM attrlist
					WHERE listcode = p_attributes_in;
			IF p_count_attr_ex = 0 THEN
				p_attributes_in := 0;
			END IF;
		END IF;
				
				--flipflop
				
				-- Извлекаем продукт из стока для сравнения по предельным ценам
		SELECT product INTO p_product FROM stockcurrent WHERE id =  p_currstock_in;
		--условие для подтягивания цены из таблицы со статичными ценами для соответстующих товаров
		p_newprice = cast(trim(product_object->>'newprice') as double precision);
		IF p_is_new_prod = false THEN
			select s.price into p_staticprice 
				from product_static_prices s
					inner join products p on p.id = s.product and p.isstaticprice = true 
				where s.company = p_company and s.product = p_currstock_in;
			IF p_staticprice is not null and p_staticprice < p_newprice THEN
				RAISE SQLSTATE 'S0002';  
			END IF;
		END IF;
		--flipflop
				
		p_wholesale_price = coalesce(cast(product_object->>'wholesale_price' as double precision),0);
				
			
		------07.09.2022
		select max(numpor)+1 into p_numpor from invoicelist where invoice=p_invoice_in and company=p_company 
		and stock<>p_currstock_in ;
		------07.09.2022
				
		INSERT INTO invoicelist(invoice,stock,units,newprice,attributes,purchaseprice,newprod,sku,comments,prodchanges,updateallprodprice,company,hotkey,"scale",pieceprice,attributes_json,wholesale_price
		------07.09.2022
			,numpor 		  
		------07.09.2022
		)
			VALUES(p_invoice_in,p_currstock_in,p_amount_in,p_newprice,
				   p_attributes_in, cast(trim(product_object->>'purchaseprice') as double precision),p_is_new_prod,trim(product_object->>'SKU'), --NEW CODE
					    trim(product_object->>'reason'), case when p_prod_changes then cast(product_object->>'category' as varchar) ||','||cast(product_object->>'taxid' as varchar) 
							||','|| cast(trim(coalesce(product_object->>'cnofea','')) as varchar)||','||cast(coalesce(trim(product_object->>'brand'),'0') as varchar)||','||p_bonusrate::varchar
							||','||p_unitsprid::varchar||','||p_isdelete::varchar||','||p_piece::varchar||','||p_pieceinpack::varchar
							else null end, cast(product_object->>'updateprice' as boolean), p_company, p_hot, p_scale, p_pieceprice,p_attr::json,p_wholesale_price
					------07.09.2022
					   ,coalesce(p_numpor,1) 
					------07.09.2022   
			);
		--END IF;
		--// 20230901 by AB add update public.products if p_is_new_prod is false and p_prod_changes is true <
		/*  if invoicelist.newprod is NULL and invoicelist.prodchanges is not null, then it works in lines 311-320 of public.goods_add function.  
		 * It seems that it was broken, because line 303 above set p_is_new_prod true even when product was not new but changes to products were made.
		 * 
		 if p_is_new_prod = false  and p_prod_changes = true then
			if cast(product_object->>'category' as bigint) is not null then 
				update products set category = cast(product_object->>'category' as bigint)
					where id = p_currstock_in and company = p_company;
			end if;
			if cast(product_object->>'taxid' as int) is not null then
				update products set taxid = cast(product_object->>'taxid' as int)
					where id = p_currstock_in and company = p_company;
			end if;
			if cast(product_object->>'cnofea' as varchar) is not null or cast(product_object->>'cnofea' as varchar) <> '' then
				update products set cnofeacode = cast(product_object->>'cnofea' as varchar)
					where id = p_currstock_in and company = p_company;
			end if;
			if cast(product_object->>'brand' as bigint) is not null then
				update products set brand = cast(product_object->>'brand' as bigint)
					where id = p_currstock_in and company = p_company;
			end if;
			if p_bonusrate is not null then
				update products set bonusrate = p_bonusrate
					where id = p_currstock_in and company = p_company;
			end if;
			if p_unitsprid is not null then
				update products set unitsprid = p_unitsprid
					where id = p_currstock_in and company = p_company;
			end if;
			if p_isdelete is not null then
				update products set deleted = p_isdelete
					where id = p_currstock_in and company = p_company;
			end if;
			if p_piece is not null then
				update products set piece = p_piece
					where id = p_currstock_in and company = p_company;
			end if;
			if p_pieceinpack is not null then
				update products set pieceinpack = p_pieceinpack
					where id = p_currstock_in and company = p_company;
			end if;
		end if;
			*/		 
			--// 20230901 by AB add update public.products if p_is_new_prod is false and p_prod_changes is true >

		IF p_attributes_in <> '0' AND p_attributes_in IS NOT NULL THEN
			UPDATE attrlist 
	    		SET istemp = false
					WHERE listcode = p_attributes_in
						AND company = p_company;
		END IF;

			
	END LOOP;

	result := json_build_object('code','success','text',p_currstock_in,'note',p_warning);
	return next;

	EXCEPTION
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','В накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','exception','text','Цена данного товара превышает предельную цену!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
			return next;	
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','exception','text','Нельзя изменять товар категории "Весовые товары"!');
			return next;		
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким штрих-кодом!');
			return next;
		WHEN SQLSTATE 'S0006' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким наименованием!');
			return next;	
		WHEN SQLSTATE 'S0007' THEN
			result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
			return next;
		WHEN SQLSTATE 'S0008' THEN
			result := json_build_object('code','exception','text','Для добавления сертификатов перейдите во вкладку "Подарочные сертификаты"!');
			return next;				
		WHEN SQLSTATE 'S0009' THEN
			result := json_build_object('code','exception','text','Ошибка при сохранении патрийных характеристик!');
			return next;
	
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 IF p_check = 'invoicelist_pkey' THEN
		   result := json_build_object('code','exception','text','Данный товар уже добавлен в накладную!');
	   ELSIF p_check = 'prod_name_temp_idx' THEN 
		   result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким наименованием ожидает обработки! Требуется сначала обработать активную накладную!');
	   ELSIF p_check = 'prod_code_temp_idx' THEN 
		   result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким кодом ожидает обработки! Требуется сначала обработать активную накладную!');
	   ELSE
	     result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   END IF;

     return next;

END;
$$;


ALTER FUNCTION public.invoice_addprod(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 675 (class 1255 OID 16499)
-- Name: invoice_addprod_xls(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_addprod_xls(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company           					bigint;
 p_error			       					varchar;
 p_check						 					varchar;
 p_invoiceprod 				    		json;
 p_code												varchar;
 p_name												varchar;
 p_prod_id										bigint;
 p_cat_id											bigint;
 p_cat_name										varchar;
 p_brand_id										bigint;
 p_brand_name									varchar;
 p_result				 							json;
 p_func_code					 				varchar;
 p_func_text					 				varchar;
 p_user												bigint;
 p_invoice										bigint;
 p_units											float8;
 p_pricebuy										float8;
 p_pricesell									float8;
 p_taxid											smallint;
 p_cnofea											varchar;
 p_errors_j										varchar;
--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) <
 p_piece								varchar  	:= null;
 p_pieceinpack							bigint 	:= null;
 p_pieceprice										float8;
 p_unitsprid							smallint  := null;
--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) >

BEGIN

/*
{"invoice": "12", "company": 9, "user": "42", "invoiceprods": [
	{"Category":"Складные ножи","Name":"Генферон 500 000 МЕ №10 суппозитории","Code":"2000000137322","PriceBuy":2105,"PriceSell":2526,"Units":2,"Brand":"Opinel", "Nds":"Да",
		"Cnofeacode":"123"},
	{"Category":"Складные ножи","Name":"Складной нож Opinel 12 carbon","Code":900602,"PriceBuy":5250,"PriceSell":7500,"Units":4,"Brand":"Opinel", "Nds":"Да", 
		"Cnofeacode":"123"},
	{"Category":"Складные ножи","Name":"Складной нож Opinel 10 stainless","Code":900603,"PriceBuy":4550,"PriceSell":6500,"Units":3,"Brand":"Opinel", "Nds":"Нет",
		"Cnofeacode":"123"}
 ]
}
*/
	
		p_company := cast(trim(inf->>'company') as bigint);
		p_user		:= cast(trim(inf->>'user') as bigint);
		p_invoice := cast(trim(inf->>'invoice') as bigint);
		
		IF p_company IS NULL OR p_user IS NULL OR p_invoice IS NULL THEN
			RAISE SQLSTATE 'S0001';
		END IF;
	 
	 FOR p_invoiceprod IN SELECT * FROM json_array_elements((inf)->'invoiceprods')
	 LOOP
			
			p_code 		 	 := nullif(trim(p_invoiceprod->>'Code'),'');
			p_name 		 	 := nullif(trim(p_invoiceprod->>'Name'),'');
			p_cat_name 	 :=	trim(p_invoiceprod->>'Category');	
			p_brand_name := trim(p_invoiceprod->>'Brand');
			p_units   	 := cast(nullif(trim(p_invoiceprod->>'Units'),'') as double precision);
			p_pricebuy	 := cast(nullif(trim(p_invoiceprod->>'PriceBuy'),'') as double precision);
			p_pricesell	 := cast(nullif(trim(p_invoiceprod->>'PriceSell'),'') as double precision);
			p_taxid			 := case when lower(trim(p_invoiceprod->>'Nds')) like '%да%' then 1 else 0 end;
			p_cnofea		 := nullif(trim(p_invoiceprod->>'Cnofeacode'),'');
--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) <
			p_piece		 := case when lower(trim(p_invoiceprod->>'Piece')) like '%да%' then 'true' else 'false' end;
			p_pieceinpack := cast(nullif(trim(p_invoiceprod->>'PieceInPack'),'') as bigint);
			p_pieceprice := cast(nullif(trim(p_invoiceprod->>'PiecePrice'),'') as double precision);
		    p_unitsprid := cast(nullif(trim(p_invoiceprod->>'Unitsprid'),'') as bigint);
			--p_pieceinpack := case when p_piece = 'true' then cast(nullif(trim(p_invoiceprod->>'PieceInPack'),'') as bigint) else 0 end;
--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) >			
			-- Избегание лишнего текста
			IF (p_code IS NULL AND p_name IS NULL AND p_units IS NULL AND p_pricebuy IS NULL AND p_pricesell IS NULL) THEN
				CONTINUE;
			END IF;
			
			IF p_code IS NULL THEN		
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Не указан код товара!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Не указан код товара!')::text;
				END IF;		 
				CONTINUE;
			ELSIF "length"(p_code) > 20 THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Длинна штрих-кода превышает допустимое значение!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Длинна штрих-кода превышает допустимое значение!')::text;
				END IF;		 
				CONTINUE;
			ELSIF p_units IS NULL THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Не указано количество товара!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Не указано количество товара!')::text;
				END IF;		 
				CONTINUE;	
			ELSIF p_units < 0 THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Указанное количество товара меньше нуля!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Указанное количество товара меньше нуля!')::text;
				END IF;		 
				CONTINUE;		
			ELSIF p_pricebuy IS NULL THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Не указана закупочная цена товара!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Не указана закупочная цена товара!')::text;
				END IF;		 
				CONTINUE;			
			ELSIF p_pricebuy < 0 THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Указанная закупочная цена меньше нуля!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Указанная закупочная цена меньше нуля!')::text;
				END IF;		 
				CONTINUE;			
			ELSIF p_pricesell IS NULL THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Не указана цена продажи товара!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Не указана цена продажи товара!')::text;
				END IF;		 
				CONTINUE;		
			ELSIF p_pricesell < 0 THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Указанная цена товара меньше нуля!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Указанная цена товара меньше нуля!')::text;
				END IF;		 
				CONTINUE;			
			ELSIF p_taxid IS NULL THEN
				IF p_errors_j IS NULL THEN
				  p_errors_j := json_build_object('name',p_name,'code',p_code,'exception','Не указан признак НДС товара!')::text;
				ELSE
				  p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception','Не указан признак НДС товара!')::text;
				END IF;		 
				CONTINUE;
			END IF;
			
			SELECT id into p_prod_id
				FROM products 
					WHERE company = p_company 
						AND code = p_code
							AND name = p_name;
			
		  -- Подтягиваем ТНВЭД, если не получили от пользователя
			IF p_cnofea IS NULL THEN
				SELECT cnofeacode into p_cnofea 
					FROM products 
						WHERE company = p_company 
							AND code = p_code;
			END IF;
			
			-- Манипуляции с категориями
			IF p_cat_name IS NOT NULL THEN
				SELECT id INTO p_cat_id 
					FROM categories  
						WHERE company = p_company 
							AND lower(name) = lower(p_cat_name);
				IF p_cat_id IS NULL THEN
					INSERT INTO categories(name,deleted,company)
						VALUES (p_cat_name,false,p_company)
							RETURNING id INTO p_cat_id;
				ELSIF p_cat_id = -1 THEN
					IF p_errors_j IS NULL THEN
						p_errors_j := json_build_object('name',p_name,'code',p_code,'exception',
								'Весовые товары нужно добавлять в специальном разделе!')::text;
					ELSE
						p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception',
								'Весовые товары нужно добавлять в специальном разделе!')::text;
					END IF;		 
					CONTINUE;
				END IF;		
			ELSE	
				p_cat_id := 0;
			END IF;
			
			-- Манипуляци с брендами
			IF p_brand_name IS NOT NULL THEN		
				SELECT id INTO p_brand_id 
					FROM brands
						WHERE lower(brand) = lower(p_brand_name);
				IF p_brand_id IS NULL THEN
					IF p_errors_j IS NULL THEN
						p_errors_j := json_build_object('name',p_name,'code',p_code,'exception',
								'Указанный бренд не найден в системе! Обратитесь в службу поддержки для добавления указанного бренда!')::text;
					ELSE
						p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception',
								'Указанный бренд не найден в системе! Обратитесь в службу поддержки для добавления указанного бренда!')::text;
					END IF;		 
					CONTINUE;
				END IF;
			ELSE
				p_brand_id := 0;
			END IF;
			
			-- Вызов функции, записывающей позиции в инвойс
      SELECT invoice_addprod(json_build_object('type','2','user',p_user,'invoice',p_invoice,'stockcurrentfrom',json_agg(json_build_object('id',p_prod_id,'sku',null,
										'code',p_code,'name',p_name,'brand',p_brand_id,'taxid',p_taxid,'amount',p_units,'cnofea',p_cnofea,'category',p_cat_id,'newprice',p_pricesell,
										--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) <
										'piece',p_piece,'pieceinpack',p_pieceinpack,'pieceprice',p_pieceprice,'unitsprid',p_unitsprid,
										--// 20230817 by AB add products.piece to report (enable upload to transfer all product info ) >
												'attributes',null,'updateprice',true,'purchaseprice',p_pricebuy)))) INTO p_result;
			IF p_result->>'code' LIKE '%error%' or p_result->>'code' LIKE '%exception%' THEN
		    p_func_code := p_result->>'code';
			  p_func_text := p_result->>'text';
				IF p_errors_j IS NULL THEN
					p_errors_j := json_build_object('name',p_name,'code',p_code,'exception',
						case when p_func_code = 'error' then p_func_text||' ('||coalesce(p_name,'')||' - '||coalesce(p_code,'')||')' else 'Произошла непредвиденная ошибка! Обратитесь в службу поддержки!' end)::text;
				ELSE
					p_errors_j := p_errors_j ||','|| json_build_object('name',p_name,'code',p_code,'exception',
						case when p_func_code = 'error' then p_func_text||' ('||coalesce(p_name,'')||' - '||coalesce(p_code,'')||')' else 'Произошла непредвиденная ошибка! Обратитесь в службу поддержки!' end)::text;
				END IF;		 
				CONTINUE;
		  END IF;
	 
	 END LOOP;
	 
	 p_errors_j := '['||p_errors_j||']';
	 
	 result := json_build_object('code','success','text','','exception',p_errors_j::json);
   return next;
	
	 EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','exception','text','Идентификаторы компании, инвойса или пользователя не были переданы!');
		 return next; 	  
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   return next;
		 
END;$$;


ALTER FUNCTION public.invoice_addprod_xls(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 676 (class 1255 OID 16501)
-- Name: invoice_create(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_create(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company       bigint;
 p_company2			 bigint;
 invoice_object  json;
 p_code				   varchar;
 p_text				   varchar;
 p_error			   varchar;
 p_invoicenumber bigint;
 p_type_in			 bigint;
 p_point_in			 bigint;
 p_stock_to_in	 bigint;
 p_stock_from_in bigint;
 p_date					 date;
BEGIN

	-- {"stockfrom" : "1", "stockto" : "2", "user" : "1", "altinvoice" : "SPB123", "type" : "1", "counterparty" : "1", "invoicedate": "19.07.2019", "isweight": false, "scale": 123}
  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
  -- Типы: 0 - смена цены, 1 - перемещение товара, 2 - добавление товара
  -- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

	SELECT (inf)::json into invoice_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(invoice_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		p_type_in 	    := cast(invoice_object->>'type' as bigint);
		p_stock_to_in	  := cast(invoice_object->>'stockto' as bigint);
		p_stock_from_in := cast(invoice_object->>'stockfrom' as bigint);
		p_date					:= to_date(invoice_object->>'invoicedate','DD.MM.YYYY');

		-- Добавление\Списание
		IF p_type_in in ('2','7') THEN
		
			/*SELECT id INTO p_point_in
        FROM points
				  WHERE company = p_company
					  AND point_type = '0'
						  AND status = 'ACTIVE';
			IF p_point_in IS NULL THEN
			  result := json_build_object('code','error','text','Центральный склад не был идентифицирован!');
        return next;
		    return;
			END IF;*/
			null;
			
		ELSIF p_type_in = '1' THEN

      -- Проверка на принадлежность точек к одной компании
		  BEGIN

		    /*SELECT distinct(c.id) INTO p_company2
		      FROM companies c
			      LEFT JOIN points p ON (p.company = c.id)
				      AND p.id IN (p_stock_to_in,p_stock_from_in);*/

				SELECT distinct company INTO p_company2
				  FROM points 
					  WHERE id IN (p_stock_to_in,p_stock_from_in);

		  EXCEPTION
			  WHEN too_many_rows THEN
				  result := json_build_object('code','exception','text','Перемещать товар между складами разных компаний - запрещено!');
          return next;
		      return;
		  END;

    ELSE

      result := json_build_object('code','exception','text','Некорректный тип накладной(инвойса)!');
      return next;
		  return;

		END IF;

  -- Проверка на заполненность необходимых переменных
    IF p_stock_to_in IS NULL AND p_point_in IS NULL THEN
		  result := json_build_object('code','exception','text','Не указан склад с которого перемещают товар!');
      return next;
		  return;
		ELSIF p_stock_from_in IS NULL AND p_point_in IS NULL THEN
		  result := json_build_object('code','exception','text','Не указан склад на который перемещают товар!');
      return next;
		  return;
	  ELSIF p_stock_from_in = p_stock_to_in AND p_point_in IS NULL AND p_type_in NOT IN (2,7) THEN
		  result := json_build_object('code','exception','text','Для перемещения нужно выбрать разные склады!');
      return next;
		  return;
    ELSIF p_company <> p_company2 AND p_company2 IS NOT NULL THEN
			result := json_build_object('code','exception','text','Изменения разрешены только в рамках одной компании!');
      return next;
		  return; 
		END IF;

		-- Создание накладной(инвойса) для подтверждения
	  INSERT INTO invoices(altnumber,invoicedate,creator,status,company,stockfrom,stockto,type,counterparty,isweight,"scale")
	    VALUES(invoice_object->>'altinvoice',p_date,cast(invoice_object->>'user' as bigint),'FORMATION',p_company,
			  coalesce(p_point_in,p_stock_from_in),coalesce(p_point_in,p_stock_to_in),p_type_in,cast(invoice_object->>'counterparty' as bigint),
				coalesce(cast(invoice_object->>'isweight' as boolean),false),cast(invoice_object->>'scale' as bigint))
		      RETURNING invoicenumber INTO p_invoicenumber;

    result := json_build_object('code','success','text',p_invoicenumber);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;









$$;


ALTER FUNCTION public.invoice_create(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 677 (class 1255 OID 16503)
-- Name: invoice_del(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_del(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
 invoice_object  json;
 p_error			   varchar;
 p_status				 varchar;
 p_type					 bigint;
 r							 record;
 p_company			 bigint;
 p_invoice			 bigint;
BEGIN

	-- {"invoice" : "1", "user" : "2", "company" : 15}
  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCALED
  -- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

	SELECT (inf)::json into invoice_object;
	
	  p_company := cast(invoice_object->>'company' as bigint);
	  p_invoice := cast(invoice_object->>'invoice' as bigint);
		
		IF p_invoice IS NULL THEN
			RAISE SQLSTATE 'S0001';
		ELSIF p_company IS NULL THEN
			RAISE SQLSTATE 'S0002';
		END IF;
	
		SELECT status, type INTO p_status, p_type
		  FROM invoices
			  WHERE invoicenumber = p_invoice
					AND company = p_company
						FOR UPDATE;
		IF p_status IN ('ACCEPTED','DECLINE') THEN
		  result := json_build_object('code','error','text','Указанная накладная уже обработана!');
			return next;
			return;
    ELSIF p_status = ('IN_PROCESS') THEN
      result := json_build_object('code','error','text','Указанная накладная находится в обработке!');
			return next;
			return;
		END IF;

		UPDATE invoices
      SET status = 'CANCELED', approver = cast(invoice_object->>'user' as bigint), system = 'ERP'
			  WHERE invoicenumber = p_invoice
					AND company = p_company;
		
		-- Подчищаем темповую таблицу
		IF p_type = 2 THEN
			DELETE FROM products_temp
				WHERE company = p_company
					AND id IN (SELECT DISTINCT stock
											FROM invoicelist
												WHERE invoice = p_invoice
														AND company = p_company);
		  /*FOR r IN(
		    SELECT DISTINCT stock
			    FROM invoicelist
				    WHERE invoice = p_invoice
					    AND newprod = true
								AND company = p_company
		  )
		  LOOP
				DELETE FROM products_temp WHERE id = r.stock;
		  END LOOP;*/
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION 
WHEN SQLSTATE 'S0001' THEN
		result := json_build_object('code','error','text','Не был передан идентификатор накладной(инвойса)!');
		return next;
WHEN SQLSTATE 'S0002' THEN
		result := json_build_object('code','error','text','Не был передан идентификатор компании!');
		return next;		
WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;


$$;


ALTER FUNCTION public.invoice_del(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 678 (class 1255 OID 16504)
-- Name: invoice_delete(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_delete(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$
DECLARE
	r record;
	p_company bigint;
	p_invoice bigint;
	p_error text;
	p_check text;
	p_altnumber text;
	p_invoices json;
	p_array int[];
	item json;
	p_body json;
	i bigint := 0;
	p_id bigint;
BEGIN
	

	-- inf = {"company":1,"invoices":[{"id":1},{"id":2}]}
	
	p_company := coalesce(cast(inf->>'company' as bigint),0);
	p_invoices := cast(inf->>'invoices' as json);
		
		IF p_company = 0 THEN
			raise sqlstate 'S0001';
		END IF;
	
	FOR item IN SELECT * FROM json_array_elements(p_invoices)
	LOOP
	
		
		p_id := coalesce(cast(item->>'id' as bigint),0);


	
		IF p_id = 0 THEN
			raise sqlstate 'S0002';
		END IF;
		
		DELETE FROM invoicelist WHERE invoice = p_id and company = p_company;
		DELETE FROM invoices WHERE invoicenumber = p_id and company = p_company;
		
		i := i + 1;

	END LOOP;
	
	res := json_build_object('code','success', 'text','ok','invoices quantity',i)
	RETURN;
	
	
	EXCEPTION
	
	WHEN sqlstate 'S0001' THEN
		res := json_build_object('code','error','text','Empty company!')
		RETURN;
	
	WHEN sqlstate 'S0002' THEN
		res := json_build_object('code','error','text','Empty invoice!')
		RETURN;
	
	WHEN OTHERS THEN
		raise notice '%', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		
		res := json_build_object('code','internal error','text',SQLSTATE||':'||SQLERRM||':'||p_error)
		RETURN;
END;
$$;


ALTER FUNCTION public.invoice_delete(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 643 (class 1255 OID 16505)
-- Name: invoice_delprod(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_delprod(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	
 invoice_object   json;
 p_error					varchar;
 p_stock_in				bigint;
 p_code				    varchar;
 p_text				    varchar;
 p_company        bigint;
 p_deleted_cnt		int;
 p_attrib_in			bigint;
 p_status				 	varchar;
 p_has_product    int;
 p_is_new_prod    boolean;

BEGIN

	-- { "invoice" : "1", "user" : "1", "stock" : "12", "attributes" : "12"}
  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
  -- Типы: 0 - смена цены, 1 - перемещение товара, 2 - добавление товара
  -- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

	SELECT (inf)::json into invoice_object;  

		SELECT code, text INTO p_code, p_text
      FROM get_company(invoice_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

		p_stock_in  := cast(invoice_object->>'stock' as bigint);
		p_attrib_in := cast(coalesce(invoice_object->>'attributes','0') as bigint);
		
		SELECT i.status INTO p_status
		  FROM invoices i
				WHERE i.invoicenumber = cast(invoice_object->>'invoice' as bigint)
					FOR UPDATE;
		IF p_status = 'ACCEPTED' THEN
		  result := json_build_object('code','exception','text','Данная накладная(инвойс) уже была обработана! Удаление невозможно!');
      return next;
		  return;
		ELSIF p_status = 'IN_PROCESS' THEN
			result := json_build_object('code','exception','text','Данная накладная(инвойс) уже обрабатывается! Удаление невозможно!');
      return next;
		  return;
		ELSIF p_status = 'CANCELED' THEN
			result := json_build_object('code','exception','text','Данная накладная(инвойс) уже была отменена! Удаление невозможно!');
      return next;
		  return;
		END IF;
		
		
		
		----12.09.2022
		--SELECT COUNT(*) into p_has_product FROM products p
		--WHERE p.id = p_stock_in;
		----12.09.2022
		
		---
		--result := json_build_object('code','exception','text',p_has_product);
      --return next;
	  --

        ----12.09.2022 
		--if p_has_product > 0 then -- если товар существует в справочнике - номенклатура
		----12.09.2022
		
		---
		--result := json_build_object('code','exception','text','33');
      --return next;
	  --
	  
			WITH deleted AS (				
					DELETE FROM invoicelist
					WHERE stock = p_stock_in
						AND invoice = cast(invoice_object->>'invoice' as bigint)
							AND "attributes" = p_attrib_in 
								AND company = p_company
			IS TRUE RETURNING *) SELECT count(*) into p_deleted_cnt FROM deleted;
			
			if p_deleted_cnt = 0 then -- если товар с атрибутом не найден, тогда удаляем товар без атрибута
			
			---
		--result := json_build_object('code','exception','text','44');
      --return next;
	  --
	  
				DELETE FROM invoicelist
				WHERE stock = p_stock_in
					AND invoice = cast(invoice_object->>'invoice' as bigint)
						AND company = p_company;
			end if;
			
		----12.09.2022	
		--else -- если товар новый
		----12.09.2022
		
		
		---
		--result := json_build_object('code','exception','text','55');
      --return next;
	  --
		
			WITH deleted AS (
				DELETE FROM products_temp
					WHERE id = p_stock_in
						AND company = p_company
						 and "attributes" = p_attrib_in
			IS TRUE RETURNING *) SELECT count(*) into p_deleted_cnt FROM deleted;
			
			if p_deleted_cnt > 0 then -- если товар с атрибутом не найден, тогда удаляем товар без атрибута	
				
				---
		--result := json_build_object('code','exception','text','66');
      --return next;
	  --
				--DELETE FROM products_temp
				--WHERE id = p_stock_in
				--	AND company = p_company;
				
				DELETE FROM invoicelist
				WHERE stock = p_stock_in
					AND invoice = cast(invoice_object->>'invoice' as bigint)
						AND company = p_company;
			end if;
		
		----12.09.2022
		--end if;
		----12.09.2022
	
	
	
	/*
	DELETE FROM invoicelist
		  WHERE stock = p_stock_in
			  AND invoice = cast(invoice_object->>'invoice' as bigint)
				  AND attributes = p_attrib_in 
						AND company = p_company
							RETURNING newprod INTO p_is_new_prod;

		IF p_is_new_prod THEN
		  DELETE FROM products_temp
			  WHERE id = p_stock_in
				  AND company = p_company;
		ELSIF p_is_new_prod IS NULL THEN
		  result := json_build_object('code','exception','text','При удалении возникли проблемы! Попробуйте позднее!');
      return next;
		  return;
	  END IF;
	*/
	
    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;

$$;


ALTER FUNCTION public.invoice_delprod(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 679 (class 1255 OID 16507)
-- Name: invoice_edit(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_edit(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$
DECLARE 
 r record;
 p_error text;
 p_check text;
 p_invoice bigint;
 p_company bigint;
 p_counterparty bigint;
 p_invoicedate date;
 p_altnumber text;

BEGIN
	
	-- inf = {'company':1,'invoice':1,'altnumber':1,'counterparty':1,'date':'01.01.2023'}
	p_company := coalesce(cast(inf->>'company' as bigint),0);
	p_invoice := coalesce(cast(inf->>'invoice' as bigint),0);
	
	p_counterparty := cast(inf->>'counterparty' as bigint);
	p_invoicedate := cast(inf->>'invoicedate' as date);
	p_altnumber := cast(inf->>'altnumber' as text);
	
	
	IF p_company = 0 THEN
		raise SQLSTATE 'S0001';
	END IF;
	
	IF p_invoice = 0 THEN
		raise SQLSTATE 'S0002';
	END IF;

	UPDATE invoices
		SET counterparty = CASE WHEN p_counterparty IS NOT NULL THEN p_counterparty ELSE counterparty END, 
					altnumber = CASE WHEN p_altnumber IS NOT NULL THEN p_altnumber ELSE altnumber END, 
						invoicedate = CASE WHEN p_invoicedate IS NOT NULL THEN p_invoicedate ELSE invoicedate END
				
			WHERE invoicenumber = p_invoice
				AND company = p_company;
					
	res := json_build_object('code','success','text','ok')
	RETURN;
	
	EXCEPTION
	
	WHEN SQLSTATE 'S0001' THEN
		res := json_build_object('code','error','text','Empty company!');
		RETURN;
	WHEN SQLSTATE 'S0002' THEN
		res := json_build_object('code','error','text','Empty invoice!');
		RETURN;
	
	
	WHEN OTHERS THEN
		raise notice '%', SQLERRM;
		GET STACKED DIAGNOSTICS p_error := PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		res := json_build_object('code','internal error','text',SQLSTATE||': '||SQLERRM||': '||p_error);
		RETURN;
END;
$$;


ALTER FUNCTION public.invoice_edit(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 680 (class 1255 OID 16508)
-- Name: invoice_list_movement(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_list_movement(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_result  json;
 p_result2 json;
 p_code		 varchar;
 p_text		 varchar;
 p_func		 varchar;
BEGIN

	-- OLD { "invoice" : "12", "user" : "1", "product" : {"id" : 111, "amount" : 2, "partnumber" : "W500", "expdate" : "15.10.2018"}}
  -- { "invoice" : "12", "type" : "1", "user" : "1", "stockcurrentfrom" : 
  --   [{"id" : 111, "amount" : "500", "newprice" : "500", "attributes" : "12","purchaseprice" : "1",
	--		"code" : "1", "name" : "Бублики", "category" : "12", "taxid" : "0", "brand" : "Apple", "cnofea" : "Пока ХЗ", "SKU":"ХЗ"}]}
  
	-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED
	
  -- Типы: 0 - смена цены, 1 - перемещение товара, 2 - добавление товара
  
	-- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

		SELECT invoice_addprod(inf) INTO p_result;

		IF p_result->>'code' LIKE '%error%' THEN
		  p_code := p_result->>'code';
			p_text := p_result->>'text';
      p_func := 'invoice_addprod';
      RAISE SQLSTATE 'S0001';
		END IF;

		SELECT goods_movement(json_build_object('invoice',inf->>'invoice','user',inf->>'user')) INTO p_result2;

		IF p_result2->>'code' LIKE '%error%' THEN
		  p_code := p_result2->>'code';
			p_text := p_result2->>'text';
      p_func := 'goods_movement';
      RAISE SQLSTATE 'S0001';
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 result := json_build_object('code',p_code,'text',p_text,'func',p_func);
   return next;

END;













$$;


ALTER FUNCTION public.invoice_list_movement(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 681 (class 1255 OID 16509)
-- Name: invoice_processing(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_processing(invoice json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_invoice 				   json;
	p_company            bigint;
	p_status						 varchar;
	p_stockfrom					 bigint;
	p_stockto						 bigint;
	p_stock_act					 bigint;
	r                    record;
	i										 record;
	g										 record;
	z										 record;
	p_error							 varchar;
  p_invoice_in				 bigint;
	p_stock_to					 bigint;
	p_type_invoice			 integer;
	p_point_in					 bigint;
	p_store_price				 bigint;
  p_action_in					 varchar;
  p_price_to				   float8;
  p_store_out					 bigint;
  p_reason_type				 bigint;
  p_cashbox						 bigint;
	p_product						 bigint;
	p_list_exist				 boolean := false;
	p_counterparty			 bigint;
	p_createdate				 date;
	p_purchasedate			 date;
	p_units_after				 float8;
	p_units_before			 float8;
	p_isminus						 boolean := false;
	p_move_units				 float8;
	p_move_units_2			 float8;
  -- 20230520: p_scp_units_before - units of stock in stockcurrent_part before transaction / invoice
  -- 20230520: p_scp_units_after - units of stock in stockcurrent_part after transaction / invoice
  -- 20230520: p_sc_units_before - units of stock in stockcurrent before transaction / invoice
  -- 20230520: p_sc_units_after - units of stock in stockcurrent after transaction / invoice
  p_scp_units_before						float8 := 0;
  p_scp_units_after							float8 := 0;
  p_sc_units_before							float8 := 0;
  p_sc_units_after							float8 := 0;
 -- 20230522: p_sc_reason_type - need new reason type for updates of stockcurrent
  p_sc_reason_type				 bigint;
 
BEGIN
--{"invoice" : "1", "action" : "ACCEPTED", "user" : "1", "system" : "ERP", "point" : "12", "cashbox":"12"}  ERP/POS

-- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE
-- 1-Закуп(добавление), -1-Продажа, 2-Возврат на склад, -2-Возврат, -3-Списание, 4-Перемещение

  SELECT (invoice)::json into p_invoice;

		p_invoice_in := cast(p_invoice->>'invoice' as bigint);
		p_point_in   := cast(p_invoice->>'point' as bigint);
    p_action_in	 := upper(p_invoice->>'action');
    p_cashbox		 := cast(nullif(p_invoice->>'cashbox','') as bigint);

		-- Проверка статуса инвойса
		SELECT status, stockfrom, stockto, type, counterparty, createdate INTO p_status, p_stockfrom, p_stockto, p_type_invoice, p_counterparty, p_createdate
		  FROM invoices
			  WHERE invoicenumber = p_invoice_in
				  FOR UPDATE;
		IF upper(p_status) = 'CANCELED' THEN
		  result := json_build_object('code','error','text','Данная накладная была отменена!');
      return next;
		  return;
    ELSIF upper(p_status) = 'FORMATION' AND p_invoice->>'system' <> 'ERP' THEN
		  result := json_build_object('code','error','text','Данная накладная находится на стадии формирования!');
      return next;
		  return;
		ELSIF p_cashbox IS NULL THEN
			result := json_build_object('code','error','text','Требуется идентификатор кассы!');
      return next;
		  return;
		ELSIF p_status IS NULL THEN
			result := json_build_object('code','error','text','Данной накладной не существует!');
      return next;
		  return;
		ELSIF upper(p_status) not in ('ACCEPTED','DECLINE') AND upper(p_action_in) in ('ACCEPTED','DECLINE') THEN
		-- Обновление статуса накладной(инвойса)
			UPDATE invoices
		    SET status = p_action_in, system = p_invoice->>'system', approver = cast(p_invoice->>'user' as bigint), approvedate = now()
			    WHERE invoicenumber = p_invoice_in;
		END IF;
		
		-- Проверка передаваемого статуса
		IF p_action_in = 'ACCEPTED' THEN
		  p_stock_act := p_stockto;
		ELSIF p_action_in = 'DECLINE' THEN
			p_stock_act := p_stockfrom;
    ELSE	
			result := json_build_object('code','error','text','Некорректный идентификатор действия!');
      return next;
		  return;
		END IF;
		
		SELECT company INTO p_company
			FROM points
				WHERE id = p_point_in;
		
    -- Только для перемещения/добавления товара между складами
		IF (p_type_invoice in ('1','2') AND upper(p_status) not in ('ACCEPTED','DECLINE')) THEN
      FOR r IN (				  
					SELECT s.product,case when coalesce(coalesce(p2.unitsprid,p.unitsprid),1) <> 3 then l.units else 0 end as units,
						l.stock,l.attributes,l.newprice,l.stockto,l.purchaseprice, 
						coalesce(coalesce(p2.unitsprid,p.unitsprid),1) as unitsprid,
						l.wholesale_price
					  FROM invoicelist l 
						  LEFT JOIN stockcurrent s on (s.id = l.stock and s.company = l.company)
								LEFT JOIN products p on (p.id = l.stock and p.company = l.company)
								LEFT JOIN products p2 on (p2.id = s.product and p2.company = s.company)
									WHERE l.invoice = p_invoice_in
										AND l.company = p_company
	    ) 
		  LOOP
					
					p_list_exist := true;

					IF p_type_invoice = '1' THEN
						-- Перемещение
					  p_reason_type := '4';
					 -- 20230522
					 p_sc_reason_type := '400';
					 --
						p_product			:= r.product;
					ELSE
						-- Добавление
						p_reason_type := '1';
						-- 20230522
						p_sc_reason_type := '100';
						--
						p_product			:= r.stock;
						
						-- Привязка товара к поставщику
						INSERT INTO counterparty2product(counterparty,product,company)
			       SELECT p_counterparty, p_product, p_company
					     WHERE NOT EXISTS (select 1 from counterparty2product where counterparty = p_counterparty and product = p_product and company = p_company)
			      ON CONFLICT (counterparty,product,company) DO NOTHING;

					END IF;

			    -- Увеличиваем количество на складе в который перемещаем
          IF p_action_in = 'DECLINE' THEN
						-- Пока не используется (один фиг требует доработки)
			      IF p_type_invoice <> 2 THEN
						  UPDATE stockcurrent
				        SET units = units + r.units
					        WHERE id = r.stock
										AND company = p_company;
						END IF;
          ELSE
						IF coalesce(r.unitsprid,1) <> 3 THEN
							-- 20230520 assign p_sc_units_before
							SELECT units 
					        		FROM stockcurrent into p_sc_units_before
					        			WHERE id = r.stockto
											AND company = p_company;
							UPDATE stockcurrent
								SET units = units + r.units
									WHERE id = r.stockto
										AND company = p_company
											RETURNING units INTO 
							-- 20230724 fixing stock movement
										       p_units_after;
						   
						   p_sc_units_after := p_units_after;
						   -- 20230724 fixing stock movement
						  
							-- 20230520 Запись в дневник - only changes to stockcurrent
							INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,sc_units_before,sc_units_after,comments)
										VALUES(now(),
									----16.06.2023	
									--	p_reason_type,
									p_sc_reason_type,
									----16.06.2023	
								p_stockto,p_product,r.units,r.newprice,r.attributes,p_invoice_in,p_company,r.purchaseprice,p_purchasedate,p_sc_units_before,p_sc_units_after,'stockcurrent changed by invoice_processing line 172');
						-- Расчет для услуг					
						ELSE
							-- 20230520 assign p_sc_units_before
							--p_sc_units_before := 0;
							-- Обнуление на стоке
							UPDATE stockcurrent
								SET units = 0
									WHERE id = r.stockto
										AND company = p_company
											RETURNING units INTO p_sc_units_after;		
							-- Обнуление партионного учета				
						  UPDATE stockcurrent_part
								SET units = 0
									WHERE product = p_product
										AND attributes =  r.attributes
											AND point = p_stockto
												AND company = p_company;
							IF NOT FOUND THEN		
								INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
									VALUES(p_company,p_stockto,p_createdate,p_product,r.attributes,r.purchaseprice,0);
							END IF;				
							-- Запись в дневник
							INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,sc_units_after,scp_units_after,comments)
										VALUES(now(),p_reason_type,p_stockto,p_product,0,r.newprice,r.attributes,p_invoice_in,p_company,r.purchaseprice,p_purchasedate,p_sc_units_after,p_scp_units_after,'stockcurrent and stockcurrent_part units set to 0 since unitsprid=3 i.e. service by invoice_processing line190');				
						END IF;
						UPDATE storeprices
							SET price = r.newprice, wholesale_price = r.wholesale_price
								WHERE store = p_point_in
									AND stock = r.stockto
										AND company = p_company;
						
						p_units_before := p_units_after - r.units;
						p_isminus := false;
						p_move_units := r.units;
						
					  -- Для расчета партионного учета(Заполнение минусовых значений)
						IF p_units_before < 0 AND coalesce(r.unitsprid,1) <> 3 THEN
							p_isminus := true;
							FOR z IN(SELECT date, units, purchaseprice
												FROM stockcurrent_part
													WHERE company = p_company
														AND point = p_stockto
														AND product = p_product
														AND attributes = r.attributes
														AND units < 0
															ORDER BY date, purchaseprice)
							LOOP				
								-- 20230520 calculate p_units_before
		    					p_scp_units_before   := coalesce (z.units,0);
		    				    -- 20230520 logger
								--raise WARNING 'Minus values p_scp_units_before = %, p_scp_units_after = %', p_scp_units_before, p_scp_units_after;
								IF p_move_units = 0 THEN				
									EXIT;					
								ELSIF z.units > -p_move_units OR (-p_move_units = z.units) THEN		
									UPDATE stockcurrent_part
										SET units = 0
											WHERE product = p_product
												AND attributes =  r.attributes
												AND point = p_stockto
												AND company = p_company
												AND date = z.date
												AND purchaseprice = z.purchaseprice
												AND units < 0
													-- 20230520 calculate p_scp_units_after
								        			RETURNING units INTO p_scp_units_after;
								  -- 20230520 logger
								  --raise WARNING 'Minus values p_scp_units_before = %, p_scp_units_after = %', p_scp_units_before, p_scp_units_after;
								  p_move_units := p_move_units + z.units;
									-- Создаем запись в таблице перемещений, либо возвращаем на исходный склад, либо перемещаем на новый
									INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
										VALUES(now(),p_reason_type,p_stock_act,p_product,-z.units,r.newprice,r.attributes,p_invoice_in,p_company,z.purchaseprice,z.date,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by invoice_processing line 243');
								ELSIF (-p_move_units > z.units) THEN					
									UPDATE stockcurrent_part
										SET units = units + p_move_units
											WHERE product = p_product
												AND attributes =  r.attributes
												AND point = p_stockto
												AND company = p_company
												AND date = z.date
												AND purchaseprice = z.purchaseprice
												AND units < 0
													-- calculate p_scp_units_after
								        			RETURNING units INTO p_scp_units_after;			
									-- Создаем запись в таблице перемещений, либо возвращаем на исходный склад, либо перемещаем на новый
									INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
										VALUES(now(),p_reason_type,p_stock_act,p_product,p_move_units,r.newprice,r.attributes,p_invoice_in,p_company,z.purchaseprice,z.date,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by invoice_processing line 258');
									p_move_units := 0;	
								END IF;
							END LOOP;
						END IF;
						--------------------------------------------------------------
						-- Для расчета партионного учета(Обычный расчет)
						-- Убрал условие "p_units_after > 0 AND" чтобы и при нулевом добавленом товаре создавалась запись
						IF p_reason_type = 1 AND /*p_units_after > 0 AND*/ /*p_move_units <> 0 AND*/ coalesce(r.unitsprid,1) <> 3 THEN
							-- 20230520 logger
							--raise WARNING 'reason_type = 1 logger 1 p_scp_units_before = %, p_scp_units_after = %', p_scp_units_before, p_scp_units_after;
							--  20230520 assign p_scp_units_before
							SELECT units 
					        		FROM stockcurrent_part into p_scp_units_before 
					        		WHERE stockcurrent_part.point = p_stockto
										AND stockcurrent_part.date = p_createdate
										AND stockcurrent_part.product = p_product
										AND stockcurrent_part.attributes = r.attributes
										AND stockcurrent_part.company = p_company
										AND stockcurrent_part.purchaseprice = r.purchaseprice;
							-- 20230520 logger
							--raise WARNING 'reason_type = 1 logger 2 p_scp_units_before = %, p_scp_units_after = %', p_scp_units_before, p_scp_units_after;
							-- Добавление
							INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
								VALUES(p_company,p_stockto,p_createdate,p_product,r.attributes,r.purchaseprice,case when p_isminus then p_move_units else r.units end)
									--RETURNING date INTO p_purchasedate
									-- 20230520 assign p_scp_units_after
									--returning units into p_scp_units_after
							ON CONFLICT (company,point,date,product,attributes,purchaseprice)
							DO UPDATE
								SET units = stockcurrent_part.units + case when p_isminus then p_move_units else r.units end
									WHERE stockcurrent_part.point = p_stockto
										AND stockcurrent_part.date = p_createdate
										AND stockcurrent_part.product = p_product
										AND stockcurrent_part.attributes = r.attributes
										AND stockcurrent_part.company = p_company
										AND stockcurrent_part.purchaseprice = r.purchaseprice
							RETURNING date 
								INTO p_purchasedate; 
							--  20230520 assign p_scp_units_after
							SELECT units 
					        		FROM stockcurrent_part into p_scp_units_after
					        		WHERE stockcurrent_part.point = p_stockto
										AND stockcurrent_part.date = p_createdate
										AND stockcurrent_part.product = p_product
										AND stockcurrent_part.attributes = r.attributes
										AND stockcurrent_part.company = p_company
										AND stockcurrent_part.purchaseprice = r.purchaseprice;
							-- 20230520 logger
							--raise WARNING 'reason_type = 1 logger 3 p_scp_units_before = %, p_scp_units_after = %', p_scp_units_before, p_scp_units_after;
							-- Создаем запись в таблице перемещений, либо возвращаем на исходный склад, либо перемещаем на новый
							INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
								VALUES(now(),p_reason_type,p_stock_act,p_product,case when p_isminus then p_move_units else r.units end,r.newprice,r.attributes,
													p_invoice_in,p_company,r.purchaseprice,p_purchasedate,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by invoice_processing line 311');				
						ELSIF p_reason_type = 4 AND p_units_after > 0 AND p_move_units <> 0 /*AND r.unitsprid <> 3*/ THEN					
							FOR g IN(SELECT purchaseprice, purchasedate, units
											   FROM stockdiary s
												   WHERE s.reason = -4
													   AND s.point = p_stockfrom
														 AND s.date::date >= p_createdate
														 AND s.product = p_product
														 AND s.attributes = r.attributes
														 AND s.company = p_company
														 AND s.invoice = p_invoice_in
															ORDER BY s.date)
							LOOP
								IF p_isminus AND (p_move_units > g.units OR p_move_units = g.units) THEN
									p_move_units_2 := g.units;
									p_move_units 	 := p_move_units - p_move_units_2;
								ELSIF p_isminus AND p_move_units < g.units THEN
									p_move_units_2 := p_move_units;
									p_move_units 	 := 0;
								ELSIF p_isminus AND p_move_units = 0 THEN	
									EXIT;
								ELSE
									p_move_units_2 := g.units;
								END IF;
								--  20230520 assign p_scp_units_before
								SELECT units 
					        		FROM stockcurrent_part into p_scp_units_before 
					        		WHERE stockcurrent_part.point = p_stockto
											AND stockcurrent_part.date = g.purchasedate
											AND stockcurrent_part.product = p_product
											AND stockcurrent_part.attributes = r.attributes
											AND stockcurrent_part.company = p_company
											AND stockcurrent_part.purchaseprice = g.purchaseprice;
								-- Перемещение
								INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
									VALUES(p_company,p_stockto,g.purchasedate,p_product,r.attributes,g.purchaseprice,p_move_units_2)
								ON CONFLICT (company,point,date,product,attributes,purchaseprice)
								DO UPDATE
									SET units = stockcurrent_part.units + p_move_units_2
										WHERE stockcurrent_part.point = p_stockto
											AND stockcurrent_part.date = g.purchasedate
											AND stockcurrent_part.product = p_product
											AND stockcurrent_part.attributes = r.attributes
											AND stockcurrent_part.company = p_company
											AND stockcurrent_part.purchaseprice = g.purchaseprice;
								--  20230520 assign p_scp_units_after
								SELECT units 
					        		FROM stockcurrent_part into p_scp_units_after
					        		WHERE stockcurrent_part.point = p_stockto
											AND stockcurrent_part.date = g.purchasedate
											AND stockcurrent_part.product = p_product
											AND stockcurrent_part.attributes = r.attributes
											AND stockcurrent_part.company = p_company
											AND stockcurrent_part.purchaseprice = g.purchaseprice;
								-- Создаем запись в таблице перемещений, либо возвращаем на исходный склад, либо перемещаем на новый
								INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate,scp_units_before,scp_units_after,comments)
									VALUES(now(),p_reason_type,p_stock_act,p_product,p_move_units_2,r.newprice,r.attributes,p_invoice_in,
														p_company,g.purchaseprice,g.purchasedate,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by invoice_processing line 368');
							END LOOP;
						END IF;					
					END IF;
		  END LOOP;

			IF NOT p_list_exist THEN
			  result := json_build_object('code','error','text','Детализация накладной(инвойса) не доступна!');
        return next;
		    return;
			END IF;

		END IF;

  -- Удаление сообщения для точки
  DELETE FROM systemmessage s
	  WHERE s.point = p_point_in
		  AND s.invoice = p_invoice_in
			  AND (s.type_message = p_type_invoice or s.type_message = 1) -- для списания (подмена на перемещение для поса)
				  AND s.cashbox = p_cashbox;

	result := json_build_object('code','success','text',p_point_in||' '||p_invoice_in||' '||p_type_invoice||' '||p_cashbox);
	return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;
END;


$$;


ALTER FUNCTION public.invoice_processing(invoice json, OUT result json) OWNER TO postgres;

--
-- TOC entry 682 (class 1255 OID 16511)
-- Name: invoice_product_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.invoice_product_add(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

-- Сервис вызывается для добавления товара в накладную при приемке и редактировании. Не подойдет для списания, перемещения и т.д
DECLARE

	aa															record;
	p_company           						bigint;
	invoice_object      						json;
	product_object      						json;
	p_code				       						varchar;
	p_text				       						varchar;
	p_error			       							varchar;
	p_stockfrom		  	 							bigint;
	p_status					   						varchar;
	p_invoice_in				 						bigint;
	p_product_id			 						bigint;
	p_is_new_prod			 							boolean := false;
	p_check						 							varchar;
	p_amount_in 			   						float4;
	p_newprice 			   							float4;
	p_staticprice		   							float4;
	p_attributes_in		 							bigint;
	p_attributes_ex									bigint;
	p_unitsprid				 							bigint;
	p_unitsprid_old		 							bigint;
	p_prod_category		 							bigint;
	p_prod_taxid		 		 						bigint;
	p_brand													bigint;
	p_bonusrate											integer;
	p_prod_cnofea			 							varchar;
	p_prod_changes			 						boolean := false;
	p_exist_records		 							integer := 0;
	p_updateallprodprice_compare 		boolean;
	p_warning												varchar;
	p_category											bigint;
	p_count_attr_in									smallint;
	p_count_attr_ex									smallint;
	p_nds														boolean := false;	
	p_hot														integer;
	p_isdelete											boolean;
	p_isdelete_old									boolean;
	p_scale													bigint;
	p_name													varchar;
	p_piece													boolean;
	p_pieceinpack										integer;
	p_pieceprice										float4;
	p_piece_old											boolean;
	p_pieceinpack_old								integer;
	p_type													integer;
	attr_items    									json;
	product_count 									int;
	product_dopcount 									int;
	product_spr_attributes 					bigint;
	attrlist_count 									int;
	p_wholesale_price								float4;
	func_res					 							record;
	p_numpor    integer;
 
BEGIN
	
  -- { "invoice" : "12", "type" : "1", "user" : "1", "scale":0, "stockcurrentfrom" : 
  --   [{"id" : 111, "amount" : "500", "newprice" : "500", "wholesale_price":"400", "attributes" : "12","purchaseprice" : "1", "bonusrate" : 12,
	--		"code" : "1", "name" : "Бублики", "category" : "12", "taxid" : "0", "brand" : "Apple", "cnofea" : "Пока ХЗ", "SKU":"ХЗ", "reason" : "Потому-что-гладиолус", "updateprice" : false, "type": 1, "unitsprid": 1, "isdelete":false, "hotkey":12,     "piece":false, "pieceinpack":0, "pieceprice":0 }]}

  -- STATUSES: FORMATION/IN_PROCESS/ACCEPTED/DECLINE/CANCELED

	SELECT (inf)::json into invoice_object;

	p_invoice_in := cast(invoice_object->>'invoice' as bigint);
	p_scale			 := cast(coalesce(nullif(trim(invoice_object->>'scale'),''),'0') as bigint);

  SELECT code, text INTO p_code, p_text
	FROM get_company(invoice_object->>'user');
  
	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
    return next;
		return;
	END IF;
		
	SELECT case when certificatenum is null then false else true end INTO p_nds
	FROM companies
	WHERE id = p_company;

	-- Подтягивание склада, с которого будет производится списание
	SELECT stockfrom, status INTO p_stockfrom, p_status
	FROM invoices
	WHERE invoicenumber = p_invoice_in
	FOR UPDATE;
		
	IF p_status IN ('ACCEPTED','DECLINE') THEN
		result := json_build_object('code','exception','text','Указанная накладная уже обработана!');
		return next;
		return;
  ELSIF p_status = 'IN_PROCESS' THEN
		result := json_build_object('code','exception','text','Указанная накладная находится в обработке!');
		return next;
		return;
	ELSIF p_status = 'CANCELED' THEN
		result := json_build_object('code','exception','text','Указанная накладная была отменена!');
		return next;
		return;
	END IF;

	FOR product_object IN SELECT * FROM json_array_elements((invoice_object)->'stockcurrentfrom')
  LOOP 
		
		p_product_id  := cast(product_object->>'id' as bigint);
		p_amount_in		  := cast(trim(product_object->>'amount') as double precision);
    p_category			:= coalesce(cast(product_object->>'category' as bigint),0);
		p_unitsprid			:= coalesce(cast(product_object->>'unitsprid' as bigint),1);
		p_prod_changes  := false;
		p_hot						:= cast(nullif(trim(product_object->>'hotkey'),'') as integer);
		p_isdelete			:= cast(coalesce(nullif(trim(product_object->>'isdelete'),''),'false') as boolean);
		p_code					:= trim(product_object->>'code');
		p_name					:= trim(product_object->>'name');
		-- Для "распоковываемых товаров"
		p_piece					:= cast(coalesce(nullif(trim(product_object->>'piece'),''),'false') as boolean);
		p_pieceinpack		:= case when p_piece then cast(coalesce(product_object->>'pieceinpack','0') as bigint) else 0 end;
		p_pieceprice		:= case when p_piece then cast(coalesce(product_object->>'pieceprice','0') as double precision) else 0 end;
		p_attributes_in := cast(product_object->>'attributes' as bigint);
			
		IF p_piece AND p_unitsprid NOT IN (2,16,17) THEN
			RAISE SQLSTATE 'S0007';
		END IF;
			
		-- Проверка на НДС для клиентов не являющихся плательщиками НДС
		IF (product_object->>'taxid')::bigint = 1 AND NOT p_nds THEN
			RAISE SQLSTATE 'S0003';
		END IF;
			
			-- Пример приходящего значения json
			-- [{"code":3,"value":"","name":"Цвет"},{"code":2,"value":"","name":"Срок годности"}] 

		-- Если аттрибут все равно NULL (Потому что attrlist  null), чтобы поле атрибут могло принять значение 
		IF p_attributes_in IS NULL 
			THEN p_attributes_in := 0;
		END IF;
			
		SELECT count(*) INTO p_exist_records
			FROM invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND attributes = p_attributes_in
							AND company = p_company;
			
		-- необходимо проверить на дублирование по имени все новые товары.
		
		
		SELECT COUNT(*) INTO product_count FROM products where code = p_code and company = p_company and deleted = false;
		
		---14.07.2022
		SELECT COUNT(*) INTO product_dopcount FROM products_barcode where barcode = p_code and company = p_company and product = p_product_id;
		IF product_dopcount = 0 THEN
		---14.07.2022
		
			IF product_count = 0 THEN
				SELECT COUNT(*) INTO product_count FROM products where "lower"(name) = "lower"(p_name) and company = p_company and deleted = false;
					IF product_count > 0 THEN
				  		RAISE SQLSTATE 'S0010';
					END IF;
			END IF;
		
		---14.07.2022
		END IF;
		---14.07.2022
	
		-- 23.03.202
		IF product_dopcount > 0 THEN
			--RAISE SQLSTATE 'S0010';
			product_count := 1;
		END IF;
	    -- 23.03.2023
			
		-- Если атрибуты удалены, тогда обнуляем лискод
		IF p_attributes_in > 0 THEN
			SELECT count(*) into attrlist_count from attrlist where listcode = p_attributes_in;
			IF attrlist_count = 0 THEN
				p_attributes_in := 0;
			END IF;
		END IF;
		
		
		
		IF p_attributes_in > 0 THEN
			IF product_count > 0 THEN
				-- Если товар в справочнике существует, и добавились атрибуты, надо проверить входящий листкод с листкодом в справочнике.
				-- Если совпадает, тогда надо сгенерить новый листкод.
				SELECT attributes INTO product_spr_attributes FROM products WHERE code = p_code AND company = p_company;
				IF (product_spr_attributes = p_attributes_in) THEN
					INSERT INTO attributelistcode(id,company)
					VALUES(nextval('attributelistcode_id_seq'::regclass),p_company)
					RETURNING id INTO p_attributes_in;
				END IF;
			END IF;
			
			DELETE FROM attrlist WHERE listcode = p_attributes_in;
			-- [{code: 123, value: "белый", name: "цвет"}, {code: 122, value: "2.0", name: "Объем"}]
			FOR attr_items IN select * from json_array_elements(cast(product_object->>'attrlist'as json))
			LOOP
				INSERT INTO attrlist(listcode,value,attribute,istemp,company)
				VALUES(p_attributes_in,attr_items->>'value',cast(attr_items->>'code'as bigint),true,p_company);
			END LOOP;
		END IF;
			
		
		IF product_count = 0 THEN -- new product
				
			-- Подтягивание бонуса, если есть у категории товаров
			SELECT coalesce(bonusrate,0) INTO p_bonusrate
				FROM categories
					WHERE id = p_category;		
				
			-- Проверка наличия дубля кода в данной накладной
			SELECT p.id INTO p_product_id
				FROM products_temp p
					LEFT JOIN invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.code = p_code
								AND p."attributes" = p_attributes_in;
			
			IF FOUND THEN
				RAISE SQLSTATE 'S0005';
			END IF;
				
			-- Проверка наличия дубля имени в данной накладной
			SELECT p.id INTO p_product_id
				FROM products_temp p
					LEFT JOIN invoicelist i on (i.stock = p.id and i.company = p.company and i.invoice = p_invoice_in)
						WHERE p.company = p_company
							AND p.name = p_name
								AND p."attributes" = p_attributes_in;
				
				IF FOUND THEN
					RAISE SQLSTATE 'S0006';
				END IF;				
				
			-- Добавление в темповую таблицу
			INSERT INTO products_temp
				(code,name,category,taxid,brand,cnofeacode,company,bonusrate,type,unitsprid,isdiscount, 
				piece,pieceinpack,attributes_json,attributes)
			VALUES(p_code,p_name,p_category,cast(product_object->>'taxid' as bigint),
				cast(coalesce(trim(product_object->>'brand'),'0') as bigint),trim(product_object->>'cnofea'),p_company,p_bonusrate,
				cast(coalesce(trim(product_object->>'type'),'0') as integer),p_unitsprid,case when p_category = -1 then false else true end,
				p_piece,p_pieceinpack,cast(product_object->>'attrlist' as json),p_attributes_in)
				RETURNING id INTO p_product_id;
			
			p_is_new_prod := true;	

		ELSE
			p_is_new_prod := false;
			--flipflop
			SELECT category, taxid, cnofeacode, coalesce(brand,0), bonusrate, unitsprid, deleted, piece, pieceinpack, type 
				INTO p_prod_category, p_prod_taxid, p_prod_cnofea, p_brand, p_bonusrate, 
					p_unitsprid_old, p_isdelete_old, p_piece_old, p_pieceinpack_old, p_type
						FROM products
							WHERE id = p_product_id;
						
			-- Проверка на изменение значений в справочнике продуктов
			IF (p_prod_category <> cast(product_object->>'category' as bigint)) or 
			(p_prod_taxid <> cast(product_object->>'taxid' as bigint)) or 
			(coalesce(p_prod_cnofea,'') <> (coalesce(trim(product_object->>'cnofea'),''))) or (p_brand <> cast(coalesce(trim(product_object->>'brand'),'0') as bigint)) or 
			(p_unitsprid_old <> p_unitsprid) or 
			(p_isdelete_old <> p_isdelete) or 
			(p_piece <> p_piece_old) or 
			(p_pieceinpack <> p_pieceinpack_old) THEN
				
				/*НДС можно менять для весовых товаров*/
				IF (p_prod_category = -1 AND p_prod_taxid = cast(product_object->>'taxid' as bigint))	THEN
					RAISE SQLSTATE 'S0004';
				END IF;					
				
				p_prod_changes := true;
			ELSE
				p_prod_changes := false;
			END IF;
						
		END IF;

			
		SELECT updateallprodprice INTO p_updateallprodprice_compare
			FROM invoicelist
				WHERE invoice = p_invoice_in
					AND stock = p_product_id
						AND company = p_company
							AND attributes = p_attributes_in;
		
		IF cast(product_object->>'updateprice' as boolean) AND p_updateallprodprice_compare THEN
			RAISE SQLSTATE 'S0001';  
		ELSIF cast(product_object->>'updateprice' as boolean) THEN
			p_warning := 'Был добавлен товар с признаком обновления на всех точках вне зависимости от атрибутов, в списке уже есть данный товар - цена продажи будет изменена при обработке!';
		ELSIF p_updateallprodprice_compare THEN
			p_warning := 'В связи с тем, что в накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов - цена продажи будет изменена при обработке на указанную ранее!';
		END IF;

		
		-- Проверка набора атрибутов (только добавление) проверяется на дублирование.
		IF (p_attributes_in <> '0' AND p_attributes_in IS NOT NULL) THEN					
			SELECT count(listcode) INTO p_count_attr_in
				FROM attrlist a
					WHERE company = p_company
						AND listcode = p_attributes_in;
			
			FOR aa IN (
				SELECT attributes as attr
					FROM stockcurrent
						WHERE company = p_company
							AND product = p_product_id
								AND point = p_stockfrom
									AND attributes <> 0
				UNION
				SELECT attributes as attr
					FROM invoicelist
						WHERE invoice = p_invoice_in
							AND company = p_company
								AND stock = p_product_id
									AND attributes <> 0
										ORDER BY attr					 
			)
			LOOP		
				SELECT count(a2.listcode), a2.listcode INTO p_count_attr_ex, p_attributes_ex
					FROM attrlist a
						INNER JOIN attrlist a2 on (a2.attribute = a.attribute and a2.value = a.value and a2.company = a.company and a2.listcode = aa.attr and a2.istemp = false)
							WHERE a.company = p_company
								AND a.listcode = p_attributes_in
									GROUP BY a2.listcode;
				
				IF p_count_attr_ex = p_count_attr_in THEN
					p_attributes_in := p_attributes_ex;
					EXIT;
				END IF;					
			END LOOP;
					
		END IF;
				
		-- flipflop
		-- условие для подтягивания цены из таблицы со статичными ценами для соответстующих товаров
		p_newprice = cast(trim(product_object->>'newprice') as double precision);
		
		IF p_is_new_prod = false THEN
			SELECT s.price INTO p_staticprice 
				FROM product_static_prices s
					INNER JOIN products p ON p.id = s.product AND p.isstaticprice = true 
						WHERE s.company = p_company and s.product = p_product_id;
		
			IF p_staticprice is not null and p_staticprice < p_newprice THEN
				RAISE SQLSTATE 'S0002';  
			END IF;
		END IF;
				
		-- p_wholesale_price = cast(coalesce(product_object->>'wholesale_price',0) as double precision);
		p_wholesale_price = coalesce(cast(product_object->>'wholesale_price' as double precision),0);
		
		 ------07.09.2022
			 select max(numpor)+1 into p_numpor from invoicelist where invoice=p_invoice_in and company=p_company 
			 and stock<>p_product_id ;
			 ------07.09.2022

		--flipflop
		INSERT INTO invoicelist
		(invoice,stock,units,newprice,attributes,purchaseprice,newprod,sku,comments,prodchanges,updateallprodprice,company,hotkey,"scale",pieceprice,attributes_json,wholesale_price
		------07.09.2022
							,numpor 		  
						------07.09.2022
		)
		VALUES(p_invoice_in,p_product_id,p_amount_in,p_newprice, p_attributes_in, cast(trim(product_object->>'purchaseprice') as double precision),p_is_new_prod,trim(product_object->>'SKU'), --	NEW CODE
		trim(product_object->>'reason'), case when p_prod_changes then cast(product_object->>'category' as varchar) ||','||cast(product_object->>'taxid' as varchar) 
		||','|| cast(trim(coalesce(product_object->>'cnofea','')) as varchar)||','||cast(coalesce(trim(product_object->>'brand'),'0') as varchar)||','||p_bonusrate::varchar
		||','||p_unitsprid::varchar||','||p_isdelete::varchar||','||p_piece::varchar||','||p_pieceinpack::varchar
		else null end, cast(product_object->>'updateprice' as boolean), p_company, p_hot, p_scale, p_pieceprice,cast(product_object->>'attrlist' as json),p_wholesale_price
		------07.09.2022
					   ,coalesce(p_numpor,1) 
					------07.09.2022	  
			  );
		
		IF p_attributes_in <> '0' AND p_attributes_in IS NOT NULL THEN
			UPDATE attrlist 
				SET istemp = false
					WHERE listcode = p_attributes_in
						AND company = p_company;
		END IF;

	END LOOP;

  result := json_build_object('code','success','text',p_product_id,'note',p_warning);
  return next;
		
	EXCEPTION
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','exception','text','В накладной(инвойсе) уже присутствует данный товар с признаком обновления на всех точках вне зависимости от атрибутов!');
			return next;
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','exception','text','Цена данного товара превышает предельную цену!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
			return next;	
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','exception','text','Нельзя изменять товар категории "Весовые товары"!');
			return next;		
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким штрих-кодом!');
			return next;
		WHEN SQLSTATE 'S0006' THEN
			result := json_build_object('code','exception','text','В данной накладной уже присутствует товар с таким наименованием!');
			return next;	
		WHEN SQLSTATE 'S0007' THEN
			result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
			return next;
		WHEN SQLSTATE 'S0008' THEN
			result := json_build_object('code','exception','text','Для добавления сертификатов перейдите во вкладку "Подарочные сертификаты"!');
			return next;				
		WHEN SQLSTATE 'S0009' THEN
			result := json_build_object('code','exception','text','Ошибка при сохранении партийных характеристик!');
			return next;
		WHEN SQLSTATE 'S0010' THEN
			result := json_build_object('code','exception','text','В системе уже присутствует товар с таким наименованием!');
			return next;
	
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			IF p_check = 'invoicelist_pkey' THEN
				result := json_build_object('code','exception','text','Данный товар уже добавлен в накладную!');
			ELSIF p_check = 'prod_name_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким наименованием ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSIF p_check = 'prod_code_temp_idx' THEN 
				result := json_build_object('code','exception','text','Накладная(инвойс) с добавлением товара с таким кодом ожидает обработки! Требуется сначала обработать активную накладную!');
			ELSE
				result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			END IF;

    return next;
		
END;
$$;


ALTER FUNCTION public.invoice_product_add(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 683 (class 1255 OID 16513)
-- Name: logging(jsonb, jsonb, character varying, character varying); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.logging(req jsonb, resp jsonb, func character varying, ip character varying, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_result   jsonb;
	p_error 	 varchar;
  p_log_id	 bigint;
  p_req			 jsonb;
BEGIN

  SELECT (resp)::jsonb into p_result;
  SELECT (req)::jsonb into p_req;

  INSERT INTO action_logs(date, function, request, response, error, "user", host)
	  VALUES (now(), func, req, resp, case when p_result->func->>'code' like '%error%' then p_result->func->>'code' else null end, 
																		case when p_req->>'user' is not null then cast(p_req->>'user' as bigint) else null end, ip);

  result := json_build_object('code','success','text','');
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;$$;


ALTER FUNCTION public.logging(req jsonb, resp jsonb, func character varying, ip character varying, OUT result json) OWNER TO postgres;

--
-- TOC entry 769 (class 1255 OID 16514)
-- Name: new_erpusr_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.new_erpusr_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 p_company         bigint;
 json_object       json;
 erpusr_object     json;
 p_code				  	 varchar;
 p_text				  	 varchar;
 p_name_c       	 varchar;
 p_erp_usr_c	 		 bigint;
 p_error           varchar;
 p_erp_usr		 		 bigint;
 p_check					 varchar;
 p_roles					 json;
 p_cashbox_exist   boolean := false;
p2 bigint; 

BEGIN

	-- {"user" : 1, "erpusr" : {"id" : "1", "login" : "bubka@mail.ru", "name" : "Вася Пупкин", "pass" : "Кадабра", "iin: : "Кадабра", "status" : "ACTIVE", "roles" : [{"id":"1"}], "accesses" : [{ "id":1, "code":"fre213" }],
	-- Статусы: ACTIVE, DISMISS, BLOCKED

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

  SELECT (json_object)->'erpusr' into erpusr_object;

    p_erp_usr := cast(erpusr_object->>'id' as bigint); -- p_erp_usr наш id

    SELECT u.name, u.id INTO p_name_c, p_erp_usr_c
			FROM erp_users u	
				LEFT JOIN companies c on (c.id = u.company)
					WHERE c.id = p_company
					  AND u.iin = erpusr_object->>'iin'
						  AND u.status = 'ACTIVE';
    IF p_erp_usr_c IS NOT NULL AND (p_erp_usr IS NULL OR /*p_name_c <> erpusr_object->>'name'*/p_erp_usr_c<>p_erp_usr) THEN
			  result := json_build_object('code','error','text','Пользователь ERP с таким ИИН уже существует в системе!');
        return next;
		    return;
		END IF;
		
		IF lower(erpusr_object->>'login') = 'demo' THEN
			result := json_build_object('code','error','text','Для пользователя "Demo" внесение изменений запрещено!');
      return next;
		  return;
		END IF;

	  IF p_erp_usr IS NULL then
	  
	        -------17.05.2023
	       if erpusr_object->>'erp_user_id' is not NULL then
           SELECT setval('erp_users_id_seq', cast(erpusr_object->>'erp_user_id' as integer)-1) into p2;
           end if;
	       -------17.05.2023
	  
	  
			--INSERT INTO erp_users(login,name,pass,iin,company,status,accesses) 
        INSERT INTO erp_users(login,name,pass,iin,company,status,accessesu) 
	      VALUES(lower(erpusr_object->>'login'),erpusr_object->>'name',erpusr_object->>'pass',erpusr_object->>'iin',p_company,'ACTIVE', cast(erpusr_object->>'accesses' as json))
				  RETURNING id INTO p_erp_usr;
		ELSIF erpusr_object->>'pass' IS NOT NULL AND erpusr_object->>'accesses' IS NOT NULL THEN
			UPDATE erp_users
			 -- SET name = erpusr_object->>'name', pass = erpusr_object->>'pass', iin = erpusr_object->>'iin' , status = erpusr_object->>'status', accesses = cast(erpusr_object->>'accesses' as json)
			SET name = erpusr_object->>'name', pass = erpusr_object->>'pass', iin = erpusr_object->>'iin' , status = erpusr_object->>'status', accessesu = cast(erpusr_object->>'accesses' as json)	
              WHERE id = p_erp_usr;
		ELSE
			UPDATE erp_users 
			  SET name = erpusr_object->>'name', iin = erpusr_object->>'iin', status = erpusr_object->>'status'
				  WHERE id = p_erp_usr;
		END IF;
    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'erpusr_log_idx' THEN
		 result := json_build_object('code','error','text','Пользователь с таким логином уже существует в системе!');
   ELSE
	   result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;
$$;


ALTER FUNCTION public.new_erpusr_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 684 (class 1255 OID 16515)
-- Name: nomenclature_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.nomenclature_add(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 data_object 	 	   		json;
 p_error							varchar;
 p_check							varchar;
 p_category_id				bigint; 
 p_brand_id						bigint;
 p_product_id					bigint; 
 p_company						bigint;
 p_point_id 					bigint;
 p_stock_id						bigint;
 p_stock  						bigint;
 p_units              bigint;
 p_cparty_id					bigint;	
 p_code 							varchar;
 p_pricebuy           DOUBLE precision;
 r                  	record;
 p_errMessage 				varchar;

BEGIN
	-- {"company": 9, "stock":37, "taxid":0, "cpartyid":0, "data": {"Category":"GECO", "Code": "1234567890124", "Name": "Тестовый товар 2", "Brand": "RECORD", "PriceBuy":500, "PriceSell":650, "Units":10}}

	p_company := cast(trim(inf->>'company') as bigint);
	p_stock := case when (inf->>'stock') is not null then cast(trim(inf->>'stock') as bigint) else 0 end; -- склад точки
	p_cparty_id := case when (inf->>'cpartyid') is not null then cast(trim(inf->>'cpartyid') as bigint) else 0 end;
	
	SELECT (inf)->'data' into data_object;
	
	p_code := cast(trim(data_object->>'Code') as VARCHAR);
	p_units := case when (data_object->>'Units') is not null then cast(trim(data_object->>'Units') as bigint) else 0 end;
	p_pricebuy := case when (data_object->>'PriceBuy') is not null then cast(trim(data_object->>'PriceBuy') as double precision) else 0 end;
	
	if ((data_object->>'Category') is not null) then
		select c."id" into p_category_id from categories c where c.company = p_company and c."name" = trim(data_object->>'Category');		
	else	
		p_category_id := 0;
	end if;
	if (p_category_id) is null then
		INSERT INTO categories(name,deleted,company)
				VALUES (trim(data_object->>'Category'),false,p_company)
					RETURNING id INTO p_category_id;
	end if;
	
	if ((data_object->>'Brand') is not null) then		
		select b."id" into p_brand_id from brands b where b.brand = trim(data_object->>'Brand');
	else
		p_brand_id := 0;
	end if;
	if (p_brand_id) is null then	
		INSERT INTO brands(brand,manufacturer)
				VALUES (trim(data_object->>'Brand'), trim(data_object->>'Brand'))
					RETURNING id INTO p_brand_id;
	end if;
	
	select id into p_product_id from products where company = p_company and code = p_code;
	
	if p_product_id is null then
	
		INSERT INTO products(company,taxid,category,code,name,brand)
				VALUES(p_company,cast(trim(inf->>'taxid') as bigint),p_category_id,p_code,trim(data_object->>'Name'),p_brand_id)
					RETURNING id INTO p_product_id;
		
		INSERT INTO product_accounting(date,attributes,company,purchaseprice,units,product)
			VALUES(CURRENT_TIMESTAMP,0,p_company,p_pricebuy,p_units,p_product_id);
		
		if p_cparty_id > 0 then
			INSERT INTO counterparty2product(counterparty,product,company)
			VALUES(p_cparty_id,p_product_id,p_company);
		end if;
	
	end if;
	
	if (p_stock = 0) then
		for r in(select p."id" from points p where p.company = p_company and p.point_type = 1) -- склад точки
		LOOP
			INSERT INTO stockcurrent(company,point,attributes,product,units)
			VALUES(p_company,r.id,0,p_product_id,p_units)
				RETURNING id INTO p_stock_id;
				
			-- Для расчета партионного учета
			INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
								VALUES(p_company,r.id,current_date,p_product_id,0,p_pricebuy,p_units)
							ON CONFLICT (company,point,date,product,attributes,purchaseprice)
							DO UPDATE
								SET units = stockcurrent_part.units + p_units
									WHERE stockcurrent_part.point = r.id
										AND stockcurrent_part.date = current_date
										AND stockcurrent_part.product = p_product_id
										AND stockcurrent_part.attributes = 0
										AND stockcurrent_part.company = p_company
										AND stockcurrent_part.purchaseprice = p_pricebuy;
			--------------------------------------------------------------------------------------------	
	  
			select p.point into p_point_id from pointset p where p.stock = r.id; -- получаем торговую точку.
			
			INSERT INTO storeprices(store,company,stock,price)
				VALUES(p_point_id,p_company,p_stock_id,cast(trim(data_object->>'PriceSell') as double precision));
				
			INSERT INTO stockdiary(date,company,point,attributes,reason,units,price,product)
				VALUES(CURRENT_TIMESTAMP,p_company,r.id,0,5,p_units,cast(trim(data_object->>'PriceSell') as double precision),p_product_id);
		END LOOP;
	else
	
		select id into p_stock_id from stockcurrent where company = p_company and point = p_stock and product = p_product_id;
		if p_stock_id is null then
			INSERT INTO stockcurrent(company,point,attributes,product,units)
				VALUES(p_company,p_stock,0,p_product_id,p_units)
					RETURNING id INTO p_stock_id;
				
			-- Для расчета партионного учета
			INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
								VALUES(p_company,p_stock,current_date,p_product_id,0,p_pricebuy,p_units)
							ON CONFLICT (company,point,date,product,attributes,purchaseprice)
							DO UPDATE
								SET units = stockcurrent_part.units + p_units
									WHERE stockcurrent_part.point = p_stock
										AND stockcurrent_part.date = current_date
										AND stockcurrent_part.product = p_product_id
										AND stockcurrent_part.attributes = 0
										AND stockcurrent_part.company = p_company
										AND stockcurrent_part.purchaseprice = p_pricebuy;
			--------------------------------------------------------------------------------------------		
	  
			select p.point into p_point_id from pointset p where p.stock = p_stock;
		
			INSERT INTO storeprices(store,company,stock,price)
				VALUES(p_point_id,p_company,p_stock_id,cast(trim(data_object->>'PriceSell') as double precision));
			
			INSERT INTO stockdiary(date,company,point,attributes,reason,units,price,product)
				VALUES(CURRENT_TIMESTAMP,p_company,p_stock,0,5,p_units,cast(trim(data_object->>'PriceSell') as double precision),p_product_id);
		end if;
	end if;
	
    result := json_build_object('code','success','barcode',p_code);
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 if (POSITION('prod_code_idx' in SQLERRM) > 0) then p_errMessage := 'продукт с таким штрихкодом существует';
	 else if (POSITION('prod_name_idx' in SQLERRM) > 0) then p_errMessage := 'продукт с таким наименованием существует';
					else p_errMessage := SQLERRM;
				end if;
	 end if;
	 result := json_build_object('code','internal_error','barcode',p_code||'-'||p_errMessage,'text',SQLSTATE||':'||SQLERRM||':'||p_error);	 
   return next;

END;$$;


ALTER FUNCTION public.nomenclature_add(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 685 (class 1255 OID 16517)
-- Name: passreset(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.passreset(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $_$DECLARE

	p_user_id			bigint;
	p_error 	    varchar;
	p_inf		      json;

BEGIN
	-- {"company":12,"login":"user@mail.my"}
  p_inf := inf;

	IF p_inf->>'login' IS NULL THEN
	  result := json_build_object('code','error','text','Не указан логин!');
		return;
	ELSIF p_inf->>'company' IS NULL THEN
		result := json_build_object('code','error','text','Не указана компания!');
		return;
	END IF;
	
	UPDATE erp_users 
	  SET pass = '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW'
		  WHERE login = trim(p_inf->>'login') and company = cast(p_inf->>'company' as bigint) and status = 'ACTIVE'
			  RETURNING id INTO p_user_id;

	IF p_user_id IS NULL THEN
		result := json_build_object('code','error','text','Пользователь '||trim(p_inf->>'login')||' не найден!');
	ELSE
    result := json_build_object('code','success','text','');
	END IF;
	
  return next;
EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;
END;$_$;


ALTER FUNCTION public.passreset(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 686 (class 1255 OID 16518)
-- Name: plan_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.plan_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 p_company      bigint;
 json_object    json;
 cashbox_object json;
 p_code				  varchar;
 p_text				  varchar;
 p_type         integer;
 p_error				varchar;
 p_salesplanid  bigint;
 p_object				bigint;
 p_d_rate 			float4;
 p_m_rate 			float4;
 p_q_rate 			float4;
 p_y_rate 			float4;
 p_daily					float8;
 p_monthly				float8;
 p_quarterly			float8;
 p_yearly					float8;

BEGIN
	-- {"user" : 41, "plan" : {"object" : "3", "daily" : 50000, "monthly" : "100000", "quarterly" : "10", "deleted" : false, "yearly" : "10", "type" : "1","d_rate":1,"m_rate":1,"q_rate":1,"y_rate":2}}

	-- d_rate, m_rate, q_rate, y_rate - % ставка для расчета бонуса

	-- 1-сотрудник 2-касса 3-точка

	SELECT (inf)::json into json_object;
	SELECT code, text INTO p_code, p_text
		FROM get_company(json_object->>'user');
	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
		return next;
		return;
	END IF;

  SELECT (json_object)->'plan' into cashbox_object;
	
	p_d_rate := cast(coalesce(nullif(cashbox_object->>'drate',''),'0') as float4);
	p_m_rate := cast(coalesce(nullif(cashbox_object->>'mrate',''),'0') as float4);
	p_q_rate := cast(coalesce(nullif(cashbox_object->>'qrate',''),'0') as float4);
	p_y_rate := cast(coalesce(nullif(cashbox_object->>'yrate',''),'0') as float4);
	
	p_daily := cast(coalesce(nullif(cashbox_object->>'daily',''),'0') as float8);
	p_monthly := cast(coalesce(nullif(cashbox_object->>'monthly',''),'0') as float8);
	p_quarterly := cast(coalesce(nullif(cashbox_object->>'quarterly',''),'0') as float8);
	p_yearly := cast(coalesce(nullif(cashbox_object->>'yearly',''),'0') as float8);
	
	p_type := cast(cashbox_object->>'type' as integer);
	p_object := cast(cashbox_object->>'object' as bigint);
	
	IF NOT cast(cashbox_object->>'deleted' as boolean) THEN
		UPDATE salesplan 
			SET daily = p_daily, monthly = p_monthly, quarterly = p_quarterly, yearly = p_yearly, 
				type = p_type, drate = p_d_rate, mrate = p_m_rate, qrate = p_q_rate, yrate = p_y_rate
		WHERE object = p_object
		RETURNING object INTO p_salesplanid;

		IF p_salesplanid IS NULL THEN
			INSERT INTO salesplan(object,daily,monthly,quarterly,yearly,type,drate,mrate,qrate,yrate)
				VALUES(p_object,p_daily, p_monthly,p_quarterly,p_yearly,p_type,p_d_rate,p_m_rate,p_q_rate,p_y_rate);
		END IF;
	ELSE
		DELETE FROM salesplan WHERE object = p_object;
	END IF;

	result := json_build_object('code','success','text','');
	return next;

EXCEPTION WHEN OTHERS THEN
	RAISE NOTICE 'internal_error: %', SQLERRM;
	GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	return next;
END;
$$;


ALTER FUNCTION public.plan_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 687 (class 1255 OID 16519)
-- Name: pluproducts_create(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.pluproducts_create(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$
DECLARE 
	
	json_object json;
	
	p_name text;
	p_tax smallint;
	
	p_company bigint;
	p_user bigint;
	
	p_deleted boolean;
	p_product bigint;
	p_exist_name text;
	
	p_check text;
	p_error text;
	
	r record;
	p_invoicenumber bigint;
	
	p_barcode text := '';
	p_code text;
	p_prefix bigint;
	p_prefix_text text;
	p_nulls text;
	
	p_code_in text;
	p_product_in bigint;
	
BEGIN

	-- inf = {"name":"puc","company":"124","tax":0}
	SELECT inf::json INTO json_object;
	
	
	p_name := coalesce(trim(cast(json_object->>'name' as text)),'');
	p_tax  := coalesce(cast(json_object->>'tax' as smallint),0);
	p_company := coalesce(cast(json_object->>'company' as bigint),0);
	p_user := coalesce(cast(json_object->>'user' as bigint),0);
	p_code := coalesce(cast(json_object->>'code' as text),'');
	p_nulls := '';
	
	
	IF p_name = '' THEN
		raise sqlstate 'S0001';
	END IF;
		
	IF p_company = 0 THEN
		raise sqlstate 'S0002';
	END IF;
	
	IF p_code = '' THEN
		p_code = '1';
	END IF;
	
	SELECT productsweight_prefix INTO p_prefix FROM companies WHERE id = p_company;

	-- Проверка по имени		
	SELECT "name", id INTO p_exist_name, p_product
		FROM products
			WHERE lower(name) = lower(p_name) AND company = p_company;
			
	
	SELECT id, code INTO p_product_in, p_code_in 
		FROM products 
			WHERE id = p_product AND code = p_code ;
	
	IF p_product_in IS NOT NULL OR p_code_in IS NOT NULL THEN
		raise sqlstate 'S0005';
	END IF;
	
	--IF FOUND THEN
	IF p_exist_name IS NOT NULL THEN
			raise sqlstate 'S0003';
	END IF;
	
	-- Генерируем штрихкод
		FOR p_count in 1.. (5 - length(p_code)) LOOP
			p_nulls = p_nulls || '0';
		END LOOP;
		
		IF p_prefix = 0 THEN 
			p_prefix_text = p_prefix || '0';
		ELSE
			p_prefix_text = p_prefix::text;
		END IF;
		
		p_barcode := p_prefix_text || p_nulls || p_code;
		
	
	select nextval('products_id_seq') into p_product;
	
	/*
	INSERT INTO plu_products
		(id,name,code,unit_spr,taxid,company,deleted,submitdate,scale,hotkey)
			VALUES
				(p_product,p_name,'0000000',6,p_tax,p_company,false,current_date,0,0);
	*/			
		-- Добавление товара в справочник
		INSERT INTO products
			(id,code,name,category,taxid,company,brand, bonusrate, type, isdiscount, isstaticprice, unitsprid, deleted, piece,pieceinpack, details, attributes)
				VALUES
					(p_product,p_barcode,p_name,-1,p_tax,p_company,0,0,0,false,false,6,false,false,0,0,0);
		
			-- Рассылка изменений Справочника на все кассы			
			FOR r IN (
				SELECT p.id as point, b.id as cashbox
					FROM companies c
						LEFT JOIN points p on (p.company = c.id) 
							LEFT JOIN cashboxes b on (b.point = p.id)
								WHERE company = p_company 
									AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
										AND p.status = 'ACTIVE'
											AND c.status = 'ACTIVE'
												AND b.deleted = false
													AND b.isengaged = true
														ORDER BY p.id
		  )
			LOOP		
				-- Создание и заполнение накладной(инвойса) для обновления справочников
				INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
					VALUES(now(),p_user,'IN_PROCESS',p_company,r.point,r.point,3)
						RETURNING invoicenumber INTO p_invoicenumber;
							
				INSERT INTO invoicelist(invoice,stock,attributes,units,newprice,purchaseprice,delusr,updateallprodprice,newprod,company) 
					VALUES(p_invoicenumber,p_product,0,0,0,0,false,false,true,p_company);					

				-- Формирование системного сообщения для терминалов для обновления справочников
				INSERT INTO systemmessage(point,invoice,type_message,cashbox)
					VALUES(r.point,p_invoicenumber,3,r.cashbox);	
							
			END LOOP;	
		
	

	res = json_build_object('code','success','text','ok');
	RETURN;

	
	EXCEPTION 
	
		WHEN SQLSTATE'S0001' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указано наименование товара!' );
			RETURN;
	
 		WHEN SQLSTATE'S0002' THEN
 			res := json_build_object ( 'code', 'exception', 'text', 'Не указана компания!' );
 			RETURN;
		
		WHEN SQLSTATE'S0003' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Весовой товар с таким названием уже cуществует!' );
			RETURN;
	
		WHEN SQLSTATE'S0004' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Удаленный весовой товар с таким названием cуществует в системе! Если вы желает продолжить, необходимо его восстановить');
			RETURN;
		
		WHEN SQLSTATE'S0005' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Товар с таким названием или кодом уже cуществует в системе!');
			RETURN;
		
	
		WHEN OTHERS THEN
			RAISE NOTICE'internal_error: %',
			SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
		RETURN;
	
END;
$$;


ALTER FUNCTION public.pluproducts_create(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 688 (class 1255 OID 16521)
-- Name: pluproducts_del(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.pluproducts_del(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company           					bigint;
 p_product													bigint;
 p_attributes									bigint;
 p_error			       					varchar;
 p_check						 					varchar;
 p_result				 							json;
 p_func_code					 				varchar;
 p_func_text					 				varchar;
 p_user												bigint;
 p_invoice										bigint;
 r														record;
 i														record;
 p_scale											bigint;
 
BEGIN

/*
{   
		user: 1,
		company: 15,
    product: 1
}
*/
	
		p_company	:= coalesce(cast(trim(inf->>'company') as bigint),0);
		--p_user				 := cast(trim(inf->>'user') as bigint);
		p_product	:= coalesce(cast(trim(inf->>'id') as bigint),0);
		p_scale	:= cast(trim(inf->>'scale') as bigint);
		p_attributes := 0;
			
		-- Проверки на пустоту необходимых параметров
		IF p_company = 0 THEN
			RAISE SQLSTATE 'S0001';
		END IF;
		
		IF p_product = 0 THEN		
			RAISE SQLSTATE 'S0002';
		END IF;
		
		-- Проставление признака удаления
		--UPDATE products
		--	SET deleted = true
		--		WHERE id = p_product
		--			AND company = p_company;
					
		-- Удаляем связь
		DELETE FROM pluproducts_scale WHERE product = p_product AND company = p_company AND scale = p_scale;
		
		--UPDATE plu_products
		--	SET deleted = true
		--		WHERE id = p_product
		--			AND company = p_company;
	
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0004';
		END IF;
			
		FOR r IN (
			SELECT s.id as stockid, s.units, s.point as stock, s.product, s.attributes
				FROM stockcurrent s
					INNER JOIN points p on (p.id = s.point and p.company = s.company and p.status = 'ACTIVE')
						WHERE s.product = p_product
							AND s.attributes = p_attributes
							AND s.company = p_company
								ORDER BY stockid
		)
		LOOP
		
				UPDATE stockcurrent
					SET units = 0
						WHERE id = r.stockid
							AND company = p_company;
							
				IF NOT FOUND THEN
					RAISE SQLSTATE 'S0004';
				END IF;
				
				FOR i IN (
					SELECT date, units, purchaseprice
						FROM stockcurrent_part
							WHERE company = p_company
								AND point = r.stock
									AND product = r.product
										AND attributes = r.attributes
											AND (units > 0 OR units < 0)
												ORDER BY date, purchaseprice
				)
				LOOP			
					UPDATE stockcurrent_part
							SET units = 0
								WHERE product = r.product
									AND attributes =  r.attributes
									AND point = r.stock
									AND company = p_company
									AND date = i.date
									AND purchaseprice = i.purchaseprice
									AND case when i.units > 0 then units > 0 else units < 0 end;							
					-- Оставляем записи в журнале перемещений товара
					INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate)
						VALUES(now(),'-3',r.stock,r.product,i.units,0,r.attributes,null,p_company,i.purchaseprice,i.date);		
				END LOOP;
				
				--------------------------
				-- Создание инвойса для обновления количества на кассе (Чтобы кассе было понятно, что товар удалили)		
				INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
					VALUES(0,'IN_PROCESS',p_company,r.stock-1,r.stock-1,8,now()) 
						RETURNING invoicenumber INTO p_invoice;
						
				-- Вызов функции, записывающей позиции в инвойс по обновлению количества
				INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company,delete)
					VALUES(p_invoice,r.stockid,0,0,0,0,false,r.stockid,false,false, p_company,true);
					
				FOR i IN (
					SELECT id
						FROM cashboxes
							WHERE point = r.stock-1
								AND deleted = false
									AND isengaged = true
				)
				LOOP
				
					INSERT INTO systemmessage(point,invoice,type_message,cashbox)
						VALUES(r.stock-1,p_invoice,8,i.id);
				
				END LOOP;
				
				--------------------------
				
		END LOOP;
	 
		result := json_build_object('code','success','text','');
		return next;
	
	 EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Не указана компания!');
		 return next; 	 
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Идентификатор товара не был передан!');
		 return next;		 
	 WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code',p_func_code,'text',p_func_text);
		 return next; 
	 WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','При удалении товара возникли проблемы! Пожалуйста, попробуйте чуть позже.');
		 return next;	 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   return next;
		 
END;$$;


ALTER FUNCTION public.pluproducts_del(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 689 (class 1255 OID 16523)
-- Name: pluproducts_delete(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.pluproducts_delete(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$
DECLARE 
	p_error text;
	p_check text;
	
	p_company bigint;
	p_product bigint;
	json_object json;
	
	p_deleted boolean;
	
BEGIN

	-- inf = {"product":"1","company":"124","code":"1200003","delete":false}
	SELECT inf::json INTO json_object;
	
	
	p_product := coalesce(cast(json_object->>'id' as bigint),0);
	p_company := coalesce(cast(json_object->>'company' as bigint),0);
	
	
	IF p_product = 0 THEN
		raise sqlstate 'S0001';
	END IF;
	
	IF p_company = 0 THEN
		raise sqlstate 'S0002';
	END IF;
	
	SELECT deleted INTO p_deleted FROM products WHERE id = p_product AND company = p_company;
		
	IF p_deleted THEN
		raise sqlstate 'S0003';
	END IF;
	
	IF p_deleted IS NULL THEN
		raise sqlstate 'S0004';
	END IF;
	
	IF p_deleted = false THEN
		UPDATE products
			SET deleted = true
				WHERE id = p_product AND company = p_company;
	END IF;
		
			
	res = json_build_object('code','success','text','ok');
	RETURN;
	



	
	EXCEPTION 
		
		WHEN SQLSTATE'S0001' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указана идентификатор товара!' );
			RETURN;
	
		WHEN SQLSTATE'S0002' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указана компания!' );
			RETURN;
	
		WHEN SQLSTATE'S0003' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Весовой товар, который вы пытаетесь удалить уже удален!' );
			RETURN;
	
 		WHEN SQLSTATE'S0004' THEN
 			res := json_build_object ( 'code', 'exception', 'text', 'Удаляемый весовой товар не найден!' );
 			RETURN;
		
	
		WHEN OTHERS THEN
			RAISE NOTICE'internal_error: %',
			SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
		RETURN;
	
END;
$$;


ALTER FUNCTION public.pluproducts_delete(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 690 (class 1255 OID 16524)
-- Name: pluproducts_update(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.pluproducts_update(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$
DECLARE 
	
	p_company bigint;
	p_code text;
	json_object json;
	p_error text;
	p_name text;
	p_exist_name text;
	p_exist_code text;
	p_tax smallint;
	p_check text;
	p_deleted boolean;
	p_product bigint;
	p_product_in bigint;
	
BEGIN

	-- inf = {"product":"1","tax":0,"company":124}
	SELECT inf::json INTO json_object;
	
	p_product_in := coalesce(cast(json_object->>'id' as bigint),0);
	p_tax  := cast(json_object->>'tax' as smallint);
	p_company := coalesce(cast(json_object->>'company' as bigint),0);
	p_name := json_object->>'name';
	
	
	IF p_product_in = 0 THEN
		raise sqlstate 'S0001';
	END IF;
	
	IF p_name = '' THEN
		raise sqlstate 'S0002';
	END IF;
		
	IF p_company = 0 THEN
		raise sqlstate 'S0003';
	END IF;
	
	IF p_tax IS NULL THEN
		SELECT taxid INTO p_tax 
			FROM products 
				WHERE id = p_product 
					AND company = p_company;
	END IF;
	
	-- Проверка на null
	IF p_name IS NULL THEN
		SELECT "name" INTO p_name 
			FROM products 
				WHERE id = p_product 
					AND company = p_company;
	END IF;
	
		-- Проверка по имени		
	SELECT "name", id, deleted INTO p_exist_name, p_product, p_deleted
		FROM products
			WHERE lower(name) = lower(p_name) AND company = p_company;
	
	IF p_exist_name IS NOT NULL AND p_product != p_product_in THEN
		IF p_deleted  THEN
-- 			UPDATE plu_products
-- 				SET deleted = false, taxid = p_tax
-- 					WHERE id = p_product AND name = p_name
-- 						AND company = p_company;
			raise sqlstate 'S0004';
		
		ELSE
			raise sqlstate 'S0005';
		END IF;
	
	END IF;
	
	UPDATE products
		SET name = p_name, taxid = p_tax
			WHERE id = p_product_in and company = p_company;
		

			res = json_build_object('code','success','text','ok');
			RETURN;
	
	EXCEPTION 
		
		WHEN SQLSTATE'S0001' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указан идентификатор товара!' );
			RETURN;
			
		WHEN SQLSTATE'S0002' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указано наименование товара!' );
			RETURN;
	
 		WHEN SQLSTATE'S0003' THEN
 			res := json_build_object ( 'code', 'exception', 'text', 'Не указана компания!' );
 			RETURN;
		
		WHEN SQLSTATE'S0004' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Удаленный весовой товар с таким названием cуществует в системе! Если вы желает продолжить, необходимо его восстановить' );
			RETURN;
		
		WHEN SQLSTATE'S0005' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Весовой товар с таким названием уже cуществует!' );
			RETURN;
		
		WHEN OTHERS THEN
			RAISE NOTICE'internal_error: %',
			SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
		RETURN;
	
END;
$$;


ALTER FUNCTION public.pluproducts_update(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 691 (class 1255 OID 16525)
-- Name: pluproducts_updatehotkey(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.pluproducts_updatehotkey(info json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE json_object json;

	products_object json;
	p_company bigint;
	p_check varchar;
	p_error varchar;
	p_existinghotkey int4;
	p_hotkey int4;
	p_product bigint;
	p_point bigint;
	p_scale bigint;
	p_stockid bigint;
	p_user bigint;

BEGIN
	--{"company": 15, "user": "m.asanova", "pointid": 169, "products": [{barcode:"3"}]}
 SELECT (info)::json INTO json_object;

	p_company := coalesce(cast(trim(json_object->>'company') as bigint),0);
	p_hotkey := coalesce(cast(trim(json_object->>'hotkey') as int4),0);
	p_product := coalesce(cast(trim(json_object->>'id') as bigint),0);
	p_point := cast(trim(json_object->>'point') as bigint);
	p_scale := coalesce(cast(trim(json_object->>'scale') as bigint),0);
	--p_stockid := cast(trim(json_object->>'stockcurrentid') as bigint);
	--p_user := cast(trim(json_object->>'user') as varchar);

	IF p_product = 0 THEN
		raise sqlstate 'S0001';
	END IF;

	IF p_hotkey = 0 THEN
		raise sqlstate 'S0002';
	END IF;

	IF p_scale = 0 THEN
		raise sqlstate 'S0003';
	END IF;

	IF p_company = 0 THEN
		raise sqlstate 'S0004';
	END IF;

	-- IF p_id = 0 THEN
	-- 	raise sqlstate 'S0005';
	-- END IF;

 
	--Проверка на наличие горячей клавиши
	SELECT	hotkey INTO	p_existinghotkey
		FROM pluproducts_scale p 
				WHERE scale = p_scale 
					AND company = p_company 
						AND hotkey = p_hotkey;
				
	IF p_existinghotkey IS NULL THEN
		UPDATE pluproducts_scale
			SET hotkey = p_hotkey
				WHERE product = p_product AND company = p_company AND scale = p_scale;
	ELSE
		raise sqlstate 'S0005';
	END IF;	
			
	--Обновить горячую клавишу у товара
	--update stockcurrent set hotkey = p_hotkey where company = p_company and id = p_stockid and product = p_id;

	res := json_build_object('code', 'success', 'text', 'Горячая клавиша обновлена успешно!');
	return next;

	EXCEPTION

	WHEN sqlstate 'S0001' THEN 
		res := json_build_object('code', 'error', 'text', 'Не указан идентификатор товара!');
		RETURN NEXT;
	
	WHEN sqlstate 'S0002' THEN 
		res := json_build_object('code', 'error', 'text', 'Не указана горячая клавиша!');
		RETURN NEXT;

	WHEN sqlstate 'S0003' THEN 
		res := json_build_object('code', 'error', 'text', 'Весы не найдены!');
		RETURN NEXT;

	WHEN sqlstate 'S0004' THEN 
		res := json_build_object('code', 'error', 'text', 'Не указана компания!');
		RETURN NEXT;
		
	WHEN sqlstate 'S0005' THEN 
		res := json_build_object('code', 'error', 'text', 'Данный номер на весах уже занят!');
		RETURN NEXT;

	-- 
	WHEN OTHERS THEN 
		raise notice 'internal_error: %', sqlerrm;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		RETURN NEXT;

-- return next;
-- when sqlstate 'S0002' then res := json_build_object('code', 'error', 'text', 'Не указана компания!');
-- return next;
-- 
-- when sqlstate 'S0004' then res := json_build_object('code', 'error', 'text', 'Не указан идентификатор товара на складе!');
-- return next;
-- 
-- when sqlstate 'S0006' then res := json_build_object('code', 'error', 'text', 'Данный номер на весах уже занят!');
-- return next;
-- when sqlstate 'S0007' then res := json_build_object('code', 'error', 'text', 'Торговая точка не найдена!');
-- return next;
-- ild_object('code', 'internal_error', 'text', sqlstate || ':' || sqlerrm || ':' || p_error);


END;

$$;


ALTER FUNCTION public.pluproducts_updatehotkey(info json, OUT res json) OWNER TO postgres;

--
-- TOC entry 692 (class 1255 OID 16526)
-- Name: points_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.points_add(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
 p_company       bigint;
 json_object     json;
 point_object    json;
 p_code				   varchar;
 p_text				   varchar;
 p_point_id	     bigint;
 p_error			   varchar;
 p_point_type_in bigint;
 p_stock_in			 bigint;
 p_is_minus			 boolean;
 p_count				 integer := 0;
 i							 record;
 p_new_stock		 bigint;

BEGIN

	-- {"user" : 1, "point" : { "name" : "Склад", "address" : "Пупкина 18", "point_type" : "1", "is_minus" : "1", "x" : "123", "y" : "234", "image" : ""}}

	SELECT (inf)::json into json_object;

    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;

  SELECT (json_object)->'point' into point_object;

		p_point_type_in := cast(point_object->>'point_type' as bigint);
		p_is_minus		  := case point_object->>'is_minus' when '1' then true else false end;

		SELECT count(id) INTO p_count
		  FROM points
			  WHERE company = p_company	
				  AND name = trim(point_object->>'name');
		IF p_count > 0 THEN
		  result := json_build_object('code','error','text','Точка с таким названием уже существует в рамках вашей компании!');
      return next;
		  return;
		END IF;

    INSERT INTO points(name,address,company,status,point_type,is_minus,x,y/*,image*/)
	    VALUES(trim(point_object->>'name'),trim(point_object->>'address'),p_company,'ACTIVE',p_point_type_in,
						   p_is_minus, point_object->>'x',point_object->>'y'/*,point_object->>'image'*/)
			  RETURNING id INTO p_point_id;

		IF p_point_type_in = '2' THEN
			INSERT INTO points(name,address,company,status,point_type,is_minus,x,y)
			  VALUES('Склад точки "'||(trim(point_object->>'name'))||'"',trim(point_object->>'address'),p_company,'ACTIVE','1',
						   p_is_minus, point_object->>'x',point_object->>'y')
				  RETURNING id INTO p_stock_in;
			INSERT INTO pointset(point,stock)
			  VALUES(p_point_id,p_stock_in);
			-------(Залипуха, чтобы на всех точках был stockid по сертификатам)
			FOR i IN (SELECT regexp_replace(name, '\D+', '', 'g') as balance, id
									FROM products
										WHERE type = 1
											AND company = 18
												AND regexp_replace(name, '\D+', '', 'g') <> '')
			LOOP
				INSERT INTO stockcurrent(point,product,units,attributes,company)
					VALUES(p_stock_in,i.id,0,0,p_company)
						RETURNING id INTO p_new_stock;
				INSERT INTO storeprices(store,stock,price,company)
					VALUES(p_point_id,p_new_stock,cast(i.balance as double precision),p_company);
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
					VALUES(p_company,p_stock_in,current_date,i.id,0,cast(i.balance as double precision),0);
			END LOOP;	
		END IF;

    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;   
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;


$$;


ALTER FUNCTION public.points_add(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 693 (class 1255 OID 16527)
-- Name: points_change(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.points_change(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company    bigint;
 json_object  json;
 point_object json;
 p_code				varchar;
 p_text				varchar;
 p_point_id	  bigint;
 p_error			varchar;
 p_name				varchar;
 p_point_in		bigint;
 p_name_in		varchar;
 p_status_in  varchar;
 p_stock_id		bigint;
 p_isminus		boolean;
 p_isminus_in boolean;
 p_status			varchar;
 p_invoice		bigint;
 r						record;
 p_point_type integer;
BEGIN
	-- {"user" : 1, "point" : { "id" : 1, "name" : "", "address" : "", "point_type" : "", "is_minus" : "", "x" : "", "y" : "", "image" : "", "status":"CLOSE"}}
	SELECT (inf)::json into json_object;
    SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;
  SELECT (json_object)->'point' into point_object;
		p_point_in   := cast(point_object->>'id' as bigint);
		p_name_in    := trim(point_object->>'name');
		p_status_in  := upper(trim(point_object->>'status'));
		p_isminus_in := case point_object->>'is_minus' when '1' then true else false end;
		SELECT name, is_minus, status, point_type INTO p_name, p_isminus, p_status, p_point_type
		  FROM points
			  WHERE id = p_point_in
				  AND company = p_company
					  AND status = 'ACTIVE';
		-- Нельзя редактировать Центральный склад				
		IF p_point_type = 0 THEN
			RAISE SQLSTATE 'S0001'; 
		END IF;
	  SELECT id INTO p_point_id
		  FROM points
			  WHERE name = p_name_in
				  AND company = p_company
					  AND status = 'ACTIVE';
		IF p_point_id IS NOT NULL AND upper(p_status_in) <> 'CLOSE' AND upper(p_name) <> upper(p_name_in) THEN
		  result := json_build_object('code','error','text','Точка с таким именем уже существует в рамках вашей компании!');
			return next;
			return;
		END IF;
    UPDATE points
		  SET name = p_name_in, address = trim(point_object->>'address'), status = upper(p_status_in),
					point_type = cast(point_object->>'point_type' as integer), is_minus = p_isminus_in,
					x = point_object->>'x', y = point_object->>'y'
			  WHERE id = p_point_in
					AND company = p_company;
		-- Узнаем ID склада
		SELECT p.id INTO p_stock_id
		  FROM points p
			  LEFT JOIN pointset s on (s.stock = p.id)
				  LEFT JOIN points p2 on (p2.id = s.point and p2.company = p.company)
					  WHERE p2.id = p_point_in
							AND p2.company = p_company;
		-- Удаление касс и пользователей касс при закрытии точки
    IF p_status_in = 'CLOSE' THEN
		  UPDATE cashboxes
			  SET deleted = true
				  WHERE point = p_point_in;
			UPDATE cashbox_users
			  SET deleted = true
				  WHERE point = p_point_in;
		END IF;
		-- При смене названия точки и адреса - нужно сменить и на привязанном складе
		UPDATE points
		  SET status = upper(p_status_in), name = 'Склад точки "'||p_name_in||'"', address = trim(point_object->>'address') 
			  WHERE id = p_stock_id
					AND company = p_company;
				
		-- Если произошла смена учета (в минус или нет)	отправляем обновление на POS
		IF p_isminus <> p_isminus_in THEN
			INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
			  VALUES(now(),0,'IN_PROCESS',p_company,p_point_in,p_point_in,9)
				RETURNING invoicenumber INTO p_invoice;
					
		  FOR r IN (
					SELECT id
					  FROM cashboxes
						  WHERE point = p_point_in
							  AND deleted = false
									AND isengaged = true
									  ORDER BY id
		  )
			LOOP
				INSERT INTO systemmessage(point,invoice,type_message,cashbox)
					VALUES(p_point_in,p_invoice,9,r.id);
			END LOOP;
			
		END IF;
		
    result := json_build_object('code','success','text','');
    return next;
		
EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Запрещено изменять данные Центрального склада!');
		 return next; 
	WHEN OTHERS THEN
		RAISE NOTICE 'internal_error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		return next;
END;

$$;


ALTER FUNCTION public.points_change(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 694 (class 1255 OID 16529)
-- Name: prices_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prices_management(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$

DECLARE 
	r record;
	stocks record;
	p_product bigint;
	p_point bigint;
	p_price float8;
	p_company bigint;
	p_type int;
	p_deleted boolean;
	p_user bigint;
	json_object json;
	p_check varchar;
	p_error varchar;
	p_invoice bigint;
	p_counterparty bigint;
	p_cashbox bigint;
	p_old_price float8;
	p_old_counterparty bigint;
	p_pieceprice float8;
	p_stock bigint;
	p_workdate timestamp;
	p_old_price_invoice float8;
	p_sell json;
	p_buy json;
	obj json;
	p_wholesale_price float8;
	p_old_wholesale_price float8;
	p_product_count bigint;
	p_counterparty_count smallint;
	p_counterparty_name text;
	p_price_text text;
	--p_check text;
	p_count smallint;
	p_wholesale_price_text text;
	l bigint;
	arr int[];
	p_product_update bigint;
	rec record;
	

	
BEGIN

	SELECT (inf)::json into json_object; 
	-- Приходящие параметры
	/*
	{
	"deleted":false,
	"user":42,
	"company":18,
	"point":"189",
	"sell":[{"id":"1","price":"100","counterparty":"1"},{"id":"2","price":"200","counterparty":"1"}],
	"buy":[{"id":"1","price":"100","counterparty":"1","wholesaple_price":"90"},{"id":"1","price":"100","counterparty":"1",,"wholesaple_price":"90"}]
	}
	*/
	-- 0 - Цена закупа, 1 - Цена продажи
	p_deleted := cast(json_object->>'deleted' as boolean);
	
	IF p_deleted IS NULL then
		raise sqlstate 'S0006';
	END IF;
						
	p_user := coalesce(cast(json_object->>'user' as bigint),0);
	p_company := coalesce(cast(json_object->>'company' as bigint),0);
	p_product := coalesce(cast(json_object->>'product' as bigint),0);
	p_counterparty := coalesce(cast(json_object->>'counterparty' as bigint),0);

	
	-- Если признак удаления true, тогда "удаляем"
	IF p_deleted THEN
		
		IF p_product = 0 THEN
			raise sqlstate 'S0001';
		END IF;
	
		IF p_counterparty = 0 THEN
			raise sqlstate 'S0002';
		END IF;
		
		
		DELETE FROM prices WHERE product = p_product AND counterparty = p_counterparty AND company = p_company; 
		
		res = json_build_object('code','success','text','deleted');
		RETURN;
		
	END IF;
	

	FOR obj IN SELECT * FROM json_array_elements(cast(json_object->>'buy' as json))
	LOOP
		p_product := coalesce(cast(obj->>'id' as bigint),0);
		p_price := coalesce(cast(obj->>'price' as float8),0);
		p_counterparty := coalesce(cast(obj->>'counterparty' as bigint),0);
		
	
		IF p_price = 0 THEN
			raise sqlstate 'S0003';
		END IF;
	
		IF p_price < 0 THEN
			raise sqlstate 'S0007';
		END IF;
			
		SELECT price, counterparty INTO p_old_price, p_old_counterparty
			FROM prices 
				WHERE product = p_product AND "type" = 0 AND company = p_company AND counterparty <> 0;
		
		if p_old_counterparty is not null then
			if p_counterparty <> p_old_counterparty then
				select "name" into p_counterparty_name from counterparties where id = p_old_counterparty;
				raise sqlstate 'S0004';
			end if;
		end if;
				
		SELECT count(*) into p_count
			FROM prices 
				WHERE product = p_product 
					AND company = p_company 
						AND "type" = 0 
							AND counterparty = p_counterparty; 
		
		IF p_count > 0 THEN
			UPDATE prices
				SET price = p_price
					WHERE product = p_product AND company = p_company AND counterparty = p_counterparty AND "type" = 0;
		ELSE
			INSERT INTO prices
				(product,price,point,userid,company,workdate,"type",counterparty,deleted)
					VALUES
						(p_product,p_price,0,p_user,p_company,CURRENT_TIMESTAMP,0,p_counterparty,false);
		END IF;
		
	END LOOP;
	
	FOR obj IN SELECT * FROM json_array_elements(cast(json_object->>'sell' as json))
	LOOP
		p_product := coalesce(cast(obj->>'id' as bigint),0);
		--p_price := coalesce(cast(obj->>'price' as float8),0);
		p_price_text := obj->>'price';
		p_counterparty := coalesce(cast(obj->>'counterparty' as bigint),0);
		p_wholesale_price := coalesce(cast(obj->>'wholesale_price' as float8),0);
		
		IF p_price_text IS NULL OR p_price_text = '' THEN
			raise sqlstate 'S0006';
		ELSE
			p_price := cast(p_price_text as float8);
		END IF;
		
		IF p_price < 0 THEN
			raise sqlstate 'S0007';
		END IF;
		
		IF p_wholesale_price < 0 THEN
			raise sqlstate 'S0007';
		END IF;
	
		-- Для отправления накладных на изменение цен для существующих товаров
		SELECT * INTO rec FROM stockcurrent 
			WHERE product = p_product AND company = p_company;
	
		-- Ложим в массив только товары имеющиеся на складе 
		IF rec IS NOT NULL THEN
			arr = arr || p_product;
		END IF;
		
		SELECT count(*) into p_count
			FROM prices 
				WHERE product = p_product 
					AND company = p_company 
						AND "type" = 1 
							AND counterparty = p_counterparty; 
		
		IF p_count > 0 THEN
			UPDATE prices
				SET price = p_price, wholesale_price = p_wholesale_price
					WHERE product = p_product AND company = p_company AND counterparty = p_counterparty AND "type" = 1;
		ELSE
			INSERT INTO prices
				(product,price,point,userid,company,workdate,"type",counterparty,deleted,wholesale_price)
					VALUES
						(p_product,p_price,0,p_user,p_company,CURRENT_TIMESTAMP,1,p_counterparty,false,p_wholesale_price);
		END IF;	
		
		SELECT workdate INTO p_workdate FROM prices WHERE product = p_product and company = p_company and "type" = 1;
		
		FOR r IN ( SELECT id FROM points WHERE company = p_company AND point_type = 2 )
		LOOP
							
			-- Создаем накладную для обновления цен на кассах
			INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
				VALUES(p_user,'IN_PROCESS',p_company,r.id,r.id,0,p_workdate) 
					RETURNING invoicenumber INTO p_invoice;
			
			-- Берем склад
			SELECT stock INTO p_point FROM pointset WHERE point = r.id;
				
			FOR stocks IN ( SELECT * FROM stockcurrent WHERE product = p_product AND company = p_company AND point = p_point AND units <> 0)
			LOOP
			 
				-- Старые цены для таблицы invoicelist
				SELECT price INTO p_old_price_invoice FROM storeprices WHERE stock = stocks.id;
				SELECT pieceprice INTO p_pieceprice FROM storeprices WHERE stock = stocks.id;
				
				-- Детали накладной
				INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,newprod,delusr,updateallprodprice,company, oldprice, pieceprice,wholesale_price)
					VALUES(p_invoice,stocks.id,0,0,p_price,false,false,true, p_company,p_old_price_invoice,p_pieceprice,p_wholesale_price);
						
				-- Обновление цен
				UPDATE storeprices
					SET price = p_price, pieceprice = p_pieceprice, wholesale_price = p_wholesale_price
						WHERE stock = stocks.id;
						
				-- Получаем кассу для отправления сообщения 
				SELECT id INTO p_cashbox FROM cashboxes WHERE point = r.id; 
				
				IF p_cashbox IS NOT NULL THEN
					-- Отправление сообщения
					INSERT INTO public.systemmessage(point, invoice, type_message, altinvoice, cashbox)
						VALUES (r.id, p_invoice, 0, null, p_cashbox);
				END IF;
			
				
			
			END LOOP;
						
			END LOOP;
	END LOOP; 
	
	
		
	

	res = json_build_object('code','success','text','ok');
	RETURN;
	
	EXCEPTION
		WHEN 	SQLSTATE 'S0001' THEN 
			res := json_build_object('code','exception','text','Не указан товар!');
			RETURN;
		WHEN 	SQLSTATE 'S0002' THEN 
			res := json_build_object('code','exception','text','Не указан поставщик при добавлении цены!');
			RETURN;
		WHEN 	SQLSTATE 'S0003' THEN 
			res := json_build_object('code','exception','text','Не указана цена закупки!');
			RETURN;
		WHEN 	SQLSTATE 'S0006' THEN 
			res := json_build_object('code','exception','text','Не указана цена реализации!');
			RETURN;
		WHEN 	SQLSTATE 'S0004' THEN 
			res := json_build_object('code','exception','text','У данного товара уже существует контрагент! ("'||p_counterparty_name||'")');
			RETURN;
		WHEN 	SQLSTATE 'S0005' THEN 
			res := json_build_object('code','exception','text','Не указана оптовая цена!');
			RETURN;
		WHEN 	SQLSTATE 'S0007' THEN 
			res := json_build_object('code','exception','text','Указана отрицательная цена!');
			RETURN;
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			res := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			--res := json_build_object('code','internal_error','text',SQLSTATE||':'||p_error);
			RETURN;
END;
$$;


ALTER FUNCTION public.prices_management(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 695 (class 1255 OID 16531)
-- Name: prod_xsls_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.prod_xsls_add(prod json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE 

 json_object json;

 item 		   json;

 p_id 			 bigint;

 p_company	 bigint;

 p_item_id   bigint;

 p_code			 varchar;

 p_text			 varchar;

 p_error		 varchar;

BEGIN



	 -- {"user" : 1, "products" : [{ "code" : 111, "name" : "Булочки", "pricebuy" : 100, "pricesell" : "200", "partnumber" : 1, "units" : 1}, 

		 --	 { "code" : 222, "name" : "Печеньки", "pricebuy" : 200, "pricesell" : "300", "partnumber" : 2, "units" : 2}]}



	SELECT (prod)::json into json_object;



		SELECT code, text INTO p_code, p_text

      FROM get_company(json_object->>'user');

    IF p_code = 'success' THEN

	    p_company := cast(p_text as bigint);

	  ELSE

		  result := json_build_object('code',p_code,'text',p_text);

      return next;

		  return;

	  END IF;

		  

	

  FOR item IN SELECT * FROM json_array_elements((json_object)->'products')

  LOOP 



		 SELECT id INTO p_item_id

		   FROM products

			  WHERE company = p_company

				  AND code = item->>'code';



     IF p_item_id IS NULL THEN



		   -- Запись в таблицу товаров

       INSERT INTO products(code,name,pricesell,category,taxid,iscom,isscale,company)

		     VALUES(item->>'code',item->>'name',cast(item->>'pricesell' as double precision),0,0,false,false,p_company)

			     RETURNING id INTO p_id;

		 

		   -- Запись свежачка с суммой покупки

		   INSERT INTO product_accounting(partnumber,purchaseprice,product,units,date)

		     VALUES(item->>'partnumber',cast(item->>'pricebuy' as double precision),p_id,cast(item->>'units' as double precision),now());



     END IF;

		



  END LOOP;



	result := json_build_object('code','success','text','');

  return next;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;







$$;


ALTER FUNCTION public.prod_xsls_add(prod json, OUT result json) OWNER TO postgres;

--
-- TOC entry 696 (class 1255 OID 16532)
-- Name: product_bonusrate_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.product_bonusrate_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 inf_object       json;
 bonusrate_object json;
 p_company				bigint;
 p_code				  	varchar;
 p_text				  	varchar;
 p_error			  	varchar;
 p_type						varchar;
 p_id							bigint;
 p_id_array				bigint[];
 p_bonusrate			float8 := 0;
 p_exist					boolean := false; 
 r								record;
 i                record;
 p_invoice				bigint;
 p_send_point			bigint := 0;
 p_user						bigint;
 p_exception			json;
BEGIN

	-- {"company" : 1, "user" : 1, "bonusrate" : { "type" : cat, "rate" : 12, "id" : 1, "exception": [{"id": 19735, "bonusrate": 0}]}}
	-- cat/prod   types

	SELECT (inf)::json into inf_object;
	
		p_company := cast(trim(inf_object->>'company') as bigint);
		p_user		:= cast(trim(inf_object->>'user') as bigint);

  SELECT (inf_object)->'bonusrate' into bonusrate_object;

		p_type 			:= lower(trim(bonusrate_object->>'type'));
		p_id	 			:= cast(trim(bonusrate_object->>'id') as bigint);
		p_bonusrate := cast(trim(bonusrate_object->>'rate') as double precision);
		
		-- Изменение по категории
		IF p_type = 'cat' THEN
			FOR r IN (
			  SELECT p.id as prod
				  FROM categories c
						INNER JOIN products p on (p.category = c.id)
							WHERE c.company = p_company
								AND c.id = p_id
			)
			LOOP			
				UPDATE products
					SET bonusrate = p_bonusrate
						WHERE id = r.prod
							AND company = p_company;						
				SELECT array_append(p_id_array, r.prod) INTO p_id_array;			
				p_exist := true;			
			END LOOP;			
			/*IF NOT p_exist THEN
				result := json_build_object('code','error','text','Ни одного товара не было найдено по указанной категории!');
				return next;
				return;
			END IF;*/
			UPDATE categories
				SET bonusrate = p_bonusrate
					WHERE company = p_company
						AND id = p_id;
		-- Изменение по товару
		ELSIF p_type = 'prod' THEN
			UPDATE products
				SET bonusrate = p_bonusrate
					WHERE id = p_id
						AND company = p_company
							RETURNING '{'||id||'}' INTO p_id_array;
			IF NOT FOUND THEN
				result := json_build_object('code','error','text','Указанный товар не найден!');
				return next;
				return;
			END IF;
		-- Отсечение кривых запросов
		ELSE
			result := json_build_object('code','error','text','Указан некорректный тип!');
			return next;
			return;
		END IF;
		
		-- Для товара с индивидуальным бонусным рейтингом
		FOR p_exception IN SELECT * FROM json_array_elements((bonusrate_object)->'exception') 
		LOOP
			UPDATE products
				SET bonusrate = cast(p_exception->>'bonusrate' as double precision)
					WHERE id = cast(p_exception->>'id' as bigint)
						AND company = p_company;
		END LOOP;
		
		-- Рассылка обновленной информации по кассам
		FOR i IN (
			SELECT p.id as point, b.id as cashbox
            FROM companies c
              LEFT JOIN points p on (p.company = c.id) 
                LEFT JOIN cashboxes b on (b.point = p.id)
                  WHERE company = p_company 
                    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
                      AND p.status = 'ACTIVE'
                        AND c.status = 'ACTIVE'
                          AND b.deleted = false
                            AND b.isengaged = true
                              ORDER BY p.id
		)
		LOOP
			
			IF p_send_point <> i.point THEN
				
				p_send_point := i.point;
				
			  INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
					VALUES(p_user,'IN_PROCESS',p_company,i.point,i.point,3,now()) 
						RETURNING invoicenumber INTO p_invoice;
				
			  IF p_id_array IS NOT NULL THEN
					FOREACH p_id IN ARRAY p_id_array
					LOOP
						INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company,prodchanges/*Чисто поржать*/)
							VALUES(p_invoice, p_id, 0, 0, false, false, true, p_company,',,,,'||p_bonusrate);
					END LOOP;
				END IF;
				
			END IF;
			
			INSERT INTO public.systemmessage(point, invoice, type_message, altinvoice, cashbox)
				VALUES (i.point, p_invoice, 3, null, i.cashbox);
				
		END LOOP;
		
    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;











$$;


ALTER FUNCTION public.product_bonusrate_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 697 (class 1255 OID 16534)
-- Name: productbonus_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productbonus_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 bonusprod_object 		 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_id									 bigint;
 p_check							 varchar;
BEGIN

	-- {"user" : 1, "bonusprod" : {"product" : 1, "type" : "", "value" : ""}}

	SELECT (inf)::json into json_object;

		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;  

  SELECT (json_object)->'bonusprod' into bonusprod_object;

	  INSERT INTO customers_bonuscards(telephone,cardnumber,lastname,company,firstname)
				VALUES (trim(customers_object->>'telephone'), trim(customers_object->>'cardnumber'), trim(customers_object->>'lastname'),p_company,
								  trim(customers_object->>'firstname'))
					RETURNING id INTO p_id;


    result := json_build_object('code','success','text','');
    return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;$$;


ALTER FUNCTION public.productbonus_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 698 (class 1255 OID 16535)
-- Name: productspr_create(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productspr_create(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company           					bigint;
 p_error			       					varchar;
 p_check						 					varchar;
 p_user												bigint;
 json_object       						json;
 products_object	 						json;
 p_name												varchar;
 p_bonusrate									integer;
 p_category										bigint;
 p_brand											bigint;
 p_taxid											bigint;
 p_unitsprid									bigint;
 p_code												varchar;
 p_piece											boolean;
 p_pieceinpack								integer;
 p_id													bigint; 
 p_cnofeacode									varchar; -- cnofeacode
 r                						record;
 p_count_prod				 					float8 := 0;
 p_send_point		 							bigint  := 0;
 p_invoicenumber	 						bigint;
 p_nds												boolean := false;
 p_details 										bigint;
 p_attributes 								bigint;
 
BEGIN

-- {"user":1,"company":1,"product":{"code":"", "name":"", "category":"", "taxid":"", "brand":"", "cnofeacode":"", "isdiscount":"", "isstaticprice":"", "unitsprid":"", "piece":"", "pieceinpack":"","details":"0","attributes":"0"}}

		SELECT (inf)::json into json_object;
		
			p_company	:= cast(json_object->>'company' as bigint);
			p_user 		:= cast(json_object->>'user' as bigint);
			
			IF p_company IS NULL OR p_user IS NULL THEN
				RAISE SQLSTATE 'S0001';
			END IF;
			
			SELECT case when certificatenum is null then false else true end INTO p_nds
				FROM companies
					WHERE id = p_company;
	
		SELECT (json_object)->'product' into products_object;
			
			p_name						:= nullif(trim(products_object->>'name'),'');
			p_code						:= nullif(trim(products_object->>'code'),'');
			p_category				:= cast(nullif(products_object->>'category','') as bigint);
			p_brand						:= cast(nullif(products_object->>'brand','') as bigint);
			p_taxid						:= cast(nullif(products_object->>'taxid','') as bigint);
			p_unitsprid				:= cast(nullif(products_object->>'unitsprid','') as bigint);
			p_piece						:= cast(nullif(products_object->>'piece','') as boolean);
			p_pieceinpack			:= cast(nullif(products_object->>'pieceinpack','') as integer);
			p_cnofeacode      := nullif(trim(products_object->>'cnofeacode'),'');
			
			p_details := case when products_object->>'details' is null then 0
									 else cast(nullif(products_object->>'details','') as bigint) end;
		 
			p_attributes := case when products_object->>'attributes' is null then 0
									 else cast(nullif(products_object->>'attributes','') as bigint) end;
			/*
			p_details 				:= case when products_object->'details' IS NULL then 
																cast(nullif(products_object->>'details','') as bigint)
															else 0 end;
			p_attributes 				:= case when products_object->'attributes' IS NULL then 
																cast(nullif(products_object->>'attributes','') as bigint)
															else 0 end;
			*/
			-- У товаров с возможностью разкомплектации строго ограниченные значения справочника
			IF p_piece AND p_unitsprid NOT IN (2,16,17) THEN
				RAISE SQLSTATE 'S0002';
			END IF;	
			-- Проверка на НДС для клиентов не являющихся плательщиками НДС
			IF p_taxid = 1 AND NOT p_nds THEN
				RAISE SQLSTATE 'S0003';
			END IF;
			
			-- Проверка по коду
				SELECT COUNT(code) INTO p_count_prod
				  FROM products
					  WHERE code = p_code
						  AND company = p_company
								AND deleted is FALSE; --OR company = 0;
				IF p_count_prod > 0 THEN
					RAISE SQLSTATE 'S0004';
				END IF;

				-- Проверка по имени
				SELECT COUNT(code) INTO p_count_prod
				  FROM products
					  WHERE name = p_name
						  AND company = p_company
								AND deleted is FALSE;
				IF p_count_prod > 0 THEN
					RAISE SQLSTATE 'S0005';
				END IF;
				
			-- Подтягивание бонуса, если есть у категории товаров
			SELECT coalesce(bonusrate,0) INTO p_bonusrate
				FROM categories
					WHERE id = p_category;	

			-- Добавление значения в справочник
			INSERT INTO products(code,name,category,taxid,brand,company,bonusrate,type,unitsprid,isdiscount,piece,pieceinpack,cnofeacode,details,attributes)
				VALUES(p_code,p_name,p_category,p_taxid,p_brand,p_company,p_bonusrate,0,p_unitsprid,case when p_category = -1 then false else true end,p_piece,p_pieceinpack,
				p_cnofeacode,p_details,p_attributes)
					RETURNING id INTO p_id;
			
			DELETE FROM invoicelist WHERE stock IN(
				SELECT id FROM products_temp WHERE company = p_company AND code = p_code OR NAME = p_name
			);
			
			DELETE FROM products_temp WHERE company = p_company AND code = p_code OR NAME = p_name;
			
			-- 05.09.2022
			-- add to "products_barcode" table
			INSERT INTO products_barcode
			(product,barcode,company)
			VALUES
			(p_id,p_code,p_company)
			;
			-- 05.09.2022
				
			-- Рассылка изменений Справочника на все кассы			
			FOR r IN (
					SELECT p.id as point, b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  ORDER BY p.id
		  )
			LOOP		
				IF p_send_point <> r.point THEN
					p_send_point := r.point;
					-- Создание и заполнение накладной(инвойса) для обновления справочников
					INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
						VALUES(now(),p_user,'IN_PROCESS',p_company,r.point,r.point,3)
							RETURNING invoicenumber INTO p_invoicenumber;
					INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company) 
						VALUES(p_invoicenumber,p_id,0,0,false,false,true,p_company);					
				END IF;
				-- Формирование системного сообщения для терминалов для обновления справочников
				INSERT INTO systemmessage(point,invoice,type_message,cashbox)
					VALUES(r.point,p_invoicenumber,3,r.cashbox);			
			END LOOP;			
											
	 
	 result := json_build_object('code','success','text','');
   return next;
	
	 EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','exception','text','Идентификаторы компании или пользователя не были переданы!');
		 return next; 
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
		 return next;
	 WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
		 return next;	
	 WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','exception','text','Товар с таким кодом уже существует в системе! ('||p_code||')');
		 return next;				
	 WHEN SQLSTATE 'S0005' THEN
		 result := json_build_object('code','exception','text','Товар с таким наименованием уже существует в системе! ('||p_name||')');
		 return next;										
	 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   return next;
		 
END;$$;


ALTER FUNCTION public.productspr_create(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 699 (class 1255 OID 16537)
-- Name: productspr_delete_multiple(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productspr_delete_multiple(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company  bigint;
 p_error    varchar;
 p_check    varchar;
 p_user bigint;
 object_json    json;
 products_object    jsonb;
 p_id   bigint; 
 r  record;
 i  record;
 p_invoice  bigint;
 rec jsonb;
 p_send_point bigint;
 p_delete boolean;
 

 p_code text;
BEGIN

    -- {"user":1,"company":1,products:[{"id":41274},{"id":41275}]}
    
    SELECT (inf)::json into object_json;
        
    p_company   := cast(object_json->>'company' as bigint);
    p_user      := cast(object_json->>'user' as bigint);
    p_delete    := coalesce(cast(object_json->>'delete' as boolean),true);
            
    IF p_company IS NULL THEN
        RAISE SQLSTATE 'S0001';
    end if;

    if p_user IS NULL THEN
        RAISE SQLSTATE 'S0002';
    END IF;

    products_object := coalesce(cast(object_json->>'products' as jsonb),'[]');

    if products_object = '[]'::jsonb then
        RAISE SQLSTATE 'S0003';     
    end if;
        
    FOR rec in (select * from jsonb_array_elements(products_object))
    loop
        -- Для проверки (есть ограничения)
        p_id = coalesce(cast(rec->>'id' as bigint),0);
        
        if p_id = 0 then
            raise sqlstate 'S0004';
        end if;
    
                            
        -- Проставление признака удаления
        UPDATE products
            SET deleted = p_delete
                WHERE id = p_id
                    AND company = p_company;
        
        -- Рассылка изменений Справочника на все кассы          
        FOR r IN (
            SELECT p.id as point, b.id as cashbox
                FROM companies c
                    LEFT JOIN points p on (p.company = c.id) 
                        LEFT JOIN cashboxes b on (b.point = p.id)
                            WHERE company = p_company 
                                AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
                                    AND p.status = 'ACTIVE'
                                        AND c.status = 'ACTIVE'
                                            AND b.deleted = false
                                                AND b.isengaged = true
                                                    ORDER BY p.id
        )
        LOOP        
                
            p_send_point := r.point;
                
            -- Создание и заполнение накладной(инвойса) для обновления справочников
            INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
                VALUES(now(),p_user,'IN_PROCESS',p_company,r.point,r.point,3)
                    RETURNING invoicenumber INTO p_invoice;
                    
            INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company) 
                VALUES(p_invoice,p_id,0,0,false,false,true,p_company);                  
                
            -- Формирование системного сообщения для терминалов для обновления справочников
            INSERT INTO systemmessage(point,invoice,type_message,cashbox)
                VALUES(r.point,p_invoice,3,r.cashbox);          
            
        END LOOP;           
                        
        -- Процесс умервщления справочника (земля ему пухом)
        -- Поехали циклЪ
        FOR r IN (
            SELECT s.id as stockid, s.units, s.point as stock, s.product, s.attributes, p.point_type
                FROM stockcurrent s
                    INNER JOIN points p on (p.id = s.point and p.company = s.company and p.status = 'ACTIVE')
                        WHERE s.product = p_id
                            AND s.company = p_company
                                ORDER BY stockid
        )
        LOOP        
            -- Обнуление стока
            UPDATE stockcurrent
                SET units = 0
                    WHERE id = r.stockid
                        AND company = p_company;
                    
            IF NOT FOUND THEN
                RAISE SQLSTATE 'S0005';
            END IF;
                    
            -- Обнуление партиций
            FOR i IN (
                SELECT date, units, purchaseprice
                    FROM stockcurrent_part
                        WHERE company = p_company
                            AND point = r.stock
                                AND product = r.product
                                    AND attributes = r.attributes
                                        AND (units > 0 OR units < 0)
                                            ORDER BY date, purchaseprice
            )
            LOOP                
                UPDATE stockcurrent_part
                    SET units = 0
                        WHERE product = r.product
                            AND attributes =  r.attributes
                                AND point = r.stock
                                    AND company = p_company
                                        AND date = i.date
                                            AND purchaseprice = i.purchaseprice
                                                AND case when i.units > 0 then units > 0 else units < 0 end;
                                                                
                -- Оставляем записи в журнале перемещений товара
                INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate)
                    VALUES(now(),'-3',r.stock,r.product,i.units,0,r.attributes,null,p_company,i.purchaseprice,i.date);                              
            END LOOP;
                                
            -- Создание инвойса для обновления количества на кассе (Чтобы кассе было понятно, что товар удалили)    
            if r.point_type > 0 then    
                INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
                    VALUES(p_user,'IN_PROCESS',p_company,r.stock-1,r.stock-1,8,now()) 
                        RETURNING invoicenumber INTO p_invoice; 
                                
                -- Вызов функции, записывающей позиции в инвойс по обновлению количества
                INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company,delete)
                    VALUES(p_invoice,r.stockid,0,0,0,0,false,r.stockid,false,false,p_company,false);
                            
                -- На все активные кассы
                FOR i IN (
                    SELECT id
                        FROM cashboxes
                            WHERE point = r.stock-1
                                AND deleted = false
                                    AND isengaged = true
                )
                LOOP                
                    INSERT INTO systemmessage(point,invoice,type_message,cashbox)
                        VALUES(r.stock-1,p_invoice,8,i.id);             
                END LOOP;
            end if;
                                    
        END LOOP;
    END loop;
            
   result := json_build_object('code','success','text','','invoice',p_invoice);
   return next;
    
     EXCEPTION 
     WHEN SQLSTATE 'S0001' THEN
         result := json_build_object('code','exception','text','Идентификаторы компании не были переданы!');
         return next; 
     WHEN SQLSTATE 'S0002' THEN
         result := json_build_object('code','exception','text','Идентификаторы пользователя не были переданы!');
         return next;
     WHEN SQLSTATE 'S0003' THEN
         result := json_build_object('code','exception','text','Идентификаторы продукта не были переданы!');
         return next;
     WHEN SQLSTATE 'S0004' THEN
         result := json_build_object('code','exception','text','Идентификатор продукта не был передан!');
         return next;
    WHEN SQLSTATE 'S0005' THEN
         result := json_build_object('code','exception','text','При обнулении склада возникли проблемы! Пожалуйста, попробуйте чуть позже.');
         return next;
                         
     
     WHEN OTHERS THEN
       RAISE NOTICE 'internal_error: %', SQLERRM;
       GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
         result := json_build_object('code','internal_error','invoice',p_invoice,
        'text',SQLSTATE||':'||SQLERRM||':'||p_error||',p_id = '||p_id,'product',p_id);
       return next;
         
END;$$;


ALTER FUNCTION public.productspr_delete_multiple(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 700 (class 1255 OID 16539)
-- Name: productspr_edit(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productspr_edit(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
    
    -- variables
    object_json json;
    p_user bigint;
    p_code  varchar;
    p_text  varchar;
    p_error varchar;
 
    p_category  bigint;
    p_brand bigint;
 
    product_object  json;   
    p_product   bigint;
    p_company   bigint;
    p_invoice        bigint;
    
    p_attributes_listcode   bigint;
    p_details_listcode  bigint;
   
    p_attributes bigint;
    p_details bigint;
   
    p_attribute_object json;
    p_detail_object json;
    
    p_attribute_result json;
    p_detail_result  json;
    
    p_attribute_code bigint;
    p_detail_code bigint;
    
    p_attribute_value   text;
    p_detail_value text;
   
    p_product_attributes bigint;
    p_product_details bigint;
  
    rec record;
    r record;
    l record;
    i smallint := 1;

BEGIN
    
    -- inf = {"user":1,"company":1,category":1,"brand":1,"attributes":1,"products":[{"id":1},{"id":2}]}
    SELECT (inf)::json INTO object_json;  

    p_user = coalesce(cast(object_json->>'user' as bigint),0);
    
    if p_user = 0 then 
        raise sqlstate 'S0001';
    end if;

    SELECT code, text INTO p_code, p_text
        FROM public.get_company(cast(p_user as text));
    
    IF p_code = 'success' THEN
        p_company := cast(p_text as bigint);
    ELSE
        res := json_build_object('code',p_code,'text',p_text);
        return next;
    END IF;
     
    p_category = coalesce(cast(object_json->>'category' as bigint),-1);
    p_brand = coalesce(cast(object_json->>'brand' as bigint),-1);
   
    -- атрибут пришедший снаружи
    p_attributes_listcode = coalesce(cast(object_json->>'attributes' as bigint),-1);
    p_details_listcode = coalesce(cast(object_json->>'details' as bigint),-1);
   
    -- attributes
    if p_attributes_listcode = -1 or p_attributes_listcode = 0 then -- 0 - удалить атрибут, -1 - оставить, как есть
        p_attributes := p_attributes_listcode;
    end if;
  
    
    -- details
    if p_details_listcode = -1 or p_details_listcode = 0 then
        p_details = p_details_listcode;
    end if;
        
    
   FOR product_object IN (SELECT * FROM json_array_elements(object_json->'products'))
   LOOP 
        p_product = cast(product_object->>'id' as bigint); 
        
       	if p_attributes is null then
        	for r in (select * from attrlist where 
        	listcode = p_attributes_listcode order by attribute)
        	loop 
            	p_attribute_object := json_build_object('user',p_user,'listcode',p_attributes,
                	'attribcode',r.attribute,'value',r.value);
            	p_attribute_result := add_attributes(p_attribute_object);
            	p_attributes := cast(p_attribute_result->>'text' as bigint);
        	end loop;
        end if;
        
        if p_details is null then
        	for l in (select * from attrlist where 
        	listcode = p_details_listcode order by attribute)
        	loop 
            	p_detail_object := json_build_object('user',p_user,'listcode',p_details,
                	'attribcode', l.attribute,'value',l.value);
            	p_detail_result := add_attributes(p_detail_object);
            	p_details := cast(p_detail_result->>'text' as bigint);
        	end loop;
       end if;
      
        UPDATE public.products SET 
            category = CASE WHEN (p_category=-1) or (p_category is null) THEN category ELSE p_category END,
            brand = CASE WHEN (p_brand=-1) or (p_brand is null) THEN brand ELSE p_brand end,
            "attributes" = case when(p_attributes=-1) or (p_attributes is null) then "attributes" else p_attributes end
            ,details = case when (p_details=-1) or (p_details is null) then details else p_details end
                WHERE id = p_product AND company = p_company;
       
       if p_attributes <> 0 and p_attributes <> -1 then
       	p_attributes := null;
       end if;
       
      if p_details <> 0 and p_details <> -1 then
       p_details := null;
      end if;
     
       -- Рассылка изменений Справочника на все кассы           
        FOR rec IN (
                    SELECT p.id as point, b.id as cashbox
                      FROM companies c
                          LEFT JOIN points p on (p.company = c.id) 
                              LEFT JOIN cashboxes b on (b.point = p.id)
                                WHERE company = p_company 
                                    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
                                        AND p.status = 'ACTIVE'
                                            AND c.status = 'ACTIVE'
                                                  AND b.deleted = false
                                                      AND b.isengaged = true
                                                          orDER BY p.id
          )
            LOOP        
                    -- Создание и заполнение накладной(инвойса) для обновления справочников
                    INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
                        VALUES(now(),p_user,'IN_PROCESS',p_company,rec.point,rec.point,3)
                            RETURNING invoicenumber INTO p_invoice;
                    INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,UPDATEallprodprice,newprod,company) 
                        VALUES(p_invoice,p_product,0,0,false,false,true,p_company);                 
                
                -- Формирование системного сообщения для терминалов для обновления справочников
                INSERT INTO systemmessage(point,invoice,type_message,cashbox)
                    VALUES(rec.point,p_invoice,3,rec.cashbox);          
            END LOOP;
        
    END LOOP;

    res := json_build_object('code','success','text','ok');
    return next;

EXCEPTION 
    when sqlstate 'S0001' then
        res := json_build_object('code','error','text','Empty user!');
        return next;
    when sqlstate 'S0002' then
        res := json_build_object('code','error','text','Special error!','p_attributes',p_attributes,
    'p_attributes_listcode',p_attributes_listcode);
        return next;
    
    WHEN OTHERS then
    RAISE NOTICE 'internal_error: %', SQLERRM;
    GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
    res := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;

$$;


ALTER FUNCTION public.productspr_edit(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 701 (class 1255 OID 16541)
-- Name: productspr_update(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productspr_update(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company                              bigint;
 p_error                                    varchar;
 p_check                                            varchar;
 p_user                                             bigint;
 json_object                            json;
 products_object                            json;
 p_name                                             varchar;
 p_category                                     bigint;
 p_category_old                             bigint;
 p_brand                                            bigint;
 p_taxid                                            bigint;
 p_taxid_old                                    bigint;
 p_unitsprid                                    bigint;
 p_piece                                            boolean;
 p_pieceinpack                              integer;
 p_delete                                           boolean;
 p_delete_old                                   boolean;
 p_id                                                   bigint; 
 p_cnofeacode                                   varchar; -- cnofeacode
 r                                      record;
 i                                                      record;
 p_send_point                                   bigint  := 0;
 p_invoicenumber                            bigint;
 p_nds                                              boolean := false;
 p_exists                                       integer;
 p_details                                      bigint;
 p_attributes                                   bigint;
 
 --------------------------------------------
 p_attr                                             varchar;
 p_det                                              varchar;
 rec                                                    record;
 item                                               json;
 obj                                                    json;
 obj_code                                       bigint;
 obj_value                                      varchar(30);
 p_faa                                              json;
 p_attributes_in_json                   json;
 p_attributes_in                            bigint;
 p_details_in                                   bigint;


 --------------------------------------------
 
BEGIN

-- {"user":1,"company":1,"product":{"id":"", "name":"", "category":"", "brand":"", "taxid":"", "unitsprid":"", "piece":"", "pieceinpack":"","delete":""}}

    
        SELECT (inf)::json into json_object;
        
            p_company   := cast(json_object->>'company' as bigint);
            p_user      := cast(json_object->>'user' as bigint);
            
            IF p_company IS NULL OR p_user IS NULL THEN
                RAISE SQLSTATE 'S0001';
            END IF;
            
            SELECT case when certificatenum is null then false else true end INTO p_nds
                FROM companies
                    WHERE id = p_company;
    
        SELECT (json_object)->'product' into products_object;
            
            p_id                            := cast(nullif(products_object->>'id','') as bigint);
            p_name                      := nullif(trim(products_object->>'name'),'');
            p_category              := cast(nullif(products_object->>'category','') as bigint);
            p_brand                     := cast(nullif(products_object->>'brand','') as bigint);
            p_taxid                     := cast(nullif(products_object->>'taxid','') as bigint);
            p_unitsprid             := cast(nullif(products_object->>'unitsprid','') as bigint);
            p_piece                     := cast(nullif(products_object->>'piece','') as boolean);
            p_pieceinpack           := cast(nullif(products_object->>'pieceinpack','') as integer);
            p_delete                    := cast(nullif(products_object->>'delete','') as boolean);
            p_cnofeacode      := nullif(trim(products_object->>'cnofeacode'),''); 
            p_details               := cast(nullif(products_object->>'details','') as bigint);
            p_attributes      := cast(nullif(products_object->>'attributes','') as bigint);
           
            
            p_attr                      := case when products_object->>'attributesValue' is null or products_object->'attributesValue' is null then '[]' 
            else cast(nullif(products_object->>'attributesValue','') as varchar) end;
            
            p_det                       := case when products_object->>'attributesValue' is null or products_object->'detailsValue' is null then '[]' 
            else cast(nullif(products_object->>'detailsValue','') as varchar) end;
            -- [{"code":3,"value":"","name":"Цвет"},{"code":2,"value":"","name":"Срок годности"}] -- Пример приходящего значения json
            
    
            IF p_attr <> '[]' THEN
                FOR rec IN 
                        (select * from json_array_elements(p_attr::json) ) -- Циклом пробегаемся по нашему json
                        LOOP
                        select row_to_json(rec) into item;
                            obj = item::json->>'value';
                            obj_code = obj::json->>'code';  
                            obj_value = obj::json->>'value';
                        IF p_attributes_in is null then 
                            p_faa := json_build_object('user',json_object::json->>'user','attribcode',obj_code,'value', obj_value::text); 
                            p_attributes_in_json := add_attributes(p_faa); -- Возвращаем новый сгенерированный listcode
                            p_attributes_in = cast(p_attributes_in_json->>'text' as bigint);
                        ELSE
                            p_faa := json_build_object('user',json_object::json->>'user','attribcode',obj_code,'value',
                            obj_value::text,'listcode',coalesce(p_attributes_in, 0)); 
                            p_attributes_in_json := add_attributes(p_faa); 
                            p_attributes_in = cast(p_attributes_in_json->>'text' as bigint);
                        END IF;
                END LOOP;
            ELSE
                p_attributes_in = 0;
                    
            END IF;
            
            IF p_det <> '[]' THEN
                FOR rec IN 
                        (select * from json_array_elements(p_det::json) ) -- Циклом пробегаемся по нашему json
                        LOOP
                        select row_to_json(rec) into item;
                            obj = item::json->>'value';
                            obj_code = obj::json->>'code';  
                            obj_value = obj::json->>'value';
                        IF p_details_in is null then 
                            p_faa := json_build_object('user',json_object::json->>'user','attribcode',obj_code,'value', obj_value::text); 
                            p_attributes_in_json := add_attributes(p_faa); -- Возвращаем новый сгенерированный listcode
                            p_details_in = cast(p_attributes_in_json->>'text' as bigint);
                        ELSE
                            p_faa := json_build_object('user',json_object::json->>'user','attribcode',obj_code,'value',
                            obj_value::text,'listcode',coalesce(p_details_in, 0)); 
                            p_attributes_in_json := add_attributes(p_faa); 
                            p_details_in = cast(p_attributes_in_json->>'text' as bigint);
                        END IF;
                END LOOP;
            ELSE
                p_details_in = 0;
                    
            END IF;
            
            
            IF p_id IS NULL THEN
                RAISE SQLSTATE 'S0006';
            END IF;
            
            -- Для проверки (есть ограничения)
            SELECT category, taxid, deleted INTO p_category_old, p_taxid_old, p_delete_old
                FROM products
                    WHERE id = p_id;
            
            IF p_delete IS NOT TRUE THEN
                -- У товаров с возможностью разкомплектации строго ограниченные значения справочника
                IF p_piece AND p_unitsprid NOT IN (2,16,17) THEN
                    RAISE SQLSTATE 'S0002';
                END IF; 
                -- Проверка на НДС для клиентов не являющихся плательщиками НДС
                IF p_taxid = 1 AND NOT p_nds THEN
                    RAISE SQLSTATE 'S0004';
                END IF;
                -- Ограничение по весовым товарам           
                IF (p_category_old = -1 AND p_taxid_old = p_taxid/*НДС можно менять для весовых товаров*/)THEN
                    RAISE SQLSTATE 'S0005';
                END IF;
                -- То, что мертво - ожить не может
                IF p_delete_old AND NOT p_delete THEN
                    RAISE SQLSTATE 'S0007';
                END IF; 
                
                if p_name is not null then
                    select count(*) into p_exists from products p 
                    where p."name" = p_name AND 
                        p."id" <> p_id AND 
                        p.company = p_company and
                        p.deleted = false;
                        
                    if p_exists > 0 then
                        RAISE SQLSTATE 'S0010';
                    end if;
                end if;
                -- Обновление справочника
                UPDATE products
                    SET "name"          = case when p_name              is not null then p_name              else "name"            end,
                            category        = case when p_category      is not null then p_category      else category      end,
                            taxid               =   case when p_taxid           is not null then p_taxid             else taxid             end,
                            brand               =   case when p_brand           is not null then p_brand             else brand             end,
                            unitsprid       =   case when p_unitsprid   is not null then p_unitsprid     else unitsprid     end,
                            deleted         =   case when p_delete          is not null then p_delete        else deleted       end,
                            piece               =   case when p_piece           is not null then p_piece             else piece             end,
                            pieceinpack =   case when p_pieceinpack <> 0 then p_pieceinpack else pieceinpack end,
                            --cnofeacode  = case when p_cnofeacode  is not null then p_cnofeacode  else cnofeacode  end,
                            cnofeacode  = case when p_cnofeacode  is not null then p_cnofeacode end,
                            details     = case when p_details_in  is not null then p_details_in     else details     end,
                            --"attributes"= case when p_attributes  is not null then p_attributes  else attributes  end
                            "attributes"= case when p_attributes_in  is not null then p_attributes_in  else attributes  end
                            
                        WHERE id = p_id
                            AND company = p_company;
                            
                IF NOT FOUND THEN
                    RAISE SQLSTATE 'S0003';
                END IF;    
            -- 20230818 AB before product deletion it should check if product exists in stockcurrent, stockcurrent_part and in returned products in cashboxes <
            /*elseif exists(
                select 1 from stockcurrent s
                	where company = p_company
                	and product = p_id
                	and units > 0
            		) then
            	  		raise sqlstate 'S0011';*/
            -- 20230818 AB before product deletion it should check if product exists in stockcurrent, stockcurrent_part and in returned products in cashboxes	> 	
            ELSE
                -- Проставление признака удаления
                UPDATE products
                    SET deleted = true
                        WHERE id = p_id
                            AND company = p_company;
                IF NOT FOUND THEN
                    RAISE SQLSTATE 'S0008';
                END IF;
            
            END IF; 
                
            -- Рассылка изменений Справочника на все кассы          
            FOR r IN (
                    SELECT p.id as point, b.id as cashbox
                      FROM companies c
                          LEFT JOIN points p on (p.company = c.id) 
                              LEFT JOIN cashboxes b on (b.point = p.id)
                                WHERE company = p_company 
                                    AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
                                        AND p.status = 'ACTIVE'
                                            AND c.status = 'ACTIVE'
                                                  AND b.deleted = false
                                                      AND b.isengaged = true
                                                          ORDER BY p.id
          )
            LOOP        
                IF p_send_point <> r.point THEN
                    p_send_point := r.point;
                    -- Создание и заполнение накладной(инвойса) для обновления справочников
                    INSERT INTO invoices(invoicedate,creator,status,company,stockfrom,stockto,type)
                        VALUES(now(),p_user,'IN_PROCESS',p_company,r.point,r.point,3)
                            RETURNING invoicenumber INTO p_invoicenumber;
                    INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company
                    --20230828 AB modify product delete mechanism <
                    ,delete
                    --20230828 AB modify product delete mechanism >
                    ) 
                        VALUES(p_invoicenumber,p_id,0,0,false,false,true,p_company
                        --20230828 AB modify product delete mechanism <
                       ,p_delete
                       --20230828 AB modify product delete mechanism >
                      );                    
                END IF;
                -- Формирование системного сообщения для терминалов для обновления справочников
                INSERT INTO systemmessage(point,invoice,type_message,cashbox)
                    VALUES(r.point,p_invoicenumber,3,r.cashbox);            
            END LOOP;           
            
           /*
            -- Процесс умервщления справочника (земля ему пухом)
            IF p_delete THEN
                -- Поехали циклЪ
                FOR r IN (
                    SELECT s.id as stockid, s.units, s.point as stock, s.product, s.attributes, p.point_type
                        FROM stockcurrent s
                            INNER JOIN points p on (p.id = s.point and p.company = s.company and p.status = 'ACTIVE')
                                WHERE s.product = p_id
                                    AND s.company = p_company
                                        ORDER BY stockid
                )
                LOOP        
                    -- Обнуление стока
                    UPDATE stockcurrent
                        SET units = 0
                            WHERE id = r.stockid
                                AND company = p_company;
                    IF NOT FOUND THEN
                        RAISE SQLSTATE 'S0009';
                    END IF;
                    
                    -- Обнуление партиций
                    FOR i IN (
                        SELECT date, units, purchaseprice
                            FROM stockcurrent_part
                                WHERE company = p_company
                                    AND point = r.stock
                                        AND product = r.product
                                            AND attributes = r.attributes
                                                AND (units > 0 OR units < 0)
                                                    ORDER BY date, purchaseprice
                    )
                    LOOP                
                        UPDATE stockcurrent_part
                            SET units = 0
                                WHERE product = r.product
                                    AND attributes =  r.attributes
                                    AND point = r.stock
                                    AND company = p_company
                                    AND date = i.date
                                    AND purchaseprice = i.purchaseprice
                                    AND case when i.units > 0 then units > 0 else units < 0 end;
                                                                
                        -- Оставляем записи в журнале перемещений товара
                        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate)
                            VALUES(now(),'-3',r.stock,r.product,i.units,0,r.attributes,null,p_company,i.purchaseprice,i.date);                              
                    END LOOP;
                                
                    -- Создание инвойса для обновления количества на кассе (Чтобы кассе было понятно, что товар удалили)    
                    if r.point_type > 0 then    
                        INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
                            VALUES(p_user,'IN_PROCESS',p_company,r.stock-1,r.stock-1,8,now()) 
                                RETURNING invoicenumber INTO p_invoicenumber;   
                                
                        -- Вызов функции, записывающей позиции в инвойс по обновлению количества
                        INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company,delete)
                            VALUES(p_invoicenumber,r.stockid,0,0,0,0,false,r.stockid,false,false,p_company,false);
                            
                        -- На все активные кассы
                        FOR i IN (
                            SELECT id
                                FROM cashboxes
                                    WHERE point = r.stock-1
                                        AND deleted = false
                                            AND isengaged = true
                        )
                        LOOP                
                            INSERT INTO systemmessage(point,invoice,type_message,cashbox)
                                VALUES(r.stock-1,p_invoicenumber,8,i.id);               
                        END LOOP;
                    end if;
                                    
                END LOOP;
            END IF;
            */                 
     
     result := json_build_object('code','success','text','','product',p_id);
   return next;
    
     EXCEPTION 
     WHEN SQLSTATE 'S0001' THEN
         result := json_build_object('code','exception','text','Идентификаторы компании или пользователя не были переданы!');
         return next; 
     WHEN SQLSTATE 'S0002' THEN
         result := json_build_object('code','exception','text','Для поштучной продажи единица измерения должна соответствовать одному из указанных значений: Упаковка, Коробка, Одна пачка!');
         return next;
     WHEN SQLSTATE 'S0003' THEN
         result := json_build_object('code','exception','text','Возникла ошибка при обновлении справочника! Пожалуйста, попробуйте чуть позже.'); 
         return next;   
     WHEN SQLSTATE 'S0004' THEN
         result := json_build_object('code','exception','text','Ваша компания не является плательщиком НДС, пожалуйста, измените налоговую категорию товара!');
         return next;   
     WHEN SQLSTATE 'S0005' THEN
         result := json_build_object('code','exception','text','Нельзя изменять товар категории "Весовые товары"!');    
         return next;       
     WHEN SQLSTATE 'S0006' THEN
         result := json_build_object('code','exception','text','Идентификатор справочника не был получен!');                
         return next;
     WHEN SQLSTATE 'S0007' THEN
         result := json_build_object('code','exception','text','Удаленный справочник восстановлению не подлежит!');             
         return next;    
     WHEN SQLSTATE 'S0008' THEN
         result := json_build_object('code','exception','text','При удалении из справочника возникли проблемы! Пожалуйста, попробуйте чуть позже.');
         return next;
     WHEN SQLSTATE 'S0009' THEN
         result := json_build_object('code','exception','text','При обнулении склада возникли проблемы! Пожалуйста, попробуйте чуть позже.');
         return next;   
    WHEN SQLSTATE 'S0010' THEN
         result := json_build_object('code','exception','text','Товар с указанным наименованием уже существует.');
         return next;                
    -- 20230818 AB before product deletion it should check if product exists in stockcurrent, stockcurrent_part and in returned products in cashboxes <
    WHEN SQLSTATE 'S0011' THEN
         result := json_build_object('code','exception','text','Товар невозможно удалить, поскольку он есть в остатках на складе.');
         return next;
    -- 20230818 AB before product deletion it should check if product exists in stockcurrent, stockcurrent_part and in returned products in cashboxes > 
    WHEN OTHERS THEN
       RAISE NOTICE 'internal_error: %', SQLERRM;
       GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
         result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error||',p_id = '||p_id);
       return next;
      
         
END;$$;


ALTER FUNCTION public.productspr_update(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 703 (class 1255 OID 16543)
-- Name: productsweight_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productsweight_add(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE json_object json;

products_object json;

p_amount float8;

p_barcode bigint;

p_check varchar;

p_company bigint;

p_createdate TIMESTAMP;

p_error varchar;

p_hot_key bigint;

p_isdeleted BOOLEAN;

p_lastpurchaseprice float8;

p_name varchar;

p_point bigint;

p_price float8;

p_scale bigint;

p_taxid varchar;

p_user bigint;

p_updateprice BOOLEAN;

begin
--{"company": 15, "user": "m.asanova", "point": "169", "scale": "2", "createdate":"2019-10-20 14:09:12",
--"amount":4.5,"hotkey": 1,"lastpurchaseprice":433.0,"price": 455.5, "taxid": "0",updateprice:true}

--Функция для временного хранения весовых товаров, перед отправкой на кассу.
 select
	(inf)::json
into
	json_object;

p_user := cast(trim(json_object->>'user') as varchar);

p_company := cast(trim(json_object->>'company') as bigint);

p_point := cast(trim(json_object->>'point') as bigint);

p_scale := cast(trim(json_object->>'scale') as bigint);

p_createdate = date_trunc('second', now());

p_amount := cast(trim(json_object->>'amount') as float8);

p_barcode := cast(trim(json_object->>'barcode') as bigint);

p_hot_key := cast(trim(json_object->>'hotkey') as bigint);

p_isdeleted := cast(trim(json_object->>'isdeleted') as BOOLEAN);

p_lastpurchaseprice := cast(trim(json_object->>'lastpurchaseprice') as float8);

p_name := cast(trim(json_object->>'name') as varchar);

p_price := cast(trim(json_object->>'price') as float8);

p_taxid := cast(trim(json_object->>'taxid') as varchar);

p_updateprice := cast(trim(json_object->>'updateprice') as BOOLEAN);

if p_user is null then raise sqlstate 'S0001';

elsif p_company is null then raise sqlstate 'S0002';

elsif p_point is null then raise sqlstate 'S0003';

elsif p_createdate is null then raise sqlstate 'S0004';

elsif p_barcode is null then raise sqlstate 'S0005';

elsif p_name is null then raise sqlstate 'S0006';

elsif p_taxid is null then raise sqlstate 'S0007';

elsif p_hot_key is null then raise sqlstate 'S0008';

elsif p_updateprice is null then raise sqlstate 'S0009';
end if;
--Добавить новые товары
 insert
	into
	products_weight(amount, barcode, company, createdate, hotkey, lastpurchaseprice, price, name, point, taxid, "user", scale, isdeleted, issaved, updateprice, isedited)
values(p_amount, p_barcode, p_company, p_createdate, p_hot_key, p_lastpurchaseprice, p_price, p_name, p_point, p_taxid, p_user, p_scale, false, false, p_updateprice, false);

result := json_build_object('code', 'success', 'text', 'Товары успешно сохранены.', 'createdate', p_createdate);

return next;

exception
when sqlstate 'S0001' then result := json_build_object('code', 'error', 'text', 'Не указан пользователь!');

return next;
when sqlstate 'S0002' then result := json_build_object('code', 'error', 'text', 'Не указана компания!');

return next;
when sqlstate 'S0003' then result := json_build_object('code', 'error', 'text', 'Не указана торговая точка!');

return next;
when sqlstate 'S0004' then result := json_build_object('code', 'error', 'text', 'Не указано время создания!');

return next;
when sqlstate 'S0005' then result := json_build_object('code', 'error', 'text', 'Не указан штрихкод!');

return next;
when sqlstate 'S0006' then result := json_build_object('code', 'error', 'text', 'Не указано название товара!');

return next;
when sqlstate 'S0007' then result := json_build_object('code', 'error', 'text', 'Не указана налоговая категория!');

return next;
when sqlstate 'S0008' then result := json_build_object('code', 'error', 'text', 'Не указана горячая клавиша!');

return next;
when sqlstate 'S0009' then result := json_build_object('code', 'error', 'text', 'Не указано обновление цены!');

return next;
when others then raise notice 'internal_error: %',
sqlerrm;

get STACKED diagnostics p_error = PG_EXCEPTION_CONTEXT,
p_check = CONSTRAINT_NAME;

result := json_build_object('code', 'internal_error', 'text', sqlstate || ':' || sqlerrm || ':' || p_error);

return next;
end;

$$;


ALTER FUNCTION public.productsweight_add(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 704 (class 1255 OID 16544)
-- Name: productsweight_delete(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productsweight_delete(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE json_object json;

products_object json;

p_error varchar;

p_check varchar;

p_productsweight_id bigint;

p_company bigint;

p_user bigint;

begin
--{"company": 15, "user": "m.asanova", "pointid": 169, "products": [{barcode:"3"}]}
 select
	(data)::json
into
	json_object;

p_user := cast(trim(json_object->>'user') as varchar);

p_company := cast(trim(json_object->>'company') as bigint);

p_productsweight_id := cast(trim(json_object->>'productsweight_id') as bigint);

if p_user is null then raise sqlstate 'S0001';

elsif p_company is null then raise sqlstate 'S0002';
end if;
--удалить товар с темповой таблицы
 delete
from
	products_weight
where
	productsweight_id = p_productsweight_id;

result := json_build_object('code', 'success', 'text', 'Товар удален успешно.');

return next;

exception
when sqlstate 'S0001' then result := json_build_object('code', 'error', 'text', 'Не указан пользователь!');

return next;
when sqlstate 'S0002' then result := json_build_object('code', 'error', 'text', 'Не указана компания!');

return next;
when others then raise notice 'internal_error: %',
sqlerrm;

get STACKED diagnostics p_error = PG_EXCEPTION_CONTEXT,
p_check = CONSTRAINT_NAME;

result := json_build_object('code', 'internal_error', 'text', sqlstate || ':' || sqlerrm || ':' || p_error);

return next;
end;

$$;


ALTER FUNCTION public.productsweight_delete(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 705 (class 1255 OID 16545)
-- Name: productsweight_edit(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productsweight_edit(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE json_object json;

products_object json;

p_amount float8;

p_check varchar;

p_error varchar;

p_hot_key bigint;

p_isdeleted BOOLEAN;

p_isedited BOOLEAN;

p_isnewedited BOOLEAN;

p_lastpurchaseprice float8;

p_name varchar;

p_price float8;

p_productsweight_id bigint;

p_taxid varchar;

p_updateprice BOOLEAN;
declare
	begin
	--{
	--"company": "18", 
	--"user": "42", 
	--"point": "244", 
	--"scale": "5",
	--"amount": "16",
	--"barcode": "4",
	--"hotkey": "15",
	--"isedited": "true",
	--"isnewedited": "true",
	--"lastpurchaseprice": "16",
	--"name": "Картошка 16",
	--"point": "244",
	--"price": "156",
	--"scale": "5",
	--"taxid": "1",
	--"updateprice": "true",
	--"user": "42"
	--}

--Изменения весовых товаров, перед отправкой на кассу.
 select
	(data)::json
into
	json_object;

p_amount := cast(trim(json_object->>'amount') as float8);

p_hot_key := cast(trim(json_object->>'hotkey') as bigint);

p_isedited := cast(trim(json_object->>'isedited') as BOOLEAN);

p_isnewedited := cast(trim(json_object->>'isnewedited') as BOOLEAN);

p_lastpurchaseprice := cast(trim(json_object->>'lastpurchaseprice') as float8);

p_name := cast(trim(json_object->>'name') as varchar);

p_price := cast(trim(json_object->>'price') as float8);

p_productsweight_id := cast(trim(json_object->>'productsweight_id') as bigint);

p_taxid := cast(trim(json_object->>'taxid') as varchar);

p_updateprice := cast(trim(json_object->>'updateprice') as BOOLEAN);

if p_amount is null then raise sqlstate 'S0001';

elsif p_hot_key is null then raise sqlstate 'S0002';

elsif p_isedited is null then raise sqlstate 'S0003';

elsif p_isnewedited is null then raise sqlstate 'S0004';

elsif p_lastpurchaseprice is null then raise sqlstate 'S0005';

elsif p_name is null then raise sqlstate 'S0006';

elsif p_price is null then raise sqlstate 'S0007';

elsif p_productsweight_id is null then raise sqlstate 'S0008';

elsif p_taxid is null then raise sqlstate 'S0009';

elsif p_updateprice is null then raise sqlstate 'S0010';
end if;
--Редактировать новые, незаведенные товары
 if p_isnewedited is true then
update
	products_weight
set
	amount = p_amount,
	hotkey = p_hot_key,
	taxid = p_taxid,
	isedited = p_isedited,
	price = p_price,
	lastpurchaseprice = p_lastpurchaseprice,
	updateprice = p_updateprice,
	"name" = p_name
where
	productsweight_id = p_productsweight_id;

result := json_build_object('code', 'success', 'text', 'Новый товар успешно изменен.', 'новый?', p_isnewedited);

return next;
--Редактировать товары, уже отправленные на кассу
 elsif p_isnewedited is false then 
update
	products_weight
set
	amount = amount + p_amount,
	amountadding = coalesce(amountadding, 0) + p_amount,
	hotkey = p_hot_key,
	taxid = p_taxid,
	isedited = p_isedited
where
	productsweight_id = p_productsweight_id;

result := json_build_object('code', 'success', 'text', 'Товар успешно изменен.', 'новый?', p_isnewedited);

return next;
end if;

exception
when sqlstate 'S0001' then result := json_build_object('code', 'error', 'text', 'Не указано количество!');

return next;
when sqlstate 'S0002' then result := json_build_object('code', 'error', 'text', 'Не указана горячая клавиша!');

return next;
when sqlstate 'S0003' then result := json_build_object('code', 'error', 'text', 'Не указан параметр редактирования!');

return next;
when sqlstate 'S0004' then result := json_build_object('code', 'error', 'text', 'Не указано параметр редактирования нового товара!');

return next;
when sqlstate 'S0005' then result := json_build_object('code', 'error', 'text', 'Не указана последняя цена закупа!');

return next;
when sqlstate 'S0006' then result := json_build_object('code', 'error', 'text', 'Не указано наименование товара!');

return next;
when sqlstate 'S0007' then result := json_build_object('code', 'error', 'text', 'Не указана цена!');

return next;
when sqlstate 'S0008' then result := json_build_object('code', 'error', 'text', 'Не указан идентификатор весового товара!');

return next;
when sqlstate 'S0009' then result := json_build_object('code', 'error', 'text', 'Не указана налоговая категория!');

return next;
when sqlstate 'S0010' then result := json_build_object('code', 'error', 'text', 'Не указан параметр обновления цены!');

return next;

raise notice 'internal_error: %',
sqlerrm;

get STACKED diagnostics p_error = PG_EXCEPTION_CONTEXT,
p_check = CONSTRAINT_NAME;

result := json_build_object('code', 'internal_error', 'text', sqlstate || ':' || sqlerrm || ':' || p_error);

return next;
end;

$$;


ALTER FUNCTION public.productsweight_edit(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 706 (class 1255 OID 16546)
-- Name: productsweight_parse(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productsweight_parse(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE json_object json;

products_object json;

p_amount float8;
p_barcode varchar;
p_company bigint;
p_createdate timestamp;
p_check varchar;
p_error varchar;
p_hot_key bigint;
p_id bigint;
p_invoice_id bigint;
p_old_id bigint;
p_lastpurchaseprice float8;
p_name varchar;
p_price float8;
p_point bigint;
p_scale bigint;
p_taxid int8;
p_updateprice boolean;
p_user bigint;

begin
--{"company": 15, "user": "m.asanova", "point": "169", "scale": "2", data:[{}]}

--Функция для присваивания id и количества весовым товарам в темповую таблицу после успешного сохранения инвойса

 select
	(inf)::json
into
	json_object;

p_createdate= date_trunc('second', now());
p_invoice_id := cast(trim(json_object->>'invoiceid') as bigint);
p_user := cast(trim(json_object->>'user') as varchar);
p_company := cast(trim(json_object->>'company') as bigint);
p_point := cast(trim(json_object->>'point') as bigint);
p_scale := cast(trim(json_object->>'scale') as bigint);

if p_user is null then raise sqlstate 'S0001';
elsif p_company is null then raise sqlstate 'S0002';
elsif p_point is null then raise sqlstate 'S0003';
elsif p_scale is null then raise sqlstate 'S0004';
elsif p_invoice_id is null then raise sqlstate 'S0013';
end if;

for products_object in
select
	*
from
	json_array_elements((json_object)->'products') loop
		p_amount := cast(trim(products_object->>'amount') as float8);
		p_barcode := cast(trim(products_object->>'code') as varchar);
		p_hot_key := cast(trim(products_object->>'hotkey') as bigint);
		p_old_id := cast(trim(products_object->>'id') as bigint);
		p_lastpurchaseprice := cast(trim(products_object->>'lastpurchaseprice') as float8);
		p_name := cast(trim(products_object->>'name') as varchar);
		p_price := cast(trim(products_object->>'newprice') as float8);	
		p_taxid := cast(trim(products_object->>'taxid') as int8);
		p_updateprice := cast(trim(products_object->>'updateprice') as boolean);		
	
if 	  p_barcode is null then raise sqlstate 'S0005';
elsif p_name is null then raise sqlstate 'S0006';
elsif p_taxid is null then raise sqlstate 'S0007';
elsif p_hot_key is null then raise sqlstate 'S0008';
elsif p_updateprice is null then raise sqlstate 'S0009';
elsif p_amount is null then raise sqlstate 'S0010';
elsif p_lastpurchaseprice is null then raise sqlstate 'S0011';
elsif p_price is null then raise sqlstate 'S0012';
end if;
-- нахождение ID товара из основной таблицы товаров
select
	p.id
into
	p_id
from
	products p
where
	p.deleted = false
	and p.company = p_company
	and p.category = -1
	and p.code = p_barcode;

-- если товар новый - добавить его в темповую таблицу с присвоенным id
if p_old_id is null then
insert into products_weight
					(amount,barcode,company,createdate,
					hotkey,id,isdeleted,isedited,
					issaved,lastpurchaseprice,name,point,price,
					scale,taxid,updateprice,"user")
		values     	(p_amount,p_barcode::bigint,p_company,p_createdate,
					p_hot_key,p_id,false,false,
					false,p_lastpurchaseprice,p_name,p_point,p_price,
					p_scale,p_taxid,p_updateprice,p_user);
else
-- если товар старый - изменить его характеристики.
update
	products_weight
set	
	amount = p_amount,
	lastpurchaseprice = p_lastpurchaseprice,
	price = p_price,
	taxid = p_taxid,
	updateprice = p_updateprice,
	id = p_id,
	isedited = false
where
	barcode = p_barcode::bigint
	and company = p_company
	and point = p_point
	and "user" = p_user
	and isdeleted = false;
end if;
end loop;

--удаление товаров из временной таблицы инвойсов
delete from products_weight_invoices where invoice_id = p_invoice_id;

--изменение статуса инвойса
update products_weight_invoicelist set status = 'ACCEPTED' where invoice_id = p_invoice_id;

result := json_build_object('code', 'success', 'text', 'Товары успешно сохранены.');

return next;

exception
when sqlstate 'S0001' then result := json_build_object('code', 'error', 'text', 'Не найден пользователь!');
return next;
when sqlstate 'S0002' then result := json_build_object('code', 'error', 'text', 'Не найдена компания!');
return next;
when sqlstate 'S0003' then result := json_build_object('code', 'error', 'text', 'Не найдена торговая точка!');
return next;
when sqlstate 'S0004' then result := json_build_object('code', 'error', 'text', 'Не найдено время создания!');
return next;
when sqlstate 'S0005' then result := json_build_object('code', 'error', 'text', 'Не найден штрихкод!');
return next;
when sqlstate 'S0006' then result := json_build_object('code', 'error', 'text', 'Не найдено название!');
return next;
when sqlstate 'S0007' then result := json_build_object('code', 'error', 'text', 'Не найдена налоговая категория!');
return next;
when sqlstate 'S0008' then result := json_build_object('code', 'error', 'text', 'Не найдена горячая клавиша!');
return next;
when sqlstate 'S0009' then result := json_build_object('code', 'error', 'text', 'Не найдено обновление цены!');
return next;
when sqlstate 'S0010' then result := json_build_object('code', 'error', 'text', 'Не найдено количество!');
return next;
when sqlstate 'S0011' then result := json_build_object('code', 'error', 'text', 'Не найдена цена закупа!');
return next;
when sqlstate 'S0012' then result := json_build_object('code', 'error', 'text', 'Не найдена цена продажи!');
return next;
when sqlstate 'S0013' then result := json_build_object('code', 'error', 'text', 'Не найден ID накладной!');
return next;
when others then raise notice 'internal_error: %',
sqlerrm;

get STACKED diagnostics p_error = PG_EXCEPTION_CONTEXT,
p_check = CONSTRAINT_NAME;

result := json_build_object('code', 'internal_error', 'text', sqlstate || ':' || sqlerrm || ':' || p_error);

return next;
end;

$$;


ALTER FUNCTION public.productsweight_parse(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 707 (class 1255 OID 16548)
-- Name: productsweight_updatehotkey(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.productsweight_updatehotkey(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE json_object json;

products_object json;
p_company bigint;
p_check varchar;
p_error varchar;
p_existinghotkeys int4;
p_hotkey int4;
p_id bigint;
p_point bigint;
p_scale bigint;
p_stockid bigint;
p_user bigint;

begin
--{"company": 15, "user": "m.asanova", "pointid": 169, "products": [{barcode:"3"}]}
 select
	(data)::json
into
	json_object;

p_company := cast(trim(json_object->>'company') as bigint);
p_hotkey := cast(trim(json_object->>'hotkey') as int4);
p_id := cast(trim(json_object->>'id') as bigint);
p_point := cast(trim(json_object->>'point') as bigint);
p_scale := cast(trim(json_object->>'scale') as bigint);
p_stockid := cast(trim(json_object->>'stockcurrentid') as bigint);
p_user := cast(trim(json_object->>'user') as varchar);

if p_user is null then raise sqlstate 'S0001';
elsif p_company is null then raise sqlstate 'S0002';
elsif p_id is null then raise sqlstate 'S0003';
elsif p_stockid is null then raise sqlstate 'S0004';
elsif p_hotkey is null then raise sqlstate 'S0005';
elsif p_point is null then raise sqlstate 'S0007';
elsif p_scale is null then raise sqlstate 'S0008';
end if;

--Проверка на наличие горячей клавиши
select	hotkey into	p_existinghotkeys
	from	stockcurrent s 
	inner join products p on (s.product=p.id and s.company = p.company)
	where	s.company = p_company
		and s.point = p_point
		and p.deleted =false
		and s.scale = p_scale
		and	s.hotkey = p_hotkey;
IF FOUND THEN
	RAISE SQLSTATE 'S0006';
END IF;	
			
--Обновить горячую клавишу у товара
update stockcurrent set hotkey = p_hotkey where company = p_company and id = p_stockid and product = p_id;

result := json_build_object('code', 'success', 'text', 'Горячая клавиша обновлена успешно!');
return next;

exception
when sqlstate 'S0001' then result := json_build_object('code', 'error', 'text', 'Не указан пользователь!');
return next;
when sqlstate 'S0002' then result := json_build_object('code', 'error', 'text', 'Не указана компания!');
return next;
when sqlstate 'S0003' then result := json_build_object('code', 'error', 'text', 'Не указан идентификатор товара!');
return next;
when sqlstate 'S0004' then result := json_build_object('code', 'error', 'text', 'Не указан идентификатор товара на складе!');
return next;
when sqlstate 'S0005' then result := json_build_object('code', 'error', 'text', 'Не указана горячая клавиша!');
return next;
when sqlstate 'S0006' then result := json_build_object('code', 'error', 'text', 'Данный номер на весах уже занят!');
return next;
when sqlstate 'S0007' then result := json_build_object('code', 'error', 'text', 'Торговая точка не найдена!');
return next;
when sqlstate 'S0008' then result := json_build_object('code', 'error', 'text', 'Весы не найдены!');
return next;
when others then raise notice 'internal_error: %',
sqlerrm;

get STACKED diagnostics p_error = PG_EXCEPTION_CONTEXT,
p_check = CONSTRAINT_NAME;

result := json_build_object('code', 'internal_error', 'text', sqlstate || ':' || sqlerrm || ':' || p_error);

return next;
end;

$$;


ALTER FUNCTION public.productsweight_updatehotkey(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 711 (class 1255 OID 16549)
-- Name: rep_exp_date(bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.rep_exp_date(in_company bigint, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

declare 
  r record;
  ch0date date;
	ch3Date date;
  ch6Date date;
	ch9Date date;
  ch12Date date;
	json_object0 json;
  json_object3 json;
  json_object6 json;
	json_object9 json;
  json_object12 json;
	json_arr0 jsonb;
  json_arr3 jsonb;
  json_arr6 jsonb;
	json_arr9 jsonb;
  json_arr12 jsonb;
  p_error varchar;
  
BEGIN
	
	ch0Date = current_date;
  ch3Date = to_date(to_char(CURRENT_DATE+90,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  ch6Date = to_date(to_char(CURRENT_DATE+180,'yyyy-mm-dd'),'yyyy-mm-dd') ;
	ch9Date = to_date(to_char(CURRENT_DATE+270,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  ch12Date = to_date(to_char(CURRENT_DATE+360,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  
  
  
  for r in (
    select p.code, p."name", s.units, a."value" as dt 
      from products p, stockcurrent s, attrlist a
    where
      s.company = in_company and
      p.id = s.product and 
      p.company = s.company and
      
      s."attributes" = a.listcode and
      a."attribute" = 2
			and s.units > 0
      GROUP BY p.code, p."name", s.units, a."value"
			order by a."value"
  )loop
    begin     
				
			if date(r.dt) < ch0Date then
        SELECT row_to_json(r) into json_object0;
      
        if json_arr0 is null then select jsonb_build_array(json_object0) into json_arr0;
        else json_arr0 = json_arr0||json_object0::jsonb;
        end if;
      end if;
      
			if date(r.dt) < ch3Date and date(r.dt) >= ch0Date then
 				SELECT row_to_json(r) into json_object3;
        
        if json_arr3 is null then select jsonb_build_array(json_object3) into json_arr3;
        else json_arr3 = json_arr3||json_object3::jsonb;
        end if;
      end if;
      
      if date(r.dt) <= ch6Date and date(r.dt) > ch3Date then
        SELECT row_to_json(r) into json_object6;
      
        if json_arr6 is null then select jsonb_build_array(json_object6) into json_arr6;
        else json_arr6 = json_arr6||json_object6::jsonb;
        end if;
      end if;
			
			if date(r.dt) <= ch9Date and date(r.dt) > ch6Date then
        SELECT row_to_json(r) into json_object9;
      
        if json_arr9 is null then select jsonb_build_array(json_object9) into json_arr9;
        else json_arr9 = json_arr9||json_object9::jsonb;
        end if;
      end if;
      
      if date(r.dt) >= ch9Date and date(r.dt) < ch12Date then
        SELECT row_to_json(r) into json_object12;
        
        if json_arr12 is null then select jsonb_build_array(json_object12) into json_arr12;
        else json_arr12 = json_arr12||json_object12::jsonb;
        end if;
      end if;
      
    EXCEPTION
      when OTHERS then null;
    end;  
  end loop;
  
  
  if json_arr3 is not null or json_arr6 is not null or json_arr9 is not null or json_arr12 is not null then 
    result := json_build_object('code','sucess','text', '','array0',json_arr0,'array3',json_arr3,'array6',json_arr6, 'array9',json_arr9, 'array12',json_arr12);
  else 
    result := json_build_object('code','no_data_found','text', '');
	
	
  END if;
  return next;
  

  EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;
  

END; $$;


ALTER FUNCTION public.rep_exp_date(in_company bigint, OUT result json) OWNER TO postgres;

--
-- TOC entry 712 (class 1255 OID 16550)
-- Name: rep_exp_date_filt(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.rep_exp_date_filt(in_array json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

declare 
  r record;
  ch0date date;
	ch3Date date;
  ch6Date date;
	ch9Date date;
  ch12Date date;
	json_object0 json;
  json_object3 json;
  json_object6 json;
	json_object9 json;
  json_object12 json;
	json_arr0 jsonb;
  json_arr3 jsonb;
  json_arr6 jsonb;
	json_arr9 jsonb;
  json_arr12 jsonb;
  p_error varchar;
  
BEGIN
	
	ch0Date = current_date;
  ch3Date = to_date(to_char(CURRENT_DATE+90,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  ch6Date = to_date(to_char(CURRENT_DATE+180,'yyyy-mm-dd'),'yyyy-mm-dd') ;
	ch9Date = to_date(to_char(CURRENT_DATE+270,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  ch12Date = to_date(to_char(CURRENT_DATE+360,'yyyy-mm-dd'),'yyyy-mm-dd') ;
  
  
  
  for r in (
    select p1.name, s.point ,p.code, p."name", s.units, a."value" as dt 
      from products p, stockcurrent s, attrlist a, points p1
    where
      s.company = cast(trim(in_array->>'company') as bigint) and
      p.id = s.product and 
      p.company = s.company and
      p1.id=s.point and
      
      s."attributes" = a.listcode and
      a."attribute" = 2
			and s.units > 0
      GROUP BY p1.name, s.point ,p.code, p."name", s.units, a."value"
			order by a."value"
  )loop
    begin     
				
			if date(r.dt) < ch0Date then
        SELECT row_to_json(r) into json_object0;
      
        if json_arr0 is null then select jsonb_build_array(json_object0) into json_arr0;
        else json_arr0 = json_arr0||json_object0::jsonb;
        end if;
      end if;
      
			if date(r.dt) < ch3Date and date(r.dt) >= ch0Date then
 				SELECT row_to_json(r) into json_object3;
        
        if json_arr3 is null then select jsonb_build_array(json_object3) into json_arr3;
        else json_arr3 = json_arr3||json_object3::jsonb;
        end if;
      end if;
      
      if date(r.dt) <= ch6Date and date(r.dt) > ch3Date then
        SELECT row_to_json(r) into json_object6;
      
        if json_arr6 is null then select jsonb_build_array(json_object6) into json_arr6;
        else json_arr6 = json_arr6||json_object6::jsonb;
        end if;
      end if;
			
			if date(r.dt) <= ch9Date and date(r.dt) > ch6Date then
        SELECT row_to_json(r) into json_object9;
      
        if json_arr9 is null then select jsonb_build_array(json_object9) into json_arr9;
        else json_arr9 = json_arr9||json_object9::jsonb;
        end if;
      end if;
      
      if date(r.dt) >= ch9Date and date(r.dt) < ch12Date then
        SELECT row_to_json(r) into json_object12;
        
        if json_arr12 is null then select jsonb_build_array(json_object12) into json_arr12;
        else json_arr12 = json_arr12||json_object12::jsonb;
        end if;
      end if;
      
    EXCEPTION
      when OTHERS then null;
    end;  
  end loop;
  
  
  if json_arr3 is not null or json_arr6 is not null or json_arr9 is not null or json_arr12 is not null then 
    result := json_build_object('code','sucess','text', '','array0',json_arr0,'array3',json_arr3,'array6',json_arr6, 'array9',json_arr9, 'array12',json_arr12);
  else 
    result := json_build_object('code','no_data_found','text', '');
	
	
  END if;
  return next;
  

  EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;
  

END; $$;


ALTER FUNCTION public.rep_exp_date_filt(in_array json, OUT result json) OWNER TO postgres;

--
-- TOC entry 713 (class 1255 OID 16551)
-- Name: reportdata_generation(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.reportdata_generation(OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
	r							record;
	p_result			bigint[];
BEGIN
	
	-- Фиксирование даты и времени последней отработки (Начало выполнения)
	UPDATE jobcheck
		SET last_update_start = clock_timestamp()::timestamp
			WHERE jobname = 'reportdata_generation';
	
	-- Сводная информация по компаниям
	SELECT array_agg(t.count) INTO p_result
		FROM (
			-- Всего компаний
				SELECT COUNT(distinct id) as count
					FROM companies
						WHERE id NOT IN (0,2,17,49,37)
			UNION ALL
			-- Всего торговых точек
				SELECT COUNT(distinct id) as count
					FROM points
						WHERE point_type = 2
							AND company NOT IN (0,2,17,49,37)
			UNION ALL
			-- Новые компании с первого числа
				SELECT COUNT(distinct id) as count
					FROM companies
						WHERE created >= (select date_trunc('month',current_Date-1)::date)
							AND id NOT IN (0,2,17,49,37)
			UNION ALL
			-- Новые торговые точки с первого числа
				SELECT COUNT(distinct id) as count
					FROM points
						WHERE point_type = 2
							AND created >= (select date_trunc('month',current_Date-1)::date)
							AND company NOT IN (0,2,17,49,37)
			UNION ALL
			-- Количество активных компаний
				SELECT COUNT(distinct id) as count
					FROM companies
						WHERE status = 'ACTIVE'
							AND id NOT IN (0,2,17,49,37)
			UNION ALL
			-- Количество точек у активных компаний
				SELECT COUNT(distinct points.id) as count
					FROM companies
						INNER JOIN points on (points.company = companies.id and points.point_type = 2)
							WHERE companies.status = 'ACTIVE'
								AND companies.id NOT IN (0,2,17,49,37)
			UNION ALL
			-- Количество активных точек у активных компаний
				SELECT COUNT(distinct points.id) as count
					FROM companies
						INNER JOIN points on (points.company = companies.id and points.point_type = 2)
							WHERE companies.status = 'ACTIVE'
								AND points.status = 'ACTIVE'
								AND companies.id NOT IN (0,2,17,49,37)
			UNION ALL
			-- Количество активных компаний, у которых продажи более 10к тенге за последние 30 дней
				SELECT COUNT(distinct companies.id) as count
					FROM companies
							WHERE companies.status = 'ACTIVE'
								AND EXISTS (SELECT 1
																	FROM (SELECT sum(price) as price, date::date, company
																					FROM transactions
																						WHERE date::date > current_date - 31
																							AND company = companies.id
																								GROUP BY company, date::date)t
																									WHERE coalesce(t.price,0) >= 10000)
								AND companies.id NOT IN (0,2,17,49,37)																					
			UNION ALL
			-- Количество активных компаний, у которых продажи менее 10к тенге за последние 30 дней
				SELECT COUNT(distinct companies.id) as count
					FROM companies
							WHERE companies.status = 'ACTIVE'
								AND NOT EXISTS (SELECT 1
																	FROM (SELECT sum(price) as price, date::date, company
																					FROM transactions
																						WHERE date::date > current_date - 31
																							AND company = companies.id
																								GROUP BY company, date::date)t
																									WHERE coalesce(t.price,0) >= 10000)
								AND companies.id NOT IN (0,2,17,49,37)																	
			UNION ALL
			-- Количество открытых касс на текущую дату
				/*SELECT COUNT(distinct ca.cashbox)
					FROM cashboxdiary ca
						WHERE operdate = (SELECT max(operdate)
																FROM cashboxdiary
																	WHERE company = ca.company
																		AND opercode in (3,4))
							AND ca.opercode = 3	
								AND operdate::date = current_date	- 1*/
				SELECT COUNT(distinct ca.cashbox)
					FROM cashboxdiary ca
						WHERE operdate::date >= current_date - 1
							AND ca.opercode = 3
							AND ca.company NOT IN (0,2,17,49,37)					
			UNION ALL
			-- Количество открытых касс за последние 3 дня										
				SELECT COUNT(distinct ca.cashbox)
					FROM cashboxdiary ca
						WHERE operdate::date >= current_date - 4
							AND ca.opercode = 3	
							AND ca.company NOT IN (0,2,17,49,37)
			UNION ALL
			-- Количество компаний без открытых касс за 3 дня
				SELECT COUNT(distinct c.id)
					FROM companies c
						INNER JOIN points p on (p.company = c.id)
						INNER JOIN cashboxes b on (b.point = p.id)
						LEFT JOIN cashboxdiary d on (d.cashbox = b.id and d.company = c.id)
							WHERE c.status = 'ACTIVE'
								AND p.status = 'ACTIVE'
								AND b.isengaged is true
								AND b.deleted is false
								AND NOT EXISTS (SELECT 1
																	FROM cashboxdiary
																		WHERE operdate::date > current_date - 4
																			AND company = c.id
																			AND opercode = 3)
								AND c.id NOT IN (0,2,17,49,37)											
			) t;
			
			-- Садим данные в отчетную таблицу
			INSERT INTO admincompanies_report (date,allcompanies,allpoints,newcompanies,newpoints,activecomp,activecompallpoints,activecompactivepoints,compup,compdown,opencashboxes,
																							opencashboxes3,compwithoutopencash)
				VALUES(current_date-1,p_result[1],p_result[2],p_result[3],p_result[4],p_result[5],p_result[6],p_result[7],p_result[8],p_result[9],p_result[10],p_result[11],p_result[12]);
			
			-- Детализация по общему количеству компаний на дату	
		  INSERT INTO admincompanies_report_details("date","type","object")
				SELECT distinct current_date-1, 1, id
					FROM companies
						WHERE id NOT IN (0,2,17,49,37);
					
			-- Детализация по новым компаниям с 1-го числа текущего месяца
		  INSERT INTO admincompanies_report_details("date","type","object")
				SELECT distinct current_date-1, 2, id
					FROM companies
						WHERE created >= (select date_trunc('month',current_Date-1)::date)
							AND id NOT IN (0,2,17,49,37);
						
			-- Детализация по активным компаниям на дату	
		  INSERT INTO admincompanies_report_details("date","type","object")
				SELECT distinct current_date-1, 3, id
					FROM companies
						WHERE status = 'ACTIVE'
							AND id NOT IN (0,2,17,49,37);	
						
			-- Детализация по активным компаниям у которых продажи более 10к тенге за последние 30 дней
		  INSERT INTO admincompanies_report_details("date","type","object")
				SELECT distinct current_date-1, 4, companies.id
					FROM companies
							WHERE companies.status = 'ACTIVE'
								AND EXISTS (SELECT 1
																	FROM (SELECT sum(price) as price, date::date, company
																					FROM transactions
																						WHERE date::date > current_date - 31
																							AND company = companies.id
																								GROUP BY company, date::date)t
																									WHERE coalesce(t.price,0) >= 10000)
								AND companies.id NOT IN (0,2,17,49,37);
								
			-- Детализация по активным компаниям у которых продажи менее 10к тенге за последние 30 дней
		  INSERT INTO admincompanies_report_details("date","type","object")
				SELECT distinct current_date-1, 5, companies.id
					FROM companies
							WHERE companies.status = 'ACTIVE'
								AND NOT EXISTS (SELECT 1
																	FROM (SELECT sum(price) as price, date::date, company
																					FROM transactions
																						WHERE date::date > current_date - 31
																							AND company = companies.id
																								GROUP BY company, date::date)t
																									WHERE coalesce(t.price,0) >= 10000)
								AND companies.id NOT IN (0,2,17,49,37);
								
			-- Детализация по активным компаниям без открытых касс за 3 дня
		  INSERT INTO admincompanies_report_details("date","type","object")
				SELECT distinct current_date-1, 6, c.id
					FROM companies c
						INNER JOIN points p on (p.company = c.id)
						INNER JOIN cashboxes b on (b.point = p.id)
						LEFT JOIN cashboxdiary d on (d.cashbox = b.id and d.company = c.id)
							WHERE c.status = 'ACTIVE'
								AND p.status = 'ACTIVE'
								AND b.isengaged is true
								AND b.deleted is false
								AND NOT EXISTS (SELECT 1
																	FROM cashboxdiary
																		WHERE operdate::date > current_date - 4
																			AND company = c.id
																			AND opercode = 3)
								AND c.id NOT IN (0,2,17,49,37);	
																			
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'reportdata_generation';																							
	
  result := json_build_object('code','success','text','','date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION public.reportdata_generation(OUT result json) OWNER TO postgres;

--
-- TOC entry 714 (class 1255 OID 16553)
-- Name: revision(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revision(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object			json;
 products_object		json;
 p_code					varchar;
 p_text				  	varchar;
 p_error				varchar;
 p_check				varchar;
 p_company				bigint;
 p_point				bigint;
 p_stock_point			bigint;
 p_product_id			bigint;
 p_user					bigint;
 p_units				float8;
 p_unitswas 			float8;
 p_time					TIMESTAMP;
 p_submitdate			TIMESTAMP;
 p_attribute   			bigint;
 p_currunits 			float8;
 p_currprice 			float8;
 p_stock				bigint;
 p_point_last			bigint;
 r                  	record;
 i                  	record;
 z						record;
 p_invoicenumber		bigint;
 p_diff					float8;
 p_purchaseprice		float8;
 p_purchasedate			date;
 p_revtype				int;
 p_check_revtype		int;
 p_createdate			TIMESTAMP;
 p_isminus 				boolean := true;
 p_unitsselled			float8;
 p_isexists				BOOLEAN;
 p_checkproduct			bigint;
 p_revcondition			int;

BEGIN
	--{"company": 15, "user": "m.asanova", "pointid": 169, "products": [{"prodid": 13747, "unitswas": 10, "time": "10.14.2019 14:09:12" ,"attribute": 11711, "units": 11 }]}
	--"revtype":0/1  null-мобильная 0-холодная 1-горячая 2-холоднаяUpdate 3-холоднаяSubmit 4-холодная без редактирования
	--"condition":1/2 1-полная 2-частичная
	-- "revsubmit": 0-default данные уже сохранившиеся в ревизии. 1- данные в обработке. 2 - данные после обработки(выводимые в отчёт).
	p_submitdate= date_trunc('second', now());

	SELECT (data)::json into json_object;

	SELECT id into p_user from erp_users where login = LOWER(cast(trim(json_object->>'user') as VARCHAR));
	p_company := cast(trim(json_object->>'company') as bigint);
	p_point := cast(trim(json_object->>'pointid') as bigint);
	p_revtype := cast(trim(json_object->>'revtype') as int);
	p_revcondition := cast(trim(json_object->>'condition') as int);
	
	select stock into p_point_last from pointset where pointset.point = p_point;
	
	IF p_point IS NULL THEN
		RAISE SQLSTATE 'S0001';
	END IF;
	

	FOR products_object IN SELECT * FROM json_array_elements((json_object)->'products')
  LOOP
		p_product_id := cast(trim(products_object->>'prodid') as bigint);
		p_units := cast(trim(products_object->>'units') as float8);
		p_time := TO_TIMESTAMP(products_object->>'time', 'MM.DD.YYYY HH24:MI:SS');
		p_attribute := cast(trim(products_object->>'attribute') as bigint);
		p_unitswas := cast(trim(products_object->>'unitswas') as float8);
		p_isminus := false;
				
		IF p_product_id IS NULL THEN
			RAISE SQLSTATE 'S0002';
		ELSIF p_units IS NULL THEN
			RAISE SQLSTATE 'S0003';
		ELSIF p_time IS NULL THEN
			RAISE SQLSTATE 'S0004';
		ELSIF p_unitswas IS NULL THEN
			RAISE SQLSTATE 'S0005';
		ELSIF p_units < 0 THEN
			RAISE SQLSTATE 'S0006';
		END IF;
		IF p_attribute IS NULL THEN
			p_attribute := 0;
		END IF;
		
		--получаем текущее количество на точке
		SELECT s.id, s.units, p.stock, ss.price INTO p_stock, p_currunits, p_stock_point, p_currprice 
		FROM stockcurrent s,pointset p, storeprices ss
			WHERE p.stock = s.point
			AND	p.point = p_point
			AND s.id = ss.stock
			AND p.point = ss.store
			AND s.company = ss.company
			AND s.product = p_product_id
			AND s.attributes = p_attribute
			AND s.company = p_company;
		
		--Проданные за время ревизии
		SELECT	coalesce(p_unitswas-s.units,0) INTO p_unitsselled
	        FROM	stockcurrent s
	        WHERE 	s.product = p_product_id
			AND		s.attributes = p_attribute
			AND		s.point = p_stock_point
			AND 	s.company = p_company;
		
		--проверка на наличие данного товара в данной ревизии. Попадает только в последнее условие.
		SELECT product INTO p_checkproduct 
		FROM revisiondiary
			WHERE company = p_company 
			AND "user" = p_user 
			AND revtype = p_revtype 
			AND submitdate is null 
			AND createdate::date = current_date 
			AND product = p_product_id
			AND attributes = p_attribute;
		p_isexists := case when p_checkproduct is null then false else true end;
		
		IF p_revtype = 2 THEN

			p_createdate := (products_object->>'createdate')::TIMESTAMP;

			UPDATE revisiondiary
			SET units = p_units
			where createdate = p_createdate
				and point = p_stock_point
				and "user" = p_user
				and company = p_company
				and product = p_product_id
				and attributes = p_attribute
				and revtype = 0;

			result := json_build_object('code','success','text',p_createdate);
			return next;
			return;
		END IF;

		IF p_revtype = 3 THEN
			p_createdate := (products_object->>'createdate')::TIMESTAMP;
			-- Проверка на случай повторного вызова
			IF p_check_revtype IS NULL THEN
				SELECT count(*) INTO p_check_revtype
					FROM revisiondiary
						WHERE createdate = p_createdate
							AND point = p_stock_point
							AND "user" = p_user
							AND company = p_company
							AND product = p_product_id
							AND attributes = p_attribute
							AND revtype = 0;
				-- Если не было найдено записей с типом 0, значит ревизия была уже обработана			
				IF p_check_revtype = 0 THEN
					RAISE SQLSTATE 'S0007';
				END IF;
			END IF;


			UPDATE revisiondiary
			SET superviser = p_user,
				submitdate = p_submitdate,
				units = (p_units - p_unitsselled),
				revtype = 3,
				revcondition = p_revcondition,
				unitswas = (p_unitswas - p_unitsselled)
			WHERE createdate = p_createdate
				AND point = p_stock_point
				AND "user" = p_user
				AND company = p_company
				AND product = p_product_id
				AND attributes = p_attribute
				AND revtype = 0;
			
			--сохранение разницы склада и проведенной ревизии
			IF NOT FOUND THEN
				INSERT INTO revisiondiary(superviser,submitdate,createdate,revisiondate,units,unitswas,unitswhileinsert,point,"user",company,product,attributes,revtype,price)
				VALUES(p_user,p_submitdate,p_createdate,p_time,(p_units - p_unitsselled),(p_unitswas- p_unitsselled),p_currunits,p_stock_point,p_user,p_company,p_product_id,p_attribute,3,p_currprice);
			END IF;
		
		ELSIF p_revtype = 4 THEN	
				p_createdate := (products_object->>'createdate')::TIMESTAMP;
				-- Проверка на случай повторного вызова
				IF p_check_revtype IS NULL THEN
					SELECT count(*) INTO p_check_revtype
						FROM revision_temp
							WHERE "user" = p_user 
								AND point = p_point 
								AND company = p_company
								AND product = p_product_id
								AND attributes = p_attribute;
					-- Если не было найдено записей, значит ревизия была уже обработана
					IF p_check_revtype = 0 THEN
						RAISE SQLSTATE 'S0007';
					END IF;
				END IF;

	         
			--записываем данные в таблицу логов
			INSERT INTO revisiondiary(createdate,revisiondate,units,unitswas,unitswhileinsert,point,"user",company,product,attributes,revtype,price,revcondition)
			VALUES(now(),p_time,(p_units - p_unitsselled),(p_unitswas- p_unitsselled),p_currunits,p_stock_point,p_user,p_company,p_product_id,p_attribute,p_revtype,p_currprice,p_revcondition);
			
		ELSIF p_isexists = false THEN
			INSERT INTO revisiondiary(createdate,revisiondate,units,unitswas,unitswhileinsert,point,"user",company,product,attributes,revtype,price)
			VALUES(now(),p_time,p_units,p_unitswas,p_currunits,p_stock_point,p_user,p_company,p_product_id,p_attribute,p_revtype,p_currprice);
		else 
			RAISE SQLSTATE 'S0008';
		END IF;

		IF p_revtype = 0 THEN
			result := json_build_object('code','success','text',p_product_id,'revtype',p_revtype);
			return next;
			return;
		END IF;

		IF p_revtype = 4 THEN
			DELETE FROM revision_temp WHERE "user" = p_user and point = p_point and company = p_company;
		END IF;

		-- Для расчета партионного учета
		p_diff := p_unitswas - p_units;
		
		-- Для расчета партионного учета(Заполнение минусовых значений)
		IF (p_unitswas- p_unitsselled) < 0 THEN
			p_isminus := true;
			FOR z IN(SELECT date, units, purchaseprice
								FROM stockcurrent_part
									WHERE company = p_company
										AND point = p_stock_point
										AND product = p_product_id
										AND attributes = p_attribute
										AND units < 0
										ORDER BY date, purchaseprice)
			LOOP				
				IF p_diff = 0 THEN				
					EXIT;					
				ELSIF z.units > p_diff OR (p_diff = z.units) THEN		
					UPDATE stockcurrent_part
						SET units = 0
							WHERE product = p_product_id
								AND attributes =  p_attribute
								AND point = p_stock_point
								AND company = p_company
								AND date = z.date
								AND purchaseprice = z.purchaseprice
								AND units < 0;	
							  p_diff := p_diff + (-z.units);
								--записываем данные о ревизии в дневник склада
								INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
									VALUES(now(),'5',p_stock_point,p_product_id,(-z.units),0,p_attribute,p_company,z.purchaseprice,z.date);	
				ELSIF (p_diff > z.units) THEN					
					UPDATE stockcurrent_part
						SET units = units - p_diff
							WHERE product = p_product_id
								AND attributes =  p_attribute
								AND point = p_stock_point
								AND company = p_company
								AND date = z.date
								AND purchaseprice = z.purchaseprice
								AND units < 0;			
								--записываем данные о ревизии в дневник склада
								INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
									VALUES(now(),'5',p_stock_point,p_product_id,(-p_diff),0,p_attribute,p_company,z.purchaseprice,z.date);		
								p_diff := 0;	
				END IF;
			END LOOP;
		END IF;
		
		IF p_unitswas < p_units AND p_diff <> 0 THEN
			-- Самая новая запись
			/*UPDATE stockcurrent_part
				SET units = units + (-p_diff)
					WHERE company = p_company
						AND point = p_stock_point
						AND product = p_product_id
						AND attributes = p_attribute
						--AND units > 0
						AND date = (SELECT MAX(date)
													FROM stockcurrent_part
														WHERE company = p_company
															AND point = p_stock_point
															AND product = p_product_id
															AND attributes = p_attribute
															--AND units > 0
															);*/											
			WITH cte AS (
				SELECT date, purchaseprice          
					FROM stockcurrent_part
						WHERE company = p_company
							AND point = p_stock_point
							AND product = p_product_id
							AND attributes = p_attribute
							AND (purchaseprice >= 0) 
							AND date = (SELECT MAX(date)
														FROM stockcurrent_part
															WHERE company = p_company
																AND point = p_stock_point
																AND product = p_product_id
																AND attributes = p_attribute
																AND (purchaseprice >= 0))
							LIMIT  1                  
			)
			UPDATE stockcurrent_part s
				SET units = units + (-p_diff) 
					FROM	cte
						WHERE s.company = p_company
							AND s.point = p_stock_point
							AND s.product = p_product_id
							AND s.attributes = p_attribute
							AND s.date = cte.date
							AND s.purchaseprice = cte.purchaseprice
								RETURNING s.purchaseprice, s.date INTO p_purchaseprice, p_purchasedate;			
			-- На всякий случай. Такое маловероятно, но все-таки.				
			IF NOT FOUND THEN
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
					VALUES(p_company,p_stock_point,current_date,p_product_id,p_attribute,0,(-p_diff));
				--записываем данные о ревизии в дневник склада
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
					VALUES(now(),'5',p_stock_point,p_product_id,(-p_diff),0,p_attribute,p_company,0,current_date);	
			ELSE
				--записываем данные о ревизии в дневник склада
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
					VALUES(now(),'5',p_stock_point,p_product_id,(-p_diff),0,p_attribute,p_company,p_purchaseprice,p_purchasedate);
			END IF;
		ELSIF p_unitswas > p_units AND p_diff <> 0 THEN
			FOR i IN (
					SELECT date, units, purchaseprice
						FROM stockcurrent_part
							WHERE company = p_company
								AND point = p_stock_point
									AND product = p_product_id
										AND attributes = p_attribute
											AND units > 0
												ORDER BY date, purchaseprice
				)
				LOOP
					-- С самой старой записи
					IF p_diff = 0 THEN				
						EXIT;					
					ELSIF i.units > p_diff THEN		
						UPDATE stockcurrent_part
							SET units = units - p_diff
								WHERE product = p_product_id
									AND attributes =  p_attribute
									AND point = p_stock_point
									AND company = p_company
									AND date = i.date
									AND purchaseprice = i.purchaseprice
									AND units > 0
										RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
						--записываем данные о ревизии в дневник склада			
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
							VALUES(now(),'-5',p_stock_point,p_product_id,-p_diff,0,p_attribute,p_company,i.purchaseprice,i.date);			
						p_diff := 0;
					ELSIF (p_diff > i.units) OR (p_diff = i.units) THEN
						p_diff := p_diff - i.units;							
						UPDATE stockcurrent_part
							SET units = 0
								WHERE product = p_product_id
									AND attributes =  p_attribute
									AND point = p_stock_point
									AND company = p_company
									AND date = i.date
									AND purchaseprice = i.purchaseprice
									AND units > 0
										RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
						--записываем данные о ревизии в дневник склада			
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
							VALUES(now(),'-5',p_stock_point,p_product_id,-i.units,0,p_attribute,p_company,i.purchaseprice,i.date);			
					END IF;
			  END LOOP;	
				-- Если данные в партициях закончились - минусуем из последней
				IF p_diff > 0 THEN
					UPDATE stockcurrent_part
							SET units = units - p_diff
								WHERE product = p_product_id
									AND attributes =  p_attribute
									AND point = p_stock_point
									AND company = p_company
									AND date = p_purchasedate
									AND purchaseprice = p_purchaseprice;
				END IF;
		ELSE
			-- Если ничего не поменялось, то и делать тогда ничего не надо
			NULL;
		END IF;
		
		--обновляем количество товаров на складе
		UPDATE stockcurrent
			SET units = case when (units <> (p_units-p_unitsselled) or units is null) then (p_units-p_unitsselled) else units end
				WHERE id = p_stock
					AND company = p_company
						AND point = p_stock_point;
					--AND product = p_product_id
					--AND attributes = p_attribute

		--создаем инвойс для обновления количества на точках
		--Обновление количества товара (8) (на эвкалиптусе в таблице invoicelist нет поля company)
		--stockfrom,stockto -- id точки, а не склада
		--p_stock -- id из таблицы stockcurrent
		--p_company -- id компании из таблицы companies

		insert into invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
		values(0,'IN_PROCESS',p_company,p_stock_point,p_stock_point,8,now()) 
		returning invoicenumber into p_invoicenumber;

		insert into invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company)
		values(p_invoicenumber,p_stock,0,0,0,0,false,p_stock,false,false, p_company);
		
		FOR r IN (
			SELECT b.id
				FROM companies c
					LEFT JOIN points p on (p.company = c.id) 
						LEFT JOIN cashboxes b on (b.point = p.id)
							WHERE company = p_company
								AND p.id = p_point
									AND point_type = '2'/*IN ('0','1')*/ -- На торговую точку 
										AND p.status = 'ACTIVE'
											AND c.status = 'ACTIVE'
												AND b.deleted = false
													AND b.isengaged = true
														ORDER BY p.id
		) 
		LOOP
		
			INSERT INTO public.systemmessage(point, invoice, type_message, altinvoice, cashbox)
				VALUES (p_point, p_invoicenumber, 8, null, r."id");

		END LOOP;

	END LOOP;

  result := json_build_object('code','success','text',p_product_id,'submitdate',p_submitdate,'revisiondate',p_time,'revtype',p_revtype);
  return next;

EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Не указана точка ревизии!');
		 return next; 	
	WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Не указан идентификатор продукта!');
		 return next;
	WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error','text','Не указано количество!');
		 return next;
	WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','Не указано время ревизии!');
		 return next;
	WHEN SQLSTATE 'S0005' THEN
		 result := json_build_object('code','error','text','Не указано количество до ревизии!');
		 return next;
	WHEN SQLSTATE 'S0006' THEN
		 result := json_build_object('code','error','text','Количество после ревизии не должно быть отрицательным!');
		 return next;	
	WHEN SQLSTATE 'S0007' THEN
		 result := json_build_object('code','error','text','Данная ревизия уже была совершена!');
		 return next;	
	WHEN SQLSTATE 'S0008' THEN
		 result := json_build_object('code','error','text','Возникла ошибка при добавлении товара');
		 return next;
	WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);	 
		 return next;
END;$$;


ALTER FUNCTION public.revision(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 715 (class 1255 OID 16555)
-- Name: revision_idle(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revision_idle(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object    			 json;
 products_object    	 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_check							 varchar;
 p_company						 bigint;
 p_point							 bigint;
 p_stock_point				 bigint;
 p_product_id					 bigint;
 p_user								 bigint;
 p_units					     float8;
 p_unitswas 			     float8;
 p_time					       TIMESTAMP;
 p_submitdate					 TIMESTAMP;
 p_attribute   				 bigint;
 p_currunits 					 float8;
 p_currprice 			     float8;
 p_stock							 bigint;
 r                  	 record;
 i                  	 record;
 z										 record;
 p_invoicenumber			 bigint;
 p_diff								 float8;
 p_purchaseprice			 float8;
 p_purchasedate			 	 date;
 p_revtype						 int;
 p_createdate					 TIMESTAMP;
 p_isminus 						 boolean := true;
 p_revsubmit					 int;
BEGIN
	--{"company": 15, "user": "m.asanova", "pointid": 169, "products": [{"prodid": 13747, "unitswas": 10, "time": "10.14.2019 14:09:12" ,"attribute": 11711, "units": 11 }]}
	--"revtype":0/1  null-мобильная 0-холодная 1-горячая 2-холоднаяUpdate 3-холоднаяSubmit 4-холодная без редактирования
	-- "revsubmit": 0-default данные уже сохранившиеся в ревизии. 1- данные в обработке. 2 - данные после обработки(выводимые в отчёт).
	p_submitdate= date_trunc('second', current_timestamp);

	SELECT (data)::json into json_object;

		select id into p_user from erp_users where login = LOWER(cast(trim(json_object->>'user') as VARCHAR));
    p_company := cast(trim(json_object->>'company') as bigint);
		p_point := cast(trim(json_object->>'pointid') as bigint);
		p_revtype := cast(trim(json_object->>'revtype') as int);
		p_revsubmit := cast(trim(json_object->>'revsubmit') as int);

		IF p_point IS NULL THEN
			RAISE SQLSTATE 'S0001';
		END IF;



	FOR products_object IN SELECT * FROM json_array_elements((json_object)->'products')
  LOOP
		p_product_id := cast(trim(products_object->>'prodid') as bigint);
		p_units := cast(trim(products_object->>'units') as float8);
		p_time := TO_TIMESTAMP(products_object->>'time', 'MM.DD.YYYY HH24:MI:SS');
		p_attribute := cast(trim(products_object->>'attribute') as bigint);
		p_unitswas := cast(trim(products_object->>'unitswas') as float8);
		p_isminus := false;
				
		IF p_product_id IS NULL THEN
			RAISE SQLSTATE 'S0002';
		ELSIF p_units IS NULL THEN
			RAISE SQLSTATE 'S0003';
		ELSIF p_time IS NULL THEN
			RAISE SQLSTATE 'S0004';
		ELSIF p_unitswas IS NULL THEN
			RAISE SQLSTATE 'S0005';
		ELSIF p_units < 0 THEN
			RAISE SQLSTATE 'S0006';
		END IF;
		IF p_attribute IS NULL THEN
			p_attribute := 0;
		END IF;

		--получаем текущее количество на точке
		select s.id, s.units, p.stock, ss.price into p_stock, p_currunits, p_stock_point, p_currprice from stockcurrent s,pointset p, storeprices ss
			WHERE p.stock = s.point
				AND	p.point = p_point
				AND s.id = ss.stock
				AND p.point = ss.store
				AND s.company = ss.company
				AND s.product = p_product_id
				AND s.attributes = p_attribute
				AND s.company = p_company;
	

		IF p_revtype = 3 AND p_revsubmit = 1 THEN
			--записываем временные данные не подтвержденные бухгалтером	
			p_createdate := (products_object->>'createdate')::TIMESTAMP;
			UPDATE revisiondiary
			SET superviser = p_user,
					submitdate = p_submitdate,
					units = p_units,
					revtype = 3,
					unitswas = p_unitswas,
					revsubmit = 1
			where createdate = p_createdate
						and point = p_stock_point
						and "user" = p_user
						and company = p_company
						and product = p_product_id
						and attributes = p_attribute
						and revtype = 0
						and revsubmit = 0;
			--сохранение разницы склада и проведенной ревизии
			IF NOT FOUND THEN
				INSERT INTO revisiondiary(superviser,submitdate,createdate,revisiondate,units,unitswas,unitswhileinsert,point,"user",company,product,attributes,revtype,price,revsubmit)
				VALUES(p_user,p_submitdate,p_createdate,p_time,p_units,p_unitswas,p_currunits,p_stock_point,p_user,p_company,p_product_id,p_attribute,3,p_currprice,1);
			END IF;
		ELSIF p_revtype=4 AND p_revsubmit = 1 THEN
			--временно хранить данные по ревизии подряд, до подтверждения
			INSERT INTO revisiondiary(createdate,revisiondate,units,unitswas,unitswhileinsert,point,"user",company,product,attributes,revtype,price,revsubmit)
			VALUES(now(),p_time,p_units,p_unitswas,p_currunits,p_stock_point,p_user,p_company,p_product_id,p_attribute,p_revtype,p_currprice,1);
		ELSE
			--записываем данные в таблицу логов
			INSERT INTO revisiondiary(createdate,revisiondate,units,unitswas,unitswhileinsert,point,"user",company,product,attributes,revtype,price,revsubmit)
			VALUES(now(),p_time,p_units,p_unitswas,p_currunits,p_stock_point,p_user,p_company,p_product_id,p_attribute,p_revtype,p_currprice,0);
		END IF;

		IF p_revtype = 0 THEN
			result := json_build_object('code','success','text',p_product_id);
			return next;
			return;
		END IF;

		IF p_revtype = 4 AND p_revsubmit = 1 THEN
			DELETE FROM revision_temp WHERE "user" = p_user and point = p_point and company = p_company;
		END IF;


	END LOOP;

  result := json_build_object('code','success','text',p_product_id,'submitdate',p_submitdate,'revisiondate',p_time,'revtype',p_revtype);
  return next;

EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Не указана точка ревизии!');
		 return next; 	
	WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Не указан идентификатор продукта!');
		 return next;
	WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error','text','Не указано количество!');
		 return next;
	WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','Не указано время ревизии!');
		 return next;
	WHEN SQLSTATE 'S0005' THEN
		 result := json_build_object('code','error','text','Не указано количество до ревизии!');
		 return next;
	WHEN SQLSTATE 'S0006' THEN
		 result := json_build_object('code','error','text','Количество после ревизии не должно быть отрицательным!');
		 return next;	 
	WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);	 
		 return next;
END;$$;


ALTER FUNCTION public.revision_idle(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 716 (class 1255 OID 16557)
-- Name: revisiondiary_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisiondiary_add(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE
	json_object					json;
	p_error							varchar;
	p_check							varchar;
	p_company						bigint;
	p_point							bigint; -- торговая точка
	p_stock_point				bigint;
	p_product_id				bigint;
	p_user							bigint;
	p_units							float8;
	p_unitswas 					float8;
	p_time							TIMESTAMP;
	p_submitdate				TIMESTAMP;
	p_attribute   			bigint;
	p_currprice 				float8; 
	p_stock							bigint;
	r                  	record;
	i                  	record;
	j 									record;
	z										record;
	x 									record;
	rec 								record;
	p_invoicenumber			bigint;
	p_diff							float8;
	p_purchaseprice			float8;
	p_purchasedate			date;
	p_createdate				TIMESTAMP; 
	p_isminus 					boolean := true;
	p_unitsselled				float8;
	p_checkproduct			bigint;
	p_revisionnumber 		bigint;
	p_revout 						smallint;
	p_outofrevision     smallint;	
	p_units_inserted    float8;
	p_editdate          timestamp;
	
BEGIN
	-- data json	
	-- {"outofrevision":"1","point":"189","revnumber":"338"}
	
	p_submitdate = date_trunc('second', now());

	SELECT (data)::json into json_object;

	p_stock_point := cast(trim(json_object->>'point') as bigint);
  p_revisionnumber := cast(trim(json_object->>'revnumber') as bigint);
	p_company := cast(trim(json_object->>'company') as bigint);
	p_user := cast(trim(json_object->>'user') as bigint);
	p_outofrevision := cast(trim(json_object->>'outofrevision') as smallint);
	
	IF p_stock_point IS NULL THEN
		RAISE SQLSTATE 'S0001';
	END IF;

		-- Получаем point (торговую точку) из таблицы pointset
	SELECT point INTO p_point FROM pointset where stock = p_stock_point;
	

	FOR j in (select * 
		from revision_temp 
			where revisionnumber = p_revisionnumber 
				and company = p_company 
					and point = p_stock_point 
						order by outofrevision desc, 
							createdate asc)
  LOOP
		p_product_id := j.product;
		p_units := j.units;
		p_time := j.createdate;
		p_attribute :=j.attributes;
		p_unitswas := j.unitswas;
		p_user := j.user; 	
		p_company := j.company;
		--p_point := j.point;
		p_createdate := j.createdate; 
		p_revout := j.outofrevision;
		p_isminus := false;
		p_units_inserted := j.units_inserted;
		p_editdate := j.editdate;
		
		IF p_product_id IS NULL THEN
			RAISE SQLSTATE 'S0002';
		END IF;
		IF p_units IS NULL THEN
			RAISE SQLSTATE 'S0003';
		END IF;
		IF p_time IS NULL THEN
			RAISE SQLSTATE 'S0004';
		END IF;
		IF p_unitswas IS NULL THEN
			RAISE SQLSTATE 'S0005';
		END IF;
		IF p_revisionnumber IS NULL THEN
		  RAISE SQLSTATE 'S0006';
		END IF;
		
		IF p_attribute IS NULL THEN
			p_attribute := 0;
		END IF;
				
		-- Получаем текущее количество на точке
		SELECT s.id, COALESCE(ss.price,0), p_unitswas-s.units INTO p_stock, p_currprice, p_unitsselled
			FROM stockcurrent s
		LEFT JOIN storeprices ss on (ss.stock = s.id and ss.company = s.company)
		WHERE s.product = p_product_id
			AND s.attributes = p_attribute
			AND s.company = p_company
			AND s.point = p_stock_point;

			
		-- Проверка на наличие данного товара в данной ревизии. Попадает только в последнее условие.
		SELECT product INTO p_checkproduct 
			FROM revisiondiary
		WHERE company = p_company 
			AND "user" = p_user
			AND submitdate is null 
			AND createdate::date = current_date 
			AND product = p_product_id
			AND attributes = p_attribute
			AND point = p_stock_point;
		
		-- Для обнуления остатков
		IF p_revout = 0 then
			p_units := 0;
			p_unitsselled := 0;
		END IF;
		
		IF p_checkproduct IS NULL THEN -- ?
			INSERT INTO revisiondiary
			(createdate,revisiondate,units,unitswas,point,"user",company,product,attributes,price,revisionnumber,submitdate,superviser,outofrevision,editdate,units_inserted)
			VALUES
			(p_createdate,p_time,p_units,p_unitswas,p_stock_point,p_user,p_company,p_product_id,p_attribute,p_currprice,p_revisionnumber,p_submitdate,p_user,p_revout,p_editdate,p_units_inserted);
		ELSE 
			RAISE SQLSTATE 'S0007';
		END IF;
		
	-- Партионный учет ----------------------------------------------------------------------------------------------------------------------------------	
			
	-- Для расчета партионного учета
	p_diff := p_unitswas - p_units;
		
		-- Для расчета партионного учета(Заполнение минусовых значений)
		IF (p_unitswas - p_unitsselled) < 0 THEN
			p_isminus :=  true;
			FOR z IN(SELECT date, units, purchaseprice
								FROM stockcurrent_part
									WHERE company = p_company
										AND point = p_stock_point
										AND product = p_product_id
										AND attributes = p_attribute
										AND units < 0
										ORDER BY date, purchaseprice)
			LOOP				
				
				IF p_diff = 0 THEN				
					EXIT;
				END IF;
				
				IF z.units > p_diff OR (p_diff = z.units) THEN		
					UPDATE stockcurrent_part
						SET units = 0
							WHERE product = p_product_id
								AND attributes =  p_attribute
								AND point = p_stock_point
								AND company = p_company
								AND date = z.date
								AND purchaseprice = z.purchaseprice
								AND units < 0;	
							  p_diff := p_diff + (-z.units);
								--записываем данные о ревизии в дневник склада
								INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
									VALUES(now(),'5',p_stock_point,p_product_id,(-z.units),0,p_attribute,p_company,z.purchaseprice,z.date);	
				END IF;
				
				IF (p_diff > z.units) THEN					
					UPDATE stockcurrent_part
						SET units = units - p_diff
							WHERE product = p_product_id
								AND attributes =  p_attribute
								AND point = p_stock_point
								AND company = p_company
								AND date = z.date
								AND purchaseprice = z.purchaseprice
								AND units < 0;			
								--записываем данные о ревизии в дневник склада
								INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
									VALUES(now(),'5',p_stock_point,p_product_id,(-p_diff),0,p_attribute,p_company,z.purchaseprice,z.date);		
								p_diff := 0;	
				END IF;
			END LOOP;
		END IF;
		
		IF p_unitswas < p_units AND p_diff <> 0 THEN
			-- Самая новая запись							
			WITH cte AS (
				SELECT date, purchaseprice          
					FROM stockcurrent_part
						WHERE company = p_company
							AND point = p_stock_point
							AND product = p_product_id
							AND attributes = p_attribute
							AND (purchaseprice >= 0) 
							AND date = (SELECT MAX(date)
														FROM stockcurrent_part
															WHERE company = p_company
																AND point = p_stock_point
																AND product = p_product_id
																AND attributes = p_attribute
																AND (purchaseprice >= 0))
							LIMIT  1                  
			)
			UPDATE stockcurrent_part s
				SET units = units + (-p_diff) 
					FROM	cte
						WHERE s.company = p_company
							AND s.point = p_stock_point
							AND s.product = p_product_id
							AND s.attributes = p_attribute
							AND s.date = cte.date
							AND s.purchaseprice = cte.purchaseprice
								RETURNING s.purchaseprice, s.date INTO p_purchaseprice, p_purchasedate;			
			-- На всякий случай. Такое маловероятно, но все-таки.				
			IF NOT FOUND THEN
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
				VALUES(p_company,p_stock_point,current_date,p_product_id,p_attribute,0,(-p_diff));
				--записываем данные о ревизии в дневник склада
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
					VALUES(now(),'5',p_stock_point,p_product_id,(-p_diff),0,p_attribute,p_company,0,current_date);	
			ELSE
				--записываем данные о ревизии в дневник склада
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
				VALUES(now(),'5',p_stock_point,p_product_id,(-p_diff),0,p_attribute,p_company,p_purchaseprice,p_purchasedate);
			END IF;
		END IF;
		
		IF p_unitswas > p_units AND p_diff <> 0 THEN
			FOR i IN (
					SELECT date, units, purchaseprice
						FROM stockcurrent_part
							WHERE company = p_company
								AND point = p_stock_point
									AND product = p_product_id
										AND attributes = p_attribute
											AND units > 0
												ORDER BY date, purchaseprice
			)
			LOOP
				-- С самой старой записи
				IF p_diff = 0 THEN				
					EXIT;
				END IF;
				IF i.units > p_diff THEN		
					UPDATE stockcurrent_part
						SET units = units - p_diff
							WHERE product = p_product_id
								AND attributes =  p_attribute
								AND point = p_stock_point
								AND company = p_company
								AND date = i.date
								AND purchaseprice = i.purchaseprice
								AND units > 0
									RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
					--записываем данные о ревизии в дневник склада			
					INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
						VALUES(now(),'-5',p_stock_point,p_product_id,-p_diff,0,p_attribute,p_company,i.purchaseprice,i.date);			
					p_diff := 0;
				END IF;
				
				IF (p_diff > i.units) OR (p_diff = i.units) THEN
					p_diff := p_diff - i.units;							
					UPDATE stockcurrent_part
						SET units = 0
							WHERE product = p_product_id
								AND attributes =  p_attribute
								AND point = p_stock_point
								AND company = p_company
								AND date = i.date
								AND purchaseprice = i.purchaseprice
								AND units > 0
									RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
					--записываем данные о ревизии в дневник склада			
					INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate)
						VALUES(now(),'-5',p_stock_point,p_product_id,-i.units,0,p_attribute,p_company,i.purchaseprice,i.date);			
				END IF;
			END LOOP;	
				-- Если данные в партициях закончились - минусуем из последней
			IF p_diff > 0 THEN
					UPDATE stockcurrent_part
							SET units = units - p_diff
								WHERE product = p_product_id
									AND attributes =  p_attribute
									AND point = p_stock_point
									AND company = p_company
									AND date = p_purchasedate
									AND purchaseprice = p_purchaseprice;
			END IF;
			-- Если ничего не поменялось, то и делать тогда ничего не надо
		END IF;
		
		-- Партионный учет ----------------------------------------------------------------------------------------------------------------------------------
		
		--обновляем количество товаров на складе
		IF p_units <> p_unitswas THEN -- OR 
			
			UPDATE stockcurrent	
				SET units = p_units - p_unitsselled
					WHERE "id" = p_stock
						AND company = p_company
							AND point = p_stock_point;
	
		--создаем инвойс для обновления количества на точках
		--stockfrom,stockto -- id точки, а не склада
		--p_stock -- id из таблицы stockcurrent
		--p_company -- id компании из таблицы companies
		
			
			IF p_invoicenumber IS NULL THEN
				INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
					VALUES(0,'IN_PROCESS',p_company,p_point,p_point,8,now()) 
						RETURNING invoicenumber INTO p_invoicenumber;
			END IF;
		
			INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company)
				VALUES(p_invoicenumber,p_stock,0,0,0,0,false,p_stock,false,false, p_company);	
		END IF;	

	END LOOP; -- это основной цикл
	
	
	IF p_outofrevision = 0 THEN
		-- Пробегаемся по товарам не прошедшие ревизию, чтобы положить их в таблицу revisiondiary
		FOR rec IN (
			SELECT sc.product, sc.attributes, sc.units FROM stockcurrent sc
				INNER JOIN products pr
					ON sc.product = pr.id and sc.company = pr.company
						INNER JOIN revision_list rl 
							ON rl.point = sc.point and rl.company = sc.company
								AND CASE
									WHEN rl.type = 2 THEN -- Если выбраны товары по бренду
										pr.brand = rl.type_id
											WHEN rl.type = 3 THEN -- Если выбраны товары по категории
												pr.category = rl.type_id
													ELSE TRUE END
														WHERE sc.point = p_stock_point AND sc.company = p_company AND NOT pr.deleted AND sc.units <> 0
															AND rl.status = upper('active') and rl.revisionnumber = p_revisionnumber
																AND sc.id NOT IN 
																	(SELECT s.id FROM stockcurrent s 
																		LEFT JOIN revision_temp rt
																			ON rt.product = s.product AND rt.attributes = s.attributes AND rt.point = s.point AND rt.company = s.company
																				--WHERE rt.point = p_stock_point
																				WHERE rt.revisionnumber = p_revisionnumber
																				)
			)
		
		LOOP

		-- Для обнуления остатков	
		UPDATE stockcurrent 
			SET units = 0
				WHERE product = rec.product 
					AND attributes = rec.attributes 
						AND company = p_company 
							AND point = p_stock_point;
			
		SELECT id 
			INTO p_stock 
				FROM stockcurrent 
					WHERE product = rec.product 
						AND attributes = rec.attributes 
							AND point = p_stock_point
								AND company = p_company;
			
		SELECT price 
			INTO p_currprice 
				FROM storeprices 
					WHERE stock = (SELECT id FROM stockcurrent 
						WHERE product = rec.product AND attributes = rec.attributes AND company = p_company AND point = p_stock_point);
		
		INSERT INTO revisiondiary
			("attributes",company,outofrevision,point,product,revisionnumber,units,unitswas,"user",superviser,price)
				VALUES
					(rec.attributes,p_company,p_outofrevision,p_stock_point,rec.product,p_revisionnumber,0,rec.units,p_user,p_user,p_currprice);
			
		IF p_invoicenumber IS NULL THEN
			INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
				VALUES(0,'IN_PROCESS',p_company,p_point,p_point,8,now()) 
					RETURNING invoicenumber INTO p_invoicenumber;
		END IF;
		
		INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company)
			VALUES(p_invoicenumber,p_stock,0,0,0,0,false,p_stock,false,false, p_company);
			
		END LOOP;
	END IF;
	-- Для обнуления остатков
	
	
	IF p_invoicenumber IS NOT NULL THEN
		FOR r IN (
			SELECT b.id
				FROM companies c	
					LEFT JOIN points p on (p.company = c.id) 
						LEFT JOIN cashboxes b on (b.point = p.id)
							WHERE company = p_company
								AND p.id = p_point
									AND point_type = '2' -- На торговую точку 
										AND p.status = 'ACTIVE'
											AND c.status = 'ACTIVE'
												AND b.deleted = false
													AND b.isengaged = true
														ORDER BY p.id
		) 
		LOOP	
			INSERT INTO systemmessage
				(point, invoice, type_message, altinvoice, cashbox)
					VALUES 
						(p_point, p_invoicenumber, 8, null, r."id");
		END LOOP;
	END IF;
	

	DELETE FROM revision_temp WHERE revisionnumber = p_revisionnumber and "user" = p_user and point = p_stock_point and company = p_company;
	
	UPDATE revision_list 
		SET status = 'COMPLETED', submitdate = CURRENT_TIMESTAMP 
			WHERE revisionnumber = p_revisionnumber 
				AND point = p_stock_point 
					AND company = p_company;
	
	result := json_build_object('code','success','text',p_product_id,'submitdate',p_submitdate,'revisiondate',p_time,'invoice',p_invoicenumber);
	return next;

	EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			result := json_build_object('code','error','text','Не указана точка ревизии!');
			return next; 	
		WHEN SQLSTATE 'S0002' THEN
			result := json_build_object('code','error','text','Не указан идентификатор продукта!');
			return next;
		WHEN SQLSTATE 'S0003' THEN
			result := json_build_object('code','error','text','Не указано количество!');
			return next;
		WHEN SQLSTATE 'S0004' THEN
			result := json_build_object('code','error','text','Не указано время ревизии!');
			return next;
		WHEN SQLSTATE 'S0005' THEN
			result := json_build_object('code','error','text','Не указано количество до ревизии!');
			return next;
		WHEN SQLSTATE 'S0006' THEN
			result := json_build_object('code','error','text','Не указан номер ревизии!');
			return next;
		WHEN SQLSTATE 'S0007' THEN
			result := json_build_object('code','error','text','Возникла ошибка при добавлении товара');
			return next;
		WHEN SQLSTATE 'S0008' THEN
			result := json_build_object('code','error','text','Возникла ошибка при добавлении товаров не прошедших ревизию');
			return next;		
		WHEN OTHERS THEN
			RAISE NOTICE 'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||p_error,'invoice', p_invoicenumber);
			return next;
END;$$;


ALTER FUNCTION public.revisiondiary_add(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 717 (class 1255 OID 16559)
-- Name: revisiondiary_insert(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisiondiary_insert(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$
DECLARE
	rec record;
	i bigint;
	l bigint;
		
	p_revisionnumber bigint;
	p_company bigint;
	p_point bigint;
	p_user bigint;
	
	p_invoice bigint;
	
	p_error varchar;
	p_check varchar;
	
	p_stock bigint;
	p_store bigint;
	p_price float8;
	p_unitsold bigint;
	
	p_diff numeric;
	p_units numeric;
	p_unitswas numeric;
	p_isminus boolean;
	
	x record;
	y record;
	
	p_purchaseprice float8;
	p_purchasedate date;
	
	p_product bigint;
	p_attributes bigint;
	
	
	
BEGIN
	
	-- inf := {"company":124,"point":371,"revisionnumber":1,"user":126}
	-- '{"company":124,"point":371,"revisionnumber":1,"user":126}'::json
	
	p_revisionnumber := coalesce(cast(inf->>'revisionnumber' as bigint),0);
	p_company := coalesce(cast(inf->>'company' as bigint),0);
	p_point := coalesce(cast(inf->>'point' as bigint),0);
	p_user := coalesce(cast(inf->>'user' as bigint),0);
	
	
	IF p_revisionnumber = 0 THEN
		raise sqlstate 'S0001';
	END IF;
	
	IF p_company = 0 THEN
		raise sqlstate 'S0002';
	END IF;
	
	IF p_point = 0 THEN
		raise sqlstate 'S0003';
	END IF;
	
	IF p_user = 0 THEN
		raise sqlstate 'S0004';
	END IF;
	
	
	i := 1;
	FOR rec IN (
		SELECT r.*, s.id as stock, s.units, sp.price, po.point as store, r.unitswas - s.units as sold
			FROM revisiontemp r
				INNER JOIN stockcurrent s 
					ON s.product = r.product AND r.attributes = s.attributes
						AND s.company = r.company AND s.point = r.point
							LEFT JOIN storeprices sp
								ON sp.stock = s.id AND sp.company = s.company
									LEFT JOIN pointset po
										ON po.stock = s.point
											WHERE r.revisionnumber = p_revisionnumber 
												AND r.company = p_company 
													AND r.point = p_point
														ORDER BY r.product, r.attributes
				
	)
	LOOP
		raise notice '%) stock - %, price - %, sold - %, point - %',
		i, rec.stock, rec.price, rec.sold, rec.store;
		
		
		p_unitswas := rec.unitswas;
		p_units := rec.units;
		p_product := rec.product;
		p_attributes := rec.attributes;
		p_unitsold := rec.sold;
		p_price := rec.price;
		p_store := rec.store;
		p_stock := rec.stock;
		
		INSERT INTO revision_diary
			(createdate,revisiondate,product,attributes,units,unitswas,company,point,"user",superviser,submitdate,price,revisionnumber,reason)
				VALUES
					(rec.createdate,rec.revisiondate,rec.product,rec.attributes,rec.units,rec.unitswas,rec.company,rec.point,rec."user",p_user,
						current_timestamp,rec.price,rec.revisionnumber,rec.reason);
		

		
		--создаем инвойс для обновления количества на точках
		--stockfrom,stockto -- id точки, а не склада
		--p_stock -- id из таблицы stockcurrent
		--p_company -- id компании из таблицы companies
		IF p_invoice IS NULL THEN
			INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
				VALUES(0,'IN_PROCESS',p_company,p_store,p_store,8,now()) 
					RETURNING invoicenumber INTO p_invoice;
		END IF;
		
		INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company)
			VALUES(p_invoice,p_stock,0,0,0,0,false,p_stock,false,false, p_company);
				
				-- Для расчета партионного учета
		p_diff := p_unitswas - p_units;
		
		-- Для расчета партионного учета(Заполнение минусовых значений)
		IF (p_unitswas - p_unitsold) < 0 THEN
			p_isminus :=  true;
			FOR x IN(SELECT date, units, purchaseprice
								FROM stockcurrent_part
									WHERE company = p_company
										AND point = p_point
										AND product = p_product
										AND attributes = p_attributes
										AND units < 0
										ORDER BY date, purchaseprice)
			LOOP				
				
				IF p_diff = 0 THEN				
					EXIT;
				END IF;
				
				IF x.units > p_diff OR (p_diff = x.units) THEN		
					UPDATE stockcurrent_part
						SET units = 0
							WHERE product = p_product
								AND attributes =  p_attributes
								AND point = p_point
								AND company = p_company
								AND date = x.date
								AND purchaseprice = x.purchaseprice
								AND units < 0;	
							  p_diff := p_diff + (-x.units);
								--записываем данные о ревизии в дневник склада
								INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,invoice)
									VALUES(now(),'5',p_point,p_product,(-x.units),0,p_attributes,p_company,x.purchaseprice,x.date,p_invoice);	
				END IF;
				
				IF (p_diff > x.units) THEN					
					UPDATE stockcurrent_part
						SET units = units - p_diff
							WHERE product = p_product
								AND attributes =  p_attributes
								AND point = p_point
								AND company = p_company
								AND date = x.date
								AND purchaseprice = x.purchaseprice
								AND units < 0;			
								--записываем данные о ревизии в дневник склада
								INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,invoice)
									VALUES(now(),'5',p_point,p_product,(-p_diff),0,p_attributes,p_company,x.purchaseprice,x.date,p_invoice);		
								p_diff := 0;	
				END IF;
			END LOOP;
		END IF;
		
		IF p_unitswas < p_units AND p_diff <> 0 THEN
			-- Самая новая запись							
			WITH cte AS (
				SELECT date, purchaseprice          
					FROM stockcurrent_part
						WHERE company = p_company
							AND point = p_point
							AND product = p_product
							AND attributes = p_attributes
							AND (purchaseprice >= 0) 
							AND date = (SELECT MAX(date)
														FROM stockcurrent_part
															WHERE company = p_company
																AND point = p_point
																AND product = p_product
																AND attributes = p_attributes
																AND (purchaseprice >= 0))
							LIMIT  1                  
			)
			UPDATE stockcurrent_part s
				SET units = units + (-p_diff) 
					FROM	cte
						WHERE s.company = p_company
							AND s.point = p_point
							AND s.product = p_product
							AND s.attributes = p_attributes
							AND s.date = cte.date
							AND s.purchaseprice = cte.purchaseprice
								RETURNING s.purchaseprice, s.date INTO p_purchaseprice, p_purchasedate;			
			-- На всякий случай. Такое маловероятно, но все-таки.				
			IF NOT FOUND THEN
				INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
				VALUES(p_company,p_point,current_date,p_product,p_attributes,0,(-p_diff));
				--записываем данные о ревизии в дневник склада
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,invoice)
					VALUES(now(),'5',p_point,p_product,(-p_diff),0,p_attributes,p_company,0,current_date,p_invoice);	
			ELSE
				--записываем данные о ревизии в дневник склада
				INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,invoice)
				VALUES(now(),'5',p_point,p_product,(-p_diff),0,p_attributes,p_company,p_purchaseprice,p_purchasedate,p_invoice);
			END IF;
		END IF;
		
		IF p_unitswas > p_units AND p_diff <> 0 THEN
			FOR y IN (
					SELECT date, units, purchaseprice
						FROM stockcurrent_part
							WHERE company = p_company
								AND point = p_point
									AND product = p_product
										AND attributes = p_attributes
											AND units > 0
												ORDER BY date, purchaseprice
			)
			LOOP
				-- С самой старой записи
				IF p_diff = 0 THEN				
					EXIT;
				END IF;
				IF y.units > p_diff THEN		
					UPDATE stockcurrent_part
						SET units = units - p_diff
							WHERE product = p_product
								AND attributes =  p_attributes
								AND point = p_point
								AND company = p_company
								AND date = y.date
								AND purchaseprice = y.purchaseprice
								AND units > 0
									RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
					--записываем данные о ревизии в дневник склада			
					INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,invoice)
						VALUES(now(),'-5',p_point,p_product,-p_diff,0,p_attributes,p_company,y.purchaseprice,y.date,p_invoice);			
					p_diff := 0;
				END IF;
				
				IF (p_diff > y.units) OR (p_diff = y.units) THEN
					p_diff := p_diff - y.units;							
					UPDATE stockcurrent_part
						SET units = 0
							WHERE product = p_product
								AND attributes =  p_attributes
								AND point = p_point
								AND company = p_company
								AND date = y.date
								AND purchaseprice = y.purchaseprice
								AND units > 0
									RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
					--записываем данные о ревизии в дневник склада			
					INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,invoice)
						VALUES(now(),'-5',p_point,p_product,-y.units,0,p_attributes,p_company,y.purchaseprice,y.date,p_invoice);			
				END IF;
			END LOOP;	
				-- Если данные в партициях закончились - минусуем из последней
			IF p_diff > 0 THEN
					UPDATE stockcurrent_part
							SET units = units - p_diff
								WHERE product = p_product
									AND attributes =  p_attributes
									AND point = p_point
									AND company = p_company
									AND date = p_purchasedate
									AND purchaseprice = p_purchaseprice;
			END IF;
			-- Если ничего не поменялось, то и делать тогда ничего не надо
		END IF;
		
		-- Партионный учет ----------------------------------------------------------------------------------------------------------------------------------
		
		
		--обновляем количество товаров на складе
		IF p_units <> p_unitswas THEN -- OR 
			
			UPDATE stockcurrent	
				SET units = p_units - p_unitsold
					WHERE "id" = p_stock
						AND company = p_company
							AND point = p_point;
							
		END IF;	

			
	i := i + 1;
	END LOOP; -- это основной цикл
	
	IF p_invoice IS NOT NULL THEN
		FOR rec IN (
			SELECT b.id
				FROM companies c	
					LEFT JOIN points p on (p.company = c.id) 
						LEFT JOIN cashboxes b on (b.point = p.id)
							WHERE company = p_company
								AND p.id = p_store
									AND point_type = '2' -- На торговую точку 
										AND p.status = 'ACTIVE'
											AND c.status = 'ACTIVE'
												AND b.deleted = false
													AND b.isengaged = true
														ORDER BY p.id
		) 
		LOOP	
			INSERT INTO systemmessage
				(point, invoice, type_message, cashbox)
					VALUES 
						(p_store, p_invoice, 8, rec."id");
		END LOOP;
	END IF;
	
	DELETE FROM revisiontemp WHERE revisionnumber = p_revisionnumber 
		AND "user" = p_user AND point = p_point AND company = p_company;
	
	UPDATE revision_list 
		SET status = 'COMPLETED', submitdate = CURRENT_TIMESTAMP 
			WHERE revisionnumber = p_revisionnumber 
				AND point = p_point 
					AND company = p_company;

	
	res := json_build_object('text','ok','result','success');
	RETURN;
	
	EXCEPTION
	
	WHEN SQLSTATE 'S0001' THEN
		res := json_build_object('code','error','text','Empty number of revision!');
		RETURN; 
		
	WHEN SQLSTATE 'S0002' THEN
		res := json_build_object('code','error','text','Empty company!');
		RETURN; 
		
	WHEN SQLSTATE 'S0003' THEN
		res := json_build_object('code','error','text','Empty point!');
		RETURN; 
		
	WHEN SQLSTATE 'S0004' THEN
		res := json_build_object('code','error','text','Empty user!');
		RETURN; 
		
	WHEN OTHERS THEN
		raise notice 'internal error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = constraint_name;
		res := json_build_object('code','internal error','comment',SQLERRM, 'product', rec.product, 'text',SQLSTATE||':'||p_error);
		RETURN;
	
	
	
END;
$$;


ALTER FUNCTION public.revisiondiary_insert(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 718 (class 1255 OID 16561)
-- Name: revisionlist_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisionlist_add(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare 
	-- inf = { "revisionnumber":2, "point":182, "status":"ACTIVE"}
	-- inf = {"point":182}
	p_revisionnumber bigint;
	p_point bigint;
	p_status varchar;
	p_company bigint;
	p_error varchar;
	p_admin bigint;
	p_type SMALLINT;
	p_type_id bigint;
	json_object json;
	res json;
	
begin
	select (inf)::json into json_object;
	

	p_point := json_object->>'point' as bigint;
	p_admin := json_object->>'admin' as bigint;
	p_type := json_object->>'type' as SMALLINT;
	p_type_id := json_object->>'object' as bigint;

	--res = json_build_object ( 'code', 'error', 'text', 'Сервис временно не доступен!' );
	--RETURN;
	
	if p_point is null then
		raise sqlstate 'S0001';
	end if;
	
	
	select status INTO p_status from revision_list where point = p_point ORDER BY ID DESC LIMIT 1;
	
	select max(revisionnumber) into p_revisionnumber from revision_list; 
	if p_revisionnumber is null 
		then p_revisionnumber := 1;
	end if;
	
	select company into p_company from points where id = p_point;
	
	if p_status = 'CANCELLED' or p_status = 'COMPLETED' or p_status is null then
		insert into revision_list
		(revisionnumber,point,company,"admin", "type", type_id)
		values
		(p_revisionnumber+1,p_point,p_company,p_admin, p_type, p_type_id);
	else
		raise sqlstate 'S0002';
	end IF;
	
	
	result := json_build_object('code','success','text','ok','revisionnumber',p_revisionnumber+1);
    return next;
	
	exception
	when sqlstate 'S0001' then
		result := json_build_object('code','error','text','Не ввели значение точки');
		return next;
	when sqlstate 'S0002' then
		result := json_build_object('code','error','text','Ревизия по точке '||p_point||' еще не закончена');
		return next;
	when others then
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;
	
end;
$$;


ALTER FUNCTION public.revisionlist_add(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 719 (class 1255 OID 16562)
-- Name: revisionlist_delete(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisionlist_delete(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$ DECLARE
	p_revnumber BIGINT;
	p_error VARCHAR;
	p_admin BIGINT;

BEGIN
		p_revnumber := inf :: json ->> 'revisionnumber' AS BIGINT;
		p_admin := inf :: json ->> 'admin' AS BIGINT;
		
		IF p_revnumber IS NULL THEN
			raise SQLSTATE'S0001';
		END IF;
		
		IF p_admin = ( SELECT "admin" FROM revision_list WHERE p_revnumber = revisionnumber ) THEN
			UPDATE revision_list 
			SET status = 'CANCELLED' 
			WHERE revisionnumber = p_revnumber 
			AND "admin" = p_admin;
		
			DELETE FROM revision_temp WHERE revisionnumber = p_revnumber;
		
			res := json_build_object ( 'code', 'success', 'text', 'ok' );
			RETURN NEXT;
		
		ELSE 
			raise SQLSTATE'S0002';
		
		END IF;
	
	EXCEPTION 
		WHEN SQLSTATE'S0001' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указан номер ревизии!' );
		RETURN NEXT;
		WHEN SQLSTATE'S0002' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Удалить или отменить ревизию может только администратор!' );
		RETURN NEXT;
	
	
	WHEN OTHERS THEN
		RAISE NOTICE'internal_error: %',
		SQLERRM;
	GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
	RETURN NEXT;
	
END;
$$;


ALTER FUNCTION public.revisionlist_delete(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 723 (class 1255 OID 16563)
-- Name: revisiontemp_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisiontemp_add(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$ 

DECLARE

	p_error VARCHAR;
	p_units FLOAT8;
	p_revisionnumber BIGINT;
	p_product BIGINT;
	p_point BIGINT;
	p_attributes BIGINT;
	p_unitswas FLOAT8;
	product_exist BIGINT;
	p_user BIGINT;
	p_company BIGINT;
	r RECORD;
	p_count SMALLINT;
	p_add BOOLEAN;
	p_reason TEXT;
	p_product_user BIGINT;
	p_revisiondate TIMESTAMP;
	p_revision_product BIGINT;	
	
BEGIN
	
	p_units := inf ->> 'units' AS FLOAT8;
	p_revisionnumber := inf ->> 'revisionnumber' AS BIGINT;
	p_product := inf ->> 'product' AS BIGINT;
	p_attributes := inf ->> 'attributes' AS BIGINT;
	p_user := inf ->> 'user' AS BIGINT;
	p_company := inf ->> 'company' AS BIGINT;
	p_add :=  inf ->> 'add' as BOOLEAN;
	p_reason := inf ->> 'reason' as TEXT;
	
	IF p_product IS NULL THEN
			raise SQLSTATE'S0001';
	END IF;

	IF p_attributes IS NULL THEN
			raise SQLSTATE 'S0002';
	END IF;
	
	IF p_company IS NULL THEN
			raise SQLSTATE'S0003';
	END IF;
	
	IF p_units IS NULL THEN
			raise SQLSTATE'S0005';
	END IF;
	
	IF p_revisionnumber IS NULL THEN
			raise SQLSTATE'S0006';
	END IF;
	
	IF p_user IS NULL THEN
			raise SQLSTATE'S0009';
	END IF;

	SELECT point INTO p_point
		FROM revision_list 
			WHERE company = p_company AND revisionnumber = p_revisionnumber;
	
	-- Для проверки на наличие данного товара в ревизии
	SELECT product, revisiondate, "user" 
		INTO p_revision_product, p_revisiondate, p_product_user 
			FROM revisiontemp 
				WHERE product = p_product 
					AND "attributes" = p_attributes
						AND company = p_company
							AND point = p_point 
								AND revisionnumber = p_revisionnumber; 

	
	IF p_revision_product IS NOT NULL THEN
		IF p_user = p_product_user THEN
		
			IF p_revisiondate IS NULL THEN
				UPDATE revisiontemp
					SET revisiondate = current_timestamp
						WHERE product = p_product AND attributes = p_attributes AND revisionnumber = p_revisionnumber; 
			END IF;
			
			UPDATE revisiontemp
				SET units = units + p_units,  editdate = CURRENT_TIMESTAMP, units_inserted =  p_units,  
					reason = '', "user" = p_user
						WHERE product = p_product AND attributes = p_attributes AND revisionnumber = p_revisionnumber; 
		ELSE
			raise SQLSTATE 'S0007';
		END IF;
			
	ELSE

		IF p_add THEN
		
			SELECT units INTO p_unitswas FROM stockcurrent 
				WHERE product = p_product and attributes = p_attributes
					AND company = p_company AND point = p_point;
			
			IF p_unitswas IS NULL THEN
				raise SQLSTATE 'S0010';
			END IF;
				
			INSERT INTO revisiontemp
				(createdate,units,point,"user",company,product,attributes,unitswas,revisionnumber)
					VALUES
						(current_timestamp,p_units,p_point,p_user,p_company,p_product,p_attributes,p_unitswas,p_revisionnumber);
		ELSE
			raise SQLSTATE 'S0008';
		END IF;
	END IF;
	
	res = json_build_object ( 'code', 'success', 'text', 'ok' );
	RETURN NEXT;

	
	EXCEPTION 
	
	WHEN SQLSTATE'S0001' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустой код продукта!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0002' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустое значение аттрибута!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0003' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустой номер компании!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0004' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустая точка!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0005' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустое количество товара!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0006' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустой номер ревизии!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0007' THEN
		res = json_build_object('code','error','text','Данный товар уже обрабатывается другим пользователем!');
	RETURN NEXT;
	
	WHEN SQLSTATE'S0008' THEN
		res = json_build_object('code','error','text','Данного товара нет в списке! Хотите его добавить?');
	RETURN NEXT;
	
	WHEN SQLSTATE'S0009' THEN
		res = json_build_object('code','error','text','Empty user!');
	RETURN NEXT;
	
	WHEN SQLSTATE'S0010' THEN
		res = json_build_object('code','error','text','There is no such good!');
	RETURN NEXT;
	
	
	WHEN OTHERS THEN
		RAISE NOTICE'internal_error: %',
		SQLERRM;
	GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
	RETURN NEXT;
	
END;
$$;


ALTER FUNCTION public.revisiontemp_add(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 724 (class 1255 OID 16564)
-- Name: revisiontemp_insert(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisiontemp_insert(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$ 

DECLARE

	p_error VARCHAR;
	p_units FLOAT8;
	p_revnumber BIGINT;
	p_product BIGINT;
	p_point BIGINT;
	p_attributes BIGINT;
	p_unitswas FLOAT8;
	product_exist BIGINT;
	p_user BIGINT;
	p_company BIGINT;
	r RECORD;

BEGIN
	
	p_units := inf ->> 'units' AS FLOAT8;
	p_revnumber := inf ->> 'revnumber' AS BIGINT;
	p_product := inf ->> 'product' AS BIGINT;
	p_point := inf ->> 'point' AS BIGINT;
	p_attributes := inf ->> 'attributes' AS BIGINT;
	--p_unitswas := inf ->> 'unitswas' AS BIGINT;
	p_user := inf ->> 'user' AS BIGINT;
	p_company := inf ->> 'company' AS BIGINT;
	
	--res = json_build_object ( 'code', 'error', 'text', 'Сервис временно не доступен!' );
	--RETURN NEXT;
	
	IF p_product IS NULL THEN
			raise SQLSTATE'S0001';
	END IF;

	IF p_revnumber IS NULL THEN
			raise SQLSTATE'S0002';
	END IF;
	
	IF p_units IS NULL THEN
			raise SQLSTATE'S0003';
	END IF;
	
	IF p_point IS NULL THEN
			raise SQLSTATE'S0004';
	END IF;
	
	IF p_attributes IS NULL THEN
			raise SQLSTATE 'S0005';
	END IF;
	
	--IF p_unitswas IS NULL THEN
	--	p_unitswas = p_units;
	--END IF;
	
	-- Для проверки на наличие данного товара в ревизии
	SELECT * INTO r FROM revision_temp where product = p_product and revisionnumber = p_revnumber and "attributes" = p_attributes;
	
	-- Берем значение, которое было момент ревизии
	SELECT units INTO p_unitswas FROM stockcurrent WHERE product = p_product AND attributes = p_attributes AND point = p_point AND company = p_company;
	
	IF r IS NULL THEN
		INSERT INTO revision_temp 
		( units, point, "user", company, product, "attributes", unitswas, revisionnumber, units_inserted, outofrevision)
		VALUES
		( p_units, p_point, p_user, p_company, p_product, p_attributes, p_unitswas, p_revnumber, p_units, 2);
		res = json_build_object ( 'code', 'success', 'text', 'ok' );
		RETURN NEXT;
	ELSE
		IF r."user" = p_user THEN
			--raise SQLSTATE 'S0007'; -- Сообщение для этого же пользователя
			UPDATE revision_temp
			SET units = units + p_units, editdate = CURRENT_TIMESTAMP, units_inserted =  units + p_units
			WHERE product = p_product and attributes = p_attributes and revisionnumber = p_revnumber and point = p_point ; 
			res = json_build_object ( 'code', 'success', 'text', 'ok' );
			RETURN NEXT;
		ELSE 
			raise SQLSTATE 'S0008'; -- Сообщение для другого пользователя
		END IF; 
	END IF;
	
	EXCEPTION 
	
	WHEN SQLSTATE'S0001' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустой код продукта!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0002' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустой номер ревизии!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0003' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустое количество товара!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0004' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустая точка!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0005' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустое значение аттрибута!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0006' THEN
		res = json_build_object ( 'code', 'error', 'text', 'Пустое количество!' );
	RETURN NEXT;
	
	WHEN SQLSTATE'S0007' THEN
		res = json_build_object('code','error','text','Текущий товар уже существует в данной ревизии!');
	RETURN NEXT;
	
	WHEN SQLSTATE'S0008' THEN
		res = json_build_object('code','error','text','Данный товар уже обрабатывается другим пользователем!');
	RETURN NEXT;
	
	WHEN OTHERS THEN
		RAISE NOTICE'internal_error: %',
		SQLERRM;
	GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
	RETURN NEXT;
	
END;
$$;


ALTER FUNCTION public.revisiontemp_insert(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 725 (class 1255 OID 16565)
-- Name: revisiontemp_out(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisiontemp_out(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	
	p_check VARCHAR;
	p_error VARCHAR;
	pro json;

	p_attr bigint;
	p_code bigint;
	p_company bigint;
	p_name varchar;
	p_outofrevision smallint;
	p_point bigint;
	p_product bigint;
	p_products json;
	p_revnumber BIGINT;
	p_units double precision;
	p_unitswas double precision;
	p_user bigint;
	
BEGIN
	
	-- {"outofrevision":1,"revnumber":1,"company":18,"user":42,products:
	-- [{"attributes":0,"code":1,"company":18,"name":"milk","point":192, "product":1,"units":1,"unitswas":2,"user":42},
	-- {"attributes":0,"code":2,"company":18,"name":"coffee","point":192, "product":2,"units":2,"unitswas":3,"user":42}]}
	
	
	p_company := inf->>'company';
	p_outofrevision := cast(inf->>'outofrevision' as smallint);
	p_products := inf->>'products' AS json;
	p_point := inf->>'point';
	p_revnumber := inf->>'revnumber' AS BIGINT;
	p_user := inf->>'user';
	
	IF p_revnumber IS NULL THEN
		raise SQLSTATE'S0001';
	ELSIF p_outofrevision IS NULL THEN
		raise SQLSTATE'S0002';
	ELSIF p_point IS NULL THEN
		raise SQLSTATE 'S0003';
	END IF;

	FOR pro	IN SELECT * FROM json_array_elements(inf->'products')
		LOOP
		
			p_attr := cast(trim(pro->>'attributes') as bigint);
			p_product := cast(trim(pro->>'product') as bigint);
			p_units := cast(trim(pro->>'units') as double precision);
			p_unitswas := p_units;
			
			insert into revision_temp
			("attributes",company,outofrevision,point,product,revisionnumber,units,unitswas,"user")
			values
			(p_attr,p_company,p_outofrevision,p_point,p_product,p_revnumber,p_units,p_unitswas,p_user);
			
		END LOOP;

	res := json_build_object ( 'code', 'success', 'text', 'ok' );
	RETURN NEXT;
	
	EXCEPTION 
		WHEN SQLSTATE'S0001' THEN
			res = json_build_object ( 'code', 'success', 'text', 'Не указан номер ревизии!');
		RETURN NEXT;
		WHEN SQLSTATE'S0002' THEN
			res = json_build_object ( 'code', 'success', 'text', 'Не указан статус ревизии продукта (outofrevision)!');
		RETURN NEXT;
		WHEN SQLSTATE'S0003' THEN
			res = json_build_object ( 'code', 'success', 'text', 'Не указана точка!');
		RETURN NEXT;
		
		WHEN OTHERS THEN
			RAISE NOTICE'internal_error: %',
			SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT,
			p_check = CONSTRAINT_NAME;
			res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
			RETURN NEXT;
	
END;
$$;


ALTER FUNCTION public.revisiontemp_out(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 726 (class 1255 OID 16566)
-- Name: revisiontemp_update(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.revisiontemp_update(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$ 

DECLARE
	p_product BIGINT;
	p_point BIGINT;
	p_user BIGINT;
	p_company BIGINT;
	p_attribute BIGINT;
	p_unitswas float8;
	p_revnumber BIGINT;
	p_product_exists bigint;
	p_user_exists bigint;
	p_error VARCHAR;
	
BEGIN
	
	/* inf = {
  "revnumber": "55",
  "point": "371",
  "id": "41274",
  "attribute": "0",
  "unitswas": 100
	}*/
	
	
	p_product := coalesce(cast(inf ->> 'id' AS BIGINT),0);
	p_attribute := coalesce(cast(inf ->> 'attribute' AS BIGINT),0);
	p_point := coalesce(cast(inf ->> 'point' AS BIGINT),0);
	
	p_user := coalesce(cast(inf ->> 'user' AS BIGINT),0);
	p_company := coalesce(cast(inf ->> 'company' AS BIGINT),0);
	
	p_revnumber := coalesce(cast(inf ->> 'revnumber' AS BIGINT),0);
	p_unitswas := cast(inf ->> 'unitswas' AS float8);
	
	-- Pause
	--res = json_build_object ( 'code', 'error', 'text', 'Сервис временно не доступен!' );
	--RETURN NEXT;
	--
	
	IF p_product = 0 THEN
		raise sqlstate 'S0001';
	END IF;
	
	--IF p_attribute = 0 THEN
	--	raise sqlstate 'S0002';
	--END IF;
	
	IF p_point = 0 THEN
		raise sqlstate 'S0003';
	END IF;
	
	IF p_company = 0 THEN
		raise sqlstate 'S0004';
	END IF;
	
	IF p_user = 0 THEN
		raise sqlstate 'S0005';
	END IF;

	IF p_revnumber = 0 THEN
		raise sqlstate 'S0006';
	END IF;
	
	IF p_unitswas IS NULL THEN
		raise sqlstate 'S0007';
	END IF;
		
		
	/*
	SELECT units INTO p_unitswas
		FROM stockcurrent 
			WHERE product = p_product 
				AND "attributes" = p_attribute 
					AND point = p_point 
						AND company = p_company;
	*/
	
	SELECT product, "user" INTO p_product_exists, p_user_exists
		FROM revision_temp 
			WHERE product = p_product AND "attributes" = p_attribute AND revisionnumber = p_revnumber AND company = p_company AND point = p_point;

	IF p_product_exists IS NULL THEN
		INSERT INTO revision_temp
			(createdate,units,point,"user",company,product,attributes,unitswas,revisionnumber,outofrevision,units_inserted)
				VALUES
					(CURRENT_TIMESTAMP, 1, p_point, p_user, p_company, p_product, p_attribute, p_unitswas, p_revnumber,2,1);
	ELSE
		
		IF p_user = p_user_exists THEN
			UPDATE revision_temp 
				SET units = units + 1, editdate = CURRENT_TIMESTAMP, units_inserted = units_inserted + 1
					WHERE product = p_product AND point = p_point AND revisionnumber = p_revnumber AND "attributes" = p_attribute AND "user" = p_user;
		ELSE
			RAISE SQLSTATE 'S0008';
		END IF;
	END IF;
	
	res := json_build_object ( 'code', 'success', 'text', 'ok' );
	RETURN NEXT;
		
	EXCEPTION
	
		WHEN SQLSTATE 'S0001' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указан идентификатор продукта!');
		RETURN NEXT;
		
		WHEN SQLSTATE 'S0002' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указаны атрибуты!' );
		RETURN NEXT;
		
		WHEN SQLSTATE 'S0003' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указана точка!' );
		RETURN NEXT;
		
		WHEN SQLSTATE 'S0004' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указана компания!' );
		RETURN NEXT;
		
		WHEN SQLSTATE 'S0005' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указан пользователь!' );
		RETURN NEXT;
		
		WHEN SQLSTATE 'S0006' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указан номер ревизии!' );
		RETURN NEXT;
		
		WHEN SQLSTATE 'S0007' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Не указано количество товара!' );
		RETURN NEXT;
		
		WHEN SQLSTATE 'S0008' THEN
			res := json_build_object ( 'code', 'error', 'text', 'Данный товар уже обрабатывается другим пользователем!');
		RETURN NEXT;
		
	
		
		
		WHEN OTHERS THEN
			RAISE NOTICE'internal_error: %', SQLERRM;
			GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
			res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
			RETURN NEXT;
					
END;
$$;


ALTER FUNCTION public.revisiontemp_update(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 731 (class 1255 OID 16567)
-- Name: scale_invoice(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.scale_invoice(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$ DECLARE
	r record;
	p_check text;
	p_error text;
	p_product bigint;
	p_scale bigint;
	p_code bigint;
	p_company bigint;
	p_name text;
	p_tax smallint;
	p_invoicenumber bigint;
	p_newprice float8;
	p_purchaseprice float8;
	p_user bigint;
	p_barcode text;
	p_nulls text;
	p_nonulls text;
	p_count bigint;
	p_hotkey bigint;
	p_scale_in bigint;
	
BEGIN
		-- inf = {"product":"1","scale":"55","code":"5500001"}
		p_product = coalesce(cast(inf->>'id' as bigint),0);
		p_scale = coalesce(cast(inf->>'scale' as bigint),0);
		p_company = coalesce(cast(inf->>'company' as bigint),0);
		p_user = coalesce(cast(inf->>'user' as bigint),0);
		p_nulls := '';
		
		IF p_product = 0 THEN
			raise sqlstate 'S0001';
		END IF;
		
		IF p_scale = 0 THEN
			raise sqlstate 'S0002';
		END IF;
		
		IF p_code = 0 THEN
			--raise sqlstate 'S0003';
			p_code = '1';
		END IF;
		
		
		IF p_company = 0 THEN
			raise sqlstate 'S0004';
		END IF;
		
		IF p_user = 0 THEN
			raise sqlstate 'S0005';
		END IF;
		
		-- newprice
		SELECT price INTO p_newprice
			FROM prices
				WHERE product = p_product AND company = p_company AND not deleted and type = 0;
		
		-- purchaseprice
		SELECT price INTO p_purchaseprice
			FROM prices
				WHERE product = p_product AND company = p_company AND not deleted and type = 1;
		
		IF NOT FOUND THEN
			raise sqlstate 'S0006';
		ELSE
		
			-- Проверка на повторяемость добавления привязки 
			SELECT scale INTO p_scale_in FROM pluproducts_scale WHERE product = p_product AND company = p_company AND scale = p_scale;
			IF p_scale_in IS NULL THEN
			
				-- Привязка товара к весам 
				INSERT INTO pluproducts_scale
					(product,scale,hotkey,company)
						VALUES
							(p_product,p_scale,0,p_company);
		
			-- Проставление номера весам
				UPDATE pluproducts_scale
					SET hotkey = (SELECT max(hotkey)+1 FROM pluproducts_scale WHERE company = p_company AND scale = p_scale)
						WHERE product = p_product AND company = p_company AND scale = p_scale;		
			ELSE
				raise sqlstate 'S0007';
			END IF;
		END IF;			
		

		
		res = json_build_object('code','success','text','ok');
		return;
		
		EXCEPTION
		
			WHEN sqlstate 'S0001' THEN
				res = json_build_object('code','exception','text','Не указан идентификатор продукта!');
				return;
			
			WHEN sqlstate 'S0002' THEN
				res = json_build_object('code','exception','text','Не указан идентификатор весов!');
				return;
			
			WHEN sqlstate 'S0003' THEN
				res = json_build_object('code','exception','text','Не указан штрихкод продукта!');
				return;
			
			WHEN sqlstate 'S0004' THEN
				res = json_build_object('code','exception','text','Не указана компания!');
				return;
			
			WHEN sqlstate 'S0005' THEN
				res = json_build_object('code','exception','text','Не указан пользователь!');
				return;
				
			WHEN sqlstate 'S0006' THEN
				res = json_build_object('code','exception','text','Невозможно привязать товар к весам без цены!');
				return;
				
			WHEN sqlstate 'S0007' THEN
				res = json_build_object('code','exception','text','Данная привязка уже существует!');
				return;
				
			WHEN OTHERS THEN
				RAISE NOTICE 'internal_error: %', SQLERRM;
				GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
				res := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error||',p_id = '||p_product);
				return;
		 
		
END;
$$;


ALTER FUNCTION public.scale_invoice(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 732 (class 1255 OID 16568)
-- Name: scales_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.scales_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object    			 json;
 scale_object 	 	   json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_check							 varchar;
 p_id									 bigint; 
 p_name						 		 varchar;
 p_deleted						 boolean;
 p_company						 bigint;
 p_count							 smallint;
 p_point							 bigint;

BEGIN

	-- {"user": 1, "scale": {"id": 1, "name": "Овощи", "deleted": false}}

	SELECT (inf)::json into json_object; 
	
		SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');
    IF p_code = 'success' THEN
	    p_company := cast(p_text as bigint);
	  ELSE
		  result := json_build_object('code',p_code,'text',p_text);
      return next;
		  return;
	  END IF;
	
  SELECT (json_object)->'scale' into scale_object;

		p_id		  := cast(trim(scale_object->>'id') as bigint);
		p_name		:= trim(scale_object->>'name');
    p_deleted	:= cast(trim(scale_object->>'deleted') as boolean);
		p_point	:= cast(trim(scale_object->>'point') as bigint);

		IF p_id IS NOT NULL THEN
		  UPDATE scale
			  SET name = p_name, deleted = p_deleted, company = p_company, point = p_point
			    WHERE id = p_id;
		ELSE
			-- Проверка наличия весов
			SELECT count(id) INTO p_count
				FROM scale
					WHERE name = p_name
						AND company IN (p_company,0)
						AND point IN (p_point,0);
			IF p_count > 0 THEN
				RAISE SQLSTATE 'S0001';
			END IF;
			-- Добавление весов
		  INSERT INTO scale(name,deleted,company,point)
				VALUES (p_name,p_deleted,p_company,p_point)
					RETURNING id INTO p_id;
		END IF;
		
		-- Отвязывание товара от удаленной категории
			/*	IF p_deleted THEN
					UPDATE products
						SET category = 0
							WHERE category = p_id
								AND company = p_company;
				END IF;*/

    result := json_build_object('code','success','text',p_id);
    return next;

EXCEPTION
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Такие весы уже существуют!');
		 return next;
	WHEN OTHERS THEN
		RAISE NOTICE 'internal_error: %', SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		IF p_check = 'scale_name_idx' THEN
			result := json_build_object('code','error','text','Такие весы уже существуют!');
		ELSE
			result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		END IF;
	 
   return next;

END;


$$;


ALTER FUNCTION public.scales_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 733 (class 1255 OID 16569)
-- Name: staticprice_deleteprod(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.staticprice_deleteprod(data json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_error							 varchar;
 p_check							 varchar;
 p_product						 bigint;
 p_company						 bigint;
 json_object    			 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
BEGIN

	SELECT (data)::json into json_object;

	SELECT code, text INTO p_code, p_text
      FROM get_company(json_object->>'user');

	IF p_code = 'success' THEN
		p_company := cast(p_text as bigint);
	ELSE
		result := json_build_object('code',p_code,'text',p_text);
		return next;
		return;
	END IF;

	p_product := cast(trim(json_object->>'product') as bigint);
	IF p_product IS NULL THEN
			RAISE SQLSTATE 'S0001';
	END IF;

	delete from product_static_prices where product = p_product and company = p_company;
	update products set isstaticprice = false where id = p_product and company = p_company;

	result := json_build_object('code','success','text','success');
  return next;

EXCEPTION 
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Не указан товар!');
		 return next; 	
	WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);	 
		 return next;
END;
$$;


ALTER FUNCTION public.staticprice_deleteprod(data json, OUT result json) OWNER TO postgres;

--
-- TOC entry 734 (class 1255 OID 16570)
-- Name: stock_attach(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.stock_attach(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

 p_company       bigint;

 inf_object      json;

 stock_object    json;

 p_code				   varchar;

 p_text				   varchar;

 p_error			   varchar;

 p_point_type		 bigint;

 p_point_name		 varchar;

 p_stock_in			 bigint;

BEGIN



	-- {"user" : 1, "point" : "1", "attachments" : [{"stock" : "2"}]}



	SELECT (inf)::json into inf_object;

  

    SELECT code, text INTO p_code, p_text

      FROM get_company(inf_object->>'user');

    IF p_code = 'success' THEN

	    p_company := cast(p_text as bigint);

	  ELSE

		  result := json_build_object('code',p_code,'text',p_text);

      return next;

		  return;

	  END IF;



  FOR stock_object IN SELECT * FROM json_array_elements((inf_object)->'attachments')

  LOOP 

		

		p_stock_in := cast(stock_object->>'stock' as bigint);



    SELECT point_type, name INTO p_point_type, p_point_name

        FROM points

          WHERE id = p_stock_in

					  AND status = 'ACTIVE';

		IF p_point_type IS NULL THEN

      result := json_build_object('code','error','text','Выбранный склад не является активным!('||p_point_name||')');

			return next;

			return;

    ELSIF p_point_type <> 1 THEN

		  result := json_build_object('code','error','text','Привязке подлежат только склады!');

			return next;

			return;

    ELSIF p_point_type IS NULL THEN

			result := json_build_object('code','error','text','Вы выбрали неактивную точку!');

			return next;

			return;

	  END IF;



		INSERT INTO pointset(point,stock)

			VALUES(cast(inf_object->>'point' as bigint),p_stock_in);



  END LOOP;  

	

    result := json_build_object('code','success','text','');

    return next;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;









$$;


ALTER FUNCTION public.stock_attach(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 735 (class 1255 OID 16571)
-- Name: stock_attach_del(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.stock_attach_del(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$

DECLARE

 p_company       bigint;

 inf_object      json;

 p_code				   varchar;

 p_text				   varchar;

 p_error			   varchar;

 p_pointset_id	 bigint;

BEGIN



	-- {"user" : 1, "stock" : "2", "point" : "3"}



	SELECT (inf)::json into inf_object;

  

    SELECT code, text INTO p_code, p_text

      FROM get_company(inf_object->>'user');

    IF p_code = 'success' THEN

	    p_company := cast(p_text as bigint);

	  ELSE

		  result := json_build_object('code',p_code,'text',p_text);

      return next;

		  return;

	  END IF;



		DELETE FROM pointset

		  WHERE stock = cast(inf_object->>'stock' as bigint)

				  AND point = cast(inf_object->>'point' as bigint)

				    RETURNING point INTO p_pointset_id;



    IF p_pointset_id IS NULL THEN

		  result := json_build_object('code','error','text','Такой точки не существует!');

			return next;

			return;

    END IF;

	

    result := json_build_object('code','success','text','');

    return next;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;











$$;


ALTER FUNCTION public.stock_attach_del(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 738 (class 1255 OID 16572)
-- Name: stock_correction(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.stock_correction(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 update_object 		 		 json;
 p_invoicenumber_spr	 bigint;
 p_invoicenumber_units bigint;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_error							 varchar;
 p_check							 varchar;
 p_prod								 bigint;
 p_code_id						 varchar;
 p_point_in						 bigint;
 r										 record;
 i										 record;
 p_cashbox_count			 integer := 0;
BEGIN

	-- {"user" : 1, "update" : {"code" : "001231200102", "point" : 169}}

	SELECT (inf)::json into json_object;		
		
	SELECT (json_object)->'update' into update_object;
	
		p_point_in := cast(update_object->>'point' as bigint);
		p_code_id	 := trim(update_object->>'code');
		
		SELECT company INTO p_company
		  FROM points
				WHERE id = p_point_in;
	
		-- ID товара по коду
		SELECT id INTO p_prod
		  FROM products
				WHERE code = trim(update_object->>'code')
					and company = p_company;
		IF NOT FOUND THEN
      result := json_build_object('code','error','text','Товар не найден!');
			return next;
			return;
		END IF;
		
		SELECT count(id) INTO p_cashbox_count
		  FROM cashboxes
			  WHERE point = p_point_in
				  AND deleted = false
					  AND isengaged = true;
		IF p_cashbox_count = 0 THEN
			result := json_build_object('code','error','text','Нет активных касс!');
			return next;
			return;
		END IF;
		
		-- Обновление справочника
		INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) VALUES(0,'IN_PROCESS',p_company,p_point_in,p_point_in,3,now()) 
			RETURNING invoicenumber INTO p_invoicenumber_spr;
    INSERT INTO invoicelist(invoice,stock,attributes,units,delusr,updateallprodprice,newprod,company) 
			VALUES(p_invoicenumber_spr,p_prod,0,0,false,false,true,p_company);
				
		FOR r IN (
			SELECT id
				FROM stockcurrent s
				  INNER JOIN pointset ps on (ps.stock = s.point)
					  WHERE s.product = p_prod
							AND ps.point = p_point_in		
								AND s.company = p_company
	  )
		LOOP
			IF p_invoicenumber_units IS NULL THEN
				-- Обновление количества
				INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) VALUES(0,'IN_PROCESS',p_company,p_point_in,p_point_in,8,now()) 
					RETURNING invoicenumber INTO p_invoicenumber_units;
			END IF;
			INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company) 
			  VALUES(p_invoicenumber_units,r.id,0,0,0,0,false,r.id,false,false,p_company);
		END LOOP;
		
		-- Рассылка по активным кассам
		FOR i IN (
					SELECT id
					  FROM cashboxes
						  WHERE point = p_point_in
							  AND deleted = false
									AND isengaged = true
									  ORDER BY id
		)
		LOOP
			INSERT INTO systemmessage(point,invoice,type_message,cashbox)
				VALUES(p_point_in,p_invoicenumber_spr,3,i.id);
			IF p_invoicenumber_units IS NOT NULL THEN
				INSERT INTO systemmessage(point,invoice,type_message,cashbox)
					VALUES(p_point_in,p_invoicenumber_units,8,i.id);
			END IF;
		END LOOP;
		
    result := json_build_object('code','success','text','');
    return next;

EXCEPTION 
	 /*WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Запрещено изменять товары не своей компании!');
		 return next;*/
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;

END;$$;


ALTER FUNCTION public.stock_correction(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 739 (class 1255 OID 16573)
-- Name: stockcurrent_snapshot(); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.stockcurrent_snapshot(OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_error 	    varchar;
BEGIN
	
	-- Фиксирование даты и времени последней отработки (Начало выполнения)
	UPDATE jobcheck
		SET last_update_start = clock_timestamp()::timestamp
			WHERE jobname = 'stockcurrent_snapshot';
			
	-- Фиксирование количества товаров на конец дня
	INSERT INTO stockcurrent_part_snapshots(company,point,product,attributes,units,date,purchaseprice,snapdate,price)
		SELECT s.company,s.point,s.product,s.attributes,round(s.units::numeric,3),s.date,round(s.purchaseprice::numeric,2),current_date-1,coalesce(p.price,0)
			FROM stockcurrent_part s
				INNER JOIN stockcurrent s2 on (s.company = s2.company and s.point = s2.point and s.product = s2.product and s.attributes = s2.attributes)
				INNER JOIN storeprices p on (s2.company = p.company and s2.id = p.stock)
				INNER JOIN companies c on (s.company = c.id)
				  WHERE round(s.units::numeric,3) <> 0
						AND c.status = 'ACTIVE';		
	
	-- Фиксирование даты и времени последней отработки (Окончание выполнения)
	UPDATE jobcheck
		SET last_update_end = clock_timestamp()::timestamp
			WHERE jobname = 'stockcurrent_snapshot';

  result := json_build_object('code','success','text','','date',now());
  return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;

END;$$;


ALTER FUNCTION public.stockcurrent_snapshot(OUT result json) OWNER TO postgres;

--
-- TOC entry 740 (class 1255 OID 16574)
-- Name: test_func(jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.test_func(req jsonb, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$



DECLARE

	p_result   jsonb;

	p_error 	 varchar;

  p_log_id	 bigint;

BEGIN





  INSERT INTO action_logs(date, function, request, response, error)

	  VALUES (now(), 'test_func', '{"id":"1"}'::jsonb, '{"id":"1"}'::jsonb, 'Жопа!')

		  RETURNING id INTO p_log_id;



  RAISE SQLSTATE 'S0001';



EXCEPTION 

WHEN SQLSTATE 'S0001' THEN

   RAISE NOTICE 'internal_error: %', 'Все круто!';

WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLSTATE||':'||SQLERRM;

END;









$$;


ALTER FUNCTION public.test_func(req jsonb, OUT result json) OWNER TO postgres;

--
-- TOC entry 741 (class 1255 OID 16575)
-- Name: ticket_format_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.ticket_format_management(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object    			 json;
 p_ticketformat				 json;
 p_error           		 varchar;
 p_company						 bigint;
 p_point							 bigint;
 p_invoicenumber			 bigint;
 r                  	 record;
BEGIN

		SELECT (inf)::json into json_object;
		
		p_company := cast(trim(json_object->>'company') as bigint);
		p_ticketformat := cast(trim(json_object->>'ticketFormat') as json);
		p_point := cast(trim(json_object->>'point') as bigint);

		INSERT INTO ticket_format (company,json,point) values (p_company, p_ticketformat, p_point) 
				ON CONFLICT (company,point)
				DO UPDATE set json=p_ticketformat where ticket_format.company = p_company and ticket_format.point = p_point;

		insert into invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
			values(0,'IN_PROCESS',p_company,p_point,p_point,15,now())
				returning invoicenumber into p_invoicenumber;

		FOR r IN (
			SELECT b.id
				FROM companies c
					LEFT JOIN points p on (p.company = c.id) 
						LEFT JOIN cashboxes b on (b.point = p.id)
							WHERE company = p_company
								AND p.point_type = '2'
									AND p.id = p_point
									AND p.status = 'ACTIVE'
										AND c.status = 'ACTIVE'
											AND b.deleted = false
												AND b.isengaged = true
													ORDER BY p.id
		) 
		LOOP
		
			INSERT INTO public.systemmessage(point, invoice, type_message, altinvoice, cashbox)
				VALUES (p_point, p_invoicenumber, 15, null, r."id");

		END LOOP;
		
		result := json_build_object('code','success','text','success');
    return next;

EXCEPTION WHEN   OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
   return next;

END;
$$;


ALTER FUNCTION public.ticket_format_management(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 742 (class 1255 OID 16576)
-- Name: transfer_cashtrans(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_cashtrans(transinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_trans 				    			json;
	p_error					    			varchar;
  p_check										varchar;
  p_cashboxdiary_id					bigint;
  p_cashbox									bigint;
  p_opercode								bigint;
  p_count										float8 := 0;
  p_operid									bigint;
	p_company									bigint;
	details_object						json;
BEGIN


/*
{"transactions":[{
		"id":"1",  -- идентификатор со стороны кассы
		"cashid":"1",
    "summ": "153",
    "opercode": null,
    "operdate": null,
    "editdate": null,
    "person": 666,
    "comments": 1,
		"shiftnumber":1,
		"ZReport":{
                "OpenCash":2411,
                "DRefund":0,
                "AddBonus":0,
                "RefundsCount":0,
                "Cash":0,
                "Hash":"d46739e63c884e50af458aecfd79a85e",
                "DocsCount":0,
                "StartDate":"2020-05-14 16:53:31.4",
                "ClientChange":0,
                "Markups":0,
                "UseBonus":0,
                "DebitCount":0,
                "NDS":0,
                "Operations":0,
                "ShiftNumber":20,
                "rNDS":0,
                "Debit":0,
                "UserName":"Жулдыз",
                "Deficit":0,
                "OffLineCount":0,
                "Host":52,
                "SellCount":0,
                "TicketsCount":0,
                "EndDate":"2020-05-14 16:54:05.227",
                "Card":0,
                "CashierSum":2411,
                "dRefundsCount":0,
                "PKO":0,
                "CRefund":0,
                "CardCount":0,
                "UserId":100,
                "RKO":0,
                "CashCount":0,
                "CashSumm":2411,
                "TotalDiscount":0,
                "cRefundsCount":0
     }
}]}

1-РКО
2-ПКО
3-Открытие кассы 
4-Закрытие кассы

*/

	FOR p_trans IN SELECT * FROM json_array_elements((transinf)->'transactions')

  LOOP 

	  --BEGIN

		p_cashbox  := cast(p_trans->>'cashid' as bigint);
    p_opercode := cast(p_trans->>'opercode' as bigint);
    p_operid	 := cast(p_trans->>'id' as bigint);
		
		SELECT coalesce(p.company,0) INTO p_company
			FROM cashboxes c
				INNER JOIN points p on (p.id = c.point)
					WHERE c.id = p_cashbox;

	  INSERT INTO cashboxdiary(cashbox, summ, opercode, operdate, editdate, person, comments, operid, company, shiftnumber,zreport)
	    VALUES (p_cashbox, cast(p_trans->>'summ' as double precision), p_opercode, TO_TIMESTAMP(p_trans->>'operdate','DD.MM.YYYY HH24:MI:SS'), 
								TO_TIMESTAMP(nullif(p_trans->>'editdate',''),'DD.MM.YYYY HH24:MI:SS'), p_trans->>'person', trim(p_trans->>'comments'), p_operid, p_company, 
								cast(coalesce(p_trans->>'shiftnumber','0') as integer),(p_trans)->'ZReport')
				RETURNING id INTO p_cashboxdiary_id;
			
	
	  -------26.06.2023
		if (p_opercode=4) Then	
			update cashboxes set flagclose=true where id=p_cashbox;
		end if;
	  -------26.06.2023		
					
			

	END LOOP;

	result := json_build_object('code','success','text','');
	return next;

EXCEPTION WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
	 IF p_check = 'cashboxdiary_fk_cashbox' THEN
		 result := json_build_object('code','error','text','Указанной кассы не существует!');
	 ELSE
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 END IF;

   return next;

END;$$;


ALTER FUNCTION public.transfer_cashtrans(transinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 743 (class 1255 OID 16578)
-- Name: transfer_consignment(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_consignment(transinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

	p_trans 				    			json;
	p_trans_details						json;
	p_error					    			varchar;
	p_check										varchar;
	p_date										timestamp;
	p_customer								bigint;
	p_user										bigint;
	p_type										integer;
	p_company									bigint;
	p_point										bigint;
	p_prod										bigint;
	p_attr										bigint;
	p_stockid									bigint;
	p_prodprice								float8;
	p_produnits								float8;
	p_discount								float8;
	p_units_left							float8;
	p_cashbox									bigint;
	p_count										integer := 0;
	p_shop										bigint;
	p_invoicenumber						bigint;
	r													record;
	p_invoice_in						  bigint;
	p_invoice_in_det					bigint;
	p_invoicealt_in						varchar;

    ----26.05.2023
    p_scp_units_before						    float8 := 0;
    p_scp_units_after							float8 := 0;
    p_sc_units_before							float8 := 0;
    p_sc_units_after							float8 := 0;
    ----26.05.2023
	
BEGIN

/*
        { 
						"company": 15,
            "date":"24.12.2019 11:20:38",
            "customer":1,
            "cashboxuser":99,
						"cashbox":50,
						
						"invoice": 1,
						"altinvoice": "1Z",
						
						"type":0,  0 - на консигнацию, 1 - возврат
            "details":[ 
                { 
                    "stockid":19425,
                    "price":145,
										"discount":350,
                    "units":10,
										"invoicenumber":"786"  -- Тут только при возврате, т.к. возвращать могут с разных инвойсов
                }
            ]          
        }
*/

	SELECT (transinf)::json into p_trans;
	
		p_company	 			:= cast(p_trans->>'company' as bigint);
		p_date 	 	 			:= TO_TIMESTAMP(p_trans->>'date','DD.MM.YYYY HH24:MI:SS');
		p_customer 			:= cast(p_trans->>'customer' as bigint);
		p_user 		 			:= cast(p_trans->>'cashboxuser' as bigint);
		p_type		 			:= cast(p_trans->>'type' as bigint);
		p_cashbox  			:= cast(p_trans->>'cashbox' as bigint);
		
		p_invoice_in		:= cast(p_trans->>'invoice' as bigint);
		p_invoicealt_in := nullif(trim(p_trans->>'altinvoice'),'');
		
		IF p_company IS NULL THEN
			RAISE SQLSTATE 'S0002';
		ELSIF p_customer IS NULL THEN
			RAISE SQLSTATE 'S0003';
		ELSIF p_type IS NULL THEN
			RAISE SQLSTATE 'S0004';
		ELSIF p_cashbox IS NULL THEN
			RAISE SQLSTATE 'S0005';	
		END IF;
		
		-- Определяем количество активных касс на точке
		SELECT count(c1.*), c1.point INTO p_count, p_shop
			FROM cashboxes c 
				INNER JOIN cashboxes c1 on (c1.point = c.point /*and c1.id <> p_cashbox*/)
					WHERE c.id = p_cashbox
						AND c1.deleted = false
						AND c1.isengaged = true
							GROUP BY c1.point;
							
			-- Сохраняем накладную (для отчета)
			begin
		INSERT INTO consignment_invoices(invoicenumber,company,customer,cashboxuser,cashbox,"date","type",point,altinvoice)
			VALUES(p_invoice_in,p_company,p_customer,p_user,p_cashbox,p_date,p_type,p_shop,p_invoicealt_in);
			EXCEPTION
								when others then null;
			end;				
		-- Если больше одной активной кассы - создаем инвойс для обновления количества		
	  -- UPD: Рассылаем всем! Независимо от количества касс на точке	
		--IF p_count > 1 THEN
			INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate)
				VALUES(0,'IN_PROCESS',p_company,p_shop,p_shop,8,now())
					RETURNING invoicenumber INTO p_invoicenumber;
		--END IF;
		

	FOR p_trans_details IN SELECT * FROM json_array_elements((p_trans)->'details')
  LOOP 

		p_stockid 	:= cast(p_trans_details->>'stockid' as bigint);
		p_prodprice := round(cast(p_trans_details->>'price' as numeric),2);
		p_produnits	:= round(cast(p_trans_details->>'units' as numeric),3);
		p_discount	:= round(cast(coalesce(nullif(p_trans_details->>'discount',''),'0') as numeric),2);

		SELECT point, product, attributes INTO p_point, p_prod, p_attr
			FROM stockcurrent
				WHERE company = p_company
					AND id = p_stockid;
					
		-- Сохраняем детализацию накладной (для отчета)
		INSERT INTO consignment_invoicelist(invoice,company,stockid,price,totalprice,discount,units)
			SELECT p_invoice_in,p_company,p_stockid,p_prodprice,p_prodprice*p_produnits,p_discount,p_produnits
				ON CONFLICT (invoice,company,stockid) DO NOTHING;
			
		IF p_type = 0 THEN
			-- Добавление товара на консигнацию
			INSERT INTO consignment(customer,company,stockid,price,units,invoice,altinvoice,date,unitsincome,discount)
				SELECT p_customer, p_company, p_stockid, p_prodprice, p_produnits, p_invoice_in, p_invoicealt_in, p_date::date, p_produnits, p_discount   
					ON CONFLICT (customer,company,stockid,/*price*/invoice) DO NOTHING; --UPDATE SET units = consignment.units + p_produnits;	
			
			------26.05.2023	
			select units from stockcurrent s 
						into p_sc_units_before
							WHERE company = p_company
						AND id = p_stockid;	
			-----26.05.2023	
				
		    -- Уменьшение товара на складе
			UPDATE stockcurrent
				SET units = units - p_produnits
					WHERE company = p_company
						AND id = p_stockid
							RETURNING units INTO p_units_left;
			-- Оставляем запись в журнале перемещений товара
			INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,customer,cashboxuser,consignmentdate,consignmentinvoice
			------26.05.2023
			,sc_units_before,sc_units_after,comments
			------26.05.2023
			)
				VALUES(now(),'-6',p_point,p_prod,case when p_produnits < 0 then p_produnits*(-1) else p_produnits end,p_prodprice,p_attr,p_company,
									p_customer,p_user,p_date,p_invoice_in
			------26.05.2023
			,p_sc_units_before,p_units_left,'stockcurrent changed by transfer_consignment, line 151'
			------26.05.2023					
									);		
		ELSE
			-- Перезаписываем инвойс и спользуем с каждого товара отдельно, т.к. возвращать могут с разных накладных (инвойсов)
			p_invoice_in_det	:= cast(p_trans_details->>'invoicenumber' as bigint);
			-- Уменьшение товара у консигнатора
			UPDATE consignment
				SET units = units - p_produnits
					WHERE customer = p_customer
						AND company = p_company
							AND stockid = p_stockid
								AND price = p_prodprice
									AND invoice = p_invoice_in_det
										RETURNING units INTO p_units_left;
			IF NOT FOUND THEN
				RAISE SQLSTATE 'S0006';
			END IF;
		
		   ------26.05.2023	
			select units from stockcurrent s 
						into p_sc_units_before
							WHERE company = p_company
						AND id = p_stockid;	
			-----26.05.2023	
		
			-- Перемещение обратно на склад
			UPDATE stockcurrent
				SET units = units + p_produnits
					WHERE company = p_company
						AND id = p_stockid
					------26.05.2023		
					RETURNING units INTO p_units_left
					------26.05.2023	
						;
			-- Оставляем запись в журнале перемещений товара
			INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,customer,cashboxuser,consignmentdate,consignmentinvoice
			------26.05.2023
			,sc_units_before,sc_units_after,comments
			------26.05.2023
			)
				VALUES(now(),'6',p_point,p_prod,case when p_produnits < 0 then p_produnits*(-1) else p_produnits end,p_prodprice,p_attr,p_company,
									p_customer,p_user,p_date,p_invoice_in_det
			------26.05.2023
			,p_sc_units_before,p_units_left,'stockcurrent changed by transfer_consignment, line 194'
			------26.05.2023					
									);
		END IF;
		
		/* Пусть уходит в минус! (с) Начальство
		IF p_units_left < 0 THEN
			RAISE SQLSTATE 'S0001';
		END IF;
		*/
		
		-- Заполнение инвойса для обновления на других кассах
		-- UPD: Рассылаем всем! Независимо от количества касс на точке
		--IF p_count > 1 THEN
		BEGIN
			INSERT INTO invoicelist(invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company)
				VALUES(p_invoicenumber,p_stockid,0,0,0,0,false,p_stockid,false,false,p_company);
		EXCEPTION
			WHEN OTHERS THEN null;
		END;
		--END IF;
		
	END LOOP; 
		
	-- Отправка на остальные кассы, если они есть
	-- UPD: Рассылаем всем! Независимо от количества касс на точке
	--IF p_count > 1 THEN
		FOR R IN (
			SELECT c1.id as cashbox
				FROM cashboxes c 
					INNER JOIN cashboxes c1 on (c1.point = c.point /*and c1.id <> p_cashbox*/)
						WHERE c.id = p_cashbox
							AND c1.deleted = false
							AND c1.isengaged = true
		)
		LOOP
			INSERT INTO systemmessage(point,invoice,type_message,cashbox)
				VALUES(p_shop,p_invoicenumber,8,r.cashbox); 
		END LOOP;
	--END IF;

	result := json_build_object('code','success','text','');
	return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Недостаточное количество товара! ('||p_stockid||')');
		 return next; 
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Идентификатор компании не получен!');
		 return next; 
	 WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error','text','Идентификатор клиента не получен!');
		 return next; 
	 WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','Тип транзакции не получен!');
		 return next; 
	 WHEN SQLSTATE 'S0005' THEN
		 result := json_build_object('code','error','text','Идентификатор кассы не получен!');
		 return next;	
	 WHEN SQLSTATE 'S0006' THEN
		 result := json_build_object('code','error','text','Невозможно идентифицировать консигнационную запись клиента!');
		 return next;	 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error||', tr :'||transinf);  
	   return next;

END;





$$;


ALTER FUNCTION public.transfer_consignment(transinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 744 (class 1255 OID 16580)
-- Name: transfer_corr_transactions(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_corr_transactions(transinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
	p_trans 				    			json;
  p_trans_details						json;
	p_certs										json;
	p_promotions							json;
	p_coupons									json;
	p_error					    			varchar;
  p_transaction_id	  			bigint;
  p_totalprice						  float8 := 0;
  p_prodprice								float8 := 0;
	p_produnits							  float8 := 0;
  p_prod										bigint;
  p_check										varchar;
  p_stock_id								bigint;
  p_point_in								bigint;
	p_stockcurrent_id					bigint;
	p_attributes							bigint;
  p_cashbox_in							bigint;
  p_units_after							float8 := 0;
  p_is_minus								boolean;
  p_tickettype_in					  bigint;
  p_line									  bigint;
	p_actual_stock						varchar;
	p_rate										float8;
	p_cnofeacode							varchar;
	p_esf											boolean := false;
	p_company									bigint;
	p_invoicenumber						bigint;
	p_count										integer := 0;
	r													record;
	i													record;
	p_ticketid								bigint;
	p_bonuspay							  float8 := 0;
	p_bonusadd							  float8 := 0;
	p_discount								float8 := 0;
	p_card										bigint;
	p_debtor									bigint;
	p_cert										bigint;
	p_cert_summ								float8 := 0;
	p_cert_type								integer;
	p_cert_calc								float8;
	p_cert_denom							float8;
	p_paymenttype							varchar;
	p_cardpay									float8 := 0;
	p_cashpay									float8 := 0;
	p_debitpay								float8 := 0;
	p_price										float8 := 0;
	p_count_part							float8 := 0;
	p_purchaseprice						float8 := 0;
	p_purchasedate						date;
	p_logging_json						json;
	p_discount_det						float8;
	p_bonuspay_det						float8;
	p_ticketdiscount					float8;
	p_nds											float8;
	p_debt										float8;
	p_fizid										bigint;
	p_user										bigint;
	p_cert_prod								bigint;
	p_unitsprid								bigint;
	p_customerid							bigint;
	p_consignment							boolean := false;
	p_consignment_invoice			bigint;
	p_bonusgroup							bigint;
	p_compbonusgroup					bigint[];
	p_certgroup								bigint;
	p_compcertgroup						bigint[];
	p_balance						 			float8 := 0;
	p_peace										boolean;
	p_couponid								bigint;
	p_couponsubtype						integer;
	p_date										timestamp;
	p_certcode 								varchar;
	p_err_line 								varchar;
	p_wholesale								integer;
	p_cnt 										integer := 0;	
BEGIN

/*
{ 
    "transactions":[ 
        { 
            "date":"24.12.2019 11:20:38",
            "bonusadd":0,
            "cashpay":0,
            "discount":0,
            "cert":[ 
                { 
                    "code":"1234"
                }
            ],
            "bonuspay":0,
            "debtorid":0,
            "parentid":0,
						"coupon":[
												{
													"number":"123456"
												}
										],
            "ofdurl":"",
            "price":2020,
            "cashboxuser":99,
            "details":[ 
                { 
                    "bonusadd":0,
                    "product":19425,
										"excisestamp":[]
                    "price":2020,
                    "line":40,
                    "ticketdiscount":0,
										"pieceunits":5,
                    "discount":0,
                    "attributes":0,
                    "units":1,
                    "bonuspay":0,
										"cert":[{"code":"12345"},{"code":"12346"}],
                    "bonusrate":0,
                    "nds":216.43,
										"coupon":[
												{
													"number":"123456"
												}
										],
										"invoicenumber":"586",
										"promotions":[
                        {
                            "id":37,
                            "amount":210
                        }
                    ]
                }
            ],
            "ofdnumber":"24",
            "certpay":5000,
            "tickettype":0,
            "cardpay":0,
            "ticketid":24,
            "bonusid":0,
            "cashbox":50,
            "sellerid":0,
            "customerid":0,
            "fizid":0,
						"debtpay":500,
            "paymenttype":"debit",
            "hash":"c717fedf9c727cde877aed3723d6c7cf",
            "debitpay":2020,
						"detailsdiscount":0,
						"shiftnumber":1,
						
						"consignment": true
						"total": 50
						"issalebypiece: false
						
						"promotions":[
                        {
                            "id":37,
                            "amount":210
                        }
                    ]
        }
    ]
}
*/
	p_err_line := '0';

	FOR p_trans IN SELECT * FROM json_array_elements((transinf)->'transactions') LOOP 
		  p_cashbox_in     := cast(p_trans->>'cashbox' as bigint);
      p_tickettype_in  := cast(p_trans->>'tickettype' as bigint);
			p_invoicenumber	 := null;
			p_count					 := 0;
			p_ticketid			 := cast(p_trans->>'ticketid' as bigint);
			p_bonuspay			 := round(coalesce(cast(p_trans->>'bonuspay' as numeric),0),2);
			p_bonusadd			 := round(coalesce(cast(p_trans->>'bonusadd' as numeric),0),2);
			p_card					 := coalesce(cast(p_trans->>'bonusid' as double precision),0);
			p_discount			 := round(coalesce(cast(p_trans->>'discount' as numeric),0),2);
			p_debtor				 := coalesce(cast(p_trans->>'debtorid' as bigint),0);
			p_paymenttype		 := lower(trim(p_trans->>'paymenttype'));
			p_cardpay				 := round(coalesce(cast(p_trans->>'cardpay' as numeric),0),2);
			p_cashpay				 := round(coalesce(cast(p_trans->>'cashpay' as numeric),0),2);
			p_price					 := round(cast(p_trans->>'price' as numeric),2);
			p_debitpay			 := round(coalesce(cast(p_trans->>'debitpay' as numeric),0),2);
			p_debt					 := round(coalesce(cast(p_trans->>'debtpay' as numeric),0),2);
			p_fizid					 := coalesce(cast(p_trans->>'fizid' as bigint),0); 
			p_user					 := cast(p_trans->>'cashboxuser' as bigint);
			p_consignment		 := cast(coalesce(p_trans->>'consignment','false') as boolean);
			p_customerid		 := cast(nullif(p_trans->>'customerid','') as bigint);
			p_date					 := TO_TIMESTAMP(p_trans->>'date','DD.MM.YYYY HH24:MI:SS');
			
			-- Плюсы за минусы заехали
			IF p_tickettype_in = 1 THEN
				p_price    := case when (p_price <= 0)    then p_price    else -p_price    end;
				p_cardpay  := case when (p_cardpay <= 0)  then p_cardpay  else -p_cardpay  end;
				p_cashpay  := case when (p_cashpay <= 0)  then p_cashpay  else -p_cashpay  end;
				p_debitpay := case when (p_debitpay <= 0) then p_debitpay else -p_debitpay end;
				--p_debt		 := case when (p_debt <= 0) 	  then p_debt 		else -p_debt 		 end;
				p_debt		 := case when (p_paymenttype = 'debt' and p_debt = 0) then p_price else p_debt end;
			END IF;	
			
			-- Определяем ID точки
			SELECT point INTO p_point_in
			  FROM cashboxes
				  WHERE id = p_cashbox_in;
			
			-- Определяем ID склада
			SELECT p.id, p.is_minus, p.company, count(c.id) INTO p_stock_id, p_is_minus, p_company, p_count
				FROM points p
					LEFT JOIN pointset s on (s.stock = p.id)
						LEFT JOIN points p2 on (p2.id = s.point and p2.company = p.company)
							LEFT JOIN cashboxes c on (c.point = p2.id and c.deleted = false and c.isengaged = true)
								WHERE p2.id = p_point_in
									AND p.status = 'ACTIVE'
											GROUP BY p.id, p.is_minus, p.company;
			IF p_point_in IS NULL THEN
				RAISE SQLSTATE 'S0003';
			ELSIF p_company IS NULL THEN
				RAISE SQLSTATE 'S0007';
			END IF;
			
			-- Определяем бонус-группу компании
			SELECT coalesce(bonus_group,0), coalesce(certificate_group,0) INTO p_bonusgroup, p_certgroup
				FROM companies
					WHERE id = p_company;	
			-- Собираем все ID компаний по одной группе (бонусы)
			IF p_bonusgroup <> 0 THEN
				SELECT ARRAY_AGG(id) INTO p_compbonusgroup 
					FROM companies
						WHERE bonus_group = p_bonusgroup;
			END IF;
			-- Собираем все ID компаний по одной группе (сертификаты)
			IF p_certgroup <> 0 THEN
				SELECT ARRAY_AGG(id) INTO p_compcertgroup 
					FROM companies
						WHERE certificate_group = p_certgroup;
			END IF;

			SELECT id INTO p_transaction_id 
				FROM transactions
			WHERE company = p_company
				and point = p_point_in
				and cashbox = p_cashbox_in
				and "date"::date = p_date::date
				and ticketid = p_ticketid;
				
			-- Значит запись уже есть
			IF p_transaction_id IS NULL THEN
				continue;
			END IF;
			
			IF p_stock_id IS NULL THEN
				RAISE SQLSTATE 'S0001';
			ELSIF p_count > 1 AND NOT p_consignment THEN
				INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate,isconsignment)
					VALUES(0,'IN_PROCESS',p_company,p_point_in,p_point_in,8,now(),p_consignment)
						RETURNING invoicenumber INTO p_invoicenumber;
			END IF;
			
			FOR p_trans_details IN SELECT * FROM json_array_elements((p_trans)->'details') LOOP
				p_prod			 		 := cast(p_trans_details->>'product' as bigint);
				p_produnits	 		 := round(cast(p_trans_details->>'units' as numeric),3);  
				p_prodprice	 		 := round(cast(p_trans_details->>'price' as numeric),2);
				p_attributes 		 := cast(p_trans_details->>'attributes' as bigint);
				p_totalprice 		 := p_produnits * p_prodprice;
				p_line			 		 := cast(p_trans_details->>'line' as bigint);
				p_count_part 		 := p_produnits;
				p_purchaseprice  := null; 
				p_purchasedate	 := null;
				p_discount_det	 := round(coalesce(cast(p_trans_details->>'discount' as numeric),0),2);
				p_ticketdiscount := round(coalesce(cast(p_trans_details->>'ticketdiscount' as numeric),0),2);
				p_bonuspay_det	 := round(coalesce(cast(p_trans_details->>'bonuspay' as numeric),0),2);
				p_nds						 := round(coalesce(cast(p_trans_details->>'nds' as numeric),0),2);				
				p_consignment_invoice := cast(nullif(p_trans_details->>'invoicenumber','') as bigint);				
				p_peace := cast(coalesce(p_trans_details->>'issalebypiece','false') as boolean);
				p_wholesale := coalesce(cast(p_trans_details->>'wholesale' as integer),0);
				
				select count(*) into p_cnt from transaction_details td
				where td.transactionid = p_transaction_id
					and td.line = p_line;
					
				if p_cnt > 0 then
					CONTINUE;
				end if;
								
				-- Плюсы за минусы заехали
				IF p_tickettype_in = 1 THEN
					p_nds := case when (p_nds <= 0) then p_nds else -p_nds end;
				END IF;
				
				SELECT unitsprid, case when p_peace is null then piece else p_peace end INTO p_unitsprid, p_peace
					FROM products
						WHERE id = p_prod
							AND company = p_company;
				-- Берем уже округленную сумму, т.к. этот товар имеет четкую стоимость при распаковке	
				IF p_peace THEN
					p_totalprice := cast(p_trans_details->>'total' as numeric); 
				END IF;
				
				-- Рассчитывать только если это не услуга
				IF p_unitsprid <> 3 THEN
					-- При консигнационном чеке количество уменьшается у консигнатора, а не у клиента
					IF NOT p_consignment THEN
						-- Подсчет количества на складе
						UPDATE stockcurrent
							SET units = units - /*p_produnits*/case when p_tickettype_in = 1 and p_produnits > 0 then -p_produnits else p_produnits end
								WHERE point = p_stock_id
									AND product = p_prod
										AND attributes = p_attributes
											AND company = p_company
												RETURNING id, units INTO p_stockcurrent_id, p_units_after;
						IF p_stockcurrent_id IS NULL THEN
							RAISE SQLSTATE 'S0002';
						END IF;
					ELSE
						-- Поиск записи у клиента
						SELECT id INTO p_stockcurrent_id
							FROM stockcurrent
								WHERE point = p_stock_id
									AND product = p_prod
										AND attributes = p_attributes
											AND company = p_company;
						IF p_stockcurrent_id IS NULL THEN
							RAISE SQLSTATE 'S0002';
						END IF;
						-- Подсчет количества у консигнатора					
						UPDATE consignment
							SET units = units - p_produnits
								WHERE company = p_company
									AND customer = p_customerid
										AND stockid = p_stockcurrent_id
											-- AND price = p_prodprice
											AND invoice = p_consignment_invoice
												RETURNING units INTO p_units_after;
					END IF;

					-- Для обновления стока на кассе
					IF p_actual_stock IS NULL THEN
						p_actual_stock := json_build_object('id',p_stockcurrent_id,'units',p_units_after)::text;
					ELSE
						p_actual_stock := p_actual_stock ||','|| json_build_object('id',p_stockcurrent_id,'units',p_units_after)::text;
					END IF;
				
					CASE p_tickettype_in
							WHEN 0 THEN
								-- Расчет для партиционного учета (продажа/возврат)
								FOR i IN (
									SELECT date, units, purchaseprice
										FROM stockcurrent_part
											WHERE company = p_company
												AND point = p_stock_id
												AND product = p_prod
												AND attributes = p_attributes
												AND units > 0
													ORDER BY date, purchaseprice
								)
								LOOP
									IF p_count_part = 0 THEN				
										EXIT;					
									ELSIF i.units > p_count_part THEN		
										UPDATE stockcurrent_part
											SET units = units - p_count_part
												WHERE product = p_prod
													AND attributes =  p_attributes
													AND point = p_stock_id
													AND company = p_company
													AND date = i.date
													AND purchaseprice = i.purchaseprice
													AND units > 0
														RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
										-- Оставляем запись в журнале перемещений товара
										INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,
										purchasedate,customer,consignmentinvoice) VALUES(p_date,'-1',p_stock_id,p_prod,p_count_part,
											round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2),
											p_attributes, p_company,p_transaction_id,i.purchaseprice,i.date,case when p_consignment 
											then p_customerid else null end,p_consignment_invoice);
										p_count_part := 0;
									ELSIF (p_count_part > i.units) OR (p_count_part = i.units) THEN
										p_count_part := p_count_part - i.units;							
										UPDATE stockcurrent_part
											SET units = 0
												WHERE product = p_prod
													AND attributes =  p_attributes
													AND point = p_stock_id
													AND company = p_company
													AND date = i.date
													AND purchaseprice = i.purchaseprice
													AND units > 0
														RETURNING purchaseprice, date INTO p_purchaseprice, p_purchasedate;
										-- Оставляем запись в журнале перемещений товара
										INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,
										purchasedate,customer,consignmentinvoice) VALUES(p_date,'-1',p_stock_id,p_prod,i.units,
										round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2),
										p_attributes, p_company,p_transaction_id,i.purchaseprice,i.date,case when p_consignment 
										then p_customerid else null end,p_consignment_invoice);
									END IF;
								END LOOP;
					ELSE
						SELECT purchaseprice, purchasedate INTO p_purchaseprice, p_purchasedate
							FROM stockdiary
								WHERE point = p_stock_id
									AND product = p_prod
									AND attributes = p_attributes
									AND reason = - 1
									AND company = p_company
									AND date = (SELECT MAX(date)
																FROM stockdiary
																	WHERE point = p_stock_id
																		AND product = p_prod
																		AND attributes = p_attributes
																		AND reason = - 1
																		AND units >= -p_produnits
																		AND company = p_company)
										ORDER BY date desc
											LIMIT 1;
						-- На случай отсутствия данных					
						IF p_purchaseprice IS NOT NULL AND p_purchasedate IS NOT NULL THEN				
							UPDATE stockcurrent_part
								SET units = units - case when p_tickettype_in = 1 and p_count_part > 0 then -p_count_part else p_count_part end
									WHERE product = p_prod
										AND attributes =  p_attributes
										AND point = p_stock_id
										AND company = p_company
										AND date = p_purchasedate
										AND purchaseprice = p_purchaseprice;
						ELSE
							WITH min_part AS (
								SELECT date, purchaseprice
									FROM stockcurrent_part
										WHERE product = p_prod
											AND attributes =  p_attributes
											AND point = p_stock_id
											AND company = p_company
											ORDER BY case when units < 0 then 0 when units > 0 then 1 else 2 end, units, date											
									LIMIT  1             
							)
							UPDATE stockcurrent_part s
								SET units = units - case when p_tickettype_in = 1 and p_count_part > 0 then -p_count_part else p_count_part end
									FROM min_part
										WHERE s.product = p_prod
											AND s.attributes =  p_attributes
											AND s.point = p_stock_id
											AND s.company = p_company
											AND s.date = min_part.date
											AND s.purchaseprice = min_part.purchaseprice
												RETURNING s.purchaseprice, s.date INTO p_purchaseprice, p_purchasedate;
						END IF;
						-- Оставляем запись в журнале перемещений товара
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,purchasedate,
						customer,consignmentinvoice) VALUES(p_date,'2',p_stock_id,p_prod,p_produnits,
						round((p_prodprice-((p_discount_det+p_ticketdiscount)/-p_produnits)-p_bonuspay_det/-p_produnits)::numeric,2),
						p_attributes,p_company, p_transaction_id,p_purchaseprice,p_purchasedate,case when p_consignment 
						then p_customerid else null end,p_consignment_invoice);
						p_count_part := 0;	
					END CASE;
				
					-- Для учета минусового значения в партиционном учете (только для продаж)
					IF p_count_part > 0 AND p_tickettype_in = 0 THEN
						IF p_purchaseprice IS NOT NULL THEN 
							UPDATE stockcurrent_part
								SET units = units - p_count_part
									WHERE product = p_prod
										AND attributes =  p_attributes
										AND point = p_stock_id
										AND company = p_company
										AND date = p_purchasedate
										AND purchaseprice = p_purchaseprice;
						ELSE
							WITH min_part AS (
								SELECT date, purchaseprice
									FROM stockcurrent_part
										WHERE product = p_prod
											AND attributes =  p_attributes
											AND point = p_stock_id
											AND company = p_company
											ORDER BY case when units < 0 then 0 when units > 0 then 1 else 2 end, units, date desc											
									LIMIT  1             
							)
							UPDATE stockcurrent_part s
								SET units = units - p_count_part 
									FROM min_part
										WHERE s.product = p_prod
											AND s.attributes =  p_attributes
											AND s.point = p_stock_id
											AND s.company = p_company
											AND s.date = min_part.date
											AND s.purchaseprice = min_part.purchaseprice
												RETURNING s.purchaseprice, s.date INTO p_purchaseprice, p_purchasedate;
						END IF;
						IF NOT FOUND THEN							
							SELECT logging(jsonb_build_object('company',p_company,'point',p_stock_id,'product',p_prod,'attributes',p_attributes,
							'units',p_produnits,'diff',p_count_part,'user',cast(p_trans->>'cashboxuser' as bigint)), 
							jsonb_build_object('transfer_transactions',
							jsonb_build_object('code','error','text','Недостаточно данных для расчета партиционирования!')),'transfer_transactions','')
							INTO p_logging_json;
						END IF;		
						-- Оставляем запись в журнале перемещений товара
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,
						purchasedate,customer,consignmentinvoice) VALUES(p_date,'-1',p_stock_id,p_prod,p_count_part,
						round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2),p_attributes,
						p_company,p_transaction_id,p_purchaseprice,p_purchasedate,case when p_consignment 
						then p_customerid else null end,p_consignment_invoice);
					END IF;				
				ELSE -- Только для услуг	
					-- Обнуление в стоке
					UPDATE stockcurrent
						SET units = 0
							WHERE point = p_stock_id
								AND product = p_prod
									AND attributes = p_attributes
										AND company = p_company
											RETURNING id INTO p_stockcurrent_id;
					IF NOT FOUND THEN
						RAISE SQLSTATE 'S0002';
					END IF;						
					-- Для обновления стока на кассе
					IF p_actual_stock IS NULL THEN
						p_actual_stock := json_build_object('id',p_stockcurrent_id,'units',0)::text;
					ELSE
						p_actual_stock := p_actual_stock ||','|| json_build_object('id',p_stockcurrent_id,'units',0)::text;
					END IF;								
					-- Обнуление в партионном учете
					UPDATE stockcurrent_part
						SET units = 0
							WHERE point = p_stock_id
								AND product = p_prod
									AND attributes = p_attributes
										AND company = p_company;
					-- Данные партии для дневника					
					SELECT date, purchaseprice INTO p_purchasedate, p_purchaseprice
										FROM stockcurrent_part
											WHERE company = p_company
												AND point = p_stock_id
												AND product = p_prod
												AND attributes = p_attributes
												AND date = (SELECT MAX(date)
																			FROM stockcurrent_part
																				WHERE company = p_company
																					AND point = p_stock_id
																					AND product = p_prod
																					AND attributes = p_attributes)
																						LIMIT 1;
					IF NOT FOUND THEN
						RAISE SQLSTATE 'S0002';
					END IF;																	
					-- Оставляем запись в журнале перемещений товара
						INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,
						purchasedate,customer,consignmentinvoice) VALUES(p_date,'-1',p_stock_id,p_prod,p_count_part,
						round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2),
						p_attributes, p_company,p_transaction_id,p_purchaseprice,p_purchasedate,case when p_consignment 
						then p_customerid else null end,p_consignment_invoice);
				END IF;

				-- Определение НДС\ТНВЭД
				SELECT t.rate, p.cnofeacode, case when s.code is not null then true else false end INTO p_rate, p_cnofeacode, p_esf
				  FROM taxes t
					  LEFT JOIN products p on (p.taxid = t.id)
						  LEFT JOIN seizurelist s on (s.code = p.cnofeacode)
						    WHERE p.id = p_prod;

			  INSERT INTO transaction_details(
						transactionid,product,units,price,totalprice,attributes,line,taxrate,cnofeacode,
						bonusadd,bonuspay,bonusrate,discount,nds,
						company,ticketdiscount,invoice,piece,pieceunits,wholesale)
				  VALUES(p_transaction_id,p_prod,p_produnits,p_prodprice,p_totalprice,p_attributes,p_line,p_rate,p_cnofeacode,
									 round(coalesce(cast(p_trans_details->>'bonusadd' as numeric),0),2),
									 p_bonuspay_det,coalesce(cast(p_trans_details->>'bonusrate' as double precision),0),
									 p_discount_det,p_nds,p_company,p_ticketdiscount, case when p_consignment_invoice is not null 
									 then p_consignment_invoice else 0 end,p_peace,
									 coalesce(cast(p_trans_details->>'pieceunits' as integer),0),p_wholesale);
				
				-- Заполнение инвойса для обновления на других кассах
				IF p_count > 1 AND NOT p_consignment THEN
				  INSERT INTO invoicelist(invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company)
					  VALUES(p_invoicenumber,p_stockcurrent_id,0,0,0,0,false,p_stockcurrent_id,false,false,p_company);
				END IF;
				
				-- Обработка данных по подарочным сертификатам(продажа/возврат)
				FOR p_certs IN SELECT * FROM json_array_elements((p_trans_details)->'cert')
				LOOP
					IF p_tickettype_in = 0 THEN
						-- Активирование сертификата
						p_certcode = trim(p_certs->>'code');
						p_cert = null;
						BEGIN
							UPDATE giftcertificates
								SET active = true, balance = denomination, 
								expiredate = (current_date + interval '1 month' * period)::date, selldate = current_date
									WHERE code = trim(p_certs->>'code')
										AND case when p_certgroup = 0 then company = p_company else company = any(p_compcertgroup) end
											RETURNING id, denomination INTO p_cert, p_cert_summ;
							IF p_cert is null THEN
								RAISE SQLSTATE 'S0006';
							END IF;
						EXCEPTION 
							WHEN OTHERS THEN
								UPDATE giftcertificates
								SET active = true, balance = denomination, 
								expiredate = (current_date + interval '1 month' * period)::date, selldate = current_date
									WHERE code = trim(p_certs->>'code')
										AND company = p_company
											RETURNING id, denomination INTO p_cert, p_cert_summ;
								IF p_cert is null THEN
									RAISE SQLSTATE 'S0006';
								END IF;
								UPDATE giftcertificates	SET code = 'D'||code
									WHERE code = trim(p_certs->>'code')
										AND company <> p_company;
						END;
						-- Запись в историю событий
						INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
							VALUES(p_company,now(),2,p_cert,p_cert_summ,p_transaction_id,p_point_in,p_certgroup);
					ELSE
						-- Отмена активации сертификата
						UPDATE giftcertificates
							SET active = false, balance = 0, expiredate = null, selldate = null
								WHERE code = trim(p_certs->>'code')
									AND case when p_certgroup = 0 then company = p_company else company = any(p_compcertgroup) end--company = p_company
										RETURNING id, denomination INTO p_cert, p_cert_summ;
						IF NOT FOUND THEN
							RAISE SQLSTATE 'S0006';
						END IF;				
						-- Запись в историю событий
						INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
							VALUES(p_company,now(),6,p_cert,p_cert_summ,p_transaction_id,p_point_in,p_certgroup);
					END IF;
				END LOOP;
				
				-- Обработка использованных акций
				FOR p_promotions IN SELECT * FROM json_array_elements((p_trans_details)->'promotions')
				LOOP
					INSERT INTO transaction_promotions(transactionid,product,attributes,company,promotion,amount)
						VALUES(p_transaction_id,p_prod,p_attributes,p_company,cast(p_promotions->>'id' as bigint),
						cast(round((p_promotions->>'amount')::numeric,2) as double precision));
				END LOOP;

				-- Обработка купонов (На товары)
				FOR p_coupons IN SELECT * FROM json_array_elements((p_trans_details)->'coupon')
				LOOP
					-- Косяк с кассы (иногда приходят пустые number)
					IF nullif(trim(p_coupons->>'number'),'') IS NULL THEN
						CONTINUE;
					END IF;
					SELECT id, subtype INTO p_couponid, p_couponsubtype
						FROM coupons
							WHERE "number" = trim(p_coupons->>'number')
								AND company = p_company;
					IF NOT FOUND THEN
						RAISE SQLSTATE 'S0008';
					END IF;			
					IF p_couponsubtype = 2 THEN
						UPDATE coupons
							SET active = false
								WHERE id = p_couponid
									AND company = p_company;
						IF NOT FOUND THEN
							RAISE SQLSTATE 'S0008';
						END IF;
					END IF;
					-- Запись в дневник			 
					INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
						VALUES(p_company,now(),2,p_couponid,p_transaction_id);
				END LOOP;

			END LOOP; -- DETAILS
			
			-- Отправка на остальные кассы, если они есть
			IF p_count > 1 AND NOT p_consignment THEN
			  FOR R IN (
				  SELECT b.id as cashbox
					  FROM companies c
						  LEFT JOIN points p on (p.company = c.id) 
							  LEFT JOIN cashboxes b on (b.point = p.id)
							    WHERE company = p_company 
								    AND point_type = '2' 
									    AND p.status = 'ACTIVE'
										    AND c.status = 'ACTIVE'
												  AND b.deleted = false
													  AND b.isengaged = true
														  AND point = p_point_in
															  AND b.id <> p_cashbox_in
														      ORDER BY p.id 
				)
				LOOP
				  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
						VALUES(p_point_in,p_invoicenumber,8,r.cashbox); 
				END LOOP;
			END IF;

	END LOOP; -- END
	
	-- "Элегантного" варианта не нашлось... Сранный postgres...

  p_actual_stock := '['|| p_actual_stock ||']';

	result := json_build_object('code','success','text',p_actual_stock::json);

	return next;

EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error_stock','text','Склад точки не идентифицирован!');
		 return next;
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Товар на складе не найден! Номер чека - '||p_ticketid||', p_id'||p_prod);
		 return next;
	 WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error_stock','text','Не удалось определить точку кассы!');
		 return next;
	 WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error_stock','text','Не удалось определить должника!');
		 return next;	 
	 WHEN SQLSTATE 'S0005' THEN
		 result := json_build_object('code','error_stock','text','Не удалось определить бонусную карту!');
		 return next;	 
	 WHEN SQLSTATE 'S0006' THEN
		 result := json_build_object('code','error_stock','text','Не удалось определить подарочный сертификат!');
		 return next;	
	 WHEN SQLSTATE 'S0007' THEN
		 result := json_build_object('code','error_stock','text','Точка либо касса были деактивированы! Касса: '||p_cashbox_in||' (Точка: '||p_point_in||')');
		 return next;
	 WHEN SQLSTATE 'S0008' THEN
		 result := json_build_object('code','error_stock','text','Не найден купон: '||p_couponid||'!');
		 return next;	 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 IF p_check = 'transactions_details_pkey' THEN
				result := json_build_object('code','error','text','В детализации чека не может быть больше одной записи по одному товару!');
				--continue;
		 ELSIF p_check = 'transactions_fk_cashusr' THEN
			  result := json_build_object('code','error','text','Передаваемого пользователя не существует!');
		 ELSIF p_check = 'transactions_fk_point' THEN
			  result := json_build_object('code','error','text','Передаваемой точки не существует!');
     ELSE
			  result := json_build_object('code','internal_error','text',p_err_line);
		 END IF;
	   return next;

END;





$$;


ALTER FUNCTION public.transfer_corr_transactions(transinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 745 (class 1255 OID 16582)
-- Name: transfer_transactions(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.transfer_transactions(transinf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
    p_trans                                 json;
  p_trans_details                       json;
    p_certs                                     json;
    p_promotions                            json;
    p_coupons                                   json;
    p_error                                 varchar;
  p_transaction_id              bigint;
  p_totalprice                        float8 := 0;
  p_prodprice                               float8 := 0;
    p_produnits                           float8 := 0;
  p_prod                                        bigint;
  p_check                                       varchar;
  p_stock_id                                bigint;
  p_point_in                                bigint;
  p_stockcurrent_id                 bigint;
  -- 20230608: stockcurrent_part id
  p_scp_id                  bigint;
  p_attributes                          bigint;
  p_cashbox_in                          bigint;
  --p_units_after                           float8 := 0;
  -- 20230520: p_scp_units_before - units of stock in stockcurrent_part before transaction / invoice
  -- 20230520: p_scp_units_after - units of stock in stockcurrent_part after transaction / invoice
  -- 20230520: p_sc_units_before - units of stock in stockcurrent before transaction / invoice
  -- 20230520: p_sc_units_after - units of stock in stockcurrent after transaction / invoice
  p_scp_units_before                        float8 := 0;
  p_scp_units_after                         float8 := 0;
  p_sc_units_before                         float8 := 0;
  p_sc_units_after                          float8 := 0;
  p_is_minus                                boolean;
  p_tickettype_in                     bigint;
  p_line                                      bigint;
    p_actual_stock                      varchar;
    p_rate                                      float8;
    p_cnofeacode                            varchar;
    p_esf                                           boolean := false;
    p_company                                   bigint;
    p_invoicenumber                     bigint;
    p_count                                     integer := 0;
    r                                                   record;
    i                                                   record;
    p_ticketid                              bigint;
    p_bonuspay                            float8 := 0;
    p_bonusadd                            float8 := 0;
    p_discount                              float8 := 0;
    p_card                                      bigint;
    p_debtor                                    bigint;
    p_cert                                      bigint;
    p_cert_summ                             float8 := 0;
    p_cert_type                             integer;
    p_cert_calc                             float8;
    p_cert_denom                            float8;
    p_paymenttype                           varchar;
    p_cardpay                                   float8 := 0;
    p_cashpay                                   float8 := 0;
    p_debitpay                              float8 := 0;
    p_price                                     float8 := 0;
    p_count_part                            float8 := 0;
    p_purchaseprice                     float8 := 0;
    p_purchasedate                      date;
    p_logging_json                      json;
    p_discount_det                      float8;
    p_bonuspay_det                      float8;
    p_ticketdiscount                    float8;
    p_nds                                           float8;
    p_debt                                      float8;
    p_fizid                                     bigint;
    p_user                                      bigint;
    p_cert_prod                             bigint;
    p_unitsprid                             bigint;
    p_customerid                            bigint;
    p_consignment                           boolean := false;
    p_consignment_invoice           bigint;
    p_bonusgroup                            bigint;
    p_compbonusgroup                    bigint[];
    p_certgroup                             bigint;
    p_compcertgroup                     bigint[];
    p_balance                                   float8 := 0;
    p_peace                                     boolean;
    p_couponid                              bigint;
    p_couponsubtype                     integer;
    p_date                                      timestamp;
    p_certcode                              varchar;
    p_err_line                              varchar;
    p_wholesale                             integer;
    p_ipor                               integer;
    p_ipriz                               integer;
    p_teln                              varchar;
   
   ------
   p_purchaseprice1                     float8 := 0;
    p_purchasedate1                     date;
   ------

    -- 01.07.2023
    p_markup float8 = 0; 
    -- 01.07.2023
   
BEGIN

/*
{ 
    "transactions":[ 
        { 
            "date":"24.12.2019 11:20:38",
            "bonusadd":0,
            "cashpay":0,
            "discount":0,
            "cert":[ 
                { 
                    "code":"1234"
                }
            ],
            "bonuspay":0,
            "debtorid":0,
            "parentid":0,
                        "coupon":[
                                                {
                                                    "number":"123456"
                                                }
                                        ],
            "ofdurl":"",
            "price":2020,
            "cashboxuser":99,
            "details":[ 
                { 
                    "bonusadd":0,
                    "product":19425,
                                        "excisestamp":[]
                    "price":2020,
                    "line":40,
                    "ticketdiscount":0,
                                        "pieceunits":5,
                    "discount":0,
                    "attributes":0,
                    "units":1,
                    "bonuspay":0,
                                        "cert":[{"code":"12345"},{"code":"12346"}],
                    "bonusrate":0,
                    "nds":216.43,
                                        "coupon":[
                                                {
                                                    "number":"123456"
                                                }
                                        ],
                                        "invoicenumber":"586",
                                        "promotions":[
                        {
                            "id":37,
                            "amount":210
                        }
                    ]
                }
            ],
            "ofdnumber":"24",
            "certpay":5000,
            "tickettype":0,
            "cardpay":0,
            "ticketid":24,
            "bonusid":0,
            "cashbox":50,
            "sellerid":0,
            "customerid":0,
            "fizid":0,
                        "debtpay":500,
            "paymenttype":"debit",
            "hash":"c717fedf9c727cde877aed3723d6c7cf",
            "debitpay":2020,
                        "detailsdiscount":0,
                        "shiftnumber":1,
                        
                        "consignment": true
                        "total": 50
                        "issalebypiece: false
                        
                        "promotions":[
                        {
                            "id":37,
                            "amount":210
                        }
                    ]
        }
    ]
}
*/
    p_err_line := '0';

    FOR p_trans IN SELECT * FROM json_array_elements((transinf)->'transactions')

  LOOP 

      --BEGIN

          p_cashbox_in     := cast(p_trans->>'cashbox' as bigint);
      p_tickettype_in  := cast(p_trans->>'tickettype' as bigint);
            p_invoicenumber  := null;
            p_count                  := 0;
            p_ticketid           := cast(p_trans->>'ticketid' as bigint);
            p_bonuspay           := round(coalesce(cast(p_trans->>'bonuspay' as numeric),0),2);
            p_bonusadd           := round(coalesce(cast(p_trans->>'bonusadd' as numeric),0),2);
            p_card                   := coalesce(cast(p_trans->>'bonusid' as double precision),0);
            p_discount           := round(coalesce(cast(p_trans->>'discount' as numeric),0),2);
            p_debtor                 := coalesce(cast(p_trans->>'debtorid' as bigint),0);
            p_paymenttype        := lower(trim(p_trans->>'paymenttype'));
            p_cardpay                := round(coalesce(cast(p_trans->>'cardpay' as numeric),0),2);
            p_cashpay                := round(coalesce(cast(p_trans->>'cashpay' as numeric),0),2);
            p_price                  := round(cast(p_trans->>'price' as numeric),2);
            p_debitpay           := round(coalesce(cast(p_trans->>'debitpay' as numeric),0),2);
            p_debt                   := round(coalesce(cast(p_trans->>'debtpay' as numeric),0),2);
            p_fizid                  := coalesce(cast(p_trans->>'fizid' as bigint),0); 
            p_user                   := cast(p_trans->>'cashboxuser' as bigint);
            p_consignment        := cast(coalesce(p_trans->>'consignment','false') as boolean);
            p_customerid         := cast(nullif(p_trans->>'customerid','') as bigint);
            p_date                   := TO_TIMESTAMP(p_trans->>'date','DD.MM.YYYY HH24:MI:SS');
            
            p_err_line := 'line 0.1';
            
            -- Плюсы за минусы заехали
            IF p_tickettype_in = 1 THEN
                p_price    := case when (p_price <= 0)    then p_price    else -p_price    end;
                p_cardpay  := case when (p_cardpay <= 0)  then p_cardpay  else -p_cardpay  end;
                p_cashpay  := case when (p_cashpay <= 0)  then p_cashpay  else -p_cashpay  end;
                p_debitpay := case when (p_debitpay <= 0) then p_debitpay else -p_debitpay end;
                --p_debt         := case when (p_debt <= 0)       then p_debt       else -p_debt         end;
                p_debt       := case when (p_paymenttype = 'debt' and p_debt = 0) then p_price else p_debt end;
            END IF; 
            
            p_err_line := 'line 0.2';
            -- Определяем ID точки
            SELECT point INTO p_point_in
              FROM cashboxes
                  WHERE id = p_cashbox_in;
            
            -- Определяем ID склада
            SELECT p.id, p.is_minus, p.company, count(c.id) INTO p_stock_id, p_is_minus, p_company, p_count
                FROM points p
                    LEFT JOIN pointset s on (s.stock = p.id)
                        LEFT JOIN points p2 on (p2.id = s.point and p2.company = p.company)
                            LEFT JOIN cashboxes c on (c.point = p2.id and c.deleted = false and c.isengaged = true)
                                WHERE p2.id = p_point_in
                                    AND p.status = 'ACTIVE'
                                        -- AND c.id <> p_cashbox_in
                                            GROUP BY p.id, p.is_minus, p.company;
            IF p_point_in IS NULL THEN
                RAISE SQLSTATE 'S0003';
            ELSIF p_company IS NULL THEN
                RAISE SQLSTATE 'S0007';
            END IF;
            p_err_line := 'line 0.3';
            -- Определяем бонус-группу компании
            SELECT coalesce(bonus_group,0), coalesce(certificate_group,0) INTO p_bonusgroup, p_certgroup
                FROM companies
                    WHERE id = p_company;   
            -- Собираем все ID компаний по одной группе (бонусы)
            IF p_bonusgroup <> 0 THEN
                SELECT ARRAY_AGG(id) INTO p_compbonusgroup 
                    FROM companies
                        WHERE bonus_group = p_bonusgroup;
            END IF;
            -- Собираем все ID компаний по одной группе (сертификаты)
            IF p_certgroup <> 0 THEN
                SELECT ARRAY_AGG(id) INTO p_compcertgroup 
                    FROM companies
                        WHERE certificate_group = p_certgroup;
            END IF;
            p_err_line := 'line 0.4';
        
            ----04.11.2022
            IF (p_fizid <> 0) and (p_debt <> 0) then
            
               if not exists (
                 select * from fiz_customers where id = p_fizid
                )  then 
            
                p_ipor:=0;
                p_ipriz:=0;
                p_teln:='testn';
                
            while p_ipriz=0 
             loop
              
              if not exists (
                 select * from fiz_customers where telephone = p_teln||cast(p_ipor as varchar) AND company = p_company
                ) then 
                
              INSERT INTO public.fiz_customers(id,telephone, lastname, firstname, company, debt)
              VALUES(p_fizid,p_teln||cast(p_ipor as varchar), p_teln||cast(p_ipor as varchar), p_teln||cast(p_ipor as varchar), p_company, 0)
             
               --RETURNING id INTO p_fizid
               ;
              
              p_ipriz=1;
                         
             end if;
              
            p_ipor:=p_ipor+1;    
           end loop;
                
               
                
               end if;  
           
            end if; 
            ----04.11.2022
        
            INSERT INTO transactions(ticketid,price,paymenttype,paymenttransid,customerid,cashboxuser,ofdnumber,ofdurl,point,date,cashbox,tickettype,bonuspay,cardpay,
                        cashpay,debitpay,debtpay,bonusadd,bonuscardid,discount,company,fiz_customerid, debtorid, sellerid, hash, certpay,detailsdiscount,shiftnumber,consignment
                        -- 26.09.2022
                        ,markup
                        -- 26.09.2022
                        )
              SELECT p_ticketid,p_price,p_paymenttype,p_trans->>'paymenttransid',
                           p_customerid,p_user,p_trans->>'ofdnumber',p_trans->>'ofdurl',
                                        p_point_in,p_date,p_cashbox_in,p_tickettype_in,p_bonuspay,
                             case when p_paymenttype = 'card' and p_cardpay = 0 then p_price else p_cardpay end,
                             case when p_paymenttype = 'cash' and p_cashpay = 0 then p_price else p_cashpay end,
                             case when p_paymenttype = 'debit' and p_debitpay = 0 then p_price else p_debitpay end,
                             case when p_paymenttype = 'debt' and p_debt = 0 then p_price else p_debt end,
                                            /*p_debitpay,*/p_bonusadd,p_card,p_discount,p_company,p_fizid,p_debtor,coalesce(cast(p_trans->>'sellerid' as bigint),0), 
                                            trim(p_trans->>'hash'),round(coalesce(cast(p_trans->>'certpay' as numeric),0),2),round(coalesce(cast(p_trans->>'detailsdiscount' as numeric),0),2),
                                cast(coalesce(p_trans->>'shiftnumber','0') as integer),p_consignment
                            -- 26.09.2022
                            ,round(coalesce(cast(p_trans->>'markup' as numeric),0),2)
                            -- 26.09.2022
                    WHERE NOT EXISTS (select 1 from transactions where ticketid = p_ticketid and cashbox = p_cashbox_in and point = p_point_in 
                                                                and date = p_date)
            ON CONFLICT (ticketid,cashbox,point,date,company) DO NOTHING
                  RETURNING id INTO p_transaction_id;
                
            
            
                 
            p_err_line := 'line 0.5';
            -- Значит запись уже есть
            IF p_transaction_id IS NULL THEN
                continue;
            END IF;
            
            -- Обработка купонов (На чек)
            FOR p_coupons IN SELECT * FROM json_array_elements((p_trans)->'coupon')  
            LOOP
                -- Косяк с кассы (иногда приходят пустые number)
                IF nullif(trim(p_coupons->>'number'),'') IS NULL THEN
                    CONTINUE;
                END IF; 
                SELECT id, subtype INTO p_couponid, p_couponsubtype
                    FROM coupons
                        WHERE "number" = trim(p_coupons->>'number')
                            AND company = p_company;
                IF NOT FOUND THEN
                    RAISE SQLSTATE 'S0008';
                END IF;         
                IF p_couponsubtype = 2 THEN
                    UPDATE coupons
                        SET active = false
                            WHERE id = p_couponid
                                AND company = p_company;
                    IF NOT FOUND THEN
                        RAISE SQLSTATE 'S0008';
                    END IF;
                END IF;
                -- Запись в дневник          
                INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
                    VALUES(p_company,now(),2,p_couponid,p_transaction_id);
            END LOOP;
            p_err_line := 'line 0.6';
            IF p_stock_id IS NULL THEN
                RAISE SQLSTATE 'S0001';
            ELSIF p_count > 1 AND NOT p_consignment THEN
                INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate,isconsignment)
                    VALUES(0,'IN_PROCESS',p_company,p_point_in,p_point_in,8,now(),p_consignment)
                        RETURNING invoicenumber INTO p_invoicenumber;
            END IF;
            
            -- Если чек на должника
            IF p_debt <> 0 THEN
                --IF p_fizid <> 0 THEN
                p_err_line := '1';
                    UPDATE fiz_customers
                        SET debt = debt + p_debt
                            WHERE id = p_fizid
                                AND company = p_company
                                    RETURNING debt INTO p_balance;
                /*ELSIF customerid <> 0 THEN
                    UPDATE customers
                        SET debt = debt + p_debt
                            WHERE id = customerid
                                AND company = p_company;
                ELSE
                    RAISE SQLSTATE 'S0004';
                END IF;*/
                -- Если запись не найдена
                IF NOT FOUND THEN
                    p_err_line := '2';
                    
                    ----04.11.2022
                    if exists(
                    select * from fiz_customers 
                       where telephone in 
                       (
                       select telephone from fiz_customers where id =p_fizid 
                       ) and 
                       company=p_company
                    )  then 
                    UPDATE fiz_customers
                        SET debt = debt + p_debt
                            WHERE telephone in 
                    (
                    select telephone from fiz_customers where id =p_fizid 
                    ) and 
                   company=p_company;
                   else
                   begin
                   ----04.11.2022
                
                
                    UPDATE fiz_customers
                        SET debt = debt + p_debt, company = p_company
                            WHERE id = p_fizid  
                            ----04.11.2022
                            --and debt = 0
                            ----04.11.2022
                                    RETURNING debt INTO p_balance;
                    IF NOT FOUND THEN
                        p_err_line := '3';
                        RAISE SQLSTATE 'S0004';
                    END IF;
                
                   ----04.11.2022
                    end;
                   end if;
                   ----04.11.2022
                
                -- Если после списания долг становится меньше 0 - просто обнуляем   
                END IF;
                p_err_line := '4';
                IF p_balance < 0 THEN
                    UPDATE fiz_customers
                        SET debt = 0
                            WHERE id = p_fizid
                                AND company = p_company;
                END IF;                 
                -- Запись в дневник
                    INSERT INTO debtorsdiary(customer,transaction,type,debt,date,company,"user","system")
                        VALUES(p_fizid,p_transaction_id,case when p_debt >= 0 then 1 else -1 end,p_debt,now(),p_company,p_user,'POS');              
            END IF;
            
            -- Если есть информация по бонусной карте
            IF p_card IS NOT NULL AND p_card <> 0 THEN

                -- Если есть оплата бонусами (только для оплаты)
                IF p_bonuspay IS NOT NULL AND p_bonuspay <> 0 AND p_tickettype_in = 0 THEN
                    INSERT INTO bonuscardsdiary (card,ticket,transaction,type,bonus,date,company,"group")
                        VALUES (p_card,p_ticketid,p_transaction_id,-1,p_bonuspay,now(),p_company,p_bonusgroup);
                    UPDATE customers_bonuscards
                        SET bonuses = bonuses - p_bonuspay 
                            WHERE id = p_card;
                                --AND company = p_company
                                --AND case when p_bonusgroup = 0 then company = p_company else company = any(p_compbonusgroup) end;
                    IF NOT FOUND THEN
                        RAISE SQLSTATE 'S0005';
                    END IF;             
                END IF;

                -- Если есть начисленные бонусы
                IF p_bonusadd IS NOT NULL AND p_bonusadd <> 0 THEN
                    INSERT INTO bonuscardsdiary (card,ticket,transaction,type,bonus,date,company,"group")
                        VALUES (p_card,p_ticketid,p_transaction_id,case p_tickettype_in when 0 then 1 else -1 end,case when p_bonusadd < 0 then (p_bonusadd * (-1)) else p_bonusadd end,
                                                now(),p_company,p_bonusgroup);
                    -- Рассчет при покупке
                    IF p_tickettype_in = 0 THEN
                        UPDATE customers_bonuscards
                            SET bonuses = bonuses + p_bonusadd 
                                WHERE id = p_card;
                                    --AND company = p_company
                                    --AND case when p_bonusgroup = 0 then company = p_company else company = any(p_compbonusgroup) end;
                        IF NOT FOUND THEN
                            RAISE SQLSTATE 'S0005';
                        END IF;         
                    -- Рассчет при возврате
                    ELSE
                        UPDATE customers_bonuscards
                            SET bonuses = bonuses - case when p_bonusadd < 0 then (p_bonusadd * (-1)) else p_bonusadd end
                                WHERE id = p_card;
                                    --AND company = p_company
                                    --AND case when p_bonusgroup = 0 then company = p_company else company = any(p_compbonusgroup) end;
                        IF NOT FOUND THEN
                            RAISE SQLSTATE 'S0005';
                        END IF;         
                    END IF;
                END IF;

            END IF;

            FOR p_trans_details IN SELECT * FROM json_array_elements((p_trans)->'details')   

            LOOP

                p_prod                   := cast(p_trans_details->>'product' as bigint);
                p_produnits          := round(cast(p_trans_details->>'units' as numeric),3);  
                p_prodprice          := round(cast(p_trans_details->>'price' as numeric),2);
                p_attributes         := cast(p_trans_details->>'attributes' as bigint);
                p_totalprice         := p_produnits * p_prodprice;
                p_line                   := cast(p_trans_details->>'line' as bigint);
                p_count_part         := p_produnits;
                p_purchaseprice  := null; 
                p_purchasedate   := null;
                p_discount_det   := round(coalesce(cast(p_trans_details->>'discount' as numeric),0),2);
                p_ticketdiscount := round(coalesce(cast(p_trans_details->>'ticketdiscount' as numeric),0),2);
                p_bonuspay_det   := round(coalesce(cast(p_trans_details->>'bonuspay' as numeric),0),2);
                p_nds                        := round(coalesce(cast(p_trans_details->>'nds' as numeric),0),2);
                
                p_consignment_invoice := cast(nullif(p_trans_details->>'invoicenumber','') as bigint);
                
                p_peace := cast(coalesce(p_trans_details->>'issalebypiece','false') as boolean);
                p_wholesale := coalesce(cast(p_trans_details->>'wholesale' as integer),0);
                p_markup := round(coalesce(cast(p_trans_details->>'markup' as numeric),0),2);
                
                /*if p_prod in (927889,928239) then
                    CONTINUE;
                end if;*/
                
                -- Плюсы за минусы заехали
                IF p_tickettype_in = 1 THEN
                    p_nds    := case when (p_nds <= 0) then p_nds else -p_nds end;
                END IF;
                
                SELECT unitsprid, case when p_peace is null then piece else p_peace end INTO p_unitsprid, p_peace
                    FROM products
                        WHERE id = p_prod
                            AND company = p_company;
                -- Берем уже округленную сумму, т.к. этот товар имеет четкую стоимость при распаковке   
                IF p_peace THEN
                    p_totalprice := cast(p_trans_details->>'total' as numeric); 
                END IF;
                
                -- Рассчитывать только если это не услуга
                IF p_unitsprid <> 3 THEN
                    -- При консигнационном чеке количество уменьшается у консигнатора, а не у клиента
                    IF NOT p_consignment THEN
                    -- 20230520 assign p_sc_units_before through SELECT in stockcurrent
                    select units from stockcurrent s 
                        into p_sc_units_before
                            WHERE product = p_prod
                                AND attributes =  p_attributes
                                AND point = p_stock_id
                                AND company = p_company; 
                    -- Подсчет количества на складе
                        UPDATE stockcurrent
                            SET units = units - /*p_produnits*/case when p_tickettype_in = 1 and p_produnits > 0 then -p_produnits else p_produnits end
                                WHERE point = p_stock_id
                                    AND product = p_prod
                                        AND attributes = p_attributes
                                            AND company = p_company
                                                RETURNING id, units INTO p_stockcurrent_id, p_sc_units_after;
                        -- 20230520 record stockcurrent changes into stockdiary
                                        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,customer,consignmentinvoice,sc_units_before,sc_units_after,comments,sc_id)
                                            VALUES(p_date,case when p_tickettype_in = 0 then -100 else 200 end,p_stock_id,p_prod,p_count_part,
                                            round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2)+round((p_markup/p_produnits)::numeric,2),
                                        p_attributes,
                                                            p_company,p_transaction_id,case when p_consignment then p_customerid else null end,p_consignment_invoice,p_sc_units_before,p_sc_units_after,'stockcurrent changed by transfer-transactions, line 568'
                                                            -- 20230608 add stockcurrent_id logging into stockdiary
                                                            ,p_stockcurrent_id
                                                            -- 20230608 add stockcurrent_id logging into stockdiary
                                                            );
                        IF p_stockcurrent_id IS NULL THEN
                            RAISE SQLSTATE 'S0002';
                        END IF;
                    ELSE
                        -- Поиск записи у клиента
                        SELECT id INTO p_stockcurrent_id
                            FROM stockcurrent
                                WHERE point = p_stock_id
                                    AND product = p_prod
                                        AND attributes = p_attributes
                                            AND company = p_company;
                        IF p_stockcurrent_id IS NULL THEN
                            RAISE SQLSTATE 'S0002';
                        END IF;
                        -- Подсчет количества у консигнатора                    
                        UPDATE consignment
                            SET units = units - p_produnits
                                WHERE company = p_company
                                    AND customer = p_customerid
                                        AND stockid = p_stockcurrent_id
                                            -- AND price = p_prodprice
                                            AND invoice = p_consignment_invoice
                                                RETURNING units INTO p_sc_units_after;
                    END IF;

                    -- Для обновления стока на кассе
                    IF p_actual_stock IS NULL THEN
                        p_actual_stock := json_build_object('id',p_stockcurrent_id,'units',p_sc_units_after)::text;
                    ELSE
                        p_actual_stock := p_actual_stock ||','|| json_build_object('id',p_stockcurrent_id,'units',p_sc_units_after)::text;
                    END IF;
                
                    CASE p_tickettype_in
                            WHEN 0 THEN
                                -- Расчет для партиционного учета (продажа/возврат)
                                FOR i IN (
                                    SELECT date, units, purchaseprice
                                        FROM stockcurrent_part
                                            WHERE company = p_company
                                                AND point = p_stock_id
                                                AND product = p_prod
                                                AND attributes = p_attributes
                                                AND units > 0
                                                    ORDER BY date, purchaseprice
                                )
                                LOOP
                                    IF p_count_part = 0 THEN                
                                        EXIT;                   
                                    ELSIF i.units > p_count_part then
                                        -- 20230520 assign p_scp_units_before
                                        p_scp_units_before := coalesce (i.units,0);
                                        UPDATE stockcurrent_part
                                            SET units = units - p_count_part
                                                WHERE product = p_prod
                                                    AND attributes =  p_attributes
                                                    AND point = p_stock_id
                                                    AND company = p_company
                                                    AND date = i.date
                                                    AND purchaseprice = i.purchaseprice
                                                    AND units > 0
                                                        RETURNING purchaseprice, date, 
                                                            -- 20230520 assign p_scp_units_after
                                                            units 
                                                            -- 20230608 add stockcurrent_part id logging into stockdiary
                                                            ,id
                                                                INTO p_purchaseprice, p_purchasedate, p_scp_units_after
                                                                , p_scp_id;
                                        -- Оставляем запись в журнале перемещений товара
                                        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,purchasedate,customer,consignmentinvoice,scp_units_before,scp_units_after,comments,scp_id)
                                            VALUES(p_date,'-1',p_stock_id,p_prod,p_count_part,round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2)+round((p_markup/p_produnits)::numeric,2),p_attributes,
                                                            p_company,p_transaction_id,i.purchaseprice,i.date,case when p_consignment then p_customerid else null end,p_consignment_invoice,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by transfer-transactions, line 635'
                                                            --20230608 log scp_id
                                                            ,p_scp_id
                                                            );
                                        p_count_part := 0;
                                    ELSIF (p_count_part > i.units) OR (p_count_part = i.units) THEN
                                        p_count_part := p_count_part - i.units;
                                        -- 20230520 assign p_scp_units_before
                                        p_scp_units_before := coalesce (i.units,0);
                                        UPDATE stockcurrent_part
                                            SET units = 0
                                                WHERE product = p_prod
                                                    AND attributes =  p_attributes
                                                    AND point = p_stock_id
                                                    AND company = p_company
                                                    AND date = i.date
                                                    AND purchaseprice = i.purchaseprice
                                                    AND units > 0
                                                        RETURNING purchaseprice, date,
                                                    -- 20230520 assign p_scp_units_after
                                                            units 
                                                            -- 20230608 add stockcurrent_part id logging into stockdiary
                                                            ,id
                                                                INTO p_purchaseprice, p_purchasedate, p_scp_units_after
                                                                , p_scp_id;
                                        -- Оставляем запись в журнале перемещений товара
                                        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,purchasedate,customer,consignmentinvoice,scp_units_before,scp_units_after,comments,scp_id)
                                            VALUES(p_date,'-1',p_stock_id,p_prod,i.units,round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2)+round((p_markup/p_produnits)::numeric,2),p_attributes,
                                                            p_company,p_transaction_id,i.purchaseprice,i.date,case when p_consignment then p_customerid else null end,p_consignment_invoice,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by transfer-transactions, line 656'
                                                            --20230608 log scp_id
                                                            ,p_scp_id
                                                            );
                                    END IF;
                                END LOOP;
                    ELSE
                        SELECT purchaseprice, purchasedate INTO p_purchaseprice, p_purchasedate
                            FROM stockdiary
                                WHERE point = p_stock_id
                                    AND product = p_prod
                                    AND attributes = p_attributes
                                    AND reason = - 1
                                    AND company = p_company
                                    AND date = (SELECT MAX(date)
                                                                FROM stockdiary
                                                                    WHERE point = p_stock_id
                                                                        AND product = p_prod
                                                                        AND attributes = p_attributes
                                                                        AND reason = - 1
                                                                        AND units >= -p_produnits
                                                                        AND company = p_company)
                                        ORDER BY date desc
                                            LIMIT 1;
                        -- На случай отсутствия данных                  
                        IF p_purchaseprice IS NOT NULL AND p_purchasedate IS NOT NULL THEN  
                        -----26.05.2023
                        
                        SELECT units INTO p_scp_units_before
                        FROM stockcurrent_part s
                        WHERE product = p_prod
                                        AND attributes =  p_attributes
                                        AND point = p_stock_id
                                        AND company = p_company
                                        AND date = p_purchasedate
                                        AND purchaseprice = p_purchaseprice;
                        -----26.05.2023
                            UPDATE stockcurrent_part
                                SET units = units - /*p_count_part*/case when p_tickettype_in = 1 and p_count_part > 0 then -p_count_part else p_count_part end
                                    WHERE product = p_prod
                                        AND attributes =  p_attributes
                                        AND point = p_stock_id
                                        AND company = p_company
                                        AND date = p_purchasedate
                                        AND purchaseprice = p_purchaseprice
                                            RETURNING units
                                            ----13.06.2023
                                            ,id
                                            ----13.06.2023
                                            INTO p_scp_units_after
                                            ----13.06.2023
                                            , p_scp_id
                                            ----13.06.2023
                                            ;
                        else
                        
                           -------07.06.2023
                           SELECT date, purchaseprice into p_purchasedate1,p_purchaseprice1
                                    FROM stockcurrent_part
                                        WHERE product = p_prod
                                            AND attributes =  p_attributes
                                            AND point = p_stock_id
                                            AND company = p_company
                                            ORDER BY case when units < 0 then 0 when units > 0 then 1 else 2 end, units, date
                                            /*AND (units < 0 OR units > 0 OR units = 0)
                                            AND date = (SELECT MIN(date)
                                                                        FROM stockcurrent_part
                                                                            WHERE product = p_prod
                                                                                AND attributes =  p_attributes
                                                                                AND point = p_stock_id
                                                                                AND (units < 0 OR units > 0 OR units = 0)
                                                                                AND company = p_company)*/
                                    LIMIT  1;      
                        
                           -------07.06.2023
                        
                            --  20230520 assign p_scp_units_before
                            SELECT units INTO p_scp_units_before 
                                    FROM stockcurrent_part s
                                        WHERE s.product = p_prod
                                            AND s.attributes =  p_attributes
                                            AND s.point = p_stock_id
                                            AND s.company = p_company
                                            -------07.06.2023
                                            AND s.date = p_purchasedate1
                                            AND s.purchaseprice = p_purchaseprice1;
                                            ---AND s.date = min_part.date
                                            ---AND s.purchaseprice = min_part.purchaseprice;
                                            -------07.06.2023
                                        
                            WITH min_part AS (
                                SELECT date, purchaseprice
                                    FROM stockcurrent_part
                                        WHERE product = p_prod
                                            AND attributes =  p_attributes
                                            AND point = p_stock_id
                                            AND company = p_company
                                            ORDER BY case when units < 0 then 0 when units > 0 then 1 else 2 end, units, date
                                            /*AND (units < 0 OR units > 0 OR units = 0)
                                            AND date = (SELECT MIN(date)
                                                                        FROM stockcurrent_part
                                                                            WHERE product = p_prod
                                                                                AND attributes =  p_attributes
                                                                                AND point = p_stock_id
                                                                                AND (units < 0 OR units > 0 OR units = 0)
                                                                                AND company = p_company)*/
                                    LIMIT  1             
                            )
                            UPDATE stockcurrent_part s
                                SET units = units - /*p_count_part*/case when p_tickettype_in = 1 and p_count_part > 0 then -p_count_part else p_count_part end
                                    FROM min_part
                                        WHERE s.product = p_prod
                                            AND s.attributes =  p_attributes
                                            AND s.point = p_stock_id
                                            AND s.company = p_company
                                            AND s.date = min_part.date
                                            AND s.purchaseprice = min_part.purchaseprice
                                                RETURNING s.purchaseprice, s.date,
                                            -- assign p_scp_units_after
                                                s.units
                                                ----13.06.2023
                                                ,s.id
                                                ----13.06.2023
                                                INTO p_purchaseprice, p_purchasedate, p_scp_units_after
                                                ----13.06.2023
                                                , p_scp_id
                                                ----13.06.2023
                                                ;
                        END IF;
                        -- Оставляем запись в журнале перемещений товара
                        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,purchasedate,customer,consignmentinvoice,scp_units_before,scp_units_after,comments
                        ----13.06.2023
                        ,scp_id
                        ----13.06.2023
                        )
                            VALUES(p_date,'2',p_stock_id,p_prod,p_produnits,round((p_prodprice-((p_discount_det+p_ticketdiscount)/-p_produnits)-p_bonuspay_det/-p_produnits)::numeric,2)+round((p_markup/p_produnits)::numeric,2),p_attributes,p_company,
                                            p_transaction_id,p_purchaseprice,p_purchasedate,case when p_consignment then p_customerid else null end,p_consignment_invoice,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by transfer-transactions'
                        ----13.06.2023
                        , p_scp_id 
                        ----13.06.2023
                                            );
                        p_count_part := 0;  
                    END CASE;
                
                    -- Для учета минусового значения в партиционном учете (только для продаж)
                    IF p_count_part > 0 AND p_tickettype_in = 0 THEN
                        IF p_purchaseprice IS NOT NULL THEN 
                            --  20230520 assign p_scp_units_before
                            p_scp_units_before := coalesce(
                                (SELECT units 
                                    FROM stockcurrent_part s
                                        WHERE s.product = p_prod
                                            AND s.attributes =  p_attributes
                                            AND s.point = p_stock_id
                                            AND s.company = p_company
                                            -------07.06.2023
                                            AND s.date = p_purchasedate
                                            AND s.purchaseprice = p_purchaseprice),0);                                          
                                            --AND s.date = min_part.date
                                            --AND s.purchaseprice = min_part.purchaseprice),0);
                                            -------07.06.2023
                                        
                            UPDATE stockcurrent_part
                                SET units = units - p_count_part
                                    WHERE product = p_prod
                                        AND attributes =  p_attributes
                                        AND point = p_stock_id
                                        AND company = p_company
                                        AND date = p_purchasedate
                                        AND purchaseprice = p_purchaseprice
                                            RETURNING 
                                            -- assign p_scp_units_after
                                            -------07.06.2023
                                                units 
                                                ----13.06.2023
                                                ,id
                                                ----13.06.2023
                                                INTO p_scp_units_after
                                                ----13.06.2023
                                                , p_scp_id
                                                ----13.06.2023
                                                ;
                                            -------07.06.2023
                        ELSE
                            --  20230520 assign p_scp_units_before
                            p_scp_units_before := coalesce(
                                (SELECT units 
                                    FROM stockcurrent_part s
                                        WHERE s.product = p_prod
                                            AND s.attributes =  p_attributes
                                            AND s.point = p_stock_id
                                            AND s.company = p_company
                                            LIMIT 1),0);
                            WITH min_part AS (
                                SELECT date, purchaseprice
                                    FROM stockcurrent_part
                                        WHERE product = p_prod
                                            AND attributes =  p_attributes
                                            AND point = p_stock_id
                                            AND company = p_company
                                            ORDER BY case when units < 0 then 0 when units > 0 then 1 else 2 end, units, date desc
                                            /*AND (units < 0 OR units > 0 OR units = 0)
                                            AND date = (SELECT MAX(date)
                                                                        FROM stockcurrent_part
                                                                            WHERE product = p_prod
                                                                                AND attributes =  p_attributes
                                                                                AND point = p_stock_id
                                                                                AND (units < 0 OR units > 0 OR units = 0)
                                                                                AND company = p_company)*/
                                    LIMIT  1             
                            )
                            UPDATE stockcurrent_part s
                                SET units = units - p_count_part 
                                    FROM min_part
                                        WHERE s.product = p_prod
                                            AND s.attributes =  p_attributes
                                            AND s.point = p_stock_id
                                            AND s.company = p_company
                                            AND s.date = min_part.date
                                            AND s.purchaseprice = min_part.purchaseprice
                                                RETURNING s.purchaseprice, s.date,
                                            -- 20230520 assign p_scp_units_after
                                                s.units
                                                ----13.06.2023
                                                ,s.id
                                                ----13.06.2023
                                                INTO p_purchaseprice, p_purchasedate, p_scp_units_after
                                                ----13.06.2023
                                                , p_scp_id
                                                ----13.06.2023
                                                ;
                        END IF;
                        IF NOT FOUND THEN                           
                            SELECT logging(jsonb_build_object('company',p_company,'point',p_stock_id,'product',p_prod,'attributes',p_attributes,
                                                                                                    'units',p_produnits,'diff',p_count_part,'user',cast(p_trans->>'cashboxuser' as bigint)), 
                            jsonb_build_object('transfer_transactions',jsonb_build_object('code','error','text','Недостаточно данных для расчета партиционирования!')),'transfer_transactions','')
                                    INTO p_logging_json;
                        END IF;     
                        -- Оставляем запись в журнале перемещений товара
                        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,purchasedate,customer,consignmentinvoice,scp_units_before,scp_units_after,comments
                        ----13.06.2023
                        ,scp_id
                        ----13.06.2023
                        )
                            VALUES(p_date,'-1',p_stock_id,p_prod,p_count_part,round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2)+round((p_markup/p_produnits)::numeric,2),p_attributes,
                                                p_company,p_transaction_id,p_purchaseprice,p_purchasedate,case when p_consignment then p_customerid else null end,p_consignment_invoice,p_scp_units_before,p_scp_units_after,'stockcurrent_part changed by transfer-transactions'
                        ----13.06.2023
                        , p_scp_id
                        ----13.06.2023
                                                );
                    END IF;
                -- Только для услуг 
                ELSE
                    -- Обнуление в стоке
                    UPDATE stockcurrent
                        SET units = 0
                            WHERE point = p_stock_id
                                AND product = p_prod
                                    AND attributes = p_attributes
                                        AND company = p_company
                                            RETURNING id INTO p_stockcurrent_id;
                    IF NOT FOUND THEN
                        RAISE SQLSTATE 'S0002';
                    END IF;                     
                    -- Для обновления стока на кассе
                    IF p_actual_stock IS NULL THEN
                        p_actual_stock := json_build_object('id',p_stockcurrent_id,'units',0)::text;
                    ELSE
                        p_actual_stock := p_actual_stock ||','|| json_build_object('id',p_stockcurrent_id,'units',0)::text;
                    END IF;                             
                    -- Обнуление в партионном учете
                    UPDATE stockcurrent_part
                        SET units = 0
                            WHERE point = p_stock_id
                                AND product = p_prod
                                    AND attributes = p_attributes
                                        AND company = p_company
                                        ----13.06.2023
                                        --RETURNING NULL INTO p_scp_id
                                        ----13.06.2023
                                        ;
                    -- Данные партии для дневника                   
                    SELECT date, purchaseprice INTO p_purchasedate, p_purchaseprice
                                        FROM stockcurrent_part
                                            WHERE company = p_company
                                                AND point = p_stock_id
                                                AND product = p_prod
                                                AND attributes = p_attributes
                                                AND date = (SELECT MAX(date)
                                                                            FROM stockcurrent_part
                                                                                WHERE company = p_company
                                                                                    AND point = p_stock_id
                                                                                    AND product = p_prod
                                                                                    AND attributes = p_attributes)
                                                                                        LIMIT 1;
                    IF NOT FOUND THEN
                        RAISE SQLSTATE 'S0002';
                    END IF;                                                                 
                    -- Оставляем запись в журнале перемещений товара
                        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,transactionid,purchaseprice,purchasedate,customer,consignmentinvoice,sc_units_after,scp_units_after,comments
                        ----13.06.2023
                        ,scp_id, sc_id
                        ----13.06.2023
                        )
                            VALUES(p_date,'-1',p_stock_id,p_prod,p_count_part,round((p_prodprice-((p_discount_det+p_ticketdiscount)/p_produnits)-p_bonuspay_det/p_produnits)::numeric,2)+round((p_markup/p_produnits)::numeric,2),p_attributes,
                                                p_company,p_transaction_id,p_purchaseprice,p_purchasedate,case when p_consignment then p_customerid else null end,p_consignment_invoice,0,0,'stockcurrent and stockcurrent_part units set to 0 by transfer_transactions, unitsprid=3 i.e. service'
                        ----13.06.2023
                        ,p_scp_id, p_stockcurrent_id
                        ----13.06.2023                      
                                                );
                END IF;

                -- Определение НДС\ТНВЭД
                SELECT t.rate, p.cnofeacode, case when s.code is not null then true else false end INTO p_rate, p_cnofeacode, p_esf
                  FROM taxes t
                      LEFT JOIN products p on (p.taxid = t.id)
                          LEFT JOIN seizurelist s on (s.code = p.cnofeacode)
                            WHERE p.id = p_prod;

              INSERT INTO transaction_details(
                        transactionid,product,units,price,totalprice,attributes,line,taxrate,cnofeacode,
                        bonusadd,bonuspay,bonusrate,discount,nds,
                        company,ticketdiscount,invoice,piece,pieceunits,wholesale
                        -- 26.09.2022
                        ,markup                           
                        -- 26.09.2022                             
                )
                  VALUES(p_transaction_id,p_prod,p_produnits,p_prodprice,p_totalprice,p_attributes,p_line,p_rate,p_cnofeacode,
                                     round(coalesce(cast(p_trans_details->>'bonusadd' as numeric),0),2),
                                     p_bonuspay_det,coalesce(cast(p_trans_details->>'bonusrate' as double precision),0),
                                     p_discount_det,p_nds,p_company,p_ticketdiscount, case when p_consignment_invoice is not null then p_consignment_invoice else 0 end,p_peace,
                                     coalesce(cast(p_trans_details->>'pieceunits' as integer),0),p_wholesale
                                    -- 26.09.2022
                                    ,round(coalesce(cast(p_trans_details->>'markup' as numeric),0),2)                             
                                    -- 26.09.2022   
                );
                
                -- Заполнение инвойса для обновления на других кассах
                IF p_count > 1 AND NOT p_consignment THEN
                  INSERT INTO invoicelist(invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company)
                      VALUES(p_invoicenumber,p_stockcurrent_id,0,0,0,0,false,p_stockcurrent_id,false,false,p_company);
                END IF;
                
                -- Обработка данных по подарочным сертификатам(продажа/возврат)
                FOR p_certs IN SELECT * FROM json_array_elements((p_trans_details)->'cert')
                LOOP
                    IF p_tickettype_in = 0 THEN
                        -- Активирование сертификата
                        p_certcode = trim(p_certs->>'code');
                        p_cert = null;
                        BEGIN
                            UPDATE giftcertificates
                                SET active = true, balance = denomination, 
                                expiredate = (current_date + interval '1 month' * period)::date, selldate = current_date
                                    WHERE code = trim(p_certs->>'code')
                                        AND case when p_certgroup = 0 then company = p_company else company = any(p_compcertgroup) end
                                            RETURNING id, denomination INTO p_cert, p_cert_summ;
                            IF p_cert is null THEN
                                RAISE SQLSTATE 'S0006';
                            END IF;
                        EXCEPTION 
                            WHEN OTHERS THEN
                                UPDATE giftcertificates
                                SET active = true, balance = denomination, 
                                expiredate = (current_date + interval '1 month' * period)::date, selldate = current_date
                                    WHERE code = trim(p_certs->>'code')
                                        AND company = p_company
                                            RETURNING id, denomination INTO p_cert, p_cert_summ;
                                IF p_cert is null THEN
                                    RAISE SQLSTATE 'S0006';
                                END IF;
                                UPDATE giftcertificates SET code = 'D'||code
                                    WHERE code = trim(p_certs->>'code')
                                        AND company <> p_company;
                        END;
                        -- Запись в историю событий
                        INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
                            VALUES(p_company,now(),2,p_cert,p_cert_summ,p_transaction_id,p_point_in,p_certgroup);
                    ELSE
                        -- Отмена активации сертификата
                        UPDATE giftcertificates
                            SET active = false, balance = 0, expiredate = null, selldate = null
                                WHERE code = trim(p_certs->>'code')
                                    AND case when p_certgroup = 0 then company = p_company else company = any(p_compcertgroup) end--company = p_company
                                        RETURNING id, denomination INTO p_cert, p_cert_summ;
                        IF NOT FOUND THEN
                            RAISE SQLSTATE 'S0006';
                        END IF;             
                        -- Запись в историю событий
                        INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
                            VALUES(p_company,now(),6,p_cert,p_cert_summ,p_transaction_id,p_point_in,p_certgroup);
                    END IF;
                END LOOP;
                
                -- Обработка использованных акций
                FOR p_promotions IN SELECT * FROM json_array_elements((p_trans_details)->'promotions')
                LOOP
                    INSERT INTO transaction_promotions(transactionid,product,attributes,company,promotion,amount)
                        VALUES(p_transaction_id,p_prod,p_attributes,p_company,cast(p_promotions->>'id' as bigint),cast(round((p_promotions->>'amount')::numeric,2) as double precision));
                END LOOP;

            END LOOP; 
            
            -- Отправка на остальные кассы, если они есть
            IF p_count > 1 AND NOT p_consignment THEN
              FOR R IN (
                  SELECT b.id as cashbox
                      FROM companies c
                          LEFT JOIN points p on (p.company = c.id) 
                              LEFT JOIN cashboxes b on (b.point = p.id)
                                WHERE company = p_company 
                                    AND point_type = '2' 
                                        AND p.status = 'ACTIVE'
                                            AND c.status = 'ACTIVE'
                                                  AND b.deleted = false
                                                      AND b.isengaged = true
                                                          AND point = p_point_in
                                                              AND b.id <> p_cashbox_in
                                                              ORDER BY p.id 
                )
                LOOP
                  INSERT INTO systemmessage(point,invoice,type_message,cashbox)
                        VALUES(p_point_in,p_invoicenumber,8,r.cashbox); 
                END LOOP;

            END IF;

    END LOOP;
    
    -- Обработка использованных акций
    FOR p_promotions IN SELECT * FROM json_array_elements((p_trans_details)->'promotions')
    LOOP
        INSERT INTO transaction_promotions(transactionid,product,attributes,company,promotion,amount)
            VALUES(p_transaction_id,null,null,p_company,cast(p_promotions->>'id' as bigint),cast(round((p_promotions->>'amount')::numeric,2) as double precision));
    END LOOP;
    
    -- Обработка купонов (На товары)
    FOR p_coupons IN SELECT * FROM json_array_elements((p_trans_details)->'coupon')
    LOOP
        -- Косяк с кассы (иногда приходят пустые number)
        IF nullif(trim(p_coupons->>'number'),'') IS NULL THEN
            CONTINUE;
        END IF;
        SELECT id, subtype INTO p_couponid, p_couponsubtype
            FROM coupons
                WHERE "number" = trim(p_coupons->>'number')
                    AND company = p_company;
        IF NOT FOUND THEN
            RAISE SQLSTATE 'S0008';
        END IF;         
        IF p_couponsubtype = 2 THEN
            UPDATE coupons
                SET active = false
                    WHERE id = p_couponid
                        AND company = p_company;
            IF NOT FOUND THEN
                RAISE SQLSTATE 'S0008';
            END IF;
        END IF;
        -- Запись в дневник          
        INSERT INTO couponsdiary(company,"date",reason,idcoup,transactionid)
            VALUES(p_company,now(),2,p_couponid,p_transaction_id);
    END LOOP;
    
    -- Обработка данных по подарочным сертификатам(использование)
    FOR p_certs IN SELECT * FROM json_array_elements((p_trans)->'cert')
    LOOP
        --(card,cash|mixed,debit)
        IF p_paymenttype = 'mixed' THEN
            -- Обновление статуса карты и обнуление баланса
            begin
                UPDATE giftcertificates
                    SET active = false, balance = 0, company = p_company
                        WHERE code = trim(p_certs->>'code')
                            AND case when p_certgroup = 0 then company = p_company else company = any(p_compcertgroup) end
                                RETURNING id, denomination, product, denomination INTO p_cert, p_cert_summ, p_cert_prod, p_cert_denom;
                IF NOT FOUND THEN
                    RAISE SQLSTATE 'S0006';
                END IF;
            EXCEPTION
                WHEN SQLSTATE 'S0006' THEN
                    RAISE SQLSTATE 'S0006';
                WHEN OTHERS THEN
                    UPDATE giftcertificates
                    SET active = false, balance = 0, company = p_company
                        WHERE code = trim(p_certs->>'code')
                            AND company = p_company
                                RETURNING id, denomination, product, denomination INTO p_cert, p_cert_summ, p_cert_prod, p_cert_denom;
                    IF NOT FOUND THEN
                        RAISE SQLSTATE 'S0006';
                    END IF;
                    UPDATE giftcertificates
                    SET code = 'D'||code
                        WHERE code = trim(p_certs->>'code')
                            AND company <> p_company;
            end;
            -- Запись в историю событий
            INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
                VALUES(p_company,now(),3,p_cert,p_cert_summ,p_transaction_id,p_point_in,p_certgroup);
        ELSE
            -- Подтягиваем данные по подарочному сертификату для дальнейшей обработки
            begin
                p_cert := null;
                SELECT id, balance, type, product, denomination INTO p_cert, p_cert_summ, p_cert_type, p_cert_prod, p_cert_denom
                    FROM giftcertificates
                        WHERE code = trim(p_certs->>'code')
                            AND case when p_certgroup = 0 then company = p_company else company = any(p_compcertgroup) end;
                IF p_cert is null THEN
                    RAISE SQLSTATE 'S0006';
                END IF;
            EXCEPTION
                WHEN SQLSTATE 'S0006' THEN
                    RAISE SQLSTATE 'S0006';
                WHEN OTHERS THEN
                    SELECT id, balance, type, product, denomination INTO p_cert, p_cert_summ, p_cert_type, p_cert_prod, p_cert_denom
                    FROM giftcertificates
                        WHERE code = trim(p_certs->>'code')
                            AND company = p_company;
                    IF p_cert is null THEN
                        RAISE SQLSTATE 'S0006';
                    END IF;
                    UPDATE giftcertificates
                    SET code = 'D'||code
                        WHERE code = trim(p_certs->>'code')
                            AND company <> p_company;
            end;
            -- Высчитываем потраченную сумму    
            IF p_cert_calc IS NULL THEN
                p_cert_calc := p_price - p_cert_summ;           
            ELSE
                p_cert_calc := p_cert_calc - p_cert_summ;
            END IF;
            -- Запись в историю событий
            INSERT INTO giftcertificatesdiary(company,date,reason,idcert,summ,transactionid,point,"group")
                VALUES(p_company,now(),3,p_cert,case when p_cert_calc <= 0 then p_price else p_cert_summ end,p_transaction_id,p_point_in,p_certgroup);
            -- Запись по остатку (для дальнейшего списания остатков)    
            IF p_cert_type = 1 and p_cert_calc < 0 THEN
                INSERT INTO giftcertificates_writeoff_balances(company,certid,balance)
                    VALUES(p_company,p_cert,-p_cert_calc);
            END IF; 
            -- Обновление статуса карты и обнуление баланса
            UPDATE giftcertificates
                SET active = case when p_cert_type = 1 then false when p_cert_type <> 1 and p_cert_calc < 0 then true end, 
                        balance = case when p_cert_calc > 0 then 0 else -p_cert_calc end, company = p_company
                    WHERE code = trim(p_certs->>'code')
                        AND case when p_certgroup = 0 then company = p_company else company = any(p_compcertgroup) end;--company = p_company;       
            IF NOT FOUND THEN
                RAISE SQLSTATE 'S0006';
            END IF;         
        END IF; 
    
       ------29.05.2023 
       p_sc_units_before:=0;
       select units into p_sc_units_before from  stockcurrent
                    WHERE product = p_cert_prod
                    AND company = p_company
                    AND point = p_stock_id; 
        
        p_scp_units_before:=0;      
        select units into p_scp_units_before from stockcurrent_part
                    WHERE product = p_cert_prod
                    AND company = p_company
                    AND point = p_stock_id
                    AND date = (SELECT max(date)
                                                FROM stockcurrent_part
                                                    WHERE product = p_cert_prod
                                                        AND company = p_company
                                                        AND point = p_stock_id)
                    AND purchaseprice = (SELECT min(purchaseprice)
                                                FROM stockcurrent_part
                                                    WHERE product = p_cert_prod
                                                        AND company = p_company
                                                        AND point = p_stock_id
                                                        AND date = (SELECT max(date)
                                                                                    FROM stockcurrent_part
                                                                                        WHERE product = p_cert_prod
                                                                                            AND company = p_company
                                                                                            AND point = p_stock_id));       
       ------29.05.2023
        
        -- Увеличиваем количество на точке, т.к. использованный сертификат теперь вновь доступен (на кассах обновлять не нужно, т.к. им пофиг вообще)
        UPDATE stockcurrent
            SET units = units + 1
                WHERE product = p_cert_prod
                    AND company = p_company
                    AND point = p_stock_id
                    ------29.05.2023
                    RETURNING units 
                    ----13.06.2023
                    ,id
                    ----13.06.2023
                    INTO p_sc_units_after
                    ----13.06.2023
                    ,p_stockcurrent_id
                    ----13.06.2023
                    ------29.05.2023
                    ;
        IF NOT FOUND THEN
            INSERT INTO stockcurrent(point,product,units,attributes,company)
                VALUES(p_stock_id,p_cert_prod,1,0,p_company);
        END IF;
        
        UPDATE stockcurrent_part
            SET units = units + 1
                WHERE product = p_cert_prod
                    AND company = p_company
                    AND point = p_stock_id
                    AND date = (SELECT max(date)
                                                FROM stockcurrent_part
                                                    WHERE product = p_cert_prod
                                                        AND company = p_company
                                                        AND point = p_stock_id)
                    AND purchaseprice = (SELECT min(purchaseprice)
                                                FROM stockcurrent_part
                                                    WHERE product = p_cert_prod
                                                        AND company = p_company
                                                        AND point = p_stock_id
                                                        AND date = (SELECT max(date)
                                                                                    FROM stockcurrent_part
                                                                                        WHERE product = p_cert_prod
                                                                                            AND company = p_company
                                                                                            AND point = p_stock_id))
        ------29.05.2023
        RETURNING units 
        ----13.06.2023
        ,id
        ----13.06.2023
        INTO p_scp_units_after
        ----13.06.2023
        ,p_scp_id
        ----13.06.2023      
        ------29.05.2023                                                                                    
                                                                                            ;
        IF NOT FOUND THEN
            INSERT INTO stockcurrent_part(company,point,date,product,attributes,purchaseprice,units)
                VALUES(p_company,p_stock_id,current_date,p_cert_prod,0,p_cert_denom,1);
        END IF;
                    
        INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,company,purchaseprice,purchasedate,transactionid,customer,consignmentinvoice,comments
        ------29.05.2023
        ,scp_units_before,scp_units_after,sc_units_before,sc_units_after
        ------29.05.2023
        ----13.06.2023
        ,scp_id, sc_id
        ----13.06.2023
        )
            VALUES(p_date,'1',p_stock_id,p_cert_prod,1,p_cert_denom,0,p_company,p_cert_denom,current_date,p_transaction_id,case when p_consignment then p_customerid else null end,p_consignment_invoice,'used gift-certificate added to stockcurrent and stockcurrent_part updated by transfer-transactions'
        ------29.05.2023
        ,p_scp_units_before,p_scp_units_after,p_sc_units_before,p_sc_units_after
        ------29.05.2023    
        ----13.06.2023
        ,p_scp_id, p_stockcurrent_id
        ----13.06.2023
            );          
    
    END LOOP;

    -- "Элегантного" варианта не нашлось... Сранный postgres...

  p_actual_stock := '['|| p_actual_stock ||']';

    result := json_build_object('code','success','text',p_actual_stock::json);

    return next;

EXCEPTION 
     WHEN SQLSTATE 'S0001' THEN
         result := json_build_object('code','error_stock','text','Склад точки не идентифицирован!');
         return next;
     WHEN SQLSTATE 'S0002' THEN
         result := json_build_object('code','error','text','Товар на складе не найден! Номер чека - '||p_ticketid||', p_id: '||p_prod||
         ', p_stock_id: '||p_stock_id||', p_attributes: '||p_attributes||', p_company: '||p_company);
         return next;
     WHEN SQLSTATE 'S0003' THEN
         result := json_build_object('code','error_stock','text','Не удалось определить точку кассы!');
         return next;
     WHEN SQLSTATE 'S0004' THEN
         result := json_build_object('code','error_stock','text','Не удалось определить должника!');
         return next;    
     WHEN SQLSTATE 'S0005' THEN
         result := json_build_object('code','error_stock','text','Не удалось определить бонусную карту!');
         return next;    
     WHEN SQLSTATE 'S0006' THEN
         result := json_build_object('code','error_stock','text','Не удалось определить подарочный сертификат!');
         return next;   
     WHEN SQLSTATE 'S0007' THEN
         result := json_build_object('code','error_stock','text','Точка либо касса были деактивированы! Касса: '||p_cashbox_in||' (Точка: '||p_point_in||')');
         return next;
     WHEN SQLSTATE 'S0008' THEN
         result := json_build_object('code','error_stock','text','Не найден купон: '||p_couponid||'!');
         return next;    
     WHEN OTHERS THEN
       RAISE NOTICE 'internal_error: %', SQLERRM;
       GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
         IF p_check = 'transactions_details_pkey' THEN
                result := json_build_object('code','error','text','В детализации чека не может быть больше одной записи по одному товару!');
                --continue;
         ELSIF p_check = 'transactions_fk_cashusr' THEN
              result := json_build_object('code','error','text','Передаваемого пользователя не существует!');
         ELSIF p_check = 'transactions_fk_point' THEN
              result := json_build_object('code','error','text','Передаваемой точки не существует!');
     -- Уникальность по point, ticketid, cashbox (если уже есть запись - пропускаем)
         /*ELSIF p_check = 'transactions_idx' THEN
              continue;*/
         ELSE
              result := json_build_object('code','internal_error','text',SQLERRM||', '||p_error||', line'||p_err_line||', fiz = '||p_fizid);
         END IF;
   --SQLSTATE||':'||SQLERRM||':'||p_error||','||p_certcode||', line = '||p_err_line
       return next;

END;

$$;


ALTER FUNCTION public.transfer_transactions(transinf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 749 (class 1255 OID 16584)
-- Name: update_cert_expdate(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_cert_expdate(param json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare 

p_error varchar;
p_company bigint;
p_code varchar;
p_expiredate date;
json_object json;


begin

	SELECT (param)::json into json_object;
	
	p_company	:= cast(json_object->>'company' as bigint);
	p_code	:= cast(json_object->>'code' as varchar);
	p_expiredate	:= cast(json_object->>'expiredate' as date);
	
	--IF p_company IS NULL OR p_code IS NULL or p_expiredate IS NULL THEN
	if p_company is null then 
				RAISE SQLSTATE 'S0001';
	END IF;
	
	if p_code is null then
				RAISE SQLSTATE 'S0002';
	END IF;
	
	if p_expiredate is null then
				RAISE SQLSTATE 'S0003';
	END IF;
	
	update giftcertificates 
	set expiredate = p_expiredate 
	where company = p_company
	and code = p_code;
	
	result := json_build_object('code','success','text', 'ok');
	return next;
	
	EXCEPTION 
	
	WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Идентификатор компании не был передан!');
		 return next; 

WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Идентификатор кода не был передан!');
		 return next; 

WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error','text','Идентификатор даты не был передан!');
		 return next; 

	
	WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error,'date',now());
   return next;
end;
	

$$;


ALTER FUNCTION public.update_cert_expdate(param json, OUT result json) OWNER TO postgres;

--
-- TOC entry 750 (class 1255 OID 16585)
-- Name: update_erp_role(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_erp_role(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
declare 

p_error varchar;
p_company bigint;
p_name varchar;
p_accesses json;
p_cnt int;

begin

	p_company	:= cast(inf->>'company' as bigint);
	p_name	:= cast(inf->>'name' as varchar);
	p_accesses	:= cast(inf->>'accesses' as json);
	
	WITH rows AS (
		update erp_roles set accesses = p_accesses
		where company = p_company
			and "name" = p_name
			RETURNING 1)
	select count(*) into p_cnt from rows;
	if p_cnt = 0 then
		insert into erp_roles("name",company,accesses)
		values (p_name,p_company,p_accesses);
	end if;
		
	result := json_build_object('code','success');
	return next;
	
	EXCEPTION 
		WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLERRM||':'||p_error);
		 return next;
end;
	

$$;


ALTER FUNCTION public.update_erp_role(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 751 (class 1255 OID 16586)
-- Name: update_news(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.update_news(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 json_object       		json;
 p_error           		varchar;
 p_id									bigint;
 p_header				  	  text;
 p_content				  	text;
BEGIN
-- {"data" : {"news_id":53, "header": "test223", "content": "big news text"}}  
-- Обновление новостей для админки.
	SELECT (inf)::json into json_object;

		p_header := cast(trim(json_object->>'header') as text);
		p_content := cast(trim(json_object->>'content') as text);
		p_id := cast(json_object->>'news_id' as bigint);

		IF p_header IS NULL THEN
			RAISE SQLSTATE 'S0001';
		ELSIF p_content IS NULL THEN
			RAISE SQLSTATE 'S0002';
		ELSIF p_id IS NULL THEN
			RAISE SQLSTATE 'S0003';
		END IF;
	
		UPDATE news
			SET header=p_header,
					content=p_content
			WHERE id=p_id;
		

		result := json_build_object('code','success','text','Новость успешно обновлена!');
		return next;
		return;

		EXCEPTION 
		WHEN SQLSTATE 'S0001' THEN
			 result := json_build_object('code','error','text','Текст заголовка не может быть пустым!');
			 return next; 	
		WHEN SQLSTATE 'S0002' THEN
			 result := json_build_object('code','error','text','Текст новости не может быть пустым!');
			 return next; 	
		WHEN SQLSTATE 'S0003' THEN
			 result := json_build_object('code','error','text','ID не может быть пустым!');
			 return next; 	
		WHEN OTHERS THEN
			 RAISE NOTICE 'internal_error: %', SQLERRM;
			 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
			 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
			 return next;

END;


$$;


ALTER FUNCTION public.update_news(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 752 (class 1255 OID 16587)
-- Name: updatetoken(jsonb); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.updatetoken(inf jsonb, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE

	p_error 	      varchar;

	p_token		      json;

  p_pointtoken_id bigint;

BEGIN



	-- {"point" : "12", "token" : "wwwww"}



  SELECT (inf)::json into p_token;



	IF p_token->>'point' IS NULL THEN

	  result := json_build_object('code','error','text','Точка не указана!');

		return;

	ELSIF p_token->>'token' IS NULL THEN

		result := json_build_object('code','error','text','Токен не указан!');

		return;

	END IF;



	UPDATE pointtoken

	  SET token = p_token->>'token'

		  WHERE point = cast(p_token->>'point' as bigint)

			  RETURNING point INTO p_pointtoken_id;



	IF p_pointtoken_id IS NULL THEN

		result := json_build_object('code','error','text','Запись не найдена!');

	ELSE

    result := json_build_object('code','success','text','');

	END IF;



  return next;



EXCEPTION WHEN OTHERS THEN

	 RAISE NOTICE 'internal_error: %', SQLERRM;

	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;

	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);

   return next;

END;$$;


ALTER FUNCTION public.updatetoken(inf jsonb, OUT result json) OWNER TO postgres;

--
-- TOC entry 753 (class 1255 OID 16588)
-- Name: upload_reconciliation(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.upload_reconciliation(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
	DECLARE
 json_object       json;
 p_error           varchar;
 p_company	 			 bigint;
 p_point           bigint;
 p_user            bigint;
 p_id			  	     bigint;
 p_begin_date      TIMESTAMP;
 
BEGIN
	-- загружаем результаты сверки (ревизии)
	-- {"id":17, "user":234, "in_data":[]}  
	SELECT (inf)::json into json_object;
	p_id := cast(json_object->>'id' as bigint);
	
	begin
		select p_begin_date into p_begin_date from reconciliation 
		where id = p_id
			and status = 1;
			result := json_build_object('code','success','text',p_id,'end_date',to_char(p_end_date, 'DD.MM.YYYY HH:MI:SS'));			
	exception
		when OTHERS then null;
	end;
	if p_begin_date is null then
		update reconciliation set in_data = json_object
		where id = p_id
			and status = 0
			RETURNING begin_date INTO p_begin_date;		
			result := json_build_object('code','success','text',p_id,'begin_date',to_char(p_begin_date, 'DD.MM.YYYY HH:MI:SS'));
	end if;
	return next;
--{"code":"success","text":123,"begin_date":"28.04.2021 14:36:01"}
EXCEPTION 
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
		 return next;
END$$;


ALTER FUNCTION public.upload_reconciliation(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 702 (class 1255 OID 16589)
-- Name: utl_changeprice_log(bigint, bigint, double precision, double precision, double precision, double precision, bigint); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.utl_changeprice_log(comp bigint, stock bigint, pr double precision, pr_old double precision, pprice double precision, pprice_old double precision, inv bigint, OUT code character varying, OUT text character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
 json_object       json;
 p_error           varchar;
 p_invoice				 varchar;
 p_type						 varchar;
 p_altinvoice			 varchar;

BEGIN

   INSERT INTO changeprice_history (company,stockid,price,price_old,date,pieceprice,pieceprice_old,invoice)
	   VALUES(comp,stock,pr,pr_old,now(),pprice,pprice_old,inv);
		
	 "code" := 'success';
	 "text" := '';
		
    RETURN NEXT;

EXCEPTION WHEN OTHERS THEN
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 "code" := 'internal_error';
	 "text" := SQLSTATE||' : '||SQLERRM;
	 
	 INSERT INTO action_logs(date, function, request, response, error)
	  VALUES (now(),'changeprice_log',json_build_object('comp',comp,'stock',stock,'pr',pr,'pr_old',pr_old,'pprice',pprice,'pprice_old',pprice_old),json_build_object('code',SQLSTATE),SQLERRM);
	 
   RETURN NEXT;

END;

$$;


ALTER FUNCTION public.utl_changeprice_log(comp bigint, stock bigint, pr double precision, pr_old double precision, pprice double precision, pprice_old double precision, inv bigint, OUT code character varying, OUT text character varying) OWNER TO postgres;

--
-- TOC entry 755 (class 1255 OID 16590)
-- Name: utl_changeprice_log(bigint, bigint, double precision, double precision, double precision, double precision, bigint, double precision, double precision); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.utl_changeprice_log(comp bigint, stock bigint, pr double precision, pr_old double precision, pprice double precision, pprice_old double precision, inv bigint, pwholesale_price double precision, pwholesale_price_old double precision, OUT code character varying, OUT text character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$

DECLARE
 json_object       json;
 p_error           varchar;
 p_invoice				 varchar;
 p_type						 varchar;
 p_altinvoice			 varchar;

BEGIN

   INSERT INTO changeprice_history (company,stockid,price,price_old,date,pieceprice,pieceprice_old,invoice,wholesale_price,wholesale_price_old)
	   VALUES(comp,stock,pr,pr_old,now(),pprice,pprice_old,inv,pwholesale_price,pwholesale_price_old);
		
	 "code" := 'success';
	 "text" := '';
		
    RETURN NEXT;

EXCEPTION WHEN OTHERS THEN
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 "code" := 'internal_error';
	 "text" := SQLSTATE||' : '||SQLERRM;
	 
	 INSERT INTO action_logs(date, function, request, response, error)
	  VALUES (now(),'changeprice_log',json_build_object('comp',comp,'stock',stock,'pr',pr,'pr_old',pr_old,'pprice',pprice,'pprice_old',pprice_old),json_build_object('code',SQLSTATE),SQLERRM);
	 
   RETURN NEXT;

END;

$$;


ALTER FUNCTION public.utl_changeprice_log(comp bigint, stock bigint, pr double precision, pr_old double precision, pprice double precision, pprice_old double precision, inv bigint, pwholesale_price double precision, pwholesale_price_old double precision, OUT code character varying, OUT text character varying) OWNER TO postgres;

--
-- TOC entry 756 (class 1255 OID 16591)
-- Name: weightgoods_add(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.weightgoods_add(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company           					bigint;
 p_deleted										boolean;
 p_point											bigint;
 p_type												integer;
 p_counterparty								bigint;
 p_hot												integer;
 p_id													bigint;
 p_attributes									bigint;
 p_brand											bigint;
 p_category										bigint := -1;
 p_purchaseprice							float8;
 p_newprice										float8;
 p_taxid											smallint;
 p_unitsprid									bigint;
 p_ubdateprice								boolean := false;
 p_error			       					varchar;
 p_check						 					varchar;
 p_invoiceprod 				    		json;
 p_code												varchar;
 p_name												varchar;
 p_result				 							json;
 p_func_code					 				varchar;
 p_func_text					 				varchar;
 p_user												bigint;
 p_invoice										bigint;
 p_units											float8;
 p_cnofea											varchar;
 p_scale											bigint;
 
BEGIN

/*
{   
		scale: 0,
		user: 1,
		company: 15,
    altinvoice: "",
    invoicedate: "04.08.2020",
    point: "190",
    type: "2"
    products: [
        {
						deleted: false,
            amount: "123",
            attributes: null,
            brand: null,
            category: "-1",
            cnofea: null,
            code: "1",
            hotKey: 1,
            id: null,
            lastpurchaseprice: 0,
            name: "ewfwer",
            newprice: 123,
            purchaseprice: "324",
            sku: null,
            taxid: "1",
            unitsprid: "6",
            updateprice: true,
        }]}
*/
	
		p_company 		 := cast(trim(inf->>'company') as bigint);
		p_user				 := cast(trim(inf->>'user') as bigint);
		p_point				 := cast(trim(inf->>'point') as bigint);
		p_scale				 := cast(nullif(trim(inf->>'scale'),'') as bigint);
		p_counterparty := 0;
		
		IF p_scale IS NULL THEN
			RAISE SQLSTATE 'S0012';
		END IF;
		
		-- Выясняем тип передаваемой точки (проверяем за фронтом)
		SELECT point_type INTO p_type
			FROM points
				WHERE id = p_point
					AND company = p_company;
		
		IF p_company IS NULL OR p_user IS NULL THEN
			RAISE SQLSTATE 'S0001';
		ELSIF p_type <> 1 THEN
			RAISE SQLSTATE 'S0002';
		END IF;
		
		-- Создание инвойса для добавления товара
		INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate,counterparty)
			VALUES(p_user,'FORMATION',p_company,p_point,p_point,2,now(), p_counterparty)
				RETURNING invoicenumber INTO p_invoice;
	 
	 FOR p_invoiceprod IN SELECT * FROM json_array_elements((inf)->'products')
	 LOOP
			
			p_units			 		:= cast(trim(p_invoiceprod->>'amount') as double precision);
			p_attributes 		:= cast(coalesce(nullif(trim(p_invoiceprod->>'attributes'),''),'0') as bigint);
			p_brand			 		:= cast(coalesce(nullif(trim(p_invoiceprod->>'brand'),''),'0') as bigint);
			p_cnofea		 		:= nullif(trim(p_invoiceprod->>'cnofea'),'');
			p_code 		 	 		:= trim(p_invoiceprod->>'code');
			p_hot				 		:= cast(nullif(trim(p_invoiceprod->>'hotkey'),'') as integer);
			p_id				 		:= cast(nullif(trim(p_invoiceprod->>'id'),'') as bigint);
			p_name 		 	 		:= trim(p_invoiceprod->>'name');	
			p_newprice			:= cast(trim(p_invoiceprod->>'newprice') as double precision);
			p_purchaseprice := cast(trim(p_invoiceprod->>'purchaseprice') as double precision);
			p_taxid			 		:= cast(trim(p_invoiceprod->>'taxid') as smallint);
			p_unitsprid			:= 6;-- В килограммах (cast(trim(p_invoiceprod->>'unitsprid') as bigint);)
			p_ubdateprice		:= cast(trim(p_invoiceprod->>'updateprice') as boolean);
			p_category			:= cast(coalesce(nullif(trim(p_invoiceprod->>'category'),''),'-1') as bigint);
			p_deleted				:= false;-- Удаление вынесли отдельно   cast(nullif(trim(p_invoiceprod->>'deleted'),'') as boolean);
			
			-- Проверки на пустоту необходимых параметров
			IF p_code IS NULL THEN		
				RAISE SQLSTATE 'S0003';
			ELSIF p_units IS NULL THEN
				RAISE SQLSTATE 'S0004';
			ELSIF p_purchaseprice IS NULL THEN
				RAISE SQLSTATE 'S0005';
			ELSIF p_newprice IS NULL THEN
				RAISE SQLSTATE 'S0006';
			ELSIF p_taxid IS NULL THEN
				RAISE SQLSTATE 'S0007';
			ELSIF p_category <> -1 THEN
				RAISE SQLSTATE 'S0008';
			ELSIF p_hot IS NULL THEN
				RAISE SQLSTATE 'S0009';
			ELSIF p_deleted IS NULL THEN
				RAISE SQLSTATE 'S0010';
			END IF;
						
			-- Вызов функции, записывающей позиции в инвойс
      SELECT invoice_addprod(json_build_object('scale',p_scale,'type','2','user',p_user,'invoice',p_invoice,'stockcurrentfrom',json_agg(json_build_object('id',p_id,
								'sku',null,'code',p_code,'name',p_name,'brand',p_brand,'taxid',p_taxid,'amount',p_units,'cnofea',p_cnofea,'category',p_category,'newprice',p_newprice,
										'attributes',p_attributes,'updateprice',p_ubdateprice,'purchaseprice',p_purchaseprice,'isdelete',p_deleted,'hotkey',p_hot,'unitsprid',p_unitsprid)))) INTO p_result;
			IF p_result->>'code' LIKE '%error%' THEN
		    p_func_code := p_result->>'code';
			  p_func_text := p_result->>'text';
				RAISE SQLSTATE 'S0011';
		  END IF;
	 
	 END LOOP;
	 
	 -- Вызов функции, добавляющей товары в систему
	 SELECT goods_add(json_build_object('invoice',p_invoice,'user',p_user)) INTO p_result;
	 IF p_result->>'code' LIKE '%error%' THEN
	   p_func_code := p_result->>'code';
		 p_func_text := p_result->>'text';
		 RAISE SQLSTATE 'S0011';
	 END IF;
	 
	 result := json_build_object('code','success','text','');
   return next;
	
	 EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Идентификаторы компании или пользователя не были переданы!');
		 return next; 	 
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','В качестве точки должен быть передан идентификатор склада!');
		 return next;		 
	 WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code','error','text','Не указан штрих-код товара! ('||p_name||')');
		 return next;	 
	 WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','Не указано количество товара! ('||p_name||')');
		 return next;	 
	 WHEN SQLSTATE 'S0005' THEN
		 result := json_build_object('code','error','text','Не указана закупочная цена товара! ('||p_name||')');
		 return next;	 
	 WHEN SQLSTATE 'S0006' THEN
		 result := json_build_object('code','error','text','Не указана цена продажи товара! ('||p_name||')');
		 return next;	 
	 WHEN SQLSTATE 'S0007' THEN
		 result := json_build_object('code','error','text','Не указан признак НДС товара! ('||p_name||')');
		 return next;
	 WHEN SQLSTATE 'S0008' THEN
		 result := json_build_object('code','error','text','Товар должен принадлежать категории "Весовые товары"! ('||p_name||')'); 
		 return next;	 
	 WHEN SQLSTATE 'S0009' THEN
		 result := json_build_object('code','error','text','Не указана горячая клавиша для товара! ('||p_name||')');
		 return next;		
	 WHEN SQLSTATE 'S0010' THEN
		 result := json_build_object('code','error','text','Не указан параметр удаления! ('||p_name||')');
		 return next;	 
	 WHEN SQLSTATE 'S0011' THEN
		 result := json_build_object('code',p_func_code,'text',p_func_text);
		 return next;	 	  
	 WHEN SQLSTATE 'S0012' THEN
		 result := json_build_object('code','error','text','Некорректный идентификатор весов!');
		 return next;		 	 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   return next;
		 
END;$$;


ALTER FUNCTION public.weightgoods_add(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 757 (class 1255 OID 16593)
-- Name: weightgoods_del(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.weightgoods_del(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company           					bigint;
 p_id													bigint;
 p_attributes									bigint;
 p_error			       					varchar;
 p_check						 					varchar;
 p_result				 							json;
 p_func_code					 				varchar;
 p_func_text					 				varchar;
 p_user												bigint;
 p_invoice										bigint;
 r														record;
 i														record;
 
BEGIN

/*
{   
		user: 1,
		company: 15,
    product: 1
}
*/
	
		p_company 		 := cast(trim(inf->>'company') as bigint);
		p_user				 := cast(trim(inf->>'user') as bigint);
		p_id 				 	 := cast(trim(inf->>'product') as bigint);
		p_attributes 	 := 0;
			
		-- Проверки на пустоту необходимых параметров
		IF p_company IS NULL OR p_user IS NULL THEN
			RAISE SQLSTATE 'S0001';
		ELSIF p_id IS NULL THEN		
			RAISE SQLSTATE 'S0002';
		END IF;
		
		-- Проставление признака удаления
		UPDATE products
			SET deleted = true
				WHERE id = p_id
					AND company = p_company;
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0004';
		END IF;
			
		FOR r IN (
			SELECT s.id as stockid, s.units, s.point as stock, s.product, s.attributes
				FROM stockcurrent s
					INNER JOIN points p on (p.id = s.point and p.company = s.company and p.status = 'ACTIVE')
						WHERE s.product = p_id
							AND s.attributes = p_attributes
							AND s.company = p_company
								ORDER BY stockid
		)
		LOOP
		
				/*-- Создание инвойса для списания товара				
				INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
					VALUES(p_user,'FORMATION',p_company,r.stock,r.stock,7,now()) 
						RETURNING invoicenumber INTO p_invoice;			
					
				-- Вызов функции, записывающей позиции в инвойс по списанию
				SELECT invoice_addprod(json_build_object('type','7','user',p_user,'invoice',p_invoice,'stockcurrentfrom',
									json_agg(json_build_object('id',r.stockid,'sku',null,'amount',r.units,'reason','В связи с удалением товара из системы','attributes',p_attributes)))) INTO p_result;
				IF p_result->>'code' LIKE '%error%' THEN
					p_func_code := p_result->>'code';
					p_func_text := p_result->>'text';
					RAISE SQLSTATE 'S0003';
				END IF;
	 
				-- Вызов функции, добавляющей товары в систему
				SELECT goods_writeoff(json_build_object('invoice',p_invoice,'user',p_user)) INTO p_result;
				IF p_result->>'code' LIKE '%error%' THEN
					p_func_code := p_result->>'code';
					p_func_text := p_result->>'text';
					RAISE SQLSTATE 'S0003';
				END IF;*/
				
				UPDATE stockcurrent
					SET units = 0
						WHERE id = r.stockid
							AND company = p_company;
				IF NOT FOUND THEN
					RAISE SQLSTATE 'S0004';
				END IF;
				
				FOR i IN (
					SELECT date, units, purchaseprice
						FROM stockcurrent_part
							WHERE company = p_company
								AND point = r.stock
									AND product = r.product
										AND attributes = r.attributes
											AND (units > 0 OR units < 0)
												ORDER BY date, purchaseprice
				)
				LOOP			
					UPDATE stockcurrent_part
							SET units = 0
								WHERE product = r.product
									AND attributes =  r.attributes
									AND point = r.stock
									AND company = p_company
									AND date = i.date
									AND purchaseprice = i.purchaseprice
									AND case when i.units > 0 then units > 0 else units < 0 end;							
					-- Оставляем записи в журнале перемещений товара
					INSERT INTO stockdiary(date,reason,point,product,units,price,attributes,invoice,company,purchaseprice,purchasedate)
						VALUES(now(),'-3',r.stock,r.product,i.units,0,r.attributes,null,p_company,i.purchaseprice,i.date);		
				END LOOP;
				
				--------------------------
				-- Создание инвойса для обновления количества на кассе (Чтобы кассе было понятно, что товар удалили)		
				INSERT INTO invoices(creator,status,company,stockfrom,stockto,type,invoicedate) 
					VALUES(0,'IN_PROCESS',p_company,r.stock-1,r.stock-1,8,now()) 
						RETURNING invoicenumber INTO p_invoice;
						
				-- Вызов функции, записывающей позиции в инвойс по обновлению количества
				INSERT INTO invoicelist (invoice,stock,attributes,units,newprice,purchaseprice,newprod,stockto,delusr,updateallprodprice,company,delete)
					VALUES(p_invoice,r.stockid,0,0,0,0,false,r.stockid,false,false, p_company,true);
					
				FOR i IN (
					SELECT id
						FROM cashboxes
							WHERE point = r.stock-1
								AND deleted = false
									AND isengaged = true
				)
				LOOP
				
					INSERT INTO systemmessage(point,invoice,type_message,cashbox)
						VALUES(r.stock-1,p_invoice,8,i.id);
				
				END LOOP;
				
				--------------------------
				
		END LOOP;
	 
		result := json_build_object('code','success','text','');
		return next;
	
	 EXCEPTION 
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Идентификаторы компании или пользователя не были переданы!');
		 return next; 	 
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Идентификатор товара не был передан!');
		 return next;		 
	 WHEN SQLSTATE 'S0003' THEN
		 result := json_build_object('code',p_func_code,'text',p_func_text);
		 return next; 
	 WHEN SQLSTATE 'S0004' THEN
		 result := json_build_object('code','error','text','При удалении товара возникли проблемы! Пожалуйста, попробуйте чуть позже.');
		 return next;	 
	 WHEN OTHERS THEN
	   RAISE NOTICE 'internal_error: %', SQLERRM;
	   GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	   return next;
		 
END;$$;


ALTER FUNCTION public.weightgoods_del(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 758 (class 1255 OID 16595)
-- Name: workorder_details_attributes(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.workorder_details_attributes(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$ 

DECLARE
  
  obj json;
  p_error varchar;
  p_check varchar;
  p_id BIGINT;
  json_object json;

BEGIN

-- inf := '{"workorder_id":1,"products":[{"id":1,"attrid":1},{"id":2,"attrid":2}]}';
  SELECT (inf)::json into json_object;
  
  p_id :=  cast(json_object ->> 'workorder_id' as bigint);
  
  IF p_id IS NULL THEN
    raise SQLSTATE'S0001';
  END IF;
  
  
  
  FOR obj IN ( SELECT * FROM json_array_elements ( json_object -> 'products' ) )
  LOOP
  
    UPDATE workorder_details 
      SET attributes = cast(obj ->> 'attrid' as bigint)
        WHERE product = cast(obj ->> 'id' as bigint ) and workorder_id = p_id;
        
  END LOOP;

res := json_build_object ( 'code', 'success', 'text', 'ok');
RETURN;

EXCEPTION 
  WHEN SQLSTATE'S0001' THEN
    res := json_build_object ( 'code', 'error', 'text', 'Не укаказан идентификатор заказ-наряда!' ) 
  RETURN;
  
  WHEN SQLSTATE'S0002' THEN
    res := json_build_object ( 'code', 'error', 'text', 'Не укаказан идентификатор изменяемого продукта!' ) 
  RETURN;

WHEN OTHERS THEN
  RAISE NOTICE'internal_error: %',
  SQLERRM;
GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT,
p_check = CONSTRAINT_NAME;
res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
RETURN;

END;
$$;


ALTER FUNCTION public.workorder_details_attributes(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 759 (class 1255 OID 16596)
-- Name: workorder_details_update(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.workorder_details_update(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$ 

DECLARE

  obj json;
  p_error varchar;
  p_check varchar;
  p_id BIGINT;
  json_object json;
  p_count bigint;
  p_units float8;
  p_product bigint;
  product_json json;

BEGIN
  
  -- { "workorder_id":16, "products":[{"id":3,"units":15},{"id":2,"units":15},{"id":1,"units":15}] }
  --SELECT (inf)::json into json_object;
  -- [{ "workorder_id": 244, "products": [ { "id": "41172", "units": "10"}]},{"workorder_id": 235, "products": [{"id": "41172","units": "5"}]}]
  --inf := {'sendData':'[{ "workorder_id": 244, "products": [ { "id": "41172", "units": "10"}]},{"workorder_id": 235, "products": [{"id": "41172","units": "5"}]}]'};
  
  json_object := inf->'sendData';
  FOR obj IN (SELECT * FROM json_array_elements(json_object))
  LOOP
    
    p_id := cast(obj->>'workorder_id' as bigint);
		
    
		IF p_id IS NULL THEN
      raise SQLSTATE'S0001';
    END IF;
  
    p_count := 0;
    
    FOR product_json IN ( SELECT * FROM json_array_elements ( obj -> 'products' ) )
    LOOP
    
      p_units = coalesce(cast(product_json ->> 'units' as float8));
      p_product = coalesce(cast(product_json ->> 'id' as bigint),0);
    
      IF p_units IS NULL THEN
        raise SQLSTATE'S0002';
      END IF;
    
      IF p_product IS NULL THEN
        raise SQLSTATE'S0003';
      END IF;
    
      UPDATE workorder_details 
        SET accepted_units = p_units
          WHERE workorder_id = p_id and product = p_product;
    
    END LOOP;
  END LOOP; -- Основной цикл
  

  res := json_build_object ( 'code', 'success', 'text', 'ok');
  RETURN;

  EXCEPTION 
    WHEN SQLSTATE'S0001' THEN
      res := json_build_object ( 'code', 'error', 'text', 'Не указан идентификатор заказ-наряда!' ) 
    RETURN;
  
    WHEN SQLSTATE'S0002' THEN
      res := json_build_object ( 'code', 'error', 'text', 'Не укаказано количество!' ) 
    RETURN;
    
    WHEN SQLSTATE'S0003' THEN
      res := json_build_object ( 'code', 'error', 'text', 'Не указан продукт!' ) 
    RETURN;

  WHEN OTHERS THEN
    RAISE NOTICE'internal_error: %',
    SQLERRM;
  GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT,
  p_check = CONSTRAINT_NAME;
  res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
  RETURN;

END;
$$;


ALTER FUNCTION public.workorder_details_update(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 760 (class 1255 OID 16597)
-- Name: workorder_insert(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.workorder_insert(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$
	DECLARE
		r record;
		p_product bigint;
		p_stock bigint;
		p_company bigint;
		p_workorder_id bigint;
		p_units float8;
		p_attribute bigint;
		p_point bigint;
		p_purchaseprice float8;
		p_price float8;
		p_error varchar;
		p_check varchar;
		p_wholesale_price float8;
		p_counterparty bigint;
		
	BEGIN
		p_product = coalesce(cast(inf->>'product' as bigint),0);
		p_stock = coalesce(cast(inf->>'point' as bigint),0); -- Склад точки (type = 1)
		p_company = coalesce(cast(inf->>'company' as bigint),0);
		
		p_workorder_id = coalesce(cast(inf->>'workorder_id' as bigint),0);
		p_units = coalesce(cast(inf->>'units' as float8),0);
		p_attribute = coalesce(cast(inf->>'attributes' as bigint),0);
		
		p_purchaseprice = coalesce(cast(inf->>'price' as float8),0);
		p_counterparty = coalesce(cast(inf->>'counterparty' as bigint),0);
		
		IF p_product = 0 THEN
			raise sqlstate 'S0001';
		END IF;
		
		IF p_stock = 0 THEN
			raise sqlstate 'S0002';
		END IF;
		
		IF p_company = 0 THEN
			raise sqlstate 'S0003';
		END IF;
		
		IF p_workorder_id = 0 THEN
			raise sqlstate 'S0004';
		END IF;
		
		IF p_units = 0 THEN
			raise sqlstate 'S0005';
		END IF;
		
		
		SELECT point INTO p_point FROM pointset WHERE stock = p_stock;
		--SELECT price INTO p_purchaseprice FROM prices WHERE product = p_product AND company = p_company AND point = p_point AND type = 0;
		SELECT price INTO p_price FROM prices WHERE product = p_product AND company = p_company AND type = 1; -- AND point = p_point 
		SELECT wholesale_price INTO p_wholesale_price FROM prices WHERE product = p_product AND company = p_company AND type = 1; -- AND point = p_point 
		
		IF p_product IN (SELECT product FROM workorder_details WHERE workorder_id = p_workorder_id)	THEN
			raise sqlstate 'S0006';
		END IF;
		
		
		INSERT INTO workorder_details
			(product, price, units, workorder_id, attributes,purchaseprice,wholesale_price, counterparty)
				VALUES
					(p_product, p_price, p_units, p_workorder_id, p_attribute, p_purchaseprice,p_wholesale_price, p_counterparty);
		
		res = json_build_object('code','success','text','ok','product',p_product)
		RETURN;
		
		EXCEPTION 
		
		WHEN SQLSTATE'S0001' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указан продукт!' );
			RETURN;
			
		WHEN SQLSTATE'S0002' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указана точка!' );
			RETURN;
	
		WHEN SQLSTATE'S0003' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указана компания!' );
			RETURN;
	
		WHEN SQLSTATE'S0004' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указан номер заказ-наряда' );
			RETURN;
	
		WHEN SQLSTATE'S0005' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указано количество!' );
			RETURN;
		
		WHEN SQLSTATE'S0006' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Товар, который вы пытаетесь добавить, уже существует в данном заказ-наряде!' );
			RETURN;
	
		WHEN OTHERS THEN
			RAISE NOTICE'internal_error: %',
			SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
		RETURN;
		
	END;
	$$;


ALTER FUNCTION public.workorder_insert(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 761 (class 1255 OID 16598)
-- Name: workorder_management(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.workorder_management(inf json, OUT res json) RETURNS json
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	r record;
	obj json;
	json_object json;
	p_company BIGINT;
	p_workorder_number varchar;
	p_workorder_id BIGINT;
	p_point BIGINT;
	p_user BIGINT;
	p_accepted_user BIGINT;
	p_accepted_date date;
	p_error VARCHAR;
-- 	p_provider bigint;
	p_deleted INT;
	p_status varchar;
	p_check_workorder bigint;
	p_check varchar;
	
BEGIN

/* 
{
 "company":18,"workorder_number":1,"point":189,
 "user":42,"product":1,"units":"1",
 "accepted_units","1","accepted_user":42, "deleted":true, "id":1
 }
 */
 
	SELECT (inf)::json into json_object;
	
	p_company := CAST ( json_object ->> 'company' AS BIGINT );
	p_point := CAST ( json_object ->> 'point' AS BIGINT );
	p_workorder_number := json_object ->> 'workorder_number';
	p_user := CAST ( json_object ->> 'user' AS BIGINT );
	-- 	p_provider := CAST ( json_object ->> 'counterparty' AS BIGINT );
	p_deleted := COALESCE(CAST (json_object ->> 'deleted' AS INT),0);
	p_workorder_id := COALESCE(CAST(json_object ->> 'workorder_id' AS INT),0);
	p_status := json_object ->> 'status';
	
	
	-- Если пришли не пустые данные 
	IF p_deleted <> 0 and p_workorder_id <> 0 THEN
		DELETE FROM workorder WHERE id = p_workorder_id;
		 
	ELSE
		IF p_status IS NULL THEN
				
				IF p_point IS NULL THEN
					raise SQLSTATE'S0001';
				END IF;
	
				IF p_company IS NULL THEN
					raise SQLSTATE'S0002';
				END IF;
	
				IF p_user IS NULL THEN
					raise SQLSTATE'S0003';
				END IF;
	
-- 				IF p_provider IS NULL THEN
-- 					raise SQLSTATE'S0004';
-- 				END IF;
				
				
				
				-- Номер заказ-наряда необязателен
				IF p_workorder_number IS NULL THEN
					SELECT nextval('workorder_seq') INTO p_workorder_number;
					-- Для предотвращения возможной ошибки с индексами
					 WHILE p_workorder_number IN (SELECT workorder_number FROM workorder) 
					 LOOP
						SELECT nextval('workorder_seq') INTO p_workorder_number;
					END LOOP;
				ELSE
					IF p_workorder_number IN (SELECT workorder_number FROM workorder) THEN
						raise SQLSTATE'S0005';
					END IF;
				END IF;
				
				-- Проверка на повторное создание заказ-наряда
				SELECT id 
					INTO p_check_workorder 
						FROM workorder 
							WHERE point = p_point 
								AND userid = p_user 
-- 									AND counterparty = p_provider 
										AND status = 'FORMATION';
							
				IF p_check_workorder IS NULL THEN
					INSERT INTO workorder 
						(point, company, workorder_number, userid
-- 						, counterparty
						)
							VALUES
								(p_point, p_company, p_workorder_number, p_user
-- 								, p_provider
								)
									RETURNING id INTO p_workorder_id;
									-- Берем id заказ-наряда для таблицы workorder_details
				ELSE
					raise SQLSTATE 'S0006';
				END IF;
		ELSE
			IF LOWER(p_status) = 'created' THEN
				UPDATE workorder
					SET status = UPPER(p_status)
						WHERE id = p_workorder_id;
			END IF;
						IF LOWER(p_status) = 'inprocess' THEN
				UPDATE workorder
					SET status = UPPER(p_status)
						WHERE id = p_workorder_id;
			END IF;
			
			IF LOWER(p_status) = 'accepted' THEN
				UPDATE workorder
					SET status = UPPER(p_status), accept_user = p_user, accept_date = current_timestamp
						WHERE id = p_workorder_id;
			END IF;
			
		END IF;

	END IF;
		
	
			
	res = json_build_object ( 'code', 'success', 'text', 'ok', 'workorder_id', p_workorder_id );
	RETURN;
	
	EXCEPTION 
		
		WHEN SQLSTATE'S0001' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указана точка!' );
			RETURN;
	
		WHEN SQLSTATE'S0002' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указана компания!' );
			RETURN;
	
		WHEN SQLSTATE'S0003' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Не указан пользователь!' );
			RETURN;
	
-- 		WHEN SQLSTATE'S0004' THEN
-- 			res := json_build_object ( 'code', 'exception', 'text', 'Не указан поставщик!' );
-- 			RETURN;
-- 		
		WHEN SQLSTATE'S0005' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Заказ-наряд с таким названием уже cуществует!' );
			RETURN;
		
		WHEN SQLSTATE'S0006' THEN
			res := json_build_object ( 'code', 'exception', 'text', 'Существует необработанный заказ-наряд. Продолжите его или удалите!' );
			RETURN;
	
		WHEN OTHERS THEN
			RAISE NOTICE'internal_error: %',
			SQLERRM;
		GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT, p_check = CONSTRAINT_NAME;
		res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
		RETURN;
	
END;
$$;


ALTER FUNCTION public.workorder_management(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 766 (class 1255 OID 16600)
-- Name: workorder_update_status(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.workorder_update_status(inf json, OUT res json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$ 

DECLARE

  obj json;
  p_error varchar;
  p_check varchar;
  p_id BIGINT;
  json_object json;
  p_count bigint;
  p_units float8;
  p_product bigint;
  product_json json;
  p_status text;
  
BEGIN
  
  -- { "workorders": [{"id": 307},{"id": 321}]}
  FOR obj IN (SELECT * FROM json_array_elements(inf->'workorders'))
  LOOP
    p_id = coalesce(cast(obj->>'id' as bigint),0);
    p_status = obj->>'status';
    
    IF p_id = 0 THEN
      raise sqlstate 'S0001';
    END IF;
    
    UPDATE workorder 
      SET status = 'APPROVED', approve_date = CURRENT_TIMESTAMP
        WHERE id = p_id;
    
  END LOOP; -- Основной цикл
  

  res := json_build_object ( 'code', 'success', 'text', 'ok');
  RETURN;

  EXCEPTION 
    WHEN SQLSTATE'S0001' THEN
      res := json_build_object ( 'code', 'error', 'text', 'Не указан идентификатор заказ-наряда!' ) 
    RETURN;
  

  WHEN OTHERS THEN
    RAISE NOTICE'internal_error: %',
    SQLERRM;
  GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT,
  p_check = CONSTRAINT_NAME;
  res := json_build_object ( 'code', 'internal_error', 'text', SQLSTATE || ':' || SQLERRM || ':' || p_error );
  RETURN;

END;
$$;


ALTER FUNCTION public.workorder_update_status(inf json, OUT res json) OWNER TO postgres;

--
-- TOC entry 767 (class 1255 OID 16601)
-- Name: writeoff_customers_debt(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.writeoff_customers_debt(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$DECLARE
 p_company      			 bigint;
 json_object    			 json;
 customers_object 		 json;
 p_code				  			 varchar;
 p_text				  			 varchar;
 p_balance						 float8 := 0;
 p_debt								 float8 := 0;
 p_id									 bigint;
 p_user								 bigint;
 p_sys								 varchar(3);
BEGIN

	-- {"company" : 1, "writeoff_debt_customers" : {"id" : "1", "debt" : 500, "user":5, "system": "ERP"}}

	SELECT (inf)::json into json_object;

		p_company := cast(trim(json_object->>'company') as bigint);

  SELECT (json_object)->'writeoff_debt_customers' into customers_object;
	
		p_id   := cast(customers_object->>'id' as bigint);
		p_debt := cast(customers_object->>'debt' as double precision);
		p_user := cast(customers_object->>'user' as bigint);
		p_sys  := coalesce(upper(customers_object->>'system'),'POS');
		
		IF p_sys NOT IN ('POS','ERP') THEN
			RAISE SQLSTATE 'S0002';
		END IF;

		UPDATE fiz_customers
			SET debt = debt - p_debt
				WHERE id = p_id
					AND company = p_company
						RETURNING debt INTO p_balance;
		IF NOT FOUND THEN
			result := json_build_object('code','error','text','Идентификатор клиента не найден!, company = '||p_company);
			return next;
			return;
		ELSIF p_balance < 0 THEN
			RAISE SQLSTATE 'S0001';
		END IF;
		
		-- Запись в дневник
		INSERT INTO debtorsdiary(customer,type,debt,date,company,"user","system")
		  VALUES(p_id,-1,p_debt*-1,now(),p_company,p_user,p_sys);
		
    result := json_build_object('code','success','text','');
    return next;

EXCEPTION
	 WHEN SQLSTATE 'S0001' THEN
		 result := json_build_object('code','error','text','Сумма списания превосходит сумму долга!');
		 return next;
	 WHEN SQLSTATE 'S0002' THEN
		 result := json_build_object('code','error','text','Признак системы отправления не опознан!');
		 return next;	 
	 WHEN OTHERS THEN
		 RAISE NOTICE 'internal_error: %', SQLERRM;
		 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM);

		 return next;

END;$$;


ALTER FUNCTION public.writeoff_customers_debt(inf json, OUT result json) OWNER TO postgres;

--
-- TOC entry 768 (class 1255 OID 16602)
-- Name: writeoff_giftbalance(json); Type: FUNCTION; Schema: public; Owner: postgres
--

CREATE FUNCTION public.writeoff_giftbalance(inf json, OUT result json) RETURNS SETOF json
    LANGUAGE plpgsql
    AS $$
DECLARE
	 p_company         		bigint;
	 p_user						 		bigint;
	 p_error		      	 	varchar;
	 json_object					json;
	 json_writeoff				json;
	 p_id							  	bigint[];
	 p_group							bigint;
BEGIN

	-- {"user": "42", "company": "18", "writeoff": {"id": [123,345]}}

  SELECT (inf)::json into json_object;

	  p_company		:= cast(json_object->>'company' as bigint);
		p_user 			:= cast(json_object->>'user' as bigint);
		
		-- Проверка на группы сертификатов
		SELECT coalesce(certificate_group,0) INTO p_group
			FROM companies
				WHERE id = p_company;	
		
	SELECT (json_object)->'writeoff' into json_writeoff;
		
		p_id 				:= ARRAY(SELECT json_array_elements_text(json_writeoff->'id'));
		
    UPDATE giftcertificates_writeoff_balances
			SET write_off = true
				WHERE case when p_group = 0 then company = p_company else company IN (SELECT id FROM companies WHERE certificate_group = p_group) end
					AND id = ANY(p_id);
		IF NOT FOUND THEN
			RAISE SQLSTATE 'S0001';
		END IF;
									
  result := json_build_object('code','success','text','');
  return next;

EXCEPTION 
WHEN SQLSTATE 'S0001' THEN
		result := json_build_object('code','error','text','Остаток с сертификата не был определен. Пожалуйста, обратитесь в служюу поддержки!');
		return next;
WHEN OTHERS THEN
	 RAISE NOTICE 'internal_error: %', SQLERRM;
	 GET STACKED DIAGNOSTICS p_error = PG_EXCEPTION_CONTEXT;
	 result := json_build_object('code','internal_error','text',SQLSTATE||':'||SQLERRM||':'||p_error);
	 return next;
	 
END;





$$;


ALTER FUNCTION public.writeoff_giftbalance(inf json, OUT result json) OWNER TO postgres;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- TOC entry 473 (class 1259 OID 49283)
-- Name: jobcheck; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.jobcheck (
    jobname character varying(255) NOT NULL,
    last_update_start timestamp(6) without time zone DEFAULT now(),
    last_update_end timestamp(6) without time zone DEFAULT now()
);


ALTER TABLE analytics.jobcheck OWNER TO postgres;

--
-- TOC entry 474 (class 1259 OID 49288)
-- Name: sellinginfo_day; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.sellinginfo_day (
    company bigint NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    gross_profit double precision NOT NULL,
    cost double precision NOT NULL,
    proceeds double precision NOT NULL,
    units numeric(1000,3) NOT NULL,
    date date NOT NULL
);


ALTER TABLE analytics.sellinginfo_day OWNER TO postgres;

--
-- TOC entry 6093 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.company; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.company IS 'ID компании';


--
-- TOC entry 6094 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.point; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.point IS 'ID склада';


--
-- TOC entry 6095 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.product; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.product IS 'ID продукта';


--
-- TOC entry 6096 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.gross_profit; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.gross_profit IS 'Валовая прибыль';


--
-- TOC entry 6097 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.cost; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.cost IS 'Себестоимость';


--
-- TOC entry 6098 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.proceeds; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.proceeds IS 'Выручка';


--
-- TOC entry 6099 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.units; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.units IS 'Количество';


--
-- TOC entry 6100 (class 0 OID 0)
-- Dependencies: 474
-- Name: COLUMN sellinginfo_day.date; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_day.date IS 'За какой день';


--
-- TOC entry 475 (class 1259 OID 49291)
-- Name: sellinginfo_month; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.sellinginfo_month (
    company bigint NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    gross_profit double precision NOT NULL,
    cost double precision NOT NULL,
    proceeds double precision NOT NULL,
    units numeric(1000,3) NOT NULL,
    date date NOT NULL
);


ALTER TABLE analytics.sellinginfo_month OWNER TO postgres;

--
-- TOC entry 6101 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.company; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.company IS 'ID компании';


--
-- TOC entry 6102 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.point; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.point IS 'ID склада';


--
-- TOC entry 6103 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.product; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.product IS 'ID продукта';


--
-- TOC entry 6104 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.gross_profit; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.gross_profit IS 'Валовая прибыль';


--
-- TOC entry 6105 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.cost; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.cost IS 'Себестоимость';


--
-- TOC entry 6106 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.proceeds; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.proceeds IS 'Выручка';


--
-- TOC entry 6107 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.units; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.units IS 'Количество';


--
-- TOC entry 6108 (class 0 OID 0)
-- Dependencies: 475
-- Name: COLUMN sellinginfo_month.date; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_month.date IS 'За какой месяц(дата начала месяца)';


--
-- TOC entry 476 (class 1259 OID 49294)
-- Name: sellinginfo_week; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.sellinginfo_week (
    company bigint NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    gross_profit double precision NOT NULL,
    cost double precision NOT NULL,
    proceeds double precision NOT NULL,
    units numeric(1000,3) NOT NULL,
    date date NOT NULL
);


ALTER TABLE analytics.sellinginfo_week OWNER TO postgres;

--
-- TOC entry 6109 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.company; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.company IS 'ID компании';


--
-- TOC entry 6110 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.point; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.point IS 'ID склада';


--
-- TOC entry 6111 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.product; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.product IS 'ID продукта';


--
-- TOC entry 6112 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.gross_profit; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.gross_profit IS 'Валовая прибыль';


--
-- TOC entry 6113 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.cost; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.cost IS 'Себестоимость';


--
-- TOC entry 6114 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.proceeds; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.proceeds IS 'Выручка';


--
-- TOC entry 6115 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.units; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.units IS 'Количество';


--
-- TOC entry 6116 (class 0 OID 0)
-- Dependencies: 476
-- Name: COLUMN sellinginfo_week.date; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.sellinginfo_week.date IS 'За какую неделю(дата начала недели)';


--
-- TOC entry 477 (class 1259 OID 49297)
-- Name: stockcurrent_part_snapshots; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (company);


ALTER TABLE analytics.stockcurrent_part_snapshots OWNER TO postgres;

--
-- TOC entry 6117 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.company; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.company IS 'ID компании';


--
-- TOC entry 6118 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.point; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.point IS 'ID склада';


--
-- TOC entry 6119 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.product; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.product IS 'ID продукта';


--
-- TOC entry 6120 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.attributes; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.attributes IS 'ID листа аттрибутов';


--
-- TOC entry 6121 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.units; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.units IS 'Количество';


--
-- TOC entry 6122 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.date; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.date IS 'Дата закупки (парт)';


--
-- TOC entry 6123 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.purchaseprice; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.purchaseprice IS 'Сумма закупки за ед (парт)';


--
-- TOC entry 6124 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.snapdate; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.snapdate IS 'Дата снимка';


--
-- TOC entry 6125 (class 0 OID 0)
-- Dependencies: 477
-- Name: COLUMN stockcurrent_part_snapshots.price; Type: COMMENT; Schema: analytics; Owner: postgres
--

COMMENT ON COLUMN analytics.stockcurrent_part_snapshots.price IS 'Цена продажи на конец дня';


--
-- TOC entry 478 (class 1259 OID 49302)
-- Name: stockcurrent_part_snapshots_0_100; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_0_100 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_100 FOR VALUES FROM ('0') TO ('101');


ALTER TABLE analytics.stockcurrent_part_snapshots_0_100 OWNER TO postgres;

--
-- TOC entry 479 (class 1259 OID 49307)
-- Name: stockcurrent_part_snapshots_0_100_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_0_100_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_0_100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_100_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_0_100_2020 OWNER TO postgres;

--
-- TOC entry 480 (class 1259 OID 49312)
-- Name: stockcurrent_part_snapshots_0_100_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_0_100_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_0_100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_100_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_0_100_2021 OWNER TO postgres;

--
-- TOC entry 481 (class 1259 OID 49317)
-- Name: stockcurrent_part_snapshots_0_100_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_0_100_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_0_100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_100_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_0_100_2022 OWNER TO postgres;

--
-- TOC entry 482 (class 1259 OID 49322)
-- Name: stockcurrent_part_snapshots_0_100_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_0_100_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_0_100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_100_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_0_100_2023 OWNER TO postgres;

--
-- TOC entry 483 (class 1259 OID 49327)
-- Name: stockcurrent_part_snapshots_0_100_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_0_100_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_0_100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_100_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_0_100_2024 OWNER TO postgres;

--
-- TOC entry 484 (class 1259 OID 49332)
-- Name: stockcurrent_part_snapshots_1001_1100; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1001_1100 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_1001_1100 FOR VALUES FROM ('1001') TO ('1101');


ALTER TABLE analytics.stockcurrent_part_snapshots_1001_1100 OWNER TO postgres;

--
-- TOC entry 485 (class 1259 OID 49337)
-- Name: stockcurrent_part_snapshots_1001_1100_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1001_1100_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1001_1100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1001_1100_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1001_1100_2020 OWNER TO postgres;

--
-- TOC entry 486 (class 1259 OID 49342)
-- Name: stockcurrent_part_snapshots_1001_1100_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1001_1100_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1001_1100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1001_1100_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1001_1100_2021 OWNER TO postgres;

--
-- TOC entry 487 (class 1259 OID 49347)
-- Name: stockcurrent_part_snapshots_1001_1100_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1001_1100_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1001_1100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1001_1100_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1001_1100_2022 OWNER TO postgres;

--
-- TOC entry 488 (class 1259 OID 49352)
-- Name: stockcurrent_part_snapshots_1001_1100_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1001_1100_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1001_1100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1001_1100_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1001_1100_2023 OWNER TO postgres;

--
-- TOC entry 489 (class 1259 OID 49357)
-- Name: stockcurrent_part_snapshots_1001_1100_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1001_1100_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1001_1100 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1001_1100_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1001_1100_2024 OWNER TO postgres;

--
-- TOC entry 490 (class 1259 OID 49362)
-- Name: stockcurrent_part_snapshots_101_200; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_101_200 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_101_200 FOR VALUES FROM ('101') TO ('201');


ALTER TABLE analytics.stockcurrent_part_snapshots_101_200 OWNER TO postgres;

--
-- TOC entry 491 (class 1259 OID 49367)
-- Name: stockcurrent_part_snapshots_101_200_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_101_200_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_101_200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_101_200_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_101_200_2020 OWNER TO postgres;

--
-- TOC entry 492 (class 1259 OID 49372)
-- Name: stockcurrent_part_snapshots_101_200_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_101_200_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_101_200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_101_200_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_101_200_2021 OWNER TO postgres;

--
-- TOC entry 493 (class 1259 OID 49377)
-- Name: stockcurrent_part_snapshots_101_200_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_101_200_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_101_200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_101_200_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_101_200_2022 OWNER TO postgres;

--
-- TOC entry 494 (class 1259 OID 49382)
-- Name: stockcurrent_part_snapshots_101_200_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_101_200_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_101_200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_101_200_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_101_200_2023 OWNER TO postgres;

--
-- TOC entry 495 (class 1259 OID 49387)
-- Name: stockcurrent_part_snapshots_101_200_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_101_200_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_101_200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_101_200_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_101_200_2024 OWNER TO postgres;

--
-- TOC entry 496 (class 1259 OID 49392)
-- Name: stockcurrent_part_snapshots_1101_1200; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1101_1200 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_1101_1200 FOR VALUES FROM ('1101') TO ('1201');


ALTER TABLE analytics.stockcurrent_part_snapshots_1101_1200 OWNER TO postgres;

--
-- TOC entry 497 (class 1259 OID 49397)
-- Name: stockcurrent_part_snapshots_1101_1200_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1101_1200_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1101_1200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1101_1200_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1101_1200_2020 OWNER TO postgres;

--
-- TOC entry 498 (class 1259 OID 49402)
-- Name: stockcurrent_part_snapshots_1101_1200_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1101_1200_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1101_1200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1101_1200_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1101_1200_2021 OWNER TO postgres;

--
-- TOC entry 499 (class 1259 OID 49407)
-- Name: stockcurrent_part_snapshots_1101_1200_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1101_1200_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1101_1200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1101_1200_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1101_1200_2022 OWNER TO postgres;

--
-- TOC entry 500 (class 1259 OID 49412)
-- Name: stockcurrent_part_snapshots_1101_1200_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1101_1200_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1101_1200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1101_1200_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1101_1200_2023 OWNER TO postgres;

--
-- TOC entry 501 (class 1259 OID 49417)
-- Name: stockcurrent_part_snapshots_1101_1200_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1101_1200_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1101_1200 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1101_1200_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1101_1200_2024 OWNER TO postgres;

--
-- TOC entry 502 (class 1259 OID 49422)
-- Name: stockcurrent_part_snapshots_1201_1300; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1201_1300 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_1201_1300 FOR VALUES FROM ('1201') TO ('1301');


ALTER TABLE analytics.stockcurrent_part_snapshots_1201_1300 OWNER TO postgres;

--
-- TOC entry 503 (class 1259 OID 49427)
-- Name: stockcurrent_part_snapshots_1201_1300_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1201_1300_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1201_1300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1201_1300_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1201_1300_2020 OWNER TO postgres;

--
-- TOC entry 504 (class 1259 OID 49432)
-- Name: stockcurrent_part_snapshots_1201_1300_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1201_1300_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1201_1300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1201_1300_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1201_1300_2021 OWNER TO postgres;

--
-- TOC entry 505 (class 1259 OID 49437)
-- Name: stockcurrent_part_snapshots_1201_1300_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1201_1300_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1201_1300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1201_1300_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1201_1300_2022 OWNER TO postgres;

--
-- TOC entry 506 (class 1259 OID 49442)
-- Name: stockcurrent_part_snapshots_1201_1300_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1201_1300_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1201_1300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1201_1300_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1201_1300_2023 OWNER TO postgres;

--
-- TOC entry 507 (class 1259 OID 49447)
-- Name: stockcurrent_part_snapshots_1201_1300_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1201_1300_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1201_1300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1201_1300_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1201_1300_2024 OWNER TO postgres;

--
-- TOC entry 508 (class 1259 OID 49452)
-- Name: stockcurrent_part_snapshots_1301_1400; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1301_1400 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_1301_1400 FOR VALUES FROM ('1301') TO ('1401');


ALTER TABLE analytics.stockcurrent_part_snapshots_1301_1400 OWNER TO postgres;

--
-- TOC entry 509 (class 1259 OID 49457)
-- Name: stockcurrent_part_snapshots_1301_1400_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1301_1400_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1301_1400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1301_1400_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1301_1400_2020 OWNER TO postgres;

--
-- TOC entry 510 (class 1259 OID 49462)
-- Name: stockcurrent_part_snapshots_1301_1400_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1301_1400_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1301_1400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1301_1400_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1301_1400_2021 OWNER TO postgres;

--
-- TOC entry 511 (class 1259 OID 49467)
-- Name: stockcurrent_part_snapshots_1301_1400_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1301_1400_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1301_1400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1301_1400_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1301_1400_2022 OWNER TO postgres;

--
-- TOC entry 512 (class 1259 OID 49472)
-- Name: stockcurrent_part_snapshots_1301_1400_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1301_1400_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1301_1400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1301_1400_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1301_1400_2023 OWNER TO postgres;

--
-- TOC entry 513 (class 1259 OID 49477)
-- Name: stockcurrent_part_snapshots_1301_1400_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1301_1400_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1301_1400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1301_1400_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1301_1400_2024 OWNER TO postgres;

--
-- TOC entry 514 (class 1259 OID 49482)
-- Name: stockcurrent_part_snapshots_1401_1500; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1401_1500 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_1401_1500 FOR VALUES FROM ('1401') TO ('1501');


ALTER TABLE analytics.stockcurrent_part_snapshots_1401_1500 OWNER TO postgres;

--
-- TOC entry 515 (class 1259 OID 49487)
-- Name: stockcurrent_part_snapshots_1401_1500_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1401_1500_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1401_1500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1401_1500_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1401_1500_2020 OWNER TO postgres;

--
-- TOC entry 516 (class 1259 OID 49492)
-- Name: stockcurrent_part_snapshots_1401_1500_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1401_1500_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1401_1500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1401_1500_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1401_1500_2021 OWNER TO postgres;

--
-- TOC entry 517 (class 1259 OID 49497)
-- Name: stockcurrent_part_snapshots_1401_1500_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1401_1500_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1401_1500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1401_1500_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1401_1500_2022 OWNER TO postgres;

--
-- TOC entry 518 (class 1259 OID 49502)
-- Name: stockcurrent_part_snapshots_1401_1500_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1401_1500_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1401_1500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1401_1500_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1401_1500_2023 OWNER TO postgres;

--
-- TOC entry 519 (class 1259 OID 49507)
-- Name: stockcurrent_part_snapshots_1401_1500_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_1401_1500_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_1401_1500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_1401_1500_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_1401_1500_2024 OWNER TO postgres;

--
-- TOC entry 520 (class 1259 OID 49512)
-- Name: stockcurrent_part_snapshots_201_300; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_201_300 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_201_300 FOR VALUES FROM ('201') TO ('301');


ALTER TABLE analytics.stockcurrent_part_snapshots_201_300 OWNER TO postgres;

--
-- TOC entry 521 (class 1259 OID 49517)
-- Name: stockcurrent_part_snapshots_201_300_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_201_300_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_201_300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_201_300_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_201_300_2020 OWNER TO postgres;

--
-- TOC entry 522 (class 1259 OID 49522)
-- Name: stockcurrent_part_snapshots_201_300_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_201_300_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_201_300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_201_300_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_201_300_2021 OWNER TO postgres;

--
-- TOC entry 523 (class 1259 OID 49527)
-- Name: stockcurrent_part_snapshots_201_300_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_201_300_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_201_300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_201_300_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_201_300_2022 OWNER TO postgres;

--
-- TOC entry 524 (class 1259 OID 49532)
-- Name: stockcurrent_part_snapshots_201_300_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_201_300_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_201_300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_201_300_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_201_300_2023 OWNER TO postgres;

--
-- TOC entry 525 (class 1259 OID 49537)
-- Name: stockcurrent_part_snapshots_201_300_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_201_300_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_201_300 ATTACH PARTITION analytics.stockcurrent_part_snapshots_201_300_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_201_300_2024 OWNER TO postgres;

--
-- TOC entry 526 (class 1259 OID 49542)
-- Name: stockcurrent_part_snapshots_301_400; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_301_400 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_301_400 FOR VALUES FROM ('301') TO ('401');


ALTER TABLE analytics.stockcurrent_part_snapshots_301_400 OWNER TO postgres;

--
-- TOC entry 527 (class 1259 OID 49547)
-- Name: stockcurrent_part_snapshots_301_400_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_301_400_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_301_400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_301_400_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_301_400_2020 OWNER TO postgres;

--
-- TOC entry 528 (class 1259 OID 49552)
-- Name: stockcurrent_part_snapshots_301_400_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_301_400_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_301_400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_301_400_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_301_400_2021 OWNER TO postgres;

--
-- TOC entry 529 (class 1259 OID 49557)
-- Name: stockcurrent_part_snapshots_301_400_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_301_400_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_301_400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_301_400_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_301_400_2022 OWNER TO postgres;

--
-- TOC entry 530 (class 1259 OID 49562)
-- Name: stockcurrent_part_snapshots_301_400_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_301_400_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_301_400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_301_400_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_301_400_2023 OWNER TO postgres;

--
-- TOC entry 531 (class 1259 OID 49567)
-- Name: stockcurrent_part_snapshots_301_400_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_301_400_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_301_400 ATTACH PARTITION analytics.stockcurrent_part_snapshots_301_400_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_301_400_2024 OWNER TO postgres;

--
-- TOC entry 532 (class 1259 OID 49572)
-- Name: stockcurrent_part_snapshots_401_500; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_401_500 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_401_500 FOR VALUES FROM ('401') TO ('501');


ALTER TABLE analytics.stockcurrent_part_snapshots_401_500 OWNER TO postgres;

--
-- TOC entry 533 (class 1259 OID 49577)
-- Name: stockcurrent_part_snapshots_401_500_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_401_500_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_401_500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_401_500_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_401_500_2020 OWNER TO postgres;

--
-- TOC entry 534 (class 1259 OID 49582)
-- Name: stockcurrent_part_snapshots_401_500_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_401_500_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_401_500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_401_500_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_401_500_2021 OWNER TO postgres;

--
-- TOC entry 535 (class 1259 OID 49587)
-- Name: stockcurrent_part_snapshots_401_500_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_401_500_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_401_500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_401_500_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_401_500_2022 OWNER TO postgres;

--
-- TOC entry 536 (class 1259 OID 49592)
-- Name: stockcurrent_part_snapshots_401_500_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_401_500_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_401_500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_401_500_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_401_500_2023 OWNER TO postgres;

--
-- TOC entry 537 (class 1259 OID 49597)
-- Name: stockcurrent_part_snapshots_401_500_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_401_500_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_401_500 ATTACH PARTITION analytics.stockcurrent_part_snapshots_401_500_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_401_500_2024 OWNER TO postgres;

--
-- TOC entry 538 (class 1259 OID 49602)
-- Name: stockcurrent_part_snapshots_501_600; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_501_600 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_501_600 FOR VALUES FROM ('501') TO ('601');


ALTER TABLE analytics.stockcurrent_part_snapshots_501_600 OWNER TO postgres;

--
-- TOC entry 539 (class 1259 OID 49607)
-- Name: stockcurrent_part_snapshots_501_600_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_501_600_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_501_600 ATTACH PARTITION analytics.stockcurrent_part_snapshots_501_600_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_501_600_2020 OWNER TO postgres;

--
-- TOC entry 540 (class 1259 OID 49612)
-- Name: stockcurrent_part_snapshots_501_600_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_501_600_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_501_600 ATTACH PARTITION analytics.stockcurrent_part_snapshots_501_600_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_501_600_2021 OWNER TO postgres;

--
-- TOC entry 541 (class 1259 OID 49617)
-- Name: stockcurrent_part_snapshots_501_600_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_501_600_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_501_600 ATTACH PARTITION analytics.stockcurrent_part_snapshots_501_600_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_501_600_2022 OWNER TO postgres;

--
-- TOC entry 542 (class 1259 OID 49622)
-- Name: stockcurrent_part_snapshots_501_600_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_501_600_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_501_600 ATTACH PARTITION analytics.stockcurrent_part_snapshots_501_600_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_501_600_2023 OWNER TO postgres;

--
-- TOC entry 543 (class 1259 OID 49627)
-- Name: stockcurrent_part_snapshots_501_600_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_501_600_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_501_600 ATTACH PARTITION analytics.stockcurrent_part_snapshots_501_600_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_501_600_2024 OWNER TO postgres;

--
-- TOC entry 544 (class 1259 OID 49632)
-- Name: stockcurrent_part_snapshots_601_700; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_601_700 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_601_700 FOR VALUES FROM ('601') TO ('701');


ALTER TABLE analytics.stockcurrent_part_snapshots_601_700 OWNER TO postgres;

--
-- TOC entry 545 (class 1259 OID 49637)
-- Name: stockcurrent_part_snapshots_601_700_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_601_700_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_601_700 ATTACH PARTITION analytics.stockcurrent_part_snapshots_601_700_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_601_700_2020 OWNER TO postgres;

--
-- TOC entry 546 (class 1259 OID 49642)
-- Name: stockcurrent_part_snapshots_601_700_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_601_700_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_601_700 ATTACH PARTITION analytics.stockcurrent_part_snapshots_601_700_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_601_700_2021 OWNER TO postgres;

--
-- TOC entry 547 (class 1259 OID 49647)
-- Name: stockcurrent_part_snapshots_601_700_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_601_700_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_601_700 ATTACH PARTITION analytics.stockcurrent_part_snapshots_601_700_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_601_700_2022 OWNER TO postgres;

--
-- TOC entry 548 (class 1259 OID 49652)
-- Name: stockcurrent_part_snapshots_601_700_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_601_700_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_601_700 ATTACH PARTITION analytics.stockcurrent_part_snapshots_601_700_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_601_700_2023 OWNER TO postgres;

--
-- TOC entry 549 (class 1259 OID 49657)
-- Name: stockcurrent_part_snapshots_601_700_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_601_700_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_601_700 ATTACH PARTITION analytics.stockcurrent_part_snapshots_601_700_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_601_700_2024 OWNER TO postgres;

--
-- TOC entry 550 (class 1259 OID 49662)
-- Name: stockcurrent_part_snapshots_701_800; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_701_800 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_701_800 FOR VALUES FROM ('701') TO ('801');


ALTER TABLE analytics.stockcurrent_part_snapshots_701_800 OWNER TO postgres;

--
-- TOC entry 551 (class 1259 OID 49667)
-- Name: stockcurrent_part_snapshots_701_800_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_701_800_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_701_800 ATTACH PARTITION analytics.stockcurrent_part_snapshots_701_800_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_701_800_2020 OWNER TO postgres;

--
-- TOC entry 552 (class 1259 OID 49672)
-- Name: stockcurrent_part_snapshots_701_800_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_701_800_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_701_800 ATTACH PARTITION analytics.stockcurrent_part_snapshots_701_800_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_701_800_2021 OWNER TO postgres;

--
-- TOC entry 553 (class 1259 OID 49677)
-- Name: stockcurrent_part_snapshots_701_800_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_701_800_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_701_800 ATTACH PARTITION analytics.stockcurrent_part_snapshots_701_800_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_701_800_2022 OWNER TO postgres;

--
-- TOC entry 554 (class 1259 OID 49682)
-- Name: stockcurrent_part_snapshots_701_800_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_701_800_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_701_800 ATTACH PARTITION analytics.stockcurrent_part_snapshots_701_800_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_701_800_2023 OWNER TO postgres;

--
-- TOC entry 555 (class 1259 OID 49687)
-- Name: stockcurrent_part_snapshots_701_800_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_701_800_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_701_800 ATTACH PARTITION analytics.stockcurrent_part_snapshots_701_800_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_701_800_2024 OWNER TO postgres;

--
-- TOC entry 556 (class 1259 OID 49692)
-- Name: stockcurrent_part_snapshots_801_900; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_801_900 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_801_900 FOR VALUES FROM ('801') TO ('901');


ALTER TABLE analytics.stockcurrent_part_snapshots_801_900 OWNER TO postgres;

--
-- TOC entry 557 (class 1259 OID 49697)
-- Name: stockcurrent_part_snapshots_801_900_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_801_900_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_801_900 ATTACH PARTITION analytics.stockcurrent_part_snapshots_801_900_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_801_900_2020 OWNER TO postgres;

--
-- TOC entry 558 (class 1259 OID 49702)
-- Name: stockcurrent_part_snapshots_801_900_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_801_900_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_801_900 ATTACH PARTITION analytics.stockcurrent_part_snapshots_801_900_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_801_900_2021 OWNER TO postgres;

--
-- TOC entry 559 (class 1259 OID 49707)
-- Name: stockcurrent_part_snapshots_801_900_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_801_900_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_801_900 ATTACH PARTITION analytics.stockcurrent_part_snapshots_801_900_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_801_900_2022 OWNER TO postgres;

--
-- TOC entry 560 (class 1259 OID 49712)
-- Name: stockcurrent_part_snapshots_801_900_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_801_900_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_801_900 ATTACH PARTITION analytics.stockcurrent_part_snapshots_801_900_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_801_900_2023 OWNER TO postgres;

--
-- TOC entry 561 (class 1259 OID 49717)
-- Name: stockcurrent_part_snapshots_801_900_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_801_900_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_801_900 ATTACH PARTITION analytics.stockcurrent_part_snapshots_801_900_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_801_900_2024 OWNER TO postgres;

--
-- TOC entry 562 (class 1259 OID 49722)
-- Name: stockcurrent_part_snapshots_901_1000; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_901_1000 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
)
PARTITION BY RANGE (snapdate);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots ATTACH PARTITION analytics.stockcurrent_part_snapshots_901_1000 FOR VALUES FROM ('901') TO ('1001');


ALTER TABLE analytics.stockcurrent_part_snapshots_901_1000 OWNER TO postgres;

--
-- TOC entry 563 (class 1259 OID 49727)
-- Name: stockcurrent_part_snapshots_901_1000_2020; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_901_1000_2020 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_901_1000 ATTACH PARTITION analytics.stockcurrent_part_snapshots_901_1000_2020 FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_901_1000_2020 OWNER TO postgres;

--
-- TOC entry 564 (class 1259 OID 49732)
-- Name: stockcurrent_part_snapshots_901_1000_2021; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_901_1000_2021 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_901_1000 ATTACH PARTITION analytics.stockcurrent_part_snapshots_901_1000_2021 FOR VALUES FROM ('2021-01-01') TO ('2022-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_901_1000_2021 OWNER TO postgres;

--
-- TOC entry 565 (class 1259 OID 49737)
-- Name: stockcurrent_part_snapshots_901_1000_2022; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_901_1000_2022 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_901_1000 ATTACH PARTITION analytics.stockcurrent_part_snapshots_901_1000_2022 FOR VALUES FROM ('2022-01-01') TO ('2023-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_901_1000_2022 OWNER TO postgres;

--
-- TOC entry 566 (class 1259 OID 49742)
-- Name: stockcurrent_part_snapshots_901_1000_2023; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_901_1000_2023 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_901_1000 ATTACH PARTITION analytics.stockcurrent_part_snapshots_901_1000_2023 FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_901_1000_2023 OWNER TO postgres;

--
-- TOC entry 567 (class 1259 OID 49747)
-- Name: stockcurrent_part_snapshots_901_1000_2024; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.stockcurrent_part_snapshots_901_1000_2024 (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    snapdate date NOT NULL,
    price double precision DEFAULT 0 NOT NULL
);
ALTER TABLE ONLY analytics.stockcurrent_part_snapshots_901_1000 ATTACH PARTITION analytics.stockcurrent_part_snapshots_901_1000_2024 FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');


ALTER TABLE analytics.stockcurrent_part_snapshots_901_1000_2024 OWNER TO postgres;

--
-- TOC entry 568 (class 1259 OID 49752)
-- Name: temp_rep_collection; Type: TABLE; Schema: analytics; Owner: postgres
--

CREATE TABLE analytics.temp_rep_collection (
    name character varying(255),
    code character varying(255),
    total_line bigint,
    share real,
    cum_share real,
    coeff real,
    abc character varying(1),
    xyz character varying(1),
    "user" smallint NOT NULL,
    company integer,
    product bigint,
    point integer
);


ALTER TABLE analytics.temp_rep_collection OWNER TO postgres;

--
-- TOC entry 569 (class 1259 OID 49758)
-- Name: function_calls; Type: TABLE; Schema: functioncalls; Owner: postgres
--

CREATE TABLE functioncalls.function_calls (
    id bigint NOT NULL,
    name character varying(150),
    zapros text
);


ALTER TABLE functioncalls.function_calls OWNER TO postgres;

--
-- TOC entry 570 (class 1259 OID 49764)
-- Name: j_object; Type: TABLE; Schema: functioncalls; Owner: postgres
--

CREATE TABLE functioncalls.j_object (
    json_agg json
);


ALTER TABLE functioncalls.j_object OWNER TO postgres;

--
-- TOC entry 205 (class 1259 OID 16603)
-- Name: _db_version; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public._db_version (
    version text
);


ALTER TABLE public._db_version OWNER TO postgres;

--
-- TOC entry 206 (class 1259 OID 16609)
-- Name: access_table_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.access_table_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.access_table_id_seq OWNER TO postgres;

--
-- TOC entry 207 (class 1259 OID 16611)
-- Name: access_table; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.access_table (
    id bigint DEFAULT nextval('public.access_table_id_seq'::regclass) NOT NULL,
    reg_code character varying(255) NOT NULL,
    name_rus character varying(255) NOT NULL,
    name_kz character varying(255) NOT NULL,
    category character varying(255) DEFAULT nextval('public.access_table_id_seq'::regclass) NOT NULL,
    category_id bigint NOT NULL,
    nameu character varying,
    categoryu character varying,
    category_idu bigint
);


ALTER TABLE public.access_table OWNER TO postgres;

--
-- TOC entry 465 (class 1259 OID 24605)
-- Name: access_table_copy; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.access_table_copy (
    id bigint NOT NULL,
    reg_code character varying(255) NOT NULL,
    name_rus character varying(255) NOT NULL,
    name_kz character varying(255) NOT NULL,
    category character varying(255) DEFAULT nextval('public.access_table_id_seq'::regclass) NOT NULL,
    category_id bigint NOT NULL,
    nameu character varying,
    categoryu character varying,
    category_idu bigint
);


ALTER TABLE public.access_table_copy OWNER TO postgres;

--
-- TOC entry 464 (class 1259 OID 24603)
-- Name: access_table_copy_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.access_table_copy_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.access_table_copy_id_seq OWNER TO postgres;

--
-- TOC entry 6126 (class 0 OID 0)
-- Dependencies: 464
-- Name: access_table_copy_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.access_table_copy_id_seq OWNED BY public.access_table_copy.id;


--
-- TOC entry 467 (class 1259 OID 24617)
-- Name: access_tableu; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.access_tableu (
    id bigint NOT NULL,
    reg_code character varying(255) NOT NULL,
    name_rus character varying(255) NOT NULL,
    name_kz character varying(255) NOT NULL,
    category character varying(255) DEFAULT nextval('public.access_table_id_seq'::regclass) NOT NULL,
    category_id bigint NOT NULL
);


ALTER TABLE public.access_tableu OWNER TO postgres;

--
-- TOC entry 466 (class 1259 OID 24615)
-- Name: access_tableu_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.access_tableu_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.access_tableu_id_seq OWNER TO postgres;

--
-- TOC entry 6127 (class 0 OID 0)
-- Dependencies: 466
-- Name: access_tableu_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.access_tableu_id_seq OWNED BY public.access_tableu.id;


--
-- TOC entry 208 (class 1259 OID 16619)
-- Name: action_logs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.action_logs (
    date timestamp without time zone NOT NULL,
    function character varying NOT NULL,
    request jsonb NOT NULL,
    response jsonb NOT NULL,
    error character varying,
    "user" bigint,
    host character varying,
    id bigint NOT NULL
);


ALTER TABLE public.action_logs OWNER TO postgres;

--
-- TOC entry 209 (class 1259 OID 16625)
-- Name: action_logs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.action_logs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.action_logs_id_seq OWNER TO postgres;

--
-- TOC entry 6128 (class 0 OID 0)
-- Dependencies: 209
-- Name: action_logs_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.action_logs_id_seq OWNED BY public.action_logs.id;


--
-- TOC entry 210 (class 1259 OID 16627)
-- Name: admin_accesspartner; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.admin_accesspartner (
    id bigint NOT NULL,
    accesspartner character varying
);


ALTER TABLE public.admin_accesspartner OWNER TO postgres;

--
-- TOC entry 211 (class 1259 OID 16633)
-- Name: admin_accesspartner_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.admin_accesspartner_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.admin_accesspartner_id_seq OWNER TO postgres;

--
-- TOC entry 6129 (class 0 OID 0)
-- Dependencies: 211
-- Name: admin_accesspartner_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.admin_accesspartner_id_seq OWNED BY public.admin_accesspartner.id;


--
-- TOC entry 212 (class 1259 OID 16635)
-- Name: admincompanies_report; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.admincompanies_report (
    date date NOT NULL,
    allcompanies bigint NOT NULL,
    allpoints bigint NOT NULL,
    newcompanies bigint NOT NULL,
    newpoints bigint NOT NULL,
    activecomp bigint NOT NULL,
    activecompallpoints bigint NOT NULL,
    activecompactivepoints bigint NOT NULL,
    compup bigint NOT NULL,
    compdown bigint NOT NULL,
    opencashboxes bigint NOT NULL,
    opencashboxes3 bigint NOT NULL,
    compwithoutopencash bigint NOT NULL
);


ALTER TABLE public.admincompanies_report OWNER TO postgres;

--
-- TOC entry 6130 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.allcompanies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.allcompanies IS 'Всего компаний';


--
-- TOC entry 6131 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.allpoints; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.allpoints IS 'Всего торговых точек';


--
-- TOC entry 6132 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.newcompanies; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.newcompanies IS 'Новые компании с первого числа';


--
-- TOC entry 6133 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.newpoints; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.newpoints IS 'Новые торговые точки с первого числа';


--
-- TOC entry 6134 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.activecomp; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.activecomp IS 'Количество активных компаний';


--
-- TOC entry 6135 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.activecompallpoints; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.activecompallpoints IS 'Количество точек у активных компаний';


--
-- TOC entry 6136 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.activecompactivepoints; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.activecompactivepoints IS 'Количество активных точек у активных компаний';


--
-- TOC entry 6137 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.compup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.compup IS 'Количество активных компаний, у которых продажи более 10к тенге за последние 30 дней';


--
-- TOC entry 6138 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.compdown; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.compdown IS 'Количество активных компаний, у которых продажи менее 10к тенге за последние 30 дней';


--
-- TOC entry 6139 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.opencashboxes; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.opencashboxes IS 'Количество открытых касс на текущую дату';


--
-- TOC entry 6140 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.opencashboxes3; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.opencashboxes3 IS 'Количество открытых касс за последние 3 дня';


--
-- TOC entry 6141 (class 0 OID 0)
-- Dependencies: 212
-- Name: COLUMN admincompanies_report.compwithoutopencash; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report.compwithoutopencash IS 'Количество компаний без открытых касс за 3 дня';


--
-- TOC entry 213 (class 1259 OID 16638)
-- Name: admincompanies_report_details; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.admincompanies_report_details (
    date date NOT NULL,
    type smallint NOT NULL,
    object bigint NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.admincompanies_report_details OWNER TO postgres;

--
-- TOC entry 6142 (class 0 OID 0)
-- Dependencies: 213
-- Name: COLUMN admincompanies_report_details.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report_details.date IS 'Дата';


--
-- TOC entry 6143 (class 0 OID 0)
-- Dependencies: 213
-- Name: COLUMN admincompanies_report_details.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report_details.type IS 'Тип (1-всего компаний, 2-компании с 1 числа, 3-активные компании, 4-компании с продажами > 10к, 5-компании с продажами < 10к, 6-компании без открытых касс)';


--
-- TOC entry 6144 (class 0 OID 0)
-- Dependencies: 213
-- Name: COLUMN admincompanies_report_details.object; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.admincompanies_report_details.object IS 'Объекты (на данные момент - компании)';


--
-- TOC entry 214 (class 1259 OID 16641)
-- Name: admincompanies_report_details_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.admincompanies_report_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.admincompanies_report_details_id_seq OWNER TO postgres;

--
-- TOC entry 6145 (class 0 OID 0)
-- Dependencies: 214
-- Name: admincompanies_report_details_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.admincompanies_report_details_id_seq OWNED BY public.admincompanies_report_details.id;


--
-- TOC entry 215 (class 1259 OID 16643)
-- Name: attribcode_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.attribcode_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.attribcode_id_seq OWNER TO postgres;

--
-- TOC entry 216 (class 1259 OID 16645)
-- Name: attributecat; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.attributecat (
    id bigint NOT NULL,
    value character varying NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.attributecat OWNER TO postgres;

--
-- TOC entry 217 (class 1259 OID 16652)
-- Name: attributecat_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.attributecat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.attributecat_id_seq OWNER TO postgres;

--
-- TOC entry 6146 (class 0 OID 0)
-- Dependencies: 217
-- Name: attributecat_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.attributecat_id_seq OWNED BY public.attributecat.id;


--
-- TOC entry 218 (class 1259 OID 16654)
-- Name: attributelistcode; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.attributelistcode (
    id bigint NOT NULL,
    description character varying,
    company bigint NOT NULL
);


ALTER TABLE public.attributelistcode OWNER TO postgres;

--
-- TOC entry 219 (class 1259 OID 16660)
-- Name: attributelistcode_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.attributelistcode_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.attributelistcode_id_seq OWNER TO postgres;

--
-- TOC entry 6147 (class 0 OID 0)
-- Dependencies: 219
-- Name: attributelistcode_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.attributelistcode_id_seq OWNED BY public.attributelistcode.id;


--
-- TOC entry 220 (class 1259 OID 16662)
-- Name: attributenames; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.attributenames (
    id bigint NOT NULL,
    category bigint,
    "values" character varying NOT NULL,
    deleted boolean DEFAULT false,
    format character varying DEFAULT upper(('text'::character varying)::text) NOT NULL
);


ALTER TABLE public.attributenames OWNER TO postgres;

--
-- TOC entry 221 (class 1259 OID 16670)
-- Name: attributenames_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.attributenames_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.attributenames_id_seq OWNER TO postgres;

--
-- TOC entry 6148 (class 0 OID 0)
-- Dependencies: 221
-- Name: attributenames_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.attributenames_id_seq OWNED BY public.attributenames.id;


--
-- TOC entry 222 (class 1259 OID 16672)
-- Name: attributespr_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.attributespr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.attributespr_id_seq OWNER TO postgres;

--
-- TOC entry 223 (class 1259 OID 16674)
-- Name: attributespr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.attributespr (
    attributeid bigint NOT NULL,
    id bigint DEFAULT nextval('public.attributespr_id_seq'::regclass) NOT NULL,
    value character varying NOT NULL,
    company bigint NOT NULL,
    deleted boolean DEFAULT false
);


ALTER TABLE public.attributespr OWNER TO postgres;

--
-- TOC entry 224 (class 1259 OID 16682)
-- Name: attrlist; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.attrlist (
    listcode bigint NOT NULL,
    attribute bigint NOT NULL,
    value character varying,
    istemp boolean,
    company bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.attrlist OWNER TO postgres;

--
-- TOC entry 225 (class 1259 OID 16689)
-- Name: attrset_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.attrset_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.attrset_id_seq OWNER TO postgres;

--
-- TOC entry 226 (class 1259 OID 16691)
-- Name: barcode_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.barcode_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.barcode_seq OWNER TO postgres;

--
-- TOC entry 227 (class 1259 OID 16693)
-- Name: bonuscards_diary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.bonuscards_diary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bonuscards_diary_id_seq OWNER TO postgres;

--
-- TOC entry 228 (class 1259 OID 16695)
-- Name: bonuscardsdiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.bonuscardsdiary (
    card bigint NOT NULL,
    ticket bigint NOT NULL,
    type smallint NOT NULL,
    bonus double precision NOT NULL,
    transaction bigint NOT NULL,
    date timestamp(6) without time zone NOT NULL,
    company bigint DEFAULT 0 NOT NULL,
    "group" bigint DEFAULT 0 NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.bonuscardsdiary OWNER TO postgres;

--
-- TOC entry 6149 (class 0 OID 0)
-- Dependencies: 228
-- Name: COLUMN bonuscardsdiary."group"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.bonuscardsdiary."group" IS 'ID группы компаний, либо 0';


--
-- TOC entry 229 (class 1259 OID 16700)
-- Name: bonuscardsdiary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.bonuscardsdiary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bonuscardsdiary_id_seq OWNER TO postgres;

--
-- TOC entry 6150 (class 0 OID 0)
-- Dependencies: 229
-- Name: bonuscardsdiary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.bonuscardsdiary_id_seq OWNED BY public.bonuscardsdiary.id;


--
-- TOC entry 230 (class 1259 OID 16702)
-- Name: bonusgroup_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.bonusgroup_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bonusgroup_seq OWNER TO postgres;

--
-- TOC entry 231 (class 1259 OID 16704)
-- Name: bonustypes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.bonustypes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bonustypes_id_seq OWNER TO postgres;

--
-- TOC entry 232 (class 1259 OID 16706)
-- Name: brands_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.brands_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.brands_id_seq OWNER TO postgres;

--
-- TOC entry 233 (class 1259 OID 16708)
-- Name: brands; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.brands (
    id bigint DEFAULT nextval('public.brands_id_seq'::regclass) NOT NULL,
    brand character varying(255) NOT NULL,
    manufacturer character varying(255) NOT NULL,
    deleted boolean DEFAULT false
);


ALTER TABLE public.brands OWNER TO postgres;

--
-- TOC entry 234 (class 1259 OID 16716)
-- Name: cashbox_roles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cashbox_roles (
    id bigint NOT NULL,
    name character varying NOT NULL,
    session_plan double precision,
    deleted boolean DEFAULT false
);


ALTER TABLE public.cashbox_roles OWNER TO postgres;

--
-- TOC entry 235 (class 1259 OID 16723)
-- Name: cashbox_roles_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cashbox_roles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashbox_roles_id_seq OWNER TO postgres;

--
-- TOC entry 6151 (class 0 OID 0)
-- Dependencies: 235
-- Name: cashbox_roles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cashbox_roles_id_seq OWNED BY public.cashbox_roles.id;


--
-- TOC entry 236 (class 1259 OID 16725)
-- Name: cashbox_update_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cashbox_update_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashbox_update_id_seq OWNER TO postgres;

--
-- TOC entry 237 (class 1259 OID 16727)
-- Name: cashbox_updates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cashbox_updates (
    cashboxid bigint NOT NULL,
    filename character varying NOT NULL,
    company bigint NOT NULL,
    needupdate smallint DEFAULT 1 NOT NULL,
    id bigint NOT NULL,
    createdate timestamp(6) without time zone NOT NULL,
    status character varying(255),
    pk_id bigint NOT NULL
);


ALTER TABLE public.cashbox_updates OWNER TO postgres;

--
-- TOC entry 6152 (class 0 OID 0)
-- Dependencies: 237
-- Name: COLUMN cashbox_updates.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashbox_updates.id IS 'id обновления';


--
-- TOC entry 238 (class 1259 OID 16734)
-- Name: cashbox_updates_pk_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cashbox_updates_pk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashbox_updates_pk_id_seq OWNER TO postgres;

--
-- TOC entry 6153 (class 0 OID 0)
-- Dependencies: 238
-- Name: cashbox_updates_pk_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cashbox_updates_pk_id_seq OWNED BY public.cashbox_updates.pk_id;


--
-- TOC entry 239 (class 1259 OID 16736)
-- Name: cashbox_users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cashbox_users (
    id bigint NOT NULL,
    name character varying NOT NULL,
    apppass character varying,
    role bigint NOT NULL,
    point bigint NOT NULL,
    deleted boolean NOT NULL,
    iin character varying,
    discount boolean DEFAULT false NOT NULL,
    discountperc real DEFAULT 0 NOT NULL
);


ALTER TABLE public.cashbox_users OWNER TO postgres;

--
-- TOC entry 6154 (class 0 OID 0)
-- Dependencies: 239
-- Name: COLUMN cashbox_users.discountperc; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashbox_users.discountperc IS 'Скидка %';


--
-- TOC entry 240 (class 1259 OID 16744)
-- Name: cashbox_users_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cashbox_users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashbox_users_id_seq OWNER TO postgres;

--
-- TOC entry 6155 (class 0 OID 0)
-- Dependencies: 240
-- Name: cashbox_users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cashbox_users_id_seq OWNED BY public.cashbox_users.id;


--
-- TOC entry 241 (class 1259 OID 16746)
-- Name: cashboxdiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cashboxdiary (
    id bigint NOT NULL,
    cashbox bigint NOT NULL,
    opercode bigint NOT NULL,
    summ double precision NOT NULL,
    person character varying,
    comments character varying,
    operdate timestamp without time zone NOT NULL,
    editdate timestamp without time zone,
    operid bigint NOT NULL,
    company bigint DEFAULT 0 NOT NULL,
    shiftnumber integer DEFAULT 0,
    zreport json,
    flagadd boolean DEFAULT false,
    tismessage character varying
);


ALTER TABLE public.cashboxdiary OWNER TO postgres;

--
-- TOC entry 6156 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.id IS 'ID записи';


--
-- TOC entry 6157 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.cashbox; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.cashbox IS 'ID кассы';


--
-- TOC entry 6158 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.opercode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.opercode IS 'Тип записи';


--
-- TOC entry 6159 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.summ; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.summ IS 'Сумма';


--
-- TOC entry 6160 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.person; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.person IS 'Оператор';


--
-- TOC entry 6161 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.comments; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.comments IS 'Комментарии';


--
-- TOC entry 6162 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.operdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.operdate IS 'Дата';


--
-- TOC entry 6163 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.company IS 'ID компании';


--
-- TOC entry 6164 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.shiftnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.shiftnumber IS 'Номер смены';


--
-- TOC entry 6165 (class 0 OID 0)
-- Dependencies: 241
-- Name: COLUMN cashboxdiary.zreport; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxdiary.zreport IS 'z-отчет';


--
-- TOC entry 242 (class 1259 OID 16755)
-- Name: cashboxdiary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cashboxdiary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashboxdiary_id_seq OWNER TO postgres;

--
-- TOC entry 6166 (class 0 OID 0)
-- Dependencies: 242
-- Name: cashboxdiary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cashboxdiary_id_seq OWNED BY public.cashboxdiary.id;


--
-- TOC entry 243 (class 1259 OID 16757)
-- Name: opercodes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.opercodes (
    id bigint NOT NULL,
    name character varying NOT NULL,
    deleted boolean
);


ALTER TABLE public.opercodes OWNER TO postgres;

--
-- TOC entry 244 (class 1259 OID 16763)
-- Name: cashboxdiary_types_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cashboxdiary_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashboxdiary_types_id_seq OWNER TO postgres;

--
-- TOC entry 6167 (class 0 OID 0)
-- Dependencies: 244
-- Name: cashboxdiary_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cashboxdiary_types_id_seq OWNED BY public.opercodes.id;


--
-- TOC entry 245 (class 1259 OID 16765)
-- Name: cashboxes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cashboxes (
    name character varying NOT NULL,
    amount double precision,
    point bigint NOT NULL,
    id bigint NOT NULL,
    deleted boolean NOT NULL,
    isengaged boolean NOT NULL,
    ofdid bigint,
    ofdregnum character varying,
    checkuotside boolean DEFAULT false NOT NULL,
    white boolean DEFAULT true NOT NULL,
    version character varying(10),
    updatetime timestamp without time zone,
    tisintegration boolean DEFAULT false,
    tistoken2 character varying,
    id_cassa integer,
    id_section integer,
    flagclose boolean DEFAULT false,
    tistoken character varying
);


ALTER TABLE public.cashboxes OWNER TO postgres;

--
-- TOC entry 6168 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN cashboxes.ofdid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxes.ofdid IS 'ID кассы в ОФД';


--
-- TOC entry 6169 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN cashboxes.ofdregnum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxes.ofdregnum IS 'Регистрационный номер кассы в ОФД';


--
-- TOC entry 6170 (class 0 OID 0)
-- Dependencies: 245
-- Name: COLUMN cashboxes.checkuotside; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.cashboxes.checkuotside IS 'Признак возможности просмотра чеков из вне';


--
-- TOC entry 246 (class 1259 OID 16775)
-- Name: cashboxes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.cashboxes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashboxes_id_seq OWNER TO postgres;

--
-- TOC entry 6171 (class 0 OID 0)
-- Dependencies: 246
-- Name: cashboxes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.cashboxes_id_seq OWNED BY public.cashboxes.id;


--
-- TOC entry 247 (class 1259 OID 16777)
-- Name: cashboxtoken; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cashboxtoken (
    cashbox bigint NOT NULL,
    token character varying NOT NULL
);


ALTER TABLE public.cashboxtoken OWNER TO postgres;

--
-- TOC entry 248 (class 1259 OID 16783)
-- Name: categories_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.categories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.categories_id_seq OWNER TO postgres;

--
-- TOC entry 249 (class 1259 OID 16785)
-- Name: categories; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.categories (
    id bigint DEFAULT nextval('public.categories_id_seq'::regclass) NOT NULL,
    name character varying NOT NULL,
    parentid bigint DEFAULT 0,
    image bytea,
    deleted boolean NOT NULL,
    company bigint NOT NULL,
    bonusrate integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.categories OWNER TO postgres;

--
-- TOC entry 250 (class 1259 OID 16794)
-- Name: certificategroup_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.certificategroup_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.certificategroup_seq OWNER TO postgres;

--
-- TOC entry 251 (class 1259 OID 16796)
-- Name: changeprice_history; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.changeprice_history (
    company bigint NOT NULL,
    stockid bigint NOT NULL,
    price double precision NOT NULL,
    price_old double precision,
    date timestamp(0) without time zone NOT NULL,
    pieceprice double precision DEFAULT 0 NOT NULL,
    pieceprice_old double precision,
    invoice bigint,
    id bigint NOT NULL,
    wholesale_price double precision,
    wholesale_price_old double precision
);


ALTER TABLE public.changeprice_history OWNER TO postgres;

--
-- TOC entry 6172 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.company IS 'ID компании';


--
-- TOC entry 6173 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.stockid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.stockid IS 'ID stockcurrent';


--
-- TOC entry 6174 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.price IS 'Установленная цена';


--
-- TOC entry 6175 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.price_old; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.price_old IS 'Предыдущая цена';


--
-- TOC entry 6176 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.date IS 'Дата изменения';


--
-- TOC entry 6177 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.pieceprice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.pieceprice IS 'Цена за штуку (разукомплектация)';


--
-- TOC entry 6178 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.pieceprice_old; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.pieceprice_old IS 'Предыдущая цена за штуку (разукомплектация)';


--
-- TOC entry 6179 (class 0 OID 0)
-- Dependencies: 251
-- Name: COLUMN changeprice_history.invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.changeprice_history.invoice IS 'Накладная события';


--
-- TOC entry 252 (class 1259 OID 16800)
-- Name: changeprice_history_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.changeprice_history_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.changeprice_history_id_seq OWNER TO postgres;

--
-- TOC entry 6180 (class 0 OID 0)
-- Dependencies: 252
-- Name: changeprice_history_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.changeprice_history_id_seq OWNED BY public.changeprice_history.id;


--
-- TOC entry 253 (class 1259 OID 16802)
-- Name: character_entity; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.character_entity (
    name text NOT NULL,
    ch character(1)
);


ALTER TABLE public.character_entity OWNER TO postgres;

--
-- TOC entry 254 (class 1259 OID 16808)
-- Name: clients_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.clients_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.clients_seq OWNER TO postgres;

--
-- TOC entry 255 (class 1259 OID 16810)
-- Name: clients; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.clients (
    id bigint DEFAULT nextval('public.clients_seq'::regclass) NOT NULL,
    email character varying,
    phone character varying,
    message character varying
);


ALTER TABLE public.clients OWNER TO postgres;

--
-- TOC entry 256 (class 1259 OID 16817)
-- Name: closedcash_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.closedcash_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.closedcash_id_seq OWNER TO postgres;

--
-- TOC entry 257 (class 1259 OID 16819)
-- Name: cnofea_exceptions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cnofea_exceptions (
    code character varying NOT NULL,
    name character varying NOT NULL,
    isauto boolean NOT NULL
);


ALTER TABLE public.cnofea_exceptions OWNER TO postgres;

--
-- TOC entry 258 (class 1259 OID 16825)
-- Name: cnofealist; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.cnofealist (
    transactionid bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    date date,
    company bigint,
    processed boolean DEFAULT false,
    esfid bigint
);


ALTER TABLE public.cnofealist OWNER TO postgres;

--
-- TOC entry 259 (class 1259 OID 16829)
-- Name: companies; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.companies (
    id bigint NOT NULL,
    name character varying NOT NULL,
    bin character varying NOT NULL,
    address character varying NOT NULL,
    head character varying,
    head_iin character varying,
    accountant character varying,
    accountant_iin character varying,
    status character varying NOT NULL,
    gcoea character varying,
    certificatenum integer,
    certificateseries integer,
    isactivate boolean DEFAULT false NOT NULL,
    certificatedate date,
    holding boolean DEFAULT false NOT NULL,
    holding_parent bigint,
    bonus_group bigint DEFAULT 0 NOT NULL,
    certificate_group bigint DEFAULT 0 NOT NULL,
    coupon_group bigint DEFAULT 0 NOT NULL,
    created date DEFAULT CURRENT_DATE NOT NULL,
    productsweight_prefix smallint DEFAULT 0,
    wholesale boolean DEFAULT false NOT NULL,
    partner_id bigint
);


ALTER TABLE public.companies OWNER TO postgres;

--
-- TOC entry 6181 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN companies.bonus_group; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.bonus_group IS 'Группа для объединения бонусов. (Сиквенс bonusgroup_seq)';


--
-- TOC entry 6182 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN companies.certificate_group; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.certificate_group IS 'Группа для объединения сертификатов. (Сиквенс certificategroup_seq)';


--
-- TOC entry 6183 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN companies.coupon_group; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.coupon_group IS 'Группа для объединения купонов.';


--
-- TOC entry 6184 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN companies.created; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.created IS 'Дата заведения';


--
-- TOC entry 6185 (class 0 OID 0)
-- Dependencies: 259
-- Name: COLUMN companies.productsweight_prefix; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.companies.productsweight_prefix IS 'Префикс для весовых товаров. Стандартное значение - китайские весы(0)';


--
-- TOC entry 260 (class 1259 OID 16843)
-- Name: companies_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.companies_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.companies_id_seq OWNER TO postgres;

--
-- TOC entry 6186 (class 0 OID 0)
-- Dependencies: 260
-- Name: companies_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.companies_id_seq OWNED BY public.companies.id;


--
-- TOC entry 573 (class 1259 OID 65619)
-- Name: company_types; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.company_types (
    id bigint NOT NULL,
    name character varying
);


ALTER TABLE public.company_types OWNER TO postgres;

--
-- TOC entry 572 (class 1259 OID 65617)
-- Name: company_types_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.company_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.company_types_id_seq OWNER TO postgres;

--
-- TOC entry 6187 (class 0 OID 0)
-- Dependencies: 572
-- Name: company_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.company_types_id_seq OWNED BY public.company_types.id;


--
-- TOC entry 261 (class 1259 OID 16845)
-- Name: consignment; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.consignment (
    customer bigint NOT NULL,
    company bigint NOT NULL,
    stockid bigint NOT NULL,
    price double precision NOT NULL,
    units numeric(1000,3) NOT NULL,
    invoice bigint NOT NULL,
    altinvoice character varying(255),
    date date NOT NULL,
    unitsincome numeric(1000,3) NOT NULL,
    discount double precision DEFAULT 0 NOT NULL
);


ALTER TABLE public.consignment OWNER TO postgres;

--
-- TOC entry 6188 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.customer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.customer IS 'ID юр. клиента';


--
-- TOC entry 6189 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.company IS 'ID компании';


--
-- TOC entry 6190 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.stockid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.stockid IS 'ID записи stockcurrent';


--
-- TOC entry 6191 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.price IS 'Цена за единицу';


--
-- TOC entry 6192 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.units; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.units IS 'Количество';


--
-- TOC entry 6193 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.invoice IS 'Инвойс (созданный на кассе)';


--
-- TOC entry 6194 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.altinvoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.altinvoice IS 'Номер, присвоенный самим клиентом';


--
-- TOC entry 6195 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.date IS 'Дата инвойса';


--
-- TOC entry 6196 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.unitsincome; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.unitsincome IS 'Пришедшее количество';


--
-- TOC entry 6197 (class 0 OID 0)
-- Dependencies: 261
-- Name: COLUMN consignment.discount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment.discount IS 'Скидка на товар';


--
-- TOC entry 262 (class 1259 OID 16852)
-- Name: consignment_invoicelist; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.consignment_invoicelist (
    invoice bigint NOT NULL,
    company bigint NOT NULL,
    stockid bigint NOT NULL,
    price numeric(1000,2) NOT NULL,
    totalprice numeric(1000,2) NOT NULL,
    discount numeric(1000,2) DEFAULT 0 NOT NULL,
    units numeric(1000,3) NOT NULL
);


ALTER TABLE public.consignment_invoicelist OWNER TO postgres;

--
-- TOC entry 6198 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN consignment_invoicelist.invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoicelist.invoice IS 'Номер инвойса (накладной)';


--
-- TOC entry 6199 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN consignment_invoicelist.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoicelist.company IS 'ID компании';


--
-- TOC entry 6200 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN consignment_invoicelist.stockid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoicelist.stockid IS 'ID стока (stockcurrent)';


--
-- TOC entry 6201 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN consignment_invoicelist.price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoicelist.price IS 'Стоимость за штуку';


--
-- TOC entry 6202 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN consignment_invoicelist.totalprice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoicelist.totalprice IS 'Общая стоимость';


--
-- TOC entry 6203 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN consignment_invoicelist.discount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoicelist.discount IS 'Скидка';


--
-- TOC entry 6204 (class 0 OID 0)
-- Dependencies: 262
-- Name: COLUMN consignment_invoicelist.units; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoicelist.units IS 'Количество';


--
-- TOC entry 263 (class 1259 OID 16859)
-- Name: consignment_invoices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.consignment_invoices (
    invoicenumber bigint NOT NULL,
    company bigint NOT NULL,
    customer bigint NOT NULL,
    cashboxuser bigint NOT NULL,
    cashbox bigint NOT NULL,
    date timestamp(0) without time zone NOT NULL,
    type smallint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    altinvoice character varying(255)
);


ALTER TABLE public.consignment_invoices OWNER TO postgres;

--
-- TOC entry 6205 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.invoicenumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.invoicenumber IS 'Номер накладной (генерит касса)';


--
-- TOC entry 6206 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.company IS 'ID компании';


--
-- TOC entry 6207 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.customer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.customer IS 'ID клиента (юр)';


--
-- TOC entry 6208 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.cashboxuser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.cashboxuser IS 'ID пользователя кассы (инициатора)';


--
-- TOC entry 6209 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.cashbox; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.cashbox IS 'ID кассы';


--
-- TOC entry 6210 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.date IS 'Дата операции';


--
-- TOC entry 6211 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.type IS 'Тип операции (0 - на консигнацию, 1 - возврат)';


--
-- TOC entry 6212 (class 0 OID 0)
-- Dependencies: 263
-- Name: COLUMN consignment_invoices.altinvoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_invoices.altinvoice IS 'Альтернативное название';


--
-- TOC entry 264 (class 1259 OID 16863)
-- Name: consignment_snapshots; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.consignment_snapshots (
    customer bigint NOT NULL,
    company bigint NOT NULL,
    stockid bigint NOT NULL,
    price double precision NOT NULL,
    units numeric(1000,3) NOT NULL,
    invoice bigint NOT NULL,
    altinvoice character varying(255),
    date date NOT NULL,
    unitsincome numeric(1000,3) NOT NULL,
    discount double precision NOT NULL,
    snapdate date NOT NULL,
    purchaseprice double precision NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.consignment_snapshots OWNER TO postgres;

--
-- TOC entry 6213 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.customer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.customer IS 'ID юр. клиента';


--
-- TOC entry 6214 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.company IS 'ID компании';


--
-- TOC entry 6215 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.stockid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.stockid IS 'ID записи stockcurrent';


--
-- TOC entry 6216 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.price IS 'Цена за единицу';


--
-- TOC entry 6217 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.units; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.units IS 'Количество';


--
-- TOC entry 6218 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.invoice IS 'Инвойс (созданный на кассе)';


--
-- TOC entry 6219 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.altinvoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.altinvoice IS 'Номер, присвоенный самим клиентом';


--
-- TOC entry 6220 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.date IS 'Дата инвойса';


--
-- TOC entry 6221 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.unitsincome; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.unitsincome IS 'Пришедшее количество';


--
-- TOC entry 6222 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.discount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.discount IS 'Скидка на товар';


--
-- TOC entry 6223 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.snapdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.snapdate IS 'Дата снимка';


--
-- TOC entry 6224 (class 0 OID 0)
-- Dependencies: 264
-- Name: COLUMN consignment_snapshots.purchaseprice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.consignment_snapshots.purchaseprice IS 'Себестоимость единицы (FIFO)';


--
-- TOC entry 265 (class 1259 OID 16869)
-- Name: consignment_snapshots_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.consignment_snapshots_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.consignment_snapshots_id_seq OWNER TO postgres;

--
-- TOC entry 6225 (class 0 OID 0)
-- Dependencies: 265
-- Name: consignment_snapshots_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.consignment_snapshots_id_seq OWNED BY public.consignment_snapshots.id;


--
-- TOC entry 266 (class 1259 OID 16871)
-- Name: counterparties; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.counterparties (
    id bigint NOT NULL,
    name character varying NOT NULL,
    bin character varying NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    company bigint NOT NULL,
    address character varying,
    bank character varying,
    bik character varying,
    certificatenum integer,
    certificateseries integer,
    iik character varying(255),
    kbe integer,
    country character varying DEFAULT 'KZ'::character varying NOT NULL,
    email character varying
);


ALTER TABLE public.counterparties OWNER TO postgres;

--
-- TOC entry 267 (class 1259 OID 16879)
-- Name: counterparties_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.counterparties_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.counterparties_id_seq OWNER TO postgres;

--
-- TOC entry 6226 (class 0 OID 0)
-- Dependencies: 267
-- Name: counterparties_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.counterparties_id_seq OWNED BY public.counterparties.id;


--
-- TOC entry 268 (class 1259 OID 16881)
-- Name: counterparty2product; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.counterparty2product (
    counterparty bigint NOT NULL,
    product bigint NOT NULL,
    company bigint NOT NULL
);


ALTER TABLE public.counterparty2product OWNER TO postgres;

--
-- TOC entry 269 (class 1259 OID 16884)
-- Name: couponobjtypes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.couponobjtypes (
    id smallint NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.couponobjtypes OWNER TO postgres;

--
-- TOC entry 270 (class 1259 OID 16888)
-- Name: coupons_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.coupons_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.coupons_id_seq OWNER TO postgres;

--
-- TOC entry 271 (class 1259 OID 16890)
-- Name: coupons; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.coupons (
    id bigint DEFAULT nextval('public.coupons_id_seq'::regclass) NOT NULL,
    company bigint NOT NULL,
    number character varying NOT NULL,
    discount double precision NOT NULL,
    object bigint NOT NULL,
    objtype smallint NOT NULL,
    expire date NOT NULL,
    active boolean DEFAULT true NOT NULL,
    type smallint DEFAULT 0 NOT NULL,
    subtype smallint DEFAULT 1 NOT NULL
);


ALTER TABLE public.coupons OWNER TO postgres;

--
-- TOC entry 6227 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.number; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.number IS 'Номер купона';


--
-- TOC entry 6228 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.discount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.discount IS 'Скидка';


--
-- TOC entry 6229 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.object; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.object IS 'ID объекта';


--
-- TOC entry 6230 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.objtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.objtype IS 'Тип (0-все,1-категория,2-бренд,3-товар)';


--
-- TOC entry 6231 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.expire; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.expire IS 'Дата окончания';


--
-- TOC entry 6232 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.active IS 'Признак активности';


--
-- TOC entry 6233 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.type IS '1-на товар/2-на чек';


--
-- TOC entry 6234 (class 0 OID 0)
-- Dependencies: 271
-- Name: COLUMN coupons.subtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.coupons.subtype IS '1-многоразовый/2-одноразовый';


--
-- TOC entry 272 (class 1259 OID 16900)
-- Name: couponsdiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.couponsdiary (
    company bigint NOT NULL,
    date timestamp(6) without time zone NOT NULL,
    reason smallint NOT NULL,
    idcoup bigint NOT NULL,
    transactionid bigint,
    "group" bigint DEFAULT 0 NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.couponsdiary OWNER TO postgres;

--
-- TOC entry 6235 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN couponsdiary.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.couponsdiary.company IS 'ID компании';


--
-- TOC entry 6236 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN couponsdiary.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.couponsdiary.date IS 'Дата события';


--
-- TOC entry 6237 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN couponsdiary.reason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.couponsdiary.reason IS 'Действие';


--
-- TOC entry 6238 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN couponsdiary.idcoup; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.couponsdiary.idcoup IS 'ID купона';


--
-- TOC entry 6239 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN couponsdiary.transactionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.couponsdiary.transactionid IS 'ID транзакции';


--
-- TOC entry 6240 (class 0 OID 0)
-- Dependencies: 272
-- Name: COLUMN couponsdiary."group"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.couponsdiary."group" IS 'ID группы компаний по купонам';


--
-- TOC entry 273 (class 1259 OID 16904)
-- Name: couponsdiary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.couponsdiary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.couponsdiary_id_seq OWNER TO postgres;

--
-- TOC entry 6241 (class 0 OID 0)
-- Dependencies: 273
-- Name: couponsdiary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.couponsdiary_id_seq OWNED BY public.couponsdiary.id;


--
-- TOC entry 274 (class 1259 OID 16906)
-- Name: couponsdiaryreasons; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.couponsdiaryreasons (
    id smallint NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.couponsdiaryreasons OWNER TO postgres;

--
-- TOC entry 275 (class 1259 OID 16910)
-- Name: customers_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.customers_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.customers_id_seq OWNER TO postgres;

--
-- TOC entry 276 (class 1259 OID 16912)
-- Name: customers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customers (
    id bigint DEFAULT nextval('public.customers_id_seq'::regclass) NOT NULL,
    name character varying NOT NULL,
    bin character varying DEFAULT '000000000000'::character varying NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    company bigint DEFAULT 0 NOT NULL,
    address character varying DEFAULT 'Без адреса'::character varying NOT NULL,
    debt double precision DEFAULT 0 NOT NULL
);


ALTER TABLE public.customers OWNER TO postgres;

--
-- TOC entry 277 (class 1259 OID 16924)
-- Name: customers_bonuscards_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.customers_bonuscards_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.customers_bonuscards_id_seq OWNER TO postgres;

--
-- TOC entry 278 (class 1259 OID 16926)
-- Name: customers_bonuscards; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.customers_bonuscards (
    id bigint DEFAULT nextval('public.customers_bonuscards_id_seq'::regclass) NOT NULL,
    telephone character varying(255) NOT NULL,
    cardnumber character varying,
    lastname character varying(255),
    firstname character varying(255),
    bonuses double precision DEFAULT 0 NOT NULL,
    status character varying(255) DEFAULT 'ACTIVE'::character varying NOT NULL,
    company bigint NOT NULL,
    fizid bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.customers_bonuscards OWNER TO postgres;

--
-- TOC entry 6242 (class 0 OID 0)
-- Dependencies: 278
-- Name: COLUMN customers_bonuscards.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customers_bonuscards.company IS 'ID компании';


--
-- TOC entry 6243 (class 0 OID 0)
-- Dependencies: 278
-- Name: COLUMN customers_bonuscards.fizid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.customers_bonuscards.fizid IS 'Привязка к клиенту (физ)';


--
-- TOC entry 279 (class 1259 OID 16936)
-- Name: debtors_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.debtors_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.debtors_id_seq OWNER TO postgres;

--
-- TOC entry 280 (class 1259 OID 16938)
-- Name: debtorsdiary_id; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.debtorsdiary_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.debtorsdiary_id OWNER TO postgres;

--
-- TOC entry 281 (class 1259 OID 16940)
-- Name: debtorsdiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.debtorsdiary (
    customer bigint NOT NULL,
    transaction bigint,
    type smallint NOT NULL,
    debt double precision DEFAULT 0 NOT NULL,
    date timestamp(6) without time zone DEFAULT now() NOT NULL,
    company bigint DEFAULT 0 NOT NULL,
    "user" bigint DEFAULT 0,
    system character varying(255),
    customertype smallint DEFAULT 0 NOT NULL,
    id bigint DEFAULT nextval('public.debtorsdiary_id'::regclass) NOT NULL
);


ALTER TABLE public.debtorsdiary OWNER TO postgres;

--
-- TOC entry 6244 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.customer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.customer IS 'ID клиента';


--
-- TOC entry 6245 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.transaction; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.transaction IS 'ID транзакции';


--
-- TOC entry 6246 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.type IS 'Тип действия';


--
-- TOC entry 6247 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.debt; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.debt IS 'Сумма действия';


--
-- TOC entry 6248 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.date IS 'Дата';


--
-- TOC entry 6249 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.company IS 'ID компании';


--
-- TOC entry 6250 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary."user"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary."user" IS 'Пользователь совершивший действие';


--
-- TOC entry 6251 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.system; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.system IS 'Откуда обработано (ERP/POS)';


--
-- TOC entry 6252 (class 0 OID 0)
-- Dependencies: 281
-- Name: COLUMN debtorsdiary.customertype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.debtorsdiary.customertype IS '0 - Физ. лицо, 1 - юр. лицо';


--
-- TOC entry 282 (class 1259 OID 16949)
-- Name: discount_types_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.discount_types_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 32767
    CACHE 1;


ALTER TABLE public.discount_types_id_seq OWNER TO postgres;

--
-- TOC entry 283 (class 1259 OID 16951)
-- Name: discounts_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.discounts_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.discounts_id_seq OWNER TO postgres;

--
-- TOC entry 284 (class 1259 OID 16953)
-- Name: discounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.discounts (
    id bigint DEFAULT nextval('public.discounts_id_seq'::regclass) NOT NULL,
    company bigint NOT NULL,
    type smallint NOT NULL,
    object bigint NOT NULL,
    discount real NOT NULL,
    expirationdate date NOT NULL,
    startdate date NOT NULL,
    point bigint NOT NULL,
    createdate timestamp(6) without time zone DEFAULT now() NOT NULL,
    isactive boolean DEFAULT false NOT NULL,
    discountsum boolean DEFAULT false NOT NULL,
    fromtime time(6) without time zone DEFAULT '00:00:00'::time without time zone,
    totime time(6) without time zone DEFAULT '00:00:00'::time without time zone,
    tag boolean DEFAULT false
);


ALTER TABLE public.discounts OWNER TO postgres;

--
-- TOC entry 6253 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.type IS 'Тип скидки: магазин, точка, категория, товар';


--
-- TOC entry 6254 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.object; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.object IS 'Объект скидки';


--
-- TOC entry 6255 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.discount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.discount IS 'Скидка %';


--
-- TOC entry 6256 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.expirationdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.expirationdate IS 'Дата окончания (если есть)';


--
-- TOC entry 6257 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.startdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.startdate IS 'Дата начала';


--
-- TOC entry 6258 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.point; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.point IS 'Торговая точка';


--
-- TOC entry 6259 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.createdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.createdate IS 'Дата создания';


--
-- TOC entry 6260 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.isactive; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.isactive IS 'Активность записи(может быть и не проставлена)';


--
-- TOC entry 6261 (class 0 OID 0)
-- Dependencies: 284
-- Name: COLUMN discounts.discountsum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.discounts.discountsum IS 'В случае наличия у товара скидки по сроку годности суммировать или нет';


--
-- TOC entry 285 (class 1259 OID 16963)
-- Name: discounttypes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.discounttypes (
    id smallint DEFAULT nextval('public.discount_types_id_seq'::regclass) NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.discounttypes OWNER TO postgres;

--
-- TOC entry 286 (class 1259 OID 16967)
-- Name: dual; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.dual AS
 SELECT 'x'::text AS dummy;


ALTER TABLE public.dual OWNER TO postgres;

--
-- TOC entry 287 (class 1259 OID 16971)
-- Name: erp_roles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.erp_roles (
    id bigint NOT NULL,
    name character varying NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    accesses json,
    company bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.erp_roles OWNER TO postgres;

--
-- TOC entry 288 (class 1259 OID 16979)
-- Name: erp_roles_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.erp_roles_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.erp_roles_id_seq OWNER TO postgres;

--
-- TOC entry 6262 (class 0 OID 0)
-- Dependencies: 288
-- Name: erp_roles_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.erp_roles_id_seq OWNED BY public.erp_roles.id;


--
-- TOC entry 289 (class 1259 OID 16981)
-- Name: erp_users; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.erp_users (
    id bigint NOT NULL,
    login character varying NOT NULL,
    name character varying NOT NULL,
    pass character varying NOT NULL,
    iin character varying NOT NULL,
    role integer,
    company bigint NOT NULL,
    status character varying NOT NULL,
    accesses json DEFAULT '[{"id":42,"code":"setting_portal_user"}]'::json NOT NULL,
    accessesu json DEFAULT '[]'::json NOT NULL
);


ALTER TABLE public.erp_users OWNER TO postgres;

--
-- TOC entry 290 (class 1259 OID 16988)
-- Name: erp_users_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.erp_users_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.erp_users_id_seq OWNER TO postgres;

--
-- TOC entry 6263 (class 0 OID 0)
-- Dependencies: 290
-- Name: erp_users_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.erp_users_id_seq OWNED BY public.erp_users.id;


--
-- TOC entry 291 (class 1259 OID 16990)
-- Name: esf; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.esf (
    id bigint NOT NULL,
    esfid bigint,
    esfregnum character varying,
    esfaccountingnumber bigint,
    esfdate date DEFAULT CURRENT_DATE NOT NULL,
    type character varying DEFAULT 'OUTBOUND'::character varying NOT NULL,
    subtype character varying DEFAULT 'ORDINARY_INVOICE'::character varying NOT NULL,
    turnoverdate date NOT NULL,
    usr bigint NOT NULL,
    company bigint NOT NULL,
    status character varying DEFAULT 'FORMATION'::character varying NOT NULL,
    revise boolean DEFAULT false,
    currencycode character varying DEFAULT 'KZT'::character varying,
    contractdate date,
    contractnum character varying,
    hascontract boolean,
    term character varying,
    transporttypecode smallint,
    warrant character varying,
    warrantdate date,
    custid bigint NOT NULL,
    seller bigint DEFAULT 0 NOT NULL,
    lastupdate timestamp(0) without time zone,
    reason character varying,
    relationesregnum character varying,
    deliverydocnum character varying,
    deliverydocdate date,
    totalndsamount double precision,
    totalpricewithtax double precision,
    totalpricewithouttax double precision,
    totalturnoversize double precision,
    totalexciseamount double precision,
    destination character varying(255),
    deliveryconditioncode character varying(3),
    "сonsignortin" character varying,
    "сonsignorname" character varying,
    "сonsignoraddress" character varying,
    "сonsigneetin" character varying,
    "сonsigneename" character varying,
    "сonsigneeaddress" character varying
);


ALTER TABLE public.esf OWNER TO postgres;

--
-- TOC entry 6264 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.id IS 'ID нашей системы';


--
-- TOC entry 6265 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.esfid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.esfid IS 'ID ИС ЭСФ - присваивается сразу после отправки';


--
-- TOC entry 6266 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.esfregnum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.esfregnum IS 'Регистрационный номер ИС ЭСФ - присваивается, когда ЭСФ проходит все проверки и получает статус CREATED';


--
-- TOC entry 6267 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.esfaccountingnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.esfaccountingnumber IS 'Алтернативный номер в бухгалтерии, если нужно учитывать нумерацию из другой системы';


--
-- TOC entry 6268 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.type IS 'Входящий/Исходящий';


--
-- TOC entry 6269 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.subtype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.subtype IS 'Основной ЭСФ/Исправленный ЭСФ/Дополнительный ЭСФ';


--
-- TOC entry 6270 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.turnoverdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.turnoverdate IS 'Дата оборота за которую выставляется ЭСФ';


--
-- TOC entry 6271 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.revise; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.revise IS 'Признак сверки. Была/не была. Исходящим автоматически простовляется признак, что сверка была.';


--
-- TOC entry 6272 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.contractdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.contractdate IS 'Дата договора(контракт) на поставку товаров (работ, услуг) (E 27.4)';


--
-- TOC entry 6273 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.contractnum; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.contractnum IS 'Номер договора(контракт) на поставку товаров (работ, услуг) (E 27.3)';


--
-- TOC entry 6274 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.hascontract; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.hascontract IS 'Договор/без договора';


--
-- TOC entry 6275 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.term; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.term IS 'Условия оплаты по договору (E 28)';


--
-- TOC entry 6276 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.transporttypecode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.transporttypecode IS 'Способ отправления (E 29)';


--
-- TOC entry 6277 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.warrant; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.warrant IS 'Номер доверенности на поставку товаров (работ, услуг) (E 30.1)';


--
-- TOC entry 6278 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.warrantdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.warrantdate IS 'Дата доверенности на поставку товаров (работ, услуг) (E 30.2)';


--
-- TOC entry 6279 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.destination; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.destination IS 'Пункт назначения поставляемых товаров (работ, услуг) (E 31)';


--
-- TOC entry 6280 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf.deliveryconditioncode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf.deliveryconditioncode IS 'Условия поставки (E 31.1)';


--
-- TOC entry 6281 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf."сonsignortin"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf."сonsignortin" IS 'ИИН/БИН Грузоотправителя (D 25.1)';


--
-- TOC entry 6282 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf."сonsignorname"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf."сonsignorname" IS 'Наименование Грузоотправителя (D 25.2)';


--
-- TOC entry 6283 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf."сonsignoraddress"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf."сonsignoraddress" IS 'Адрес Грузоотправителя (D 25.3)';


--
-- TOC entry 6284 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf."сonsigneetin"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf."сonsigneetin" IS 'ИИН/БИН Грузополучателя (D 26.1)';


--
-- TOC entry 6285 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf."сonsigneename"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf."сonsigneename" IS 'Наименование Грузополучателя (D 26.2)';


--
-- TOC entry 6286 (class 0 OID 0)
-- Dependencies: 291
-- Name: COLUMN esf."сonsigneeaddress"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.esf."сonsigneeaddress" IS 'Адрес Грузополучателя (D 26.3)';


--
-- TOC entry 292 (class 1259 OID 17003)
-- Name: esf_details; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.esf_details (
    esfid bigint NOT NULL,
    description character varying NOT NULL,
    ndsamount double precision,
    ndsrate double precision,
    pricewithtax double precision,
    pricewithouttax double precision,
    declaration character varying,
    numberindeclaration character varying(64),
    quantity numeric(1000,3),
    tnvedname character varying,
    truorigincode integer,
    turnoversize double precision,
    unitcode character varying,
    unitnomenclature character varying,
    unitprice double precision,
    rowid bigint NOT NULL,
    manual boolean DEFAULT false,
    company bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.esf_details OWNER TO postgres;

--
-- TOC entry 293 (class 1259 OID 17011)
-- Name: esf_details_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.esf_details_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.esf_details_id_seq OWNER TO postgres;

--
-- TOC entry 6287 (class 0 OID 0)
-- Dependencies: 293
-- Name: esf_details_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.esf_details_id_seq OWNED BY public.esf_details.rowid;


--
-- TOC entry 294 (class 1259 OID 17013)
-- Name: esf_errors; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.esf_errors (
    code character varying NOT NULL,
    rus character varying,
    kz character varying,
    deleted boolean DEFAULT false
);


ALTER TABLE public.esf_errors OWNER TO postgres;

--
-- TOC entry 295 (class 1259 OID 17020)
-- Name: esf_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.esf_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.esf_id_seq OWNER TO postgres;

--
-- TOC entry 6288 (class 0 OID 0)
-- Dependencies: 295
-- Name: esf_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.esf_id_seq OWNED BY public.esf.id;


--
-- TOC entry 296 (class 1259 OID 17022)
-- Name: esf_statuses; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.esf_statuses (
    code character varying NOT NULL,
    rus character varying,
    kz character varying,
    deleted boolean DEFAULT false
);


ALTER TABLE public.esf_statuses OWNER TO postgres;

--
-- TOC entry 297 (class 1259 OID 17029)
-- Name: expdate_discount_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.expdate_discount_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.expdate_discount_id_seq OWNER TO postgres;

--
-- TOC entry 298 (class 1259 OID 17031)
-- Name: expdate_discount; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.expdate_discount (
    id bigint DEFAULT nextval('public.expdate_discount_id_seq'::regclass) NOT NULL,
    company bigint NOT NULL,
    "from" integer DEFAULT 0 NOT NULL,
    "to" integer DEFAULT 0 NOT NULL,
    type smallint DEFAULT 1 NOT NULL,
    discount real NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    object smallint DEFAULT 0,
    objectid bigint DEFAULT 0
);


ALTER TABLE public.expdate_discount OWNER TO postgres;

--
-- TOC entry 6289 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN expdate_discount."from"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.expdate_discount."from" IS 'Период от ';


--
-- TOC entry 6290 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN expdate_discount."to"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.expdate_discount."to" IS 'Период до';


--
-- TOC entry 6291 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN expdate_discount.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.expdate_discount.type IS 'Тип учета (1-день, 2 - месяц)';


--
-- TOC entry 6292 (class 0 OID 0)
-- Dependencies: 298
-- Name: COLUMN expdate_discount.discount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.expdate_discount.discount IS 'Размер скидки (%)';


--
-- TOC entry 299 (class 1259 OID 17041)
-- Name: fiz_customers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.fiz_customers (
    id bigint DEFAULT nextval('public.debtors_id_seq'::regclass) NOT NULL,
    telephone character varying(255),
    lastname character varying(255),
    firstname character varying(255),
    company bigint NOT NULL,
    debt double precision DEFAULT 0 NOT NULL,
    deleted boolean
);


ALTER TABLE public.fiz_customers OWNER TO postgres;

--
-- TOC entry 6293 (class 0 OID 0)
-- Dependencies: 299
-- Name: COLUMN fiz_customers.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.fiz_customers.company IS 'ID компании';


--
-- TOC entry 300 (class 1259 OID 17049)
-- Name: format; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.format (
    name character varying(255) NOT NULL,
    description character varying(255) NOT NULL
);


ALTER TABLE public.format OWNER TO postgres;

--
-- TOC entry 301 (class 1259 OID 17055)
-- Name: ftpservers; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ftpservers (
    id smallint NOT NULL,
    name character varying(255) NOT NULL
);


ALTER TABLE public.ftpservers OWNER TO postgres;

--
-- TOC entry 6294 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN ftpservers.id; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ftpservers.id IS 'ID сервера для привязки к точке';


--
-- TOC entry 6295 (class 0 OID 0)
-- Dependencies: 301
-- Name: COLUMN ftpservers.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.ftpservers.name IS 'Наименование сервера (какоме ТЦ принадлежит)';


--
-- TOC entry 302 (class 1259 OID 17058)
-- Name: gen_class_of_economic_act; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.gen_class_of_economic_act (
    code character varying NOT NULL,
    kaz character varying NOT NULL,
    rus character varying NOT NULL
);


ALTER TABLE public.gen_class_of_economic_act OWNER TO postgres;

--
-- TOC entry 303 (class 1259 OID 17064)
-- Name: giftcertificates; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.giftcertificates (
    id bigint NOT NULL,
    company bigint NOT NULL,
    product bigint NOT NULL,
    code character varying(32) NOT NULL,
    balance real NOT NULL,
    type smallint DEFAULT 1 NOT NULL,
    expiredate date,
    active boolean DEFAULT false NOT NULL,
    period smallint,
    denomination real NOT NULL,
    selldate date
);


ALTER TABLE public.giftcertificates OWNER TO postgres;

--
-- TOC entry 6296 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.product; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.product IS 'Связь с таблицей products';


--
-- TOC entry 6297 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.code; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.code IS 'Штрих-код сертификата';


--
-- TOC entry 6298 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.balance IS 'Баланс карты(в основном для многоразовых)';


--
-- TOC entry 6299 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.type IS 'Тип (многоразовые/одноразовые)';


--
-- TOC entry 6300 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.expiredate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.expiredate IS 'Дата истечения';


--
-- TOC entry 6301 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.active; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.active IS 'Активность (true до использования)';


--
-- TOC entry 6302 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.period; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.period IS 'Период активности с момента продажи (месяцы)';


--
-- TOC entry 6303 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.denomination; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.denomination IS 'Номинал';


--
-- TOC entry 6304 (class 0 OID 0)
-- Dependencies: 303
-- Name: COLUMN giftcertificates.selldate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates.selldate IS 'Дата продажи';


--
-- TOC entry 304 (class 1259 OID 17069)
-- Name: giftcertificates_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.giftcertificates_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.giftcertificates_id_seq OWNER TO postgres;

--
-- TOC entry 6305 (class 0 OID 0)
-- Dependencies: 304
-- Name: giftcertificates_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.giftcertificates_id_seq OWNED BY public.giftcertificates.id;


--
-- TOC entry 305 (class 1259 OID 17071)
-- Name: giftcertificates_writeoff_balances; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.giftcertificates_writeoff_balances (
    id bigint NOT NULL,
    company bigint NOT NULL,
    certid bigint NOT NULL,
    balance double precision NOT NULL,
    write_off boolean DEFAULT false NOT NULL,
    date date DEFAULT CURRENT_DATE NOT NULL
);


ALTER TABLE public.giftcertificates_writeoff_balances OWNER TO postgres;

--
-- TOC entry 6306 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN giftcertificates_writeoff_balances.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates_writeoff_balances.company IS 'ID компании';


--
-- TOC entry 6307 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN giftcertificates_writeoff_balances.certid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates_writeoff_balances.certid IS 'ID сертификата';


--
-- TOC entry 6308 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN giftcertificates_writeoff_balances.balance; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates_writeoff_balances.balance IS 'Баланс для списания';


--
-- TOC entry 6309 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN giftcertificates_writeoff_balances.write_off; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates_writeoff_balances.write_off IS 'Признак списания';


--
-- TOC entry 6310 (class 0 OID 0)
-- Dependencies: 305
-- Name: COLUMN giftcertificates_writeoff_balances.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificates_writeoff_balances.date IS 'Дата образования баланса для списания';


--
-- TOC entry 306 (class 1259 OID 17076)
-- Name: giftcertificates_write-off_balances_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public."giftcertificates_write-off_balances_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public."giftcertificates_write-off_balances_id_seq" OWNER TO postgres;

--
-- TOC entry 6311 (class 0 OID 0)
-- Dependencies: 306
-- Name: giftcertificates_write-off_balances_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public."giftcertificates_write-off_balances_id_seq" OWNED BY public.giftcertificates_writeoff_balances.id;


--
-- TOC entry 307 (class 1259 OID 17078)
-- Name: giftcertificatesdiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.giftcertificatesdiary (
    company bigint NOT NULL,
    date timestamp(6) without time zone NOT NULL,
    reason smallint NOT NULL,
    idcert bigint NOT NULL,
    summ double precision NOT NULL,
    invoice bigint,
    transactionid bigint,
    point bigint,
    "group" bigint DEFAULT 0 NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.giftcertificatesdiary OWNER TO postgres;

--
-- TOC entry 6312 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.company IS 'ID компании';


--
-- TOC entry 6313 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.date IS 'Дата события';


--
-- TOC entry 6314 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.reason; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.reason IS 'Действие';


--
-- TOC entry 6315 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.idcert; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.idcert IS 'ID сертификата';


--
-- TOC entry 6316 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.summ; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.summ IS 'Сумма события';


--
-- TOC entry 6317 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.invoice IS 'ID инвойса';


--
-- TOC entry 6318 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.transactionid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.transactionid IS 'ID транзакции';


--
-- TOC entry 6319 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary.point; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary.point IS 'ID точки события';


--
-- TOC entry 6320 (class 0 OID 0)
-- Dependencies: 307
-- Name: COLUMN giftcertificatesdiary."group"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.giftcertificatesdiary."group" IS 'ID группы компаний, либо 0';


--
-- TOC entry 308 (class 1259 OID 17082)
-- Name: giftcertificatesdiary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.giftcertificatesdiary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.giftcertificatesdiary_id_seq OWNER TO postgres;

--
-- TOC entry 6321 (class 0 OID 0)
-- Dependencies: 308
-- Name: giftcertificatesdiary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.giftcertificatesdiary_id_seq OWNED BY public.giftcertificatesdiary.id;


--
-- TOC entry 309 (class 1259 OID 17084)
-- Name: giftcertificatesdiaryreasons; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.giftcertificatesdiaryreasons (
    id smallint NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.giftcertificatesdiaryreasons OWNER TO postgres;

--
-- TOC entry 310 (class 1259 OID 17088)
-- Name: giftcertificatetypes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.giftcertificatetypes (
    id bigint NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.giftcertificatetypes OWNER TO postgres;

--
-- TOC entry 311 (class 1259 OID 17092)
-- Name: giftcertificatetypes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.giftcertificatetypes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.giftcertificatetypes_id_seq OWNER TO postgres;

--
-- TOC entry 6322 (class 0 OID 0)
-- Dependencies: 311
-- Name: giftcertificatetypes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.giftcertificatetypes_id_seq OWNED BY public.giftcertificatetypes.id;


--
-- TOC entry 312 (class 1259 OID 17094)
-- Name: invoicelist; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoicelist (
    invoice bigint NOT NULL,
    stock bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision,
    newprice double precision,
    purchaseprice double precision,
    newprod boolean NOT NULL,
    sku character varying,
    stockto bigint,
    delusr boolean DEFAULT false NOT NULL,
    comments character varying,
    prodchanges character varying,
    updateallprodprice boolean DEFAULT false,
    company bigint DEFAULT 0 NOT NULL,
    hotkey integer,
    scale bigint DEFAULT 0,
    delete boolean DEFAULT false NOT NULL,
    pieceprice double precision,
    oldprice double precision,
    attributes_json json,
    wholesale_price real DEFAULT 0 NOT NULL,
    numpor integer,
    detales bigint,
    detales_json json,
    categoryid bigint,
    brandid bigint,
    id integer NOT NULL
);


ALTER TABLE public.invoicelist OWNER TO postgres;

--
-- TOC entry 6323 (class 0 OID 0)
-- Dependencies: 312
-- Name: TABLE invoicelist; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON TABLE public.invoicelist IS 'stock - id изменяемых объектов. (products,stockcurrent и т.д.)';


--
-- TOC entry 6324 (class 0 OID 0)
-- Dependencies: 312
-- Name: COLUMN invoicelist.stock; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoicelist.stock IS 'stock - id изменяемых объектов. (products,stockcurrent и т.д.)';


--
-- TOC entry 6325 (class 0 OID 0)
-- Dependencies: 312
-- Name: COLUMN invoicelist.hotkey; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoicelist.hotkey IS 'Горячая клавиша (только для весовых товаров)';


--
-- TOC entry 6326 (class 0 OID 0)
-- Dependencies: 312
-- Name: COLUMN invoicelist.scale; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoicelist.scale IS 'Идентификатор весов (только для весовых товаров)';


--
-- TOC entry 6327 (class 0 OID 0)
-- Dependencies: 312
-- Name: COLUMN invoicelist.delete; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoicelist.delete IS 'Признак удаления(пока только для весовых товаров)';


--
-- TOC entry 6328 (class 0 OID 0)
-- Dependencies: 312
-- Name: COLUMN invoicelist.pieceprice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoicelist.pieceprice IS 'Цена за штуку (для "распоковываемых товаров")';


--
-- TOC entry 313 (class 1259 OID 17106)
-- Name: products_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.products_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.products_id_seq OWNER TO postgres;

--
-- TOC entry 314 (class 1259 OID 17108)
-- Name: products; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products (
    id bigint DEFAULT nextval('public.products_id_seq'::regclass) NOT NULL,
    code character varying(20) NOT NULL,
    name character varying NOT NULL,
    category bigint NOT NULL,
    taxid bigint NOT NULL,
    image bytea,
    company bigint,
    cnofeacode character varying,
    brand bigint DEFAULT 0,
    bonusrate real DEFAULT 0 NOT NULL,
    type integer DEFAULT 0 NOT NULL,
    isdiscount boolean DEFAULT true NOT NULL,
    isstaticprice boolean DEFAULT false NOT NULL,
    unitsprid bigint DEFAULT 1 NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    piece boolean DEFAULT false NOT NULL,
    pieceinpack integer DEFAULT 0 NOT NULL,
    attributes bigint DEFAULT 0 NOT NULL,
    details bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.products OWNER TO postgres;

--
-- TOC entry 6329 (class 0 OID 0)
-- Dependencies: 314
-- Name: COLUMN products.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products.type IS 'Тип товара (товар, сертификат и т.д.) 0-товар, 1-сертификат';


--
-- TOC entry 6330 (class 0 OID 0)
-- Dependencies: 314
-- Name: COLUMN products.isdiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products.isdiscount IS 'Признак возможности использования автоматической системы скидок';


--
-- TOC entry 6331 (class 0 OID 0)
-- Dependencies: 314
-- Name: COLUMN products.deleted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products.deleted IS 'Признак удаления (Весовые товары)';


--
-- TOC entry 6332 (class 0 OID 0)
-- Dependencies: 314
-- Name: COLUMN products.piece; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products.piece IS 'Признак возможности распаковать упаковку';


--
-- TOC entry 6333 (class 0 OID 0)
-- Dependencies: 314
-- Name: COLUMN products.pieceinpack; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products.pieceinpack IS 'Количество в упаковке (при возможности распаковки)';


--
-- TOC entry 315 (class 1259 OID 17126)
-- Name: stockcurrent_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stockcurrent_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stockcurrent_id_seq OWNER TO postgres;

--
-- TOC entry 316 (class 1259 OID 17128)
-- Name: stockcurrent; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stockcurrent (
    id bigint DEFAULT nextval('public.stockcurrent_id_seq'::regclass) NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    units numeric(1000,3) NOT NULL,
    attributes bigint NOT NULL,
    sku character varying,
    company bigint DEFAULT 0 NOT NULL,
    hotkey integer,
    scale bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.stockcurrent OWNER TO postgres;

--
-- TOC entry 6334 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN stockcurrent.hotkey; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.stockcurrent.hotkey IS 'Горячая клавиша (только для весовых товаров)';


--
-- TOC entry 6335 (class 0 OID 0)
-- Dependencies: 316
-- Name: COLUMN stockcurrent.scale; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.stockcurrent.scale IS 'Идентификатор весов (только для весовых товаров)';


--
-- TOC entry 317 (class 1259 OID 17137)
-- Name: gl_tp; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.gl_tp AS
 SELECT pt.id,
    pt.code,
    pt.name,
    l.units,
    l.attributes,
    s.units AS su,
    l.newprod
   FROM ((public.invoicelist l
     JOIN public.products pt ON (((pt.id = l.stock) AND (pt.company = l.company))))
     LEFT JOIN public.stockcurrent s ON (((s.product = pt.id) AND (s.company = pt.company))))
  WHERE ((l.invoice = 3716933) AND (s.units IS NULL) AND (l.company = 800))
  ORDER BY pt.id, l.attributes;


ALTER TABLE public.gl_tp OWNER TO postgres;

--
-- TOC entry 318 (class 1259 OID 17142)
-- Name: group_bonus; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.group_bonus AS
SELECT
    NULL::date AS dat,
    NULL::bigint AS id,
    NULL::bigint AS company,
    NULL::double precision AS plan,
    NULL::double precision AS sold,
    NULL::numeric AS total_award,
    NULL::character varying AS name,
    NULL::numeric AS each_award;


ALTER TABLE public.group_bonus OWNER TO postgres;

--
-- TOC entry 319 (class 1259 OID 17146)
-- Name: invoice_object; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoice_object (
    jsonb_build_object jsonb
);


ALTER TABLE public.invoice_object OWNER TO postgres;

--
-- TOC entry 320 (class 1259 OID 17152)
-- Name: invoicelist_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoicelist_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoicelist_id_seq OWNER TO postgres;

--
-- TOC entry 6336 (class 0 OID 0)
-- Dependencies: 320
-- Name: invoicelist_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoicelist_id_seq OWNED BY public.invoicelist.id;


--
-- TOC entry 321 (class 1259 OID 17154)
-- Name: invoices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoices (
    invoicenumber bigint NOT NULL,
    altnumber character varying,
    creator bigint NOT NULL,
    approver bigint,
    status character varying NOT NULL,
    company bigint NOT NULL,
    stockfrom bigint NOT NULL,
    stockto bigint NOT NULL,
    system character varying,
    type bigint NOT NULL,
    invoicedate date NOT NULL,
    approvedate timestamp without time zone,
    counterparty bigint,
    createdate timestamp(6) without time zone DEFAULT now() NOT NULL,
    isconsignment boolean DEFAULT false NOT NULL,
    isweight boolean DEFAULT false NOT NULL,
    scale bigint
);


ALTER TABLE public.invoices OWNER TO postgres;

--
-- TOC entry 6337 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN invoices.isconsignment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.isconsignment IS 'Инвойc консигнатора или клиента';


--
-- TOC entry 6338 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN invoices.isweight; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.isweight IS 'Инвойс по весовым товарам';


--
-- TOC entry 6339 (class 0 OID 0)
-- Dependencies: 321
-- Name: COLUMN invoices.scale; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.invoices.scale IS 'ID весов (для инвойсов по весовым)';


--
-- TOC entry 322 (class 1259 OID 17163)
-- Name: invoices_invoicenumber_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.invoices_invoicenumber_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invoices_invoicenumber_seq OWNER TO postgres;

--
-- TOC entry 6340 (class 0 OID 0)
-- Dependencies: 322
-- Name: invoices_invoicenumber_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.invoices_invoicenumber_seq OWNED BY public.invoices.invoicenumber;


--
-- TOC entry 323 (class 1259 OID 17165)
-- Name: invoicetypes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.invoicetypes (
    id bigint NOT NULL,
    name character varying NOT NULL,
    deleted boolean
);


ALTER TABLE public.invoicetypes OWNER TO postgres;

--
-- TOC entry 324 (class 1259 OID 17171)
-- Name: jobcheck; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.jobcheck (
    jobname character varying(255) NOT NULL,
    last_update_start timestamp(6) without time zone DEFAULT now() NOT NULL,
    last_update_end timestamp(6) without time zone DEFAULT now() NOT NULL
);


ALTER TABLE public.jobcheck OWNER TO postgres;

--
-- TOC entry 463 (class 1259 OID 24578)
-- Name: locales; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.locales (
    id bigint NOT NULL,
    company bigint NOT NULL,
    locales json
);


ALTER TABLE public.locales OWNER TO postgres;

--
-- TOC entry 462 (class 1259 OID 24576)
-- Name: locales_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.locales_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.locales_id_seq OWNER TO postgres;

--
-- TOC entry 6341 (class 0 OID 0)
-- Dependencies: 462
-- Name: locales_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.locales_id_seq OWNED BY public.locales.id;


--
-- TOC entry 325 (class 1259 OID 17176)
-- Name: margin_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.margin_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.margin_id_seq OWNER TO postgres;

--
-- TOC entry 326 (class 1259 OID 17178)
-- Name: margin_plan; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.margin_plan (
    company bigint NOT NULL,
    rate double precision,
    sum double precision,
    type smallint NOT NULL,
    date timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    active boolean DEFAULT true NOT NULL,
    object bigint DEFAULT 0 NOT NULL,
    id bigint DEFAULT nextval('public.margin_id_seq'::regclass) NOT NULL
);


ALTER TABLE public.margin_plan OWNER TO postgres;

--
-- TOC entry 6342 (class 0 OID 0)
-- Dependencies: 326
-- Name: COLUMN margin_plan.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.margin_plan.rate IS 'В процентном выражении';


--
-- TOC entry 327 (class 1259 OID 17185)
-- Name: margin_plan_types; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.margin_plan_types (
    id smallint NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.margin_plan_types OWNER TO postgres;

--
-- TOC entry 328 (class 1259 OID 17189)
-- Name: news; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.news (
    id bigint NOT NULL,
    date timestamp(6) without time zone NOT NULL,
    category smallint NOT NULL,
    header text,
    content text
);


ALTER TABLE public.news OWNER TO postgres;

--
-- TOC entry 329 (class 1259 OID 17195)
-- Name: news_diary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.news_diary (
    news_id bigint NOT NULL,
    user_id bigint NOT NULL,
    flag boolean NOT NULL,
    pk_id bigint NOT NULL
);


ALTER TABLE public.news_diary OWNER TO postgres;

--
-- TOC entry 330 (class 1259 OID 17198)
-- Name: news_diary_pk_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.news_diary_pk_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.news_diary_pk_id_seq OWNER TO postgres;

--
-- TOC entry 6343 (class 0 OID 0)
-- Dependencies: 330
-- Name: news_diary_pk_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.news_diary_pk_id_seq OWNED BY public.news_diary.pk_id;


--
-- TOC entry 331 (class 1259 OID 17200)
-- Name: news_id_sequence; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.news_id_sequence
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.news_id_sequence OWNER TO postgres;

--
-- TOC entry 332 (class 1259 OID 17202)
-- Name: newtable1; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.newtable1 (
    id bigint NOT NULL,
    name1 character varying
);


ALTER TABLE public.newtable1 OWNER TO postgres;

--
-- TOC entry 333 (class 1259 OID 17208)
-- Name: newtable1_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.newtable1 ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.newtable1_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 334 (class 1259 OID 17210)
-- Name: origincodes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.origincodes (
    id bigint NOT NULL,
    name character varying NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.origincodes OWNER TO postgres;

--
-- TOC entry 335 (class 1259 OID 17217)
-- Name: origincodes_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.origincodes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.origincodes_id_seq OWNER TO postgres;

--
-- TOC entry 6344 (class 0 OID 0)
-- Dependencies: 335
-- Name: origincodes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.origincodes_id_seq OWNED BY public.origincodes.id;


--
-- TOC entry 336 (class 1259 OID 17219)
-- Name: p_warehouse; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.p_warehouse (
    stock bigint
);


ALTER TABLE public.p_warehouse OWNER TO postgres;

--
-- TOC entry 337 (class 1259 OID 17222)
-- Name: partners; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.partners (
    id bigint NOT NULL,
    name character varying NOT NULL,
    phone character varying,
    email character varying
);


ALTER TABLE public.partners OWNER TO postgres;

--
-- TOC entry 338 (class 1259 OID 17228)
-- Name: payments_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.payments_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.payments_id_seq OWNER TO postgres;

--
-- TOC entry 339 (class 1259 OID 17230)
-- Name: pluproducts_scale; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.pluproducts_scale (
    id integer NOT NULL,
    product bigint,
    scale integer,
    hotkey integer,
    company bigint
);


ALTER TABLE public.pluproducts_scale OWNER TO postgres;

--
-- TOC entry 340 (class 1259 OID 17234)
-- Name: pluproducts_scale_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.pluproducts_scale_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.pluproducts_scale_id_seq OWNER TO postgres;

--
-- TOC entry 6345 (class 0 OID 0)
-- Dependencies: 340
-- Name: pluproducts_scale_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.pluproducts_scale_id_seq OWNED BY public.pluproducts_scale.id;


--
-- TOC entry 341 (class 1259 OID 17236)
-- Name: point_types; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.point_types (
    id integer NOT NULL,
    name character varying NOT NULL,
    deleted boolean
);


ALTER TABLE public.point_types OWNER TO postgres;

--
-- TOC entry 342 (class 1259 OID 17243)
-- Name: point_types_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.point_types_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.point_types_id_seq OWNER TO postgres;

--
-- TOC entry 6346 (class 0 OID 0)
-- Dependencies: 342
-- Name: point_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.point_types_id_seq OWNED BY public.point_types.id;


--
-- TOC entry 343 (class 1259 OID 17245)
-- Name: points; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.points (
    id bigint NOT NULL,
    name character varying NOT NULL,
    address character varying,
    company bigint NOT NULL,
    point_type integer NOT NULL,
    x character varying,
    y character varying,
    image bytea,
    is_minus boolean DEFAULT false,
    status character varying NOT NULL,
    consignment boolean DEFAULT false NOT NULL,
    ftptransfer boolean DEFAULT false NOT NULL,
    ftpobject bigint,
    ftplogin character varying(255),
    ftppassword character varying(255),
    ftpserver bigint,
    created date DEFAULT CURRENT_DATE NOT NULL
);


ALTER TABLE public.points OWNER TO postgres;

--
-- TOC entry 6347 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN points.consignment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.points.consignment IS 'Признак консигнационного склада';


--
-- TOC entry 6348 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN points.ftptransfer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.points.ftptransfer IS 'Признак передачи данных в ТРЦ';


--
-- TOC entry 6349 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN points.ftpobject; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.points.ftpobject IS 'ID объекта для передачи данных в ТРЦ';


--
-- TOC entry 6350 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN points.ftplogin; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.points.ftplogin IS 'Login для передачи данных в ТРЦ';


--
-- TOC entry 6351 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN points.ftppassword; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.points.ftppassword IS 'Пароль для передачи данных в ТРЦ';


--
-- TOC entry 6352 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN points.ftpserver; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.points.ftpserver IS 'ID сервера ТРЦ';


--
-- TOC entry 6353 (class 0 OID 0)
-- Dependencies: 343
-- Name: COLUMN points.created; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.points.created IS 'Дата заведения';


--
-- TOC entry 344 (class 1259 OID 17255)
-- Name: points_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.points_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.points_id_seq OWNER TO postgres;

--
-- TOC entry 6354 (class 0 OID 0)
-- Dependencies: 344
-- Name: points_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.points_id_seq OWNED BY public.points.id;


--
-- TOC entry 345 (class 1259 OID 17257)
-- Name: pointset; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.pointset (
    point bigint NOT NULL,
    stock bigint NOT NULL
);


ALTER TABLE public.pointset OWNER TO postgres;

--
-- TOC entry 346 (class 1259 OID 17260)
-- Name: prices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.prices (
    id integer NOT NULL,
    product bigint NOT NULL,
    price double precision NOT NULL,
    point bigint NOT NULL,
    userid bigint NOT NULL,
    company bigint NOT NULL,
    workdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP,
    type integer NOT NULL,
    counterparty bigint NOT NULL,
    deleted boolean NOT NULL,
    wholesale_price double precision
);


ALTER TABLE public.prices OWNER TO postgres;

--
-- TOC entry 347 (class 1259 OID 17264)
-- Name: prices_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.prices_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prices_id_seq OWNER TO postgres;

--
-- TOC entry 6355 (class 0 OID 0)
-- Dependencies: 347
-- Name: prices_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.prices_id_seq OWNED BY public.prices.id;


--
-- TOC entry 348 (class 1259 OID 17266)
-- Name: prices_log; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.prices_log (
    product bigint NOT NULL,
    price double precision NOT NULL,
    point bigint NOT NULL,
    userid bigint NOT NULL,
    company bigint NOT NULL,
    workdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP,
    type integer NOT NULL,
    counterparty bigint NOT NULL,
    deleted boolean NOT NULL,
    id integer NOT NULL,
    wholesale_price double precision
);


ALTER TABLE public.prices_log OWNER TO postgres;

--
-- TOC entry 349 (class 1259 OID 17270)
-- Name: prices_log_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.prices_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prices_log_id_seq OWNER TO postgres;

--
-- TOC entry 6356 (class 0 OID 0)
-- Dependencies: 349
-- Name: prices_log_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.prices_log_id_seq OWNED BY public.prices_log.id;


--
-- TOC entry 350 (class 1259 OID 17272)
-- Name: prima_codes; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.prima_codes AS
 SELECT DISTINCT p.code
   FROM public.products p,
    public.counterparty2product cp,
    public.counterparties c
  WHERE ((cp.product = p.id) AND (cp.counterparty = c.id) AND (((c.name)::text ~~* '%прима%'::text) OR ((c.name)::text ~~* '%prima%'::text)));


ALTER TABLE public.prima_codes OWNER TO postgres;

--
-- TOC entry 351 (class 1259 OID 17276)
-- Name: transaction_details; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transaction_details (
    transactionid bigint NOT NULL,
    product bigint NOT NULL,
    units double precision NOT NULL,
    price double precision NOT NULL,
    totalprice double precision NOT NULL,
    taxtotalprice double precision,
    attributes bigint NOT NULL,
    line bigint NOT NULL,
    taxrate double precision,
    cnofeacode character varying,
    bonusadd double precision DEFAULT 0,
    bonuspay double precision DEFAULT 0,
    bonusrate double precision DEFAULT 0,
    discount double precision DEFAULT 0,
    nds double precision DEFAULT 0,
    company bigint DEFAULT 0 NOT NULL,
    ticketdiscount double precision DEFAULT 0,
    invoice bigint DEFAULT 0 NOT NULL,
    piece boolean DEFAULT false,
    pieceunits integer,
    wholesale smallint DEFAULT 0 NOT NULL,
    markup double precision
);


ALTER TABLE public.transaction_details OWNER TO postgres;

--
-- TOC entry 6357 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN transaction_details.invoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transaction_details.invoice IS 'Номер инвойса с которго была продажа (консигнация)';


--
-- TOC entry 6358 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN transaction_details.piece; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transaction_details.piece IS 'Признак распаковки';


--
-- TOC entry 6359 (class 0 OID 0)
-- Dependencies: 351
-- Name: COLUMN transaction_details.pieceunits; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transaction_details.pieceunits IS 'Проданное количество (распакованное)';


--
-- TOC entry 352 (class 1259 OID 17292)
-- Name: transactions_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.transactions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.transactions_id_seq OWNER TO postgres;

--
-- TOC entry 353 (class 1259 OID 17294)
-- Name: transactions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transactions (
    id bigint DEFAULT nextval('public.transactions_id_seq'::regclass) NOT NULL,
    ticketid bigint NOT NULL,
    price double precision NOT NULL,
    cashboxuser bigint NOT NULL,
    cashbox bigint,
    paymenttransid character varying,
    customerid bigint,
    ofdnumber character varying,
    ofdurl character varying,
    status character varying,
    point bigint,
    date timestamp without time zone,
    tickettype bigint NOT NULL,
    paymenttype character varying NOT NULL,
    cardpay double precision,
    cashpay double precision,
    debitpay double precision,
    bonuspay double precision,
    bonusadd double precision,
    bonuscardid bigint DEFAULT 0,
    discount double precision DEFAULT 0,
    company bigint DEFAULT 0 NOT NULL,
    fiz_customerid bigint DEFAULT 0 NOT NULL,
    debtorid bigint DEFAULT 0 NOT NULL,
    sellerid bigint DEFAULT 0 NOT NULL,
    hash character varying(100),
    certpay double precision,
    detailsdiscount double precision DEFAULT 0,
    debtpay double precision DEFAULT 0,
    shiftnumber integer DEFAULT 0,
    consignment boolean DEFAULT false,
    markup double precision,
    tisstatus boolean DEFAULT false,
    tiserror character varying
);


ALTER TABLE public.transactions OWNER TO postgres;

--
-- TOC entry 6360 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.price IS 'Общая сумма чека';


--
-- TOC entry 6361 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.cashboxuser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.cashboxuser IS 'ID пользователя кассы';


--
-- TOC entry 6362 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.cashbox; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.cashbox IS 'ID кассы';


--
-- TOC entry 6363 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.paymenttransid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.paymenttransid IS 'ID транзакции c терминала (карты)';


--
-- TOC entry 6364 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.customerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.customerid IS 'ID клиента (юр)';


--
-- TOC entry 6365 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.ofdnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.ofdnumber IS 'Номер ОФД';


--
-- TOC entry 6366 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.ofdurl; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.ofdurl IS 'Ссылка на чек ОФД';


--
-- TOC entry 6367 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.status IS 'НЕ ИСПОЛЬЗУЕТСЯ!';


--
-- TOC entry 6368 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.point; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.point IS 'ID торговой точки';


--
-- TOC entry 6369 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.date IS 'Дата транзакции';


--
-- TOC entry 6370 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.tickettype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.tickettype IS 'Тип транзакции (продажа, возврат)';


--
-- TOC entry 6371 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.paymenttype; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.paymenttype IS 'Тип платежа (карта, наличка, mix)';


--
-- TOC entry 6372 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.cardpay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.cardpay IS 'Сумма по карте';


--
-- TOC entry 6373 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.cashpay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.cashpay IS 'Сумма нала';


--
-- TOC entry 6374 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.debitpay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.debitpay IS 'Сумма дебетного платежа';


--
-- TOC entry 6375 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.bonuspay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.bonuspay IS 'Оплата бонусами';


--
-- TOC entry 6376 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.bonusadd; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.bonusadd IS 'Начисление бонусов';


--
-- TOC entry 6377 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.bonuscardid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.bonuscardid IS 'ID бонусной записи';


--
-- TOC entry 6378 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.discount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.discount IS 'Скидка на весь чек (не учитываются кидки потоварные)';


--
-- TOC entry 6379 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.company IS 'ID компании';


--
-- TOC entry 6380 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.fiz_customerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.fiz_customerid IS 'ID клиента (физ)';


--
-- TOC entry 6381 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.debtorid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.debtorid IS 'ID должника';


--
-- TOC entry 6382 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.sellerid; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.sellerid IS 'ID консультанта';


--
-- TOC entry 6383 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.hash; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.hash IS 'ХЭШ транзакции';


--
-- TOC entry 6384 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.certpay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.certpay IS 'Израсходованная сума подарочного сертификата';


--
-- TOC entry 6385 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.detailsdiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.detailsdiscount IS 'Сумма всех скидок на товары';


--
-- TOC entry 6386 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.debtpay; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.debtpay IS 'Сумма в долг';


--
-- TOC entry 6387 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.shiftnumber; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.shiftnumber IS 'Номер смены';


--
-- TOC entry 6388 (class 0 OID 0)
-- Dependencies: 353
-- Name: COLUMN transactions.consignment; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.transactions.consignment IS 'Признак консигнационной транзакции';


--
-- TOC entry 354 (class 1259 OID 17312)
-- Name: prima_sku_sales_30d; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.prima_sku_sales_30d AS
 SELECT DISTINCT ON (td.transactionid) td.transactionid,
    t.date,
    td.totalprice,
    td.company,
    p.code,
    p.name AS prod_name,
    c.name AS count_name,
    c.bin
   FROM public.transactions t,
    public.transaction_details td,
    public.counterparty2product cp,
    public.products p,
    public.counterparties c,
    public.prima_codes pc
  WHERE ((t.company = td.company) AND (((t.date)::date >= (CURRENT_DATE - 30)) AND ((t.date)::date <= CURRENT_DATE)) AND (td.transactionid = t.id) AND (cp.product = td.product) AND (td.product = p.id) AND (cp.counterparty = c.id) AND ((p.code)::text = (pc.code)::text));


ALTER TABLE public.prima_sku_sales_30d OWNER TO postgres;

--
-- TOC entry 355 (class 1259 OID 17317)
-- Name: primaview; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.primaview AS
 SELECT td.transactionid,
    t.date,
    td.totalprice,
    td.company,
    p.name AS prod_name,
    c.name AS co_name,
    c.bin
   FROM public.transactions t,
    public.transaction_details td,
    public.counterparty2product cp,
    public.products p,
    public.counterparties c
  WHERE ((t.company = td.company) AND (((t.date)::date >= (CURRENT_DATE - 30)) AND ((t.date)::date <= CURRENT_DATE)) AND (td.transactionid = t.id) AND (cp.product = td.product) AND (td.product = p.id) AND (cp.counterparty = c.id) AND (((c.name)::text ~~* '%прима%'::text) OR ((c.name)::text ~~* '%prima%'::text)));


ALTER TABLE public.primaview OWNER TO postgres;

--
-- TOC entry 356 (class 1259 OID 17322)
-- Name: product_accounting; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_accounting (
    id bigint NOT NULL,
    purchaseprice double precision NOT NULL,
    product bigint NOT NULL,
    units double precision,
    date timestamp(4) without time zone NOT NULL,
    attributes bigint,
    company bigint NOT NULL
);


ALTER TABLE public.product_accounting OWNER TO postgres;

--
-- TOC entry 357 (class 1259 OID 17325)
-- Name: product_accounting_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.product_accounting_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.product_accounting_id_seq OWNER TO postgres;

--
-- TOC entry 6389 (class 0 OID 0)
-- Dependencies: 357
-- Name: product_accounting_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.product_accounting_id_seq OWNED BY public.product_accounting.id;


--
-- TOC entry 571 (class 1259 OID 57427)
-- Name: product_count; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_count (
    count bigint
);


ALTER TABLE public.product_count OWNER TO postgres;

--
-- TOC entry 358 (class 1259 OID 17327)
-- Name: product_static_prices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.product_static_prices (
    product bigint NOT NULL,
    price double precision NOT NULL,
    company bigint DEFAULT 0 NOT NULL
);


ALTER TABLE public.product_static_prices OWNER TO postgres;

--
-- TOC entry 359 (class 1259 OID 17331)
-- Name: products_barcode; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products_barcode (
    id integer NOT NULL,
    product bigint NOT NULL,
    barcode text NOT NULL,
    company bigint
);


ALTER TABLE public.products_barcode OWNER TO postgres;

--
-- TOC entry 360 (class 1259 OID 17337)
-- Name: products_barcode_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.products_barcode_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.products_barcode_id_seq OWNER TO postgres;

--
-- TOC entry 6390 (class 0 OID 0)
-- Dependencies: 360
-- Name: products_barcode_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.products_barcode_id_seq OWNED BY public.products_barcode.id;


--
-- TOC entry 361 (class 1259 OID 17339)
-- Name: products_id_temp_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.products_id_temp_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.products_id_temp_seq OWNER TO postgres;

--
-- TOC entry 362 (class 1259 OID 17341)
-- Name: products_spr_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.products_spr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.products_spr_id_seq OWNER TO postgres;

--
-- TOC entry 363 (class 1259 OID 17343)
-- Name: products_spr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products_spr (
    id bigint DEFAULT nextval('public.products_spr_id_seq'::regclass) NOT NULL,
    code character varying(20) NOT NULL,
    brandid bigint,
    name character varying NOT NULL
);


ALTER TABLE public.products_spr OWNER TO postgres;

--
-- TOC entry 364 (class 1259 OID 17350)
-- Name: products_temp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products_temp (
    id bigint DEFAULT nextval('public.products_id_seq'::regclass) NOT NULL,
    code character varying NOT NULL,
    name character varying NOT NULL,
    category bigint NOT NULL,
    taxid bigint,
    image bytea,
    company bigint,
    cnofeacode character varying,
    brand bigint DEFAULT 0,
    bonusrate real DEFAULT 0 NOT NULL,
    type integer DEFAULT 0 NOT NULL,
    isdiscount boolean DEFAULT true NOT NULL,
    isstaticprice boolean DEFAULT false NOT NULL,
    unitsprid bigint DEFAULT 1 NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    piece boolean DEFAULT false NOT NULL,
    pieceinpack integer DEFAULT 0 NOT NULL,
    attributes_json json,
    attributes bigint DEFAULT 0,
    details bigint DEFAULT 0
);


ALTER TABLE public.products_temp OWNER TO postgres;

--
-- TOC entry 6391 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN products_temp.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products_temp.type IS 'Тип товара (товар, сертификат и т.д.) 0-товар, 1-сертификат';


--
-- TOC entry 6392 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN products_temp.isdiscount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products_temp.isdiscount IS 'Признак возможности использования автоматической системы скидок';


--
-- TOC entry 6393 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN products_temp.deleted; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products_temp.deleted IS 'Признак удаления (Весовые товары)';


--
-- TOC entry 6394 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN products_temp.piece; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products_temp.piece IS 'Признак возможности распаковать упаковку';


--
-- TOC entry 6395 (class 0 OID 0)
-- Dependencies: 364
-- Name: COLUMN products_temp.pieceinpack; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products_temp.pieceinpack IS 'Количество в упаковке (при возможности распаковки)';


--
-- TOC entry 365 (class 1259 OID 17368)
-- Name: products_weight_productsweight_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.products_weight_productsweight_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.products_weight_productsweight_id_seq OWNER TO postgres;

--
-- TOC entry 366 (class 1259 OID 17370)
-- Name: products_weight; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.products_weight (
    name character varying NOT NULL,
    taxid character varying NOT NULL,
    company bigint NOT NULL,
    point bigint NOT NULL,
    "user" bigint,
    createdate timestamp(6) without time zone NOT NULL,
    hotkey bigint NOT NULL,
    amount double precision NOT NULL,
    lastpurchaseprice double precision NOT NULL,
    price double precision NOT NULL,
    scale bigint NOT NULL,
    id bigint,
    isdeleted boolean NOT NULL,
    barcode bigint NOT NULL,
    issaved boolean,
    updateprice boolean,
    isedited boolean NOT NULL,
    productsweight_id integer DEFAULT nextval('public.products_weight_productsweight_id_seq'::regclass) NOT NULL,
    isreserved boolean
);


ALTER TABLE public.products_weight OWNER TO postgres;

--
-- TOC entry 6396 (class 0 OID 0)
-- Dependencies: 366
-- Name: COLUMN products_weight.isreserved; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.products_weight.isreserved IS 'для резерва штрихкодов во временную таблицу инвойсов.';


--
-- TOC entry 367 (class 1259 OID 17377)
-- Name: productsweight_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.productsweight_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.productsweight_id_seq OWNER TO postgres;

--
-- TOC entry 368 (class 1259 OID 17379)
-- Name: promconditions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.promconditions (
    listcode bigint NOT NULL,
    type smallint NOT NULL,
    object bigint DEFAULT 0 NOT NULL,
    amount double precision NOT NULL,
    company bigint NOT NULL
);


ALTER TABLE public.promconditions OWNER TO postgres;

--
-- TOC entry 6397 (class 0 OID 0)
-- Dependencies: 368
-- Name: COLUMN promconditions.listcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promconditions.listcode IS 'ID списка (condlist в promotions)';


--
-- TOC entry 6398 (class 0 OID 0)
-- Dependencies: 368
-- Name: COLUMN promconditions.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promconditions.type IS 'Тип условия';


--
-- TOC entry 6399 (class 0 OID 0)
-- Dependencies: 368
-- Name: COLUMN promconditions.object; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promconditions.object IS 'ID объекта условия (товар, категория и т.д.)';


--
-- TOC entry 6400 (class 0 OID 0)
-- Dependencies: 368
-- Name: COLUMN promconditions.amount; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promconditions.amount IS 'Условия количества (Либо сумма, либо количество)';


--
-- TOC entry 6401 (class 0 OID 0)
-- Dependencies: 368
-- Name: COLUMN promconditions.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promconditions.company IS 'ID компании';


--
-- TOC entry 369 (class 1259 OID 17383)
-- Name: promconditionstype; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.promconditionstype (
    id smallint NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.promconditionstype OWNER TO postgres;

--
-- TOC entry 370 (class 1259 OID 17387)
-- Name: promdiscounts; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.promdiscounts (
    listcode bigint NOT NULL,
    type smallint NOT NULL,
    object bigint DEFAULT 0 NOT NULL,
    rate smallint NOT NULL,
    company bigint NOT NULL
);


ALTER TABLE public.promdiscounts OWNER TO postgres;

--
-- TOC entry 6402 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN promdiscounts.listcode; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promdiscounts.listcode IS 'ID списка (ID списка (disclist в promotions))';


--
-- TOC entry 6403 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN promdiscounts.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promdiscounts.type IS 'Тип скидки';


--
-- TOC entry 6404 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN promdiscounts.object; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promdiscounts.object IS 'ID объекта скидки (чек, товар и т.д.)';


--
-- TOC entry 6405 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN promdiscounts.rate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promdiscounts.rate IS '% Скидки';


--
-- TOC entry 6406 (class 0 OID 0)
-- Dependencies: 370
-- Name: COLUMN promdiscounts.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promdiscounts.company IS 'ID компании';


--
-- TOC entry 371 (class 1259 OID 17391)
-- Name: promdiscountstype; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.promdiscountstype (
    id smallint NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.promdiscountstype OWNER TO postgres;

--
-- TOC entry 372 (class 1259 OID 17395)
-- Name: promotions_condlist_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.promotions_condlist_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.promotions_condlist_seq OWNER TO postgres;

--
-- TOC entry 373 (class 1259 OID 17397)
-- Name: promotions_disclist_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.promotions_disclist_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.promotions_disclist_seq OWNER TO postgres;

--
-- TOC entry 374 (class 1259 OID 17399)
-- Name: promotions_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.promotions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.promotions_id_seq OWNER TO postgres;

--
-- TOC entry 375 (class 1259 OID 17401)
-- Name: promotions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.promotions (
    id bigint DEFAULT nextval('public.promotions_id_seq'::regclass) NOT NULL,
    company bigint NOT NULL,
    point bigint NOT NULL,
    name character varying(255) NOT NULL,
    bdate date NOT NULL,
    edate date NOT NULL,
    condlist bigint DEFAULT nextval('public.promotions_condlist_seq'::regclass) NOT NULL,
    disclist bigint DEFAULT nextval('public.promotions_disclist_seq'::regclass) NOT NULL,
    isactive boolean DEFAULT true NOT NULL,
    priority smallint DEFAULT 0 NOT NULL
);


ALTER TABLE public.promotions OWNER TO postgres;

--
-- TOC entry 6407 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.company; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.company IS 'ID компании';


--
-- TOC entry 6408 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.point; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.point IS 'ID точки';


--
-- TOC entry 6409 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.name; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.name IS 'Наименование акции';


--
-- TOC entry 6410 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.bdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.bdate IS 'Дата начала акции';


--
-- TOC entry 6411 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.edate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.edate IS 'Дата окончания акции';


--
-- TOC entry 6412 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.condlist; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.condlist IS 'ID листа условий';


--
-- TOC entry 6413 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.disclist; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.disclist IS 'ID листа события (скидок)';


--
-- TOC entry 6414 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.isactive; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.isactive IS 'Признак активности акции';


--
-- TOC entry 6415 (class 0 OID 0)
-- Dependencies: 375
-- Name: COLUMN promotions.priority; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.promotions.priority IS 'Приоритет';


--
-- TOC entry 376 (class 1259 OID 17409)
-- Name: reasontypes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reasontypes (
    id integer NOT NULL,
    name character varying NOT NULL,
    deleted boolean NOT NULL,
    visible boolean NOT NULL
);


ALTER TABLE public.reasontypes OWNER TO postgres;

--
-- TOC entry 377 (class 1259 OID 17415)
-- Name: reconciliation_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.reconciliation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.reconciliation_id_seq OWNER TO postgres;

--
-- TOC entry 378 (class 1259 OID 17417)
-- Name: reconciliation; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reconciliation (
    id bigint DEFAULT nextval('public.reconciliation_id_seq'::regclass) NOT NULL,
    begin_date timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    company bigint NOT NULL,
    point bigint NOT NULL,
    out_data json,
    in_data json,
    result json,
    end_date timestamp(6) without time zone,
    status smallint DEFAULT 0 NOT NULL,
    userid bigint NOT NULL
);


ALTER TABLE public.reconciliation OWNER TO postgres;

--
-- TOC entry 6416 (class 0 OID 0)
-- Dependencies: 378
-- Name: COLUMN reconciliation.out_data; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.reconciliation.out_data IS 'данные для ТСД';


--
-- TOC entry 6417 (class 0 OID 0)
-- Dependencies: 378
-- Name: COLUMN reconciliation.in_data; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.reconciliation.in_data IS 'данные из ТСД';


--
-- TOC entry 6418 (class 0 OID 0)
-- Dependencies: 378
-- Name: COLUMN reconciliation.result; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.reconciliation.result IS 'результат ревизии';


--
-- TOC entry 6419 (class 0 OID 0)
-- Dependencies: 378
-- Name: COLUMN reconciliation.end_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.reconciliation.end_date IS 'дата завершения';


--
-- TOC entry 6420 (class 0 OID 0)
-- Dependencies: 378
-- Name: COLUMN reconciliation.status; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.reconciliation.status IS '0-активна, 1 - завершена, 2 - отменена/удалена';


--
-- TOC entry 379 (class 1259 OID 17426)
-- Name: result; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.result (
    json_build_object json,
    id bigint NOT NULL
);


ALTER TABLE public.result OWNER TO postgres;

--
-- TOC entry 380 (class 1259 OID 17432)
-- Name: result_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.result_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.result_id_seq OWNER TO postgres;

--
-- TOC entry 6421 (class 0 OID 0)
-- Dependencies: 380
-- Name: result_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.result_id_seq OWNED BY public.result.id;


--
-- TOC entry 381 (class 1259 OID 17434)
-- Name: rev_temp_id; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.rev_temp_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rev_temp_id OWNER TO postgres;

--
-- TOC entry 382 (class 1259 OID 17436)
-- Name: reviselist; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.reviselist (
    id bigint NOT NULL,
    product bigint NOT NULL,
    declaration character varying NOT NULL,
    "position" character varying(32),
    truorigincode integer NOT NULL,
    units double precision NOT NULL,
    company bigint NOT NULL,
    "user" bigint,
    esfid bigint,
    unitcode character varying(255)
);


ALTER TABLE public.reviselist OWNER TO postgres;

--
-- TOC entry 383 (class 1259 OID 17442)
-- Name: reviselist_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.reviselist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.reviselist_id_seq OWNER TO postgres;

--
-- TOC entry 6422 (class 0 OID 0)
-- Dependencies: 383
-- Name: reviselist_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.reviselist_id_seq OWNED BY public.reviselist.id;


--
-- TOC entry 384 (class 1259 OID 17444)
-- Name: revision_diary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revision_diary (
    createdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    revisiondate timestamp(6) without time zone DEFAULT date_trunc('second'::text, CURRENT_TIMESTAMP) NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision NOT NULL,
    unitswas double precision NOT NULL,
    company bigint NOT NULL,
    point bigint NOT NULL,
    "user" bigint,
    superviser character varying,
    submitdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP,
    price double precision,
    revisionnumber bigint NOT NULL,
    outofrevision bigint DEFAULT 2,
    editdate timestamp(6) without time zone,
    units_inserted double precision,
    reason text
);


ALTER TABLE public.revision_diary OWNER TO postgres;

--
-- TOC entry 385 (class 1259 OID 17454)
-- Name: revision_difference; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revision_difference (
    barcode character varying(20) NOT NULL,
    name character varying NOT NULL,
    product bigint NOT NULL,
    purchaseprice double precision NOT NULL,
    sellprice bigint NOT NULL,
    units double precision NOT NULL,
    date timestamp(6) without time zone NOT NULL,
    attributes bigint NOT NULL,
    attrvalue character varying,
    company bigint NOT NULL,
    point bigint NOT NULL,
    "user" bigint NOT NULL,
    revision_submit_date timestamp(6) without time zone,
    id bigint NOT NULL
);


ALTER TABLE public.revision_difference OWNER TO postgres;

--
-- TOC entry 386 (class 1259 OID 17460)
-- Name: revision_difference_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.revision_difference_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.revision_difference_id_seq OWNER TO postgres;

--
-- TOC entry 6423 (class 0 OID 0)
-- Dependencies: 386
-- Name: revision_difference_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.revision_difference_id_seq OWNED BY public.revision_difference.id;


--
-- TOC entry 387 (class 1259 OID 17462)
-- Name: revision_list; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revision_list (
    id integer NOT NULL,
    revisionnumber bigint NOT NULL,
    point bigint,
    company bigint NOT NULL,
    createdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP,
    submitdate timestamp(6) without time zone,
    status character varying(20) DEFAULT 'ACTIVE'::character varying,
    outofrevision integer,
    admin bigint,
    type smallint DEFAULT 1 NOT NULL,
    type_id bigint
);


ALTER TABLE public.revision_list OWNER TO postgres;

--
-- TOC entry 6424 (class 0 OID 0)
-- Dependencies: 387
-- Name: COLUMN revision_list.type; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revision_list.type IS '1 - все товары, 2 - по бренду, 3 - по категории';


--
-- TOC entry 388 (class 1259 OID 17468)
-- Name: revision_list_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.revision_list_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.revision_list_id_seq OWNER TO postgres;

--
-- TOC entry 6425 (class 0 OID 0)
-- Dependencies: 388
-- Name: revision_list_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.revision_list_id_seq OWNED BY public.revision_list.id;


--
-- TOC entry 389 (class 1259 OID 17470)
-- Name: revision_temp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revision_temp (
    createdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    units double precision NOT NULL,
    point bigint NOT NULL,
    "user" bigint NOT NULL,
    company bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    unitswas double precision,
    revisionnumber bigint,
    outofrevision smallint DEFAULT 2,
    editdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP,
    units_inserted double precision,
    id bigint DEFAULT nextval('public.rev_temp_id'::regclass) NOT NULL
);


ALTER TABLE public.revision_temp OWNER TO postgres;

--
-- TOC entry 6426 (class 0 OID 0)
-- Dependencies: 389
-- Name: COLUMN revision_temp.createdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revision_temp.createdate IS 'Дата создания записи';


--
-- TOC entry 6427 (class 0 OID 0)
-- Dependencies: 389
-- Name: COLUMN revision_temp.units; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revision_temp.units IS 'Новое количество товаров';


--
-- TOC entry 6428 (class 0 OID 0)
-- Dependencies: 389
-- Name: COLUMN revision_temp."user"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revision_temp."user" IS 'Пользователь проводивший ревизию';


--
-- TOC entry 390 (class 1259 OID 17477)
-- Name: revisiondiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revisiondiary (
    createdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    revisiondate timestamp(6) without time zone DEFAULT date_trunc('second'::text, CURRENT_TIMESTAMP) NOT NULL,
    units double precision NOT NULL,
    unitswas double precision NOT NULL,
    point bigint NOT NULL,
    "user" bigint,
    company bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    superviser character varying,
    submitdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP,
    price double precision,
    revisionnumber bigint,
    outofrevision smallint DEFAULT 2,
    editdate timestamp(6) without time zone,
    units_inserted double precision,
    id bigint NOT NULL
);


ALTER TABLE public.revisiondiary OWNER TO postgres;

--
-- TOC entry 6429 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary.createdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary.createdate IS 'Дата создания записи';


--
-- TOC entry 6430 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary.revisiondate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary.revisiondate IS 'Время когда ревизор отсканировал первый товар';


--
-- TOC entry 6431 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary.units; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary.units IS 'Новое количество товаров';


--
-- TOC entry 6432 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary.unitswas; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary.unitswas IS 'Количсетво товаров на момент когда ревизор отсканировал первый товар';


--
-- TOC entry 6433 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary."user"; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary."user" IS 'Пользователь проводивший ревизию';


--
-- TOC entry 6434 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary.superviser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary.superviser IS 'Проверяющий ревизию';


--
-- TOC entry 6435 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary.submitdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary.submitdate IS 'Дата подтвержения проверяющим';


--
-- TOC entry 6436 (class 0 OID 0)
-- Dependencies: 390
-- Name: COLUMN revisiondiary.price; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.revisiondiary.price IS 'Цена на момент ревизии';


--
-- TOC entry 391 (class 1259 OID 17487)
-- Name: revisiondiary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.revisiondiary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.revisiondiary_id_seq OWNER TO postgres;

--
-- TOC entry 6437 (class 0 OID 0)
-- Dependencies: 391
-- Name: revisiondiary_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.revisiondiary_id_seq OWNED BY public.revisiondiary.id;


--
-- TOC entry 392 (class 1259 OID 17489)
-- Name: revisiondiary_old; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revisiondiary_old (
    createdate timestamp(6) without time zone,
    revisiondate timestamp(6) without time zone,
    units double precision,
    unitswas double precision,
    unitswhileinsert double precision,
    point bigint,
    "user" bigint,
    company bigint,
    product bigint,
    attributes bigint,
    revtype smallint,
    superviser character varying,
    submitdate timestamp(6) without time zone,
    price double precision,
    revsubmit smallint,
    revcondition smallint,
    stock bigint,
    revisionnumber bigint,
    outforevision smallint,
    id bigint NOT NULL
);


ALTER TABLE public.revisiondiary_old OWNER TO postgres;

--
-- TOC entry 393 (class 1259 OID 17495)
-- Name: revisiondiary_old_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.revisiondiary_old_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.revisiondiary_old_id_seq OWNER TO postgres;

--
-- TOC entry 6438 (class 0 OID 0)
-- Dependencies: 393
-- Name: revisiondiary_old_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.revisiondiary_old_id_seq OWNED BY public.revisiondiary_old.id;


--
-- TOC entry 394 (class 1259 OID 17497)
-- Name: revisiontemp; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.revisiontemp (
    revisionnumber bigint NOT NULL,
    createdate timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units double precision DEFAULT 0 NOT NULL,
    unitswas bigint NOT NULL,
    revisiondate timestamp(6) without time zone,
    company bigint NOT NULL,
    point bigint NOT NULL,
    "user" bigint NOT NULL,
    reason text,
    outofrevision bigint,
    editdate timestamp(6) without time zone,
    units_inserted double precision
);


ALTER TABLE public.revisiontemp OWNER TO postgres;

--
-- TOC entry 395 (class 1259 OID 17505)
-- Name: salesplan; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.salesplan (
    object bigint NOT NULL,
    daily double precision,
    monthly double precision,
    quarterly double precision,
    yearly double precision,
    type integer NOT NULL,
    drate double precision DEFAULT 0,
    mrate double precision DEFAULT 0,
    qrate double precision DEFAULT 0,
    yrate double precision DEFAULT 0
);


ALTER TABLE public.salesplan OWNER TO postgres;

--
-- TOC entry 6439 (class 0 OID 0)
-- Dependencies: 395
-- Name: COLUMN salesplan.drate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.salesplan.drate IS '% ставка для расчета бонуса';


--
-- TOC entry 396 (class 1259 OID 17512)
-- Name: salesplan_types; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.salesplan_types (
    id integer NOT NULL,
    name character varying NOT NULL,
    deleted boolean DEFAULT false NOT NULL
);


ALTER TABLE public.salesplan_types OWNER TO postgres;

--
-- TOC entry 397 (class 1259 OID 17519)
-- Name: salesplan_types_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.salesplan_types_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.salesplan_types_id_seq OWNER TO postgres;

--
-- TOC entry 6440 (class 0 OID 0)
-- Dependencies: 397
-- Name: salesplan_types_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.salesplan_types_id_seq OWNED BY public.salesplan_types.id;


--
-- TOC entry 398 (class 1259 OID 17521)
-- Name: scale_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.scale_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.scale_id_seq OWNER TO postgres;

--
-- TOC entry 399 (class 1259 OID 17523)
-- Name: scale; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.scale (
    id bigint DEFAULT nextval('public.scale_id_seq'::regclass) NOT NULL,
    name character varying(255) NOT NULL,
    deleted boolean NOT NULL,
    company bigint NOT NULL,
    point bigint
);


ALTER TABLE public.scale OWNER TO postgres;

--
-- TOC entry 400 (class 1259 OID 17527)
-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.schema_migrations (
    version bigint NOT NULL,
    dirty boolean NOT NULL
);


ALTER TABLE public.schema_migrations OWNER TO postgres;

--
-- TOC entry 401 (class 1259 OID 17530)
-- Name: seizurelist; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.seizurelist (
    code character varying NOT NULL
);


ALTER TABLE public.seizurelist OWNER TO postgres;

--
-- TOC entry 402 (class 1259 OID 17536)
-- Name: settings; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.settings (
    name character varying(50),
    value character varying(255),
    company bigint,
    id bigint NOT NULL
);


ALTER TABLE public.settings OWNER TO postgres;

--
-- TOC entry 403 (class 1259 OID 17539)
-- Name: settings_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.settings_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.settings_id_seq OWNER TO postgres;

--
-- TOC entry 6441 (class 0 OID 0)
-- Dependencies: 403
-- Name: settings_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.settings_id_seq OWNED BY public.settings.id;


--
-- TOC entry 404 (class 1259 OID 17541)
-- Name: songs; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs (
    id bigint NOT NULL,
    "group" character varying,
    song character varying,
    songtext json,
    datesozd date,
    datecreate timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE public.songs OWNER TO postgres;

--
-- TOC entry 405 (class 1259 OID 17548)
-- Name: songs1; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs1 (
    id bigint NOT NULL,
    "group" character varying,
    song character varying,
    datesozd date,
    songtext character varying,
    detecreate timestamp without time zone
);


ALTER TABLE public.songs1 OWNER TO postgres;

--
-- TOC entry 406 (class 1259 OID 17554)
-- Name: songs10; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs10 (
    id bigint NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    "group" text,
    song text,
    release_date timestamp with time zone,
    text text,
    link text
);


ALTER TABLE public.songs10 OWNER TO postgres;

--
-- TOC entry 407 (class 1259 OID 17560)
-- Name: songs1_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.songs1 ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME public.songs1_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 408 (class 1259 OID 17562)
-- Name: songs2; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs2 (
    id bigint NOT NULL,
    "group" character varying,
    song character varying,
    songtext character varying,
    datesozd date,
    detecreate timestamp without time zone,
    column1 boolean
);


ALTER TABLE public.songs2 OWNER TO postgres;

--
-- TOC entry 409 (class 1259 OID 17568)
-- Name: songs3; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs3 (
    id bigint NOT NULL,
    "group" character varying,
    song character varying,
    songtext character varying,
    datesozd date,
    detecreate timestamp without time zone
);


ALTER TABLE public.songs3 OWNER TO postgres;

--
-- TOC entry 410 (class 1259 OID 17574)
-- Name: songs3_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.songs3 ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.songs3_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 411 (class 1259 OID 17576)
-- Name: songs4; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs4 (
    id bigint NOT NULL,
    "group" character varying,
    song character varying,
    songtext json,
    datesozd date,
    datecreate timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE public.songs4 OWNER TO postgres;

--
-- TOC entry 412 (class 1259 OID 17583)
-- Name: songs5; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs5 (
    id bigint NOT NULL,
    "group" text,
    song text,
    songtext json,
    datesozd date,
    datecreate timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    release_date text,
    text text,
    link text
);


ALTER TABLE public.songs5 OWNER TO postgres;

--
-- TOC entry 413 (class 1259 OID 17590)
-- Name: songs8; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs8 (
    id bigint NOT NULL,
    "group" character varying,
    song character varying,
    songtext json,
    datesozd date,
    datecreate timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE public.songs8 OWNER TO postgres;

--
-- TOC entry 414 (class 1259 OID 17597)
-- Name: songs8_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.songs8 ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.songs8_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 415 (class 1259 OID 17599)
-- Name: songs9; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.songs9 (
    id bigint NOT NULL,
    created_at timestamp with time zone,
    updated_at timestamp with time zone,
    deleted_at timestamp with time zone,
    "group" text,
    song text,
    release_date text,
    text text,
    link text
);


ALTER TABLE public.songs9 OWNER TO postgres;

--
-- TOC entry 416 (class 1259 OID 17605)
-- Name: songs_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.songs4 ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.songs_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 417 (class 1259 OID 17607)
-- Name: songs_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.songs5 ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.songs_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 418 (class 1259 OID 17609)
-- Name: songs_id_seq2; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.songs_id_seq2
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.songs_id_seq2 OWNER TO postgres;

--
-- TOC entry 6442 (class 0 OID 0)
-- Dependencies: 418
-- Name: songs_id_seq2; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.songs_id_seq2 OWNED BY public.songs9.id;


--
-- TOC entry 419 (class 1259 OID 17611)
-- Name: songs_id_seq3; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.songs_id_seq3
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.songs_id_seq3 OWNER TO postgres;

--
-- TOC entry 6443 (class 0 OID 0)
-- Dependencies: 419
-- Name: songs_id_seq3; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.songs_id_seq3 OWNED BY public.songs10.id;


--
-- TOC entry 420 (class 1259 OID 17613)
-- Name: songs_id_seq4; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.songs ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.songs_id_seq4
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 421 (class 1259 OID 17615)
-- Name: stock_minmax; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stock_minmax (
    point bigint,
    product bigint,
    mincount bigint,
    maxcount bigint,
    id bigint NOT NULL,
    enabled boolean
);


ALTER TABLE public.stock_minmax OWNER TO postgres;

--
-- TOC entry 422 (class 1259 OID 17618)
-- Name: stock_minmax_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stock_minmax_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stock_minmax_id_seq OWNER TO postgres;

--
-- TOC entry 6444 (class 0 OID 0)
-- Dependencies: 422
-- Name: stock_minmax_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stock_minmax_id_seq OWNED BY public.stock_minmax.id;


--
-- TOC entry 423 (class 1259 OID 17620)
-- Name: stockcurrent_part; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stockcurrent_part (
    company bigint DEFAULT 0 NOT NULL,
    point bigint NOT NULL,
    product bigint NOT NULL,
    attributes bigint NOT NULL,
    units numeric(1000,3) NOT NULL,
    date date NOT NULL,
    purchaseprice double precision NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.stockcurrent_part OWNER TO postgres;

--
-- TOC entry 424 (class 1259 OID 17624)
-- Name: stockcurrent_part_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stockcurrent_part_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stockcurrent_part_id_seq OWNER TO postgres;

--
-- TOC entry 6445 (class 0 OID 0)
-- Dependencies: 424
-- Name: stockcurrent_part_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stockcurrent_part_id_seq OWNED BY public.stockcurrent_part.id;


--
-- TOC entry 425 (class 1259 OID 17626)
-- Name: stockdiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.stockdiary (
    date timestamp without time zone NOT NULL,
    reason integer NOT NULL,
    point bigint NOT NULL,
    units numeric(1000,3) NOT NULL,
    price double precision,
    product bigint NOT NULL,
    attributes bigint,
    "SKU" character varying,
    invoice bigint,
    company bigint DEFAULT 0 NOT NULL,
    purchaseprice double precision,
    transactionid bigint,
    purchasedate date,
    customer bigint,
    cashboxuser bigint,
    consignmentdate timestamp(6) without time zone,
    consignmentinvoice bigint,
    pieceprice double precision,
    id bigint NOT NULL,
    scp_units_before numeric(1000,3),
    scp_units_after numeric(1000,3),
    sc_units_before numeric(1000,3),
    sc_units_after numeric(1000,3),
    comments character varying,
    sc_id bigint,
    scp_id bigint
);


ALTER TABLE public.stockdiary OWNER TO postgres;

--
-- TOC entry 6446 (class 0 OID 0)
-- Dependencies: 425
-- Name: COLUMN stockdiary.customer; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.stockdiary.customer IS 'ID юр. клиента (консигнация)';


--
-- TOC entry 6447 (class 0 OID 0)
-- Dependencies: 425
-- Name: COLUMN stockdiary.cashboxuser; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.stockdiary.cashboxuser IS 'ID пользователя кассы (консигнация)';


--
-- TOC entry 6448 (class 0 OID 0)
-- Dependencies: 425
-- Name: COLUMN stockdiary.consignmentdate; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.stockdiary.consignmentdate IS 'Дата операции на кассе';


--
-- TOC entry 6449 (class 0 OID 0)
-- Dependencies: 425
-- Name: COLUMN stockdiary.consignmentinvoice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.stockdiary.consignmentinvoice IS 'Консигнационный инвойс (с кассы)';


--
-- TOC entry 6450 (class 0 OID 0)
-- Dependencies: 425
-- Name: COLUMN stockdiary.pieceprice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.stockdiary.pieceprice IS 'Штучная стоимость (для распакованных товаров)';


--
-- TOC entry 426 (class 1259 OID 17633)
-- Name: stockdiary_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stockdiary_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stockdiary_id_seq OWNER TO postgres;

--
-- TOC entry 427 (class 1259 OID 17635)
-- Name: stockdiary_id_seq1; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stockdiary_id_seq1
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stockdiary_id_seq1 OWNER TO postgres;

--
-- TOC entry 6451 (class 0 OID 0)
-- Dependencies: 427
-- Name: stockdiary_id_seq1; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stockdiary_id_seq1 OWNED BY public.stockdiary.id;


--
-- TOC entry 428 (class 1259 OID 17637)
-- Name: stockdiary_sc_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stockdiary_sc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stockdiary_sc_id_seq OWNER TO postgres;

--
-- TOC entry 6452 (class 0 OID 0)
-- Dependencies: 428
-- Name: stockdiary_sc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stockdiary_sc_id_seq OWNED BY public.stockdiary.sc_id;


--
-- TOC entry 429 (class 1259 OID 17639)
-- Name: stockdiary_scp_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stockdiary_scp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stockdiary_scp_id_seq OWNER TO postgres;

--
-- TOC entry 6453 (class 0 OID 0)
-- Dependencies: 429
-- Name: stockdiary_scp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.stockdiary_scp_id_seq OWNED BY public.stockdiary.scp_id;


--
-- TOC entry 430 (class 1259 OID 17641)
-- Name: stocklevel_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.stocklevel_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stocklevel_id_seq OWNER TO postgres;

--
-- TOC entry 431 (class 1259 OID 17643)
-- Name: stockproduct; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.stockproduct AS
 SELECT pr.id AS product,
    pr.code,
    pr.name,
    s.attributes,
    pr.brand AS brandid,
    COALESCE(b.brand, 'Бренд не указан'::character varying) AS brand,
    pr.category AS categoryid,
    COALESCE(ca.name, 'Бренд не указан'::character varying) AS category,
    pr.taxid,
        CASE
            WHEN (pr.taxid = 0) THEN 'Без НДС'::text
            ELSE 'С НДС'::text
        END AS tax,
    pr.company,
    s.point,
    s.units,
    s.price,
    COALESCE(s.purchaseprice, (0)::double precision) AS purchaseprice,
    s.date,
    s.transactionid
   FROM (((public.stockdiary s
     LEFT JOIN public.products pr ON ((s.product = pr.id)))
     JOIN public.categories ca ON ((ca.id = pr.category)))
     JOIN public.brands b ON ((pr.brand = b.id)))
  WHERE (s.reason = '-1'::integer)
  ORDER BY pr.id;


ALTER TABLE public.stockproduct OWNER TO postgres;

--
-- TOC entry 432 (class 1259 OID 17648)
-- Name: storeprices; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.storeprices (
    store bigint NOT NULL,
    stock bigint NOT NULL,
    price double precision NOT NULL,
    company bigint DEFAULT 0 NOT NULL,
    pieceprice double precision DEFAULT 0.0 NOT NULL,
    wholesale_price real DEFAULT 0 NOT NULL
);


ALTER TABLE public.storeprices OWNER TO postgres;

--
-- TOC entry 6454 (class 0 OID 0)
-- Dependencies: 432
-- Name: COLUMN storeprices.pieceprice; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.storeprices.pieceprice IS 'Штучная стоимость (для распакованных товаров)';


--
-- TOC entry 433 (class 1259 OID 17654)
-- Name: systemmessage; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.systemmessage (
    point bigint NOT NULL,
    invoice bigint NOT NULL,
    type_message smallint NOT NULL,
    altinvoice character varying,
    cashbox bigint NOT NULL,
    date date DEFAULT now(),
    id bigint NOT NULL
);


ALTER TABLE public.systemmessage OWNER TO postgres;

--
-- TOC entry 6455 (class 0 OID 0)
-- Dependencies: 433
-- Name: COLUMN systemmessage.date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.systemmessage.date IS 'Дата инвойса';


--
-- TOC entry 434 (class 1259 OID 17661)
-- Name: systemmessage_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.systemmessage_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.systemmessage_id_seq OWNER TO postgres;

--
-- TOC entry 6456 (class 0 OID 0)
-- Dependencies: 434
-- Name: systemmessage_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.systemmessage_id_seq OWNED BY public.systemmessage.id;


--
-- TOC entry 435 (class 1259 OID 17663)
-- Name: taxcategories_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.taxcategories_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxcategories_id_seq OWNER TO postgres;

--
-- TOC entry 436 (class 1259 OID 17665)
-- Name: taxes; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.taxes (
    id bigint NOT NULL,
    name character varying NOT NULL,
    validfrom timestamp without time zone DEFAULT '2001-01-01 00:00:00'::timestamp without time zone NOT NULL,
    category bigint NOT NULL,
    parentid bigint,
    rate double precision NOT NULL,
    ratecascade boolean DEFAULT false NOT NULL,
    rateorder integer
);


ALTER TABLE public.taxes OWNER TO postgres;

--
-- TOC entry 437 (class 1259 OID 17673)
-- Name: team_daily; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.team_daily AS
SELECT
    NULL::date AS dat,
    NULL::bigint AS id,
    NULL::bigint AS company,
    NULL::double precision AS plan,
    NULL::double precision AS drate,
    NULL::double precision AS sold,
    NULL::numeric AS total_award,
    NULL::character varying AS name,
    NULL::numeric AS each_award;


ALTER TABLE public.team_daily OWNER TO postgres;

--
-- TOC entry 438 (class 1259 OID 17677)
-- Name: team_monthly; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.team_monthly AS
SELECT
    NULL::date AS dat,
    NULL::bigint AS id,
    NULL::bigint AS company,
    NULL::double precision AS plan,
    NULL::double precision AS mrate,
    NULL::double precision AS sold,
    NULL::numeric AS total_award,
    NULL::character varying AS name,
    NULL::numeric AS each_award;


ALTER TABLE public.team_monthly OWNER TO postgres;

--
-- TOC entry 439 (class 1259 OID 17681)
-- Name: team_quarterly; Type: VIEW; Schema: public; Owner: postgres
--

CREATE VIEW public.team_quarterly AS
SELECT
    NULL::date AS dat,
    NULL::bigint AS id,
    NULL::bigint AS company,
    NULL::double precision AS plan,
    NULL::double precision AS qrate,
    NULL::double precision AS sold,
    NULL::numeric AS total_award,
    NULL::character varying AS name,
    NULL::numeric AS each_award;


ALTER TABLE public.team_quarterly OWNER TO postgres;

--
-- TOC entry 440 (class 1259 OID 17685)
-- Name: tezmodules_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.tezmodules_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tezmodules_seq OWNER TO postgres;

--
-- TOC entry 441 (class 1259 OID 17687)
-- Name: tezmodules; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tezmodules (
    id bigint DEFAULT nextval('public.tezmodules_seq'::regclass) NOT NULL,
    namemodules character varying
);


ALTER TABLE public.tezmodules OWNER TO postgres;

--
-- TOC entry 442 (class 1259 OID 17694)
-- Name: tezmodules_access_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.tezmodules_access_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tezmodules_access_seq OWNER TO postgres;

--
-- TOC entry 443 (class 1259 OID 17696)
-- Name: tezmodules_access; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.tezmodules_access (
    id bigint DEFAULT nextval('public.tezmodules_access_seq'::regclass) NOT NULL,
    company_id bigint NOT NULL,
    tezmodule_id bigint NOT NULL
);


ALTER TABLE public.tezmodules_access OWNER TO postgres;

--
-- TOC entry 444 (class 1259 OID 17700)
-- Name: ticket_format; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.ticket_format (
    company bigint NOT NULL,
    json jsonb NOT NULL,
    point bigint NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.ticket_format OWNER TO postgres;

--
-- TOC entry 445 (class 1259 OID 17706)
-- Name: ticket_format_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ticket_format_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ticket_format_id_seq OWNER TO postgres;

--
-- TOC entry 6457 (class 0 OID 0)
-- Dependencies: 445
-- Name: ticket_format_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.ticket_format_id_seq OWNED BY public.ticket_format.id;


--
-- TOC entry 446 (class 1259 OID 17708)
-- Name: ticketlines_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.ticketlines_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ticketlines_id_seq OWNER TO postgres;

--
-- TOC entry 447 (class 1259 OID 17710)
-- Name: tickets_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.tickets_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tickets_id_seq OWNER TO postgres;

--
-- TOC entry 448 (class 1259 OID 17712)
-- Name: transaction_promotions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.transaction_promotions (
    transactionid bigint NOT NULL,
    product bigint,
    attributes bigint,
    company bigint NOT NULL,
    promotion bigint NOT NULL,
    amount double precision NOT NULL,
    id bigint NOT NULL
);


ALTER TABLE public.transaction_promotions OWNER TO postgres;

--
-- TOC entry 449 (class 1259 OID 17715)
-- Name: transaction_promotions_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.transaction_promotions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.transaction_promotions_id_seq OWNER TO postgres;

--
-- TOC entry 6458 (class 0 OID 0)
-- Dependencies: 449
-- Name: transaction_promotions_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.transaction_promotions_id_seq OWNED BY public.transaction_promotions.id;


--
-- TOC entry 450 (class 1259 OID 17717)
-- Name: unit_spr_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.unit_spr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.unit_spr_id_seq OWNER TO postgres;

--
-- TOC entry 451 (class 1259 OID 17719)
-- Name: unit_spr; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.unit_spr (
    id bigint DEFAULT nextval('public.unit_spr_id_seq'::regclass) NOT NULL,
    esfid character varying(255),
    name character varying(255) NOT NULL,
    shortname character varying(255),
    fps smallint DEFAULT 2,
    deleted boolean NOT NULL
);


ALTER TABLE public.unit_spr OWNER TO postgres;

--
-- TOC entry 6459 (class 0 OID 0)
-- Dependencies: 451
-- Name: COLUMN unit_spr.fps; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.unit_spr.fps IS 'количество знаков после запятой';


--
-- TOC entry 452 (class 1259 OID 17727)
-- Name: user2roles; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.user2roles (
    "user" bigint NOT NULL,
    role bigint NOT NULL
);


ALTER TABLE public.user2roles OWNER TO postgres;

--
-- TOC entry 453 (class 1259 OID 17730)
-- Name: versions; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.versions (
    id integer NOT NULL,
    name text,
    created timestamp without time zone
);


ALTER TABLE public.versions OWNER TO postgres;

--
-- TOC entry 454 (class 1259 OID 17736)
-- Name: versions_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

ALTER TABLE public.versions ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME public.versions_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);


--
-- TOC entry 455 (class 1259 OID 17738)
-- Name: versions_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.versions_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.versions_seq OWNER TO postgres;

--
-- TOC entry 456 (class 1259 OID 17740)
-- Name: workorder; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.workorder (
    id integer NOT NULL,
    company bigint NOT NULL,
    date timestamp(6) without time zone DEFAULT CURRENT_TIMESTAMP,
    workorder_number character varying,
    point bigint NOT NULL,
    userid bigint NOT NULL,
    status character varying DEFAULT 'FORMATION'::character varying,
    accept_user bigint,
    accept_date timestamp(6) without time zone,
    counterparty bigint,
    approve_date timestamp(6) without time zone
);


ALTER TABLE public.workorder OWNER TO postgres;

--
-- TOC entry 6460 (class 0 OID 0)
-- Dependencies: 456
-- Name: COLUMN workorder.accept_user; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workorder.accept_user IS 'Пользователь, который принимает заказ-наряд';


--
-- TOC entry 6461 (class 0 OID 0)
-- Dependencies: 456
-- Name: COLUMN workorder.accept_date; Type: COMMENT; Schema: public; Owner: postgres
--

COMMENT ON COLUMN public.workorder.accept_date IS 'Дата принятия заказ-наряда';


--
-- TOC entry 457 (class 1259 OID 17748)
-- Name: workorder_details; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.workorder_details (
    id integer NOT NULL,
    product bigint,
    price double precision DEFAULT 0,
    units double precision,
    accepted_units double precision,
    workorder_id bigint,
    attributes bigint DEFAULT 0,
    purchaseprice real NOT NULL,
    counterparty bigint,
    wholesale_price double precision,
    status character varying
);


ALTER TABLE public.workorder_details OWNER TO postgres;

--
-- TOC entry 458 (class 1259 OID 17756)
-- Name: workorder_details_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.workorder_details_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.workorder_details_id_seq OWNER TO postgres;

--
-- TOC entry 6462 (class 0 OID 0)
-- Dependencies: 458
-- Name: workorder_details_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.workorder_details_id_seq OWNED BY public.workorder_details.id;


--
-- TOC entry 459 (class 1259 OID 17758)
-- Name: workorder_id_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.workorder_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.workorder_id_seq OWNER TO postgres;

--
-- TOC entry 6463 (class 0 OID 0)
-- Dependencies: 459
-- Name: workorder_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.workorder_id_seq OWNED BY public.workorder.id;


--
-- TOC entry 460 (class 1259 OID 17760)
-- Name: workorder_seq; Type: SEQUENCE; Schema: public; Owner: postgres
--

CREATE SEQUENCE public.workorder_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.workorder_seq OWNER TO postgres;

--
-- TOC entry 6464 (class 0 OID 0)
-- Dependencies: 460
-- Name: workorder_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: postgres
--

ALTER SEQUENCE public.workorder_seq OWNED BY public.workorder.workorder_number;


--
-- TOC entry 461 (class 1259 OID 17762)
-- Name: zreportdiary; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.zreportdiary (
    cashboxdiaryid bigint NOT NULL,
    cashid bigint NOT NULL,
    operdayid bigint,
    opencash double precision,
    rko double precision,
    pko double precision,
    cash double precision,
    debit double precision,
    refund double precision,
    ticketscnt bigint,
    datestart timestamp without time zone,
    dateend timestamp without time zone,
    "user" character varying,
    total double precision,
    actualtotal double precision,
    diff double precision,
    hashsumm character varying
);


ALTER TABLE public.zreportdiary OWNER TO postgres;

--
-- TOC entry 4672 (class 2604 OID 24608)
-- Name: access_table_copy id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.access_table_copy ALTER COLUMN id SET DEFAULT nextval('public.access_table_copy_id_seq'::regclass);


--
-- TOC entry 4674 (class 2604 OID 24620)
-- Name: access_tableu id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.access_tableu ALTER COLUMN id SET DEFAULT nextval('public.access_tableu_id_seq'::regclass);


--
-- TOC entry 4384 (class 2604 OID 17768)
-- Name: action_logs id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.action_logs ALTER COLUMN id SET DEFAULT nextval('public.action_logs_id_seq'::regclass);


--
-- TOC entry 4385 (class 2604 OID 17769)
-- Name: admin_accesspartner id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.admin_accesspartner ALTER COLUMN id SET DEFAULT nextval('public.admin_accesspartner_id_seq'::regclass);


--
-- TOC entry 4386 (class 2604 OID 17770)
-- Name: admincompanies_report_details id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.admincompanies_report_details ALTER COLUMN id SET DEFAULT nextval('public.admincompanies_report_details_id_seq'::regclass);


--
-- TOC entry 4387 (class 2604 OID 17771)
-- Name: attributecat id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributecat ALTER COLUMN id SET DEFAULT nextval('public.attributecat_id_seq'::regclass);


--
-- TOC entry 4389 (class 2604 OID 17772)
-- Name: attributelistcode id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributelistcode ALTER COLUMN id SET DEFAULT nextval('public.attributelistcode_id_seq'::regclass);


--
-- TOC entry 4390 (class 2604 OID 17773)
-- Name: attributenames id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributenames ALTER COLUMN id SET DEFAULT nextval('public.attributenames_id_seq'::regclass);


--
-- TOC entry 4398 (class 2604 OID 17774)
-- Name: bonuscardsdiary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.bonuscardsdiary ALTER COLUMN id SET DEFAULT nextval('public.bonuscardsdiary_id_seq'::regclass);


--
-- TOC entry 4401 (class 2604 OID 17775)
-- Name: cashbox_roles id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_roles ALTER COLUMN id SET DEFAULT nextval('public.cashbox_roles_id_seq'::regclass);


--
-- TOC entry 4404 (class 2604 OID 17776)
-- Name: cashbox_updates pk_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_updates ALTER COLUMN pk_id SET DEFAULT nextval('public.cashbox_updates_pk_id_seq'::regclass);


--
-- TOC entry 4405 (class 2604 OID 17777)
-- Name: cashbox_users id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_users ALTER COLUMN id SET DEFAULT nextval('public.cashbox_users_id_seq'::regclass);


--
-- TOC entry 4408 (class 2604 OID 17778)
-- Name: cashboxdiary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxdiary ALTER COLUMN id SET DEFAULT nextval('public.cashboxdiary_id_seq'::regclass);


--
-- TOC entry 4413 (class 2604 OID 17779)
-- Name: cashboxes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxes ALTER COLUMN id SET DEFAULT nextval('public.cashboxes_id_seq'::regclass);


--
-- TOC entry 4422 (class 2604 OID 17780)
-- Name: changeprice_history id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.changeprice_history ALTER COLUMN id SET DEFAULT nextval('public.changeprice_history_id_seq'::regclass);


--
-- TOC entry 4433 (class 2604 OID 17781)
-- Name: companies id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.companies ALTER COLUMN id SET DEFAULT nextval('public.companies_id_seq'::regclass);


--
-- TOC entry 4860 (class 2604 OID 65622)
-- Name: company_types id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.company_types ALTER COLUMN id SET DEFAULT nextval('public.company_types_id_seq'::regclass);


--
-- TOC entry 4437 (class 2604 OID 17782)
-- Name: consignment_snapshots id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_snapshots ALTER COLUMN id SET DEFAULT nextval('public.consignment_snapshots_id_seq'::regclass);


--
-- TOC entry 4438 (class 2604 OID 17783)
-- Name: counterparties id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.counterparties ALTER COLUMN id SET DEFAULT nextval('public.counterparties_id_seq'::regclass);


--
-- TOC entry 4447 (class 2604 OID 17784)
-- Name: couponsdiary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.couponsdiary ALTER COLUMN id SET DEFAULT nextval('public.couponsdiary_id_seq'::regclass);


--
-- TOC entry 4473 (class 2604 OID 17785)
-- Name: erp_roles id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.erp_roles ALTER COLUMN id SET DEFAULT nextval('public.erp_roles_id_seq'::regclass);


--
-- TOC entry 4476 (class 2604 OID 17786)
-- Name: erp_users id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.erp_users ALTER COLUMN id SET DEFAULT nextval('public.erp_users_id_seq'::regclass);


--
-- TOC entry 4486 (class 2604 OID 17787)
-- Name: esf id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf ALTER COLUMN id SET DEFAULT nextval('public.esf_id_seq'::regclass);


--
-- TOC entry 4487 (class 2604 OID 17788)
-- Name: esf_details rowid; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf_details ALTER COLUMN rowid SET DEFAULT nextval('public.esf_details_id_seq'::regclass);


--
-- TOC entry 4501 (class 2604 OID 17789)
-- Name: giftcertificates id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificates ALTER COLUMN id SET DEFAULT nextval('public.giftcertificates_id_seq'::regclass);


--
-- TOC entry 4504 (class 2604 OID 17790)
-- Name: giftcertificates_writeoff_balances id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificates_writeoff_balances ALTER COLUMN id SET DEFAULT nextval('public."giftcertificates_write-off_balances_id_seq"'::regclass);


--
-- TOC entry 4508 (class 2604 OID 17791)
-- Name: giftcertificatesdiary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatesdiary ALTER COLUMN id SET DEFAULT nextval('public.giftcertificatesdiary_id_seq'::regclass);


--
-- TOC entry 4510 (class 2604 OID 17792)
-- Name: giftcertificatetypes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatetypes ALTER COLUMN id SET DEFAULT nextval('public.giftcertificatetypes_id_seq'::regclass);


--
-- TOC entry 4518 (class 2604 OID 17793)
-- Name: invoicelist id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoicelist ALTER COLUMN id SET DEFAULT nextval('public.invoicelist_id_seq'::regclass);


--
-- TOC entry 4534 (class 2604 OID 17794)
-- Name: invoices invoicenumber; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices ALTER COLUMN invoicenumber SET DEFAULT nextval('public.invoices_invoicenumber_seq'::regclass);


--
-- TOC entry 4671 (class 2604 OID 24581)
-- Name: locales id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.locales ALTER COLUMN id SET DEFAULT nextval('public.locales_id_seq'::regclass);


--
-- TOC entry 4545 (class 2604 OID 17795)
-- Name: news_diary pk_id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.news_diary ALTER COLUMN pk_id SET DEFAULT nextval('public.news_diary_pk_id_seq'::regclass);


--
-- TOC entry 4412 (class 2604 OID 17796)
-- Name: opercodes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.opercodes ALTER COLUMN id SET DEFAULT nextval('public.cashboxdiary_types_id_seq'::regclass);


--
-- TOC entry 4546 (class 2604 OID 17797)
-- Name: origincodes id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.origincodes ALTER COLUMN id SET DEFAULT nextval('public.origincodes_id_seq'::regclass);


--
-- TOC entry 4548 (class 2604 OID 17798)
-- Name: pluproducts_scale id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pluproducts_scale ALTER COLUMN id SET DEFAULT nextval('public.pluproducts_scale_id_seq'::regclass);


--
-- TOC entry 4549 (class 2604 OID 17799)
-- Name: point_types id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.point_types ALTER COLUMN id SET DEFAULT nextval('public.point_types_id_seq'::regclass);


--
-- TOC entry 4550 (class 2604 OID 17800)
-- Name: points id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.points ALTER COLUMN id SET DEFAULT nextval('public.points_id_seq'::regclass);


--
-- TOC entry 4555 (class 2604 OID 17801)
-- Name: prices id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices ALTER COLUMN id SET DEFAULT nextval('public.prices_id_seq'::regclass);


--
-- TOC entry 4558 (class 2604 OID 17802)
-- Name: prices_log id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices_log ALTER COLUMN id SET DEFAULT nextval('public.prices_log_id_seq'::regclass);


--
-- TOC entry 4581 (class 2604 OID 17803)
-- Name: product_accounting id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_accounting ALTER COLUMN id SET DEFAULT nextval('public.product_accounting_id_seq'::regclass);


--
-- TOC entry 4583 (class 2604 OID 17804)
-- Name: products_barcode id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_barcode ALTER COLUMN id SET DEFAULT nextval('public.products_barcode_id_seq'::regclass);


--
-- TOC entry 4610 (class 2604 OID 17805)
-- Name: result id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.result ALTER COLUMN id SET DEFAULT nextval('public.result_id_seq'::regclass);


--
-- TOC entry 4611 (class 2604 OID 17806)
-- Name: reviselist id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviselist ALTER COLUMN id SET DEFAULT nextval('public.reviselist_id_seq'::regclass);


--
-- TOC entry 4616 (class 2604 OID 17807)
-- Name: revision_difference id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_difference ALTER COLUMN id SET DEFAULT nextval('public.revision_difference_id_seq'::regclass);


--
-- TOC entry 4617 (class 2604 OID 17808)
-- Name: revision_list id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_list ALTER COLUMN id SET DEFAULT nextval('public.revision_list_id_seq'::regclass);


--
-- TOC entry 4629 (class 2604 OID 17809)
-- Name: revisiondiary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary ALTER COLUMN id SET DEFAULT nextval('public.revisiondiary_id_seq'::regclass);


--
-- TOC entry 4630 (class 2604 OID 17810)
-- Name: revisiondiary_old id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary_old ALTER COLUMN id SET DEFAULT nextval('public.revisiondiary_old_id_seq'::regclass);


--
-- TOC entry 4637 (class 2604 OID 17811)
-- Name: salesplan_types id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.salesplan_types ALTER COLUMN id SET DEFAULT nextval('public.salesplan_types_id_seq'::regclass);


--
-- TOC entry 4640 (class 2604 OID 17812)
-- Name: settings id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settings ALTER COLUMN id SET DEFAULT nextval('public.settings_id_seq'::regclass);


--
-- TOC entry 4642 (class 2604 OID 17813)
-- Name: songs10 id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs10 ALTER COLUMN id SET DEFAULT nextval('public.songs_id_seq3'::regclass);


--
-- TOC entry 4646 (class 2604 OID 17814)
-- Name: songs9 id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs9 ALTER COLUMN id SET DEFAULT nextval('public.songs_id_seq2'::regclass);


--
-- TOC entry 4647 (class 2604 OID 17815)
-- Name: stock_minmax id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stock_minmax ALTER COLUMN id SET DEFAULT nextval('public.stock_minmax_id_seq'::regclass);


--
-- TOC entry 4649 (class 2604 OID 17816)
-- Name: stockcurrent_part id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent_part ALTER COLUMN id SET DEFAULT nextval('public.stockcurrent_part_id_seq'::regclass);


--
-- TOC entry 4651 (class 2604 OID 17817)
-- Name: stockdiary id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary ALTER COLUMN id SET DEFAULT nextval('public.stockdiary_id_seq1'::regclass);


--
-- TOC entry 4656 (class 2604 OID 17818)
-- Name: systemmessage id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.systemmessage ALTER COLUMN id SET DEFAULT nextval('public.systemmessage_id_seq'::regclass);


--
-- TOC entry 4661 (class 2604 OID 17819)
-- Name: ticket_format id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_format ALTER COLUMN id SET DEFAULT nextval('public.ticket_format_id_seq'::regclass);


--
-- TOC entry 4662 (class 2604 OID 17820)
-- Name: transaction_promotions id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_promotions ALTER COLUMN id SET DEFAULT nextval('public.transaction_promotions_id_seq'::regclass);


--
-- TOC entry 4665 (class 2604 OID 17821)
-- Name: workorder id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder ALTER COLUMN id SET DEFAULT nextval('public.workorder_id_seq'::regclass);


--
-- TOC entry 4668 (class 2604 OID 17822)
-- Name: workorder_details id; Type: DEFAULT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder_details ALTER COLUMN id SET DEFAULT nextval('public.workorder_details_id_seq'::regclass);


--
-- TOC entry 6002 (class 0 OID 49283)
-- Dependencies: 473
-- Data for Name: jobcheck; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6003 (class 0 OID 49288)
-- Dependencies: 474
-- Data for Name: sellinginfo_day; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6004 (class 0 OID 49291)
-- Dependencies: 475
-- Data for Name: sellinginfo_month; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6005 (class 0 OID 49294)
-- Dependencies: 476
-- Data for Name: sellinginfo_week; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6006 (class 0 OID 49307)
-- Dependencies: 479
-- Data for Name: stockcurrent_part_snapshots_0_100_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6007 (class 0 OID 49312)
-- Dependencies: 480
-- Data for Name: stockcurrent_part_snapshots_0_100_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6008 (class 0 OID 49317)
-- Dependencies: 481
-- Data for Name: stockcurrent_part_snapshots_0_100_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6009 (class 0 OID 49322)
-- Dependencies: 482
-- Data for Name: stockcurrent_part_snapshots_0_100_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6010 (class 0 OID 49327)
-- Dependencies: 483
-- Data for Name: stockcurrent_part_snapshots_0_100_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6011 (class 0 OID 49337)
-- Dependencies: 485
-- Data for Name: stockcurrent_part_snapshots_1001_1100_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6012 (class 0 OID 49342)
-- Dependencies: 486
-- Data for Name: stockcurrent_part_snapshots_1001_1100_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6013 (class 0 OID 49347)
-- Dependencies: 487
-- Data for Name: stockcurrent_part_snapshots_1001_1100_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6014 (class 0 OID 49352)
-- Dependencies: 488
-- Data for Name: stockcurrent_part_snapshots_1001_1100_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6015 (class 0 OID 49357)
-- Dependencies: 489
-- Data for Name: stockcurrent_part_snapshots_1001_1100_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6016 (class 0 OID 49367)
-- Dependencies: 491
-- Data for Name: stockcurrent_part_snapshots_101_200_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6017 (class 0 OID 49372)
-- Dependencies: 492
-- Data for Name: stockcurrent_part_snapshots_101_200_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6018 (class 0 OID 49377)
-- Dependencies: 493
-- Data for Name: stockcurrent_part_snapshots_101_200_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6019 (class 0 OID 49382)
-- Dependencies: 494
-- Data for Name: stockcurrent_part_snapshots_101_200_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6020 (class 0 OID 49387)
-- Dependencies: 495
-- Data for Name: stockcurrent_part_snapshots_101_200_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6021 (class 0 OID 49397)
-- Dependencies: 497
-- Data for Name: stockcurrent_part_snapshots_1101_1200_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6022 (class 0 OID 49402)
-- Dependencies: 498
-- Data for Name: stockcurrent_part_snapshots_1101_1200_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6023 (class 0 OID 49407)
-- Dependencies: 499
-- Data for Name: stockcurrent_part_snapshots_1101_1200_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6024 (class 0 OID 49412)
-- Dependencies: 500
-- Data for Name: stockcurrent_part_snapshots_1101_1200_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6025 (class 0 OID 49417)
-- Dependencies: 501
-- Data for Name: stockcurrent_part_snapshots_1101_1200_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6026 (class 0 OID 49427)
-- Dependencies: 503
-- Data for Name: stockcurrent_part_snapshots_1201_1300_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6027 (class 0 OID 49432)
-- Dependencies: 504
-- Data for Name: stockcurrent_part_snapshots_1201_1300_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6028 (class 0 OID 49437)
-- Dependencies: 505
-- Data for Name: stockcurrent_part_snapshots_1201_1300_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6029 (class 0 OID 49442)
-- Dependencies: 506
-- Data for Name: stockcurrent_part_snapshots_1201_1300_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6030 (class 0 OID 49447)
-- Dependencies: 507
-- Data for Name: stockcurrent_part_snapshots_1201_1300_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6031 (class 0 OID 49457)
-- Dependencies: 509
-- Data for Name: stockcurrent_part_snapshots_1301_1400_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6032 (class 0 OID 49462)
-- Dependencies: 510
-- Data for Name: stockcurrent_part_snapshots_1301_1400_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6033 (class 0 OID 49467)
-- Dependencies: 511
-- Data for Name: stockcurrent_part_snapshots_1301_1400_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6034 (class 0 OID 49472)
-- Dependencies: 512
-- Data for Name: stockcurrent_part_snapshots_1301_1400_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6035 (class 0 OID 49477)
-- Dependencies: 513
-- Data for Name: stockcurrent_part_snapshots_1301_1400_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6036 (class 0 OID 49487)
-- Dependencies: 515
-- Data for Name: stockcurrent_part_snapshots_1401_1500_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6037 (class 0 OID 49492)
-- Dependencies: 516
-- Data for Name: stockcurrent_part_snapshots_1401_1500_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6038 (class 0 OID 49497)
-- Dependencies: 517
-- Data for Name: stockcurrent_part_snapshots_1401_1500_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6039 (class 0 OID 49502)
-- Dependencies: 518
-- Data for Name: stockcurrent_part_snapshots_1401_1500_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6040 (class 0 OID 49507)
-- Dependencies: 519
-- Data for Name: stockcurrent_part_snapshots_1401_1500_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6041 (class 0 OID 49517)
-- Dependencies: 521
-- Data for Name: stockcurrent_part_snapshots_201_300_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6042 (class 0 OID 49522)
-- Dependencies: 522
-- Data for Name: stockcurrent_part_snapshots_201_300_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6043 (class 0 OID 49527)
-- Dependencies: 523
-- Data for Name: stockcurrent_part_snapshots_201_300_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6044 (class 0 OID 49532)
-- Dependencies: 524
-- Data for Name: stockcurrent_part_snapshots_201_300_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6045 (class 0 OID 49537)
-- Dependencies: 525
-- Data for Name: stockcurrent_part_snapshots_201_300_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6046 (class 0 OID 49547)
-- Dependencies: 527
-- Data for Name: stockcurrent_part_snapshots_301_400_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6047 (class 0 OID 49552)
-- Dependencies: 528
-- Data for Name: stockcurrent_part_snapshots_301_400_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6048 (class 0 OID 49557)
-- Dependencies: 529
-- Data for Name: stockcurrent_part_snapshots_301_400_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6049 (class 0 OID 49562)
-- Dependencies: 530
-- Data for Name: stockcurrent_part_snapshots_301_400_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6050 (class 0 OID 49567)
-- Dependencies: 531
-- Data for Name: stockcurrent_part_snapshots_301_400_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6051 (class 0 OID 49577)
-- Dependencies: 533
-- Data for Name: stockcurrent_part_snapshots_401_500_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6052 (class 0 OID 49582)
-- Dependencies: 534
-- Data for Name: stockcurrent_part_snapshots_401_500_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6053 (class 0 OID 49587)
-- Dependencies: 535
-- Data for Name: stockcurrent_part_snapshots_401_500_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6054 (class 0 OID 49592)
-- Dependencies: 536
-- Data for Name: stockcurrent_part_snapshots_401_500_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6055 (class 0 OID 49597)
-- Dependencies: 537
-- Data for Name: stockcurrent_part_snapshots_401_500_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6056 (class 0 OID 49607)
-- Dependencies: 539
-- Data for Name: stockcurrent_part_snapshots_501_600_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6057 (class 0 OID 49612)
-- Dependencies: 540
-- Data for Name: stockcurrent_part_snapshots_501_600_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6058 (class 0 OID 49617)
-- Dependencies: 541
-- Data for Name: stockcurrent_part_snapshots_501_600_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6059 (class 0 OID 49622)
-- Dependencies: 542
-- Data for Name: stockcurrent_part_snapshots_501_600_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6060 (class 0 OID 49627)
-- Dependencies: 543
-- Data for Name: stockcurrent_part_snapshots_501_600_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6061 (class 0 OID 49637)
-- Dependencies: 545
-- Data for Name: stockcurrent_part_snapshots_601_700_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6062 (class 0 OID 49642)
-- Dependencies: 546
-- Data for Name: stockcurrent_part_snapshots_601_700_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6063 (class 0 OID 49647)
-- Dependencies: 547
-- Data for Name: stockcurrent_part_snapshots_601_700_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6064 (class 0 OID 49652)
-- Dependencies: 548
-- Data for Name: stockcurrent_part_snapshots_601_700_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6065 (class 0 OID 49657)
-- Dependencies: 549
-- Data for Name: stockcurrent_part_snapshots_601_700_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6066 (class 0 OID 49667)
-- Dependencies: 551
-- Data for Name: stockcurrent_part_snapshots_701_800_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6067 (class 0 OID 49672)
-- Dependencies: 552
-- Data for Name: stockcurrent_part_snapshots_701_800_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6068 (class 0 OID 49677)
-- Dependencies: 553
-- Data for Name: stockcurrent_part_snapshots_701_800_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6069 (class 0 OID 49682)
-- Dependencies: 554
-- Data for Name: stockcurrent_part_snapshots_701_800_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6070 (class 0 OID 49687)
-- Dependencies: 555
-- Data for Name: stockcurrent_part_snapshots_701_800_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6071 (class 0 OID 49697)
-- Dependencies: 557
-- Data for Name: stockcurrent_part_snapshots_801_900_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6072 (class 0 OID 49702)
-- Dependencies: 558
-- Data for Name: stockcurrent_part_snapshots_801_900_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6073 (class 0 OID 49707)
-- Dependencies: 559
-- Data for Name: stockcurrent_part_snapshots_801_900_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6074 (class 0 OID 49712)
-- Dependencies: 560
-- Data for Name: stockcurrent_part_snapshots_801_900_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6075 (class 0 OID 49717)
-- Dependencies: 561
-- Data for Name: stockcurrent_part_snapshots_801_900_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6076 (class 0 OID 49727)
-- Dependencies: 563
-- Data for Name: stockcurrent_part_snapshots_901_1000_2020; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6077 (class 0 OID 49732)
-- Dependencies: 564
-- Data for Name: stockcurrent_part_snapshots_901_1000_2021; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6078 (class 0 OID 49737)
-- Dependencies: 565
-- Data for Name: stockcurrent_part_snapshots_901_1000_2022; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6079 (class 0 OID 49742)
-- Dependencies: 566
-- Data for Name: stockcurrent_part_snapshots_901_1000_2023; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6080 (class 0 OID 49747)
-- Dependencies: 567
-- Data for Name: stockcurrent_part_snapshots_901_1000_2024; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6081 (class 0 OID 49752)
-- Dependencies: 568
-- Data for Name: temp_rep_collection; Type: TABLE DATA; Schema: analytics; Owner: postgres
--



--
-- TOC entry 6082 (class 0 OID 49758)
-- Dependencies: 569
-- Data for Name: function_calls; Type: TABLE DATA; Schema: functioncalls; Owner: postgres
--

INSERT INTO functioncalls.function_calls VALUES (1, 'invoice_create_isp', 'invoice_create_isp');
INSERT INTO functioncalls.function_calls VALUES (2, 'invoice_from_nomenclature', 'invoice_from_nomenclature');
INSERT INTO functioncalls.function_calls VALUES (3, 'invoice_product_update', 'invoice_product_update');
INSERT INTO functioncalls.function_calls VALUES (4, 'invoice_addproduct_dop', 'invoice_addproduct_dop');
INSERT INTO functioncalls.function_calls VALUES (5, 'invoice_product_addnew', 'invoice_product_addnew');


--
-- TOC entry 6083 (class 0 OID 49764)
-- Dependencies: 570
-- Data for Name: j_object; Type: TABLE DATA; Schema: functioncalls; Owner: postgres
--



--
-- TOC entry 5749 (class 0 OID 16603)
-- Dependencies: 205
-- Data for Name: _db_version; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5751 (class 0 OID 16611)
-- Dependencies: 207
-- Data for Name: access_table; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.access_table VALUES (6, 'rep_team_bonus', 'Командный бонус', 'Командалық бонус', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (4, 'rep_prod_solds', 'Проданные товары', 'Сатылған өнімдер', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (1, 'rep_checkout', 'Отчет по кассам', 'Есепті шығару', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (7, 'rep_gross_profit', 'Валовая прибыль', 'Жалпы пайда', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (9, 'rep_consultants', 'Консультанты', 'Кеңесшілер', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (10, 'rep_certificates', 'Сертификаты', 'Сертификаттар', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (11, 'rep_abc_xyz', 'ABC/XYZ', 'ABC/XYZ', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (12, 'rep_debt_book', 'Долговая книга', 'Қарыз кітабы', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (13, 'rep_buyers', 'Отчёт по покупателям(физ. лицо)', 'Сатып алушылар туралы есеп (жеке)', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (2, 'rep_sales', 'Общие продажи', 'Жалпы сату', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (14, 'whs_leftovers', 'Остаток на складе', 'Қалған қор', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (15, 'whs_inv_history', 'История по накладным', 'Шот-фактура тарихы', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (44, 'setting_sales_plan', 'План продаж', 'Сату жоспары', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (40, 'setting_user_chekout', 'Пользователи касс', 'Пайдаланушыларды тексеру', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (48, 'setting_buyers', 'Покупатели юр. лица', 'Заңды сатып алушылар. беттер', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (46, 'setting_supplies', 'Поставщики', 'Жабдықтаушылар', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (42, 'setting_portal_user', 'Пользователи портала', 'Портал пайдаланушылары', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (19, 'whs_prod_move', 'Движение товара', 'Тауар қозғалысы', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (21, 'whs_revision', 'Ревизия', 'Қайта қарау', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (23, 'whs_holdings', 'Холдинги', 'Холдингтер', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (27, 'whs_exp_dates', 'Сроки годности', 'Жарамдылық мерзімі', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (29, 'whs_reconciliation', 'Сверка', 'Татуласу', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (3, 'rep_checks', 'Чеки', 'Тексерулер', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (25, 'whs_consignment', 'Консигнация', 'Консигнация', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (31, 'setting_gen_info', 'Общая информация', 'Жалпы Ақпарат', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (34, 'setting_whs', 'Склад', 'Қойма', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (83, 'market_coupons', 'Купоны', 'Купондар', 'Маркетинг и продвижение', 4, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (52, 'setting_scales', 'Весы', 'Таразылар', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (90, 'market_stock', 'Акции', 'Қор', 'Маркетинг и продвижение', 4, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (56, 'contr_prod_new_whr', 'Управление товарами', 'Элементтерді басқару', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (60, 'contr_move_between', 'Перемещение между складами', 'Қоймалар арасында жылжу', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (66, 'contr_revision', 'Ревизия', 'Қайта қарау', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (75, 'price_wizard', 'Мастер ценообразования', 'Баға шебері', 'Ценообразование', 7, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (68, 'contr_weigh_prod', 'Весовые товары', 'Салмақты тауарлар', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (70, 'contr_nomenclature', 'Номенклатура', 'Номенклатура', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (72, 'contr_reconciliation', 'Сверка', 'Татуласу', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (57, 'contr_newto_whr', 'Прием нового товара на склад', 'Жаңа тауарларды қоймаға қабылдау', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (92, 'elct_inv_broadcast', 'Передача', 'Хабар тарату', 'ЭСФ', 8, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (94, 'elct_inv_report', 'Отчет', 'Есеп беру', 'ЭСФ', 8, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (78, 'order_create', 'Создание', 'Жасау', 'Наряд-заказ', 5, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (79, 'order_treatment', 'Обработка', 'Емдеу', 'Наряд-заказ', 5, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (95, 'order_weight_prod', 'Привязка весовых товаров', 'Салмақтағы тауарларды байлау', 'Наряд-заказ', 5, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (81, 'order_receipt', 'Прием товаров по наряд-заказу', 'Жұмыс тапсырысы бойынша тауарларды қабылдау', 'Наряд-заказ', 5, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (86, 'market_bonuses', 'Бонусы', 'Бонустар', 'Маркетинг и продвижение', 4, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (88, 'market_create_discount', 'Создание скидок', 'Жеңілдіктер жасаңыз', 'Маркетинг и продвижение', 4, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (91, 'elct_inv_reception', 'Прием', 'Қабылдау', 'ЭСФ', 8, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (62, 'contr_removefrom_whr', 'Списание товара со склада', 'Қоймадан тауарларды есептен шығару', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (64, 'contr_barcode_print', 'Печать штрих кода', 'Штрих-кодты басып шығару', 'Управление товарами', 6, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (32, 'setting_store', 'Торговая точка', 'Сауда нүктесі', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (74, 'price_change', 'Изменение цен', 'Бағаның өзгеруі', 'Ценообразование', 7, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (93, 'elct_inv_attach_eds', 'Прикрепить ЭЦП', 'ЭСҚ бекітіңіз', 'ЭСФ', 8, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (5, 'rep_single_bonus', 'Индивидуальный бонус', 'Жеке бонус', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (77, 'price_marginal', 'Предельные цены', 'Шекті бағалар', 'Ценообразование', 7, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (38, 'setting_cash_reg', 'Касса', 'Кассалық аппарат', 'Настройки', 3, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (84, 'market_gift', 'Подарочные сертификаты', 'Сыйлық сертификаттары', 'Маркетинг и продвижение', 4, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (8, 'rep_discounts', 'Примененные скидки', 'Қолданылатын жеңілдіктер', 'Отчеты', 1, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (99, 'whs_prod_period', 'Отчеты по товарам за период', 'Кезеңдік тауарлық есептер', 'Отчеты (склад)', 2, NULL, NULL, NULL);
INSERT INTO public.access_table VALUES (101, 'rep_illiquid_products', 'Отчет по неликвидным товарам', 'Өтімділігі жоқ тауарлар туралы есеп', 'Отчеты', 1, NULL, NULL, NULL);


--
-- TOC entry 5999 (class 0 OID 24605)
-- Dependencies: 465
-- Data for Name: access_table_copy; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 6001 (class 0 OID 24617)
-- Dependencies: 467
-- Data for Name: access_tableu; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.access_tableu VALUES (1, 'setting_portal_user', 'Пользователи программы', 'Пользователи программы', 'Пользователи', 1);
INSERT INTO public.access_tableu VALUES (2, 'setting_user_chekout', 'Пользователи касс', 'Пользователи касс', 'Пользователи', 1);
INSERT INTO public.access_tableu VALUES (3, 'setting_sales_plan', 'План продаж', 'План продаж', 'Пользователи', 1);
INSERT INTO public.access_tableu VALUES (4, 'setting_supplies', 'Поставщики', 'Поставщики', 'Поставщики и покупатели', 2);
INSERT INTO public.access_tableu VALUES (5, 'setting_buyers', 'Покупатели юр.лица', 'Покупатели юр.лица', 'Поставщики и покупатели', 2);
INSERT INTO public.access_tableu VALUES (6, 'setting_buyers_fiz', 'Покупатели физ.лица', 'Покупатели физ.лица', 'Поставщики и покупатели', 2);
INSERT INTO public.access_tableu VALUES (7, 'setting_whs', 'Склад', 'Склад', 'Объекты торговли', 3);
INSERT INTO public.access_tableu VALUES (8, 'setting_store', 'Торговая точка', 'Торговая точка', 'Объекты торговли', 3);
INSERT INTO public.access_tableu VALUES (9, 'setting_cash_reg', 'Кассы', 'Кассы', 'Объекты торговли', 3);
INSERT INTO public.access_tableu VALUES (10, 'setting_scales', 'Весы', 'Весы', 'Объекты торговли', 3);
INSERT INTO public.access_tableu VALUES (11, 'price_change', 'Изменение цен', 'Изменение цен', 'Ценообразование', 4);
INSERT INTO public.access_tableu VALUES (12, 'price_wizard', 'Мастер ценообразования', 'Мастер ценообразования', 'Ценообразование', 4);
INSERT INTO public.access_tableu VALUES (13, 'price_marginal', 'Предельные цены', 'Предельные цены', 'Ценообразование', 4);
INSERT INTO public.access_tableu VALUES (14, 'market_coupons', 'Купоны', 'Купоны', 'Маркетинг', 5);
INSERT INTO public.access_tableu VALUES (15, 'market_gift', 'Подарочные сертификаты', 'Подарочные сертификаты', 'Маркетинг', 5);
INSERT INTO public.access_tableu VALUES (16, 'market_bonuses', 'Бонусы', 'Бонусы', 'Маркетинг', 5);
INSERT INTO public.access_tableu VALUES (17, 'market_create_discount', 'Создание скидок', 'Создание скидок', 'Маркетинг', 5);
INSERT INTO public.access_tableu VALUES (18, 'market_stock', 'Акции', 'Акции', 'Маркетинг', 5);
INSERT INTO public.access_tableu VALUES (19, 'contr_newto_whr', 'Прием товара', 'Прием товара', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (20, 'contr_move_between', 'Перемещение товара', 'Перемещение товара', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (21, 'contr_removefrom_whr', 'Списание товара', 'Списание товара', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (22, 'contr_barcode_print', 'Печать штрих кода', 'Печать штрих кода', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (23, 'contr_weigh_prod', 'Весовые товары', 'Весовые товары', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (24, 'contr_nomenclature', 'Товар', 'Товар', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (26, 'contr_revision', 'Ревизия', 'Ревизия', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (25, 'contr_reconciliation', 'Наряд-заказ', 'Наряд-заказ', 'Управление товарами', 6);
INSERT INTO public.access_tableu VALUES (27, 'rep_checks', 'Чеки', 'Чеки', 'Отчеты', 1);


--
-- TOC entry 5752 (class 0 OID 16619)
-- Dependencies: 208
-- Data for Name: action_logs; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5754 (class 0 OID 16627)
-- Dependencies: 210
-- Data for Name: admin_accesspartner; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.admin_accesspartner VALUES (1, '0,2,3,4,5,6,7,8,9,10');


--
-- TOC entry 5756 (class 0 OID 16635)
-- Dependencies: 212
-- Data for Name: admincompanies_report; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5757 (class 0 OID 16638)
-- Dependencies: 213
-- Data for Name: admincompanies_report_details; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5760 (class 0 OID 16645)
-- Dependencies: 216
-- Data for Name: attributecat; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5762 (class 0 OID 16654)
-- Dependencies: 218
-- Data for Name: attributelistcode; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.attributelistcode VALUES (0, 'еуке', 18);
INSERT INTO public.attributelistcode VALUES (1, NULL, 18);
INSERT INTO public.attributelistcode VALUES (2, NULL, 18);
INSERT INTO public.attributelistcode VALUES (3, NULL, 18);
INSERT INTO public.attributelistcode VALUES (4, NULL, 18);
INSERT INTO public.attributelistcode VALUES (5, NULL, 18);
INSERT INTO public.attributelistcode VALUES (6, NULL, 18);
INSERT INTO public.attributelistcode VALUES (7, NULL, 18);
INSERT INTO public.attributelistcode VALUES (8, NULL, 18);
INSERT INTO public.attributelistcode VALUES (9, NULL, 18);
INSERT INTO public.attributelistcode VALUES (12, NULL, 18);
INSERT INTO public.attributelistcode VALUES (13, NULL, 18);
INSERT INTO public.attributelistcode VALUES (14, NULL, 18);
INSERT INTO public.attributelistcode VALUES (15, NULL, 18);
INSERT INTO public.attributelistcode VALUES (16, NULL, 18);
INSERT INTO public.attributelistcode VALUES (17, NULL, 18);
INSERT INTO public.attributelistcode VALUES (18, NULL, 18);
INSERT INTO public.attributelistcode VALUES (19, NULL, 18);
INSERT INTO public.attributelistcode VALUES (20, NULL, 18);
INSERT INTO public.attributelistcode VALUES (21, NULL, 18);
INSERT INTO public.attributelistcode VALUES (22, NULL, 18);
INSERT INTO public.attributelistcode VALUES (23, NULL, 18);
INSERT INTO public.attributelistcode VALUES (24, NULL, 18);
INSERT INTO public.attributelistcode VALUES (25, NULL, 18);
INSERT INTO public.attributelistcode VALUES (26, NULL, 18);
INSERT INTO public.attributelistcode VALUES (27, NULL, 18);
INSERT INTO public.attributelistcode VALUES (28, NULL, 18);
INSERT INTO public.attributelistcode VALUES (29, NULL, 18);
INSERT INTO public.attributelistcode VALUES (30, NULL, 18);
INSERT INTO public.attributelistcode VALUES (31, NULL, 18);
INSERT INTO public.attributelistcode VALUES (32, NULL, 18);
INSERT INTO public.attributelistcode VALUES (33, NULL, 18);
INSERT INTO public.attributelistcode VALUES (34, NULL, 18);
INSERT INTO public.attributelistcode VALUES (35, NULL, 18);
INSERT INTO public.attributelistcode VALUES (36, NULL, 18);
INSERT INTO public.attributelistcode VALUES (37, NULL, 18);
INSERT INTO public.attributelistcode VALUES (38, NULL, 18);
INSERT INTO public.attributelistcode VALUES (39, NULL, 18);
INSERT INTO public.attributelistcode VALUES (40, NULL, 18);
INSERT INTO public.attributelistcode VALUES (41, NULL, 18);
INSERT INTO public.attributelistcode VALUES (42, NULL, 18);
INSERT INTO public.attributelistcode VALUES (43, NULL, 18);
INSERT INTO public.attributelistcode VALUES (44, NULL, 18);
INSERT INTO public.attributelistcode VALUES (45, NULL, 18);
INSERT INTO public.attributelistcode VALUES (46, NULL, 18);
INSERT INTO public.attributelistcode VALUES (47, NULL, 18);
INSERT INTO public.attributelistcode VALUES (48, NULL, 18);
INSERT INTO public.attributelistcode VALUES (49, NULL, 18);
INSERT INTO public.attributelistcode VALUES (50, NULL, 18);
INSERT INTO public.attributelistcode VALUES (51, NULL, 18);
INSERT INTO public.attributelistcode VALUES (52, NULL, 18);
INSERT INTO public.attributelistcode VALUES (53, NULL, 18);
INSERT INTO public.attributelistcode VALUES (54, NULL, 18);
INSERT INTO public.attributelistcode VALUES (55, NULL, 18);
INSERT INTO public.attributelistcode VALUES (56, NULL, 18);
INSERT INTO public.attributelistcode VALUES (57, NULL, 18);
INSERT INTO public.attributelistcode VALUES (58, NULL, 18);
INSERT INTO public.attributelistcode VALUES (59, NULL, 18);
INSERT INTO public.attributelistcode VALUES (60, NULL, 18);
INSERT INTO public.attributelistcode VALUES (61, NULL, 18);
INSERT INTO public.attributelistcode VALUES (62, NULL, 18);
INSERT INTO public.attributelistcode VALUES (63, NULL, 18);
INSERT INTO public.attributelistcode VALUES (64, NULL, 18);
INSERT INTO public.attributelistcode VALUES (65, NULL, 18);
INSERT INTO public.attributelistcode VALUES (66, NULL, 18);
INSERT INTO public.attributelistcode VALUES (67, NULL, 18);
INSERT INTO public.attributelistcode VALUES (68, NULL, 18);
INSERT INTO public.attributelistcode VALUES (69, NULL, 18);
INSERT INTO public.attributelistcode VALUES (70, NULL, 18);
INSERT INTO public.attributelistcode VALUES (71, NULL, 18);
INSERT INTO public.attributelistcode VALUES (72, NULL, 18);
INSERT INTO public.attributelistcode VALUES (73, NULL, 18);
INSERT INTO public.attributelistcode VALUES (74, NULL, 18);
INSERT INTO public.attributelistcode VALUES (75, NULL, 18);
INSERT INTO public.attributelistcode VALUES (76, NULL, 18);


--
-- TOC entry 5764 (class 0 OID 16662)
-- Dependencies: 220
-- Data for Name: attributenames; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.attributenames VALUES (3, NULL, 'Размер', false, 'SPR');
INSERT INTO public.attributenames VALUES (4, NULL, 'Цвет', false, 'SPR');
INSERT INTO public.attributenames VALUES (5, NULL, 'Объем', false, 'SPR');
INSERT INTO public.attributenames VALUES (6, NULL, 'Сезон', false, 'SPR');
INSERT INTO public.attributenames VALUES (7, NULL, 'Единица измерения', false, 'SPR');
INSERT INTO public.attributenames VALUES (8, NULL, 'Артикул', false, 'SPR');
INSERT INTO public.attributenames VALUES (9, NULL, 'Назначение', false, 'SPR');
INSERT INTO public.attributenames VALUES (10, NULL, 'Пара', false, 'SPR');
INSERT INTO public.attributenames VALUES (11, NULL, 'Пол', false, 'SPR');
INSERT INTO public.attributenames VALUES (1, NULL, 'Номер серии', false, 'TEXT');
INSERT INTO public.attributenames VALUES (2, NULL, 'Срок годности', false, 'DATE');
INSERT INTO public.attributenames VALUES (12, NULL, 'Номер полки', false, 'TEXT');
INSERT INTO public.attributenames VALUES (13, NULL, 'Модель', false, 'TEXT');
INSERT INTO public.attributenames VALUES (14, NULL, 'Фасон', false, 'TEXT');
INSERT INTO public.attributenames VALUES (15, NULL, 'Сертификат', false, 'TEXT');
INSERT INTO public.attributenames VALUES (16, NULL, 'Дата приемки', false, 'DATE');
INSERT INTO public.attributenames VALUES (17, NULL, 'Маркировка', false, 'TEXT');
INSERT INTO public.attributenames VALUES (20, NULL, 'qew', true, 'TEXT');
INSERT INTO public.attributenames VALUES (19, NULL, '559', true, 'TEXT');
INSERT INTO public.attributenames VALUES (18, NULL, '23', true, 'TEXT');
INSERT INTO public.attributenames VALUES (21, NULL, 'цу88', true, 'TEXT');
INSERT INTO public.attributenames VALUES (22, NULL, 'выа', true, 'TEXT');
INSERT INTO public.attributenames VALUES (23, NULL, 'еенге88', true, 'TEXT');
INSERT INTO public.attributenames VALUES (24, NULL, 'куеку', true, 'TEXT');
INSERT INTO public.attributenames VALUES (25, NULL, 'прпарапр', true, 'TEXT');
INSERT INTO public.attributenames VALUES (26, NULL, 'прапрпр9900', true, 'TEXT');
INSERT INTO public.attributenames VALUES (27, NULL, 'куекуе8', true, 'TEXT');
INSERT INTO public.attributenames VALUES (28, NULL, 'q188', true, 'TEXT');
INSERT INTO public.attributenames VALUES (29, NULL, 'fgfdg88', true, 'TEXT');


--
-- TOC entry 5767 (class 0 OID 16674)
-- Dependencies: 223
-- Data for Name: attributespr; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.attributespr VALUES (3, 1, 'апра2', 18, false);
INSERT INTO public.attributespr VALUES (10, 3, 'апра', 18, true);
INSERT INTO public.attributespr VALUES (10, 11, 'мит', 18, false);
INSERT INTO public.attributespr VALUES (3, 2, 'апра', 18, true);
INSERT INTO public.attributespr VALUES (3, 14, 'йцу', 18, false);
INSERT INTO public.attributespr VALUES (3, 13, 'йц', 18, false);
INSERT INTO public.attributespr VALUES (3, 16, 'вапр', 18, false);
INSERT INTO public.attributespr VALUES (3, 12, 'кек', 18, false);
INSERT INTO public.attributespr VALUES (3, 18, 'ячс', 18, true);
INSERT INTO public.attributespr VALUES (10, 17, 'ячс', 18, false);
INSERT INTO public.attributespr VALUES (3, 19, 'цйуйц', 18, true);
INSERT INTO public.attributespr VALUES (3, 15, 'вап', 18, false);
INSERT INTO public.attributespr VALUES (3, 20, '3377', 18, false);
INSERT INTO public.attributespr VALUES (3, 10, 'ыва5', 18, false);
INSERT INTO public.attributespr VALUES (3, 21, 'xl', 18, false);
INSERT INTO public.attributespr VALUES (3, 22, 'l', 18, false);
INSERT INTO public.attributespr VALUES (4, 23, 'зелёный', 18, false);
INSERT INTO public.attributespr VALUES (4, 24, 'синий', 18, false);
INSERT INTO public.attributespr VALUES (4, 25, 'красный', 18, false);
INSERT INTO public.attributespr VALUES (5, 26, '1 л.', 18, false);
INSERT INTO public.attributespr VALUES (5, 27, '0.5 л.', 18, false);
INSERT INTO public.attributespr VALUES (6, 28, 'Осень-зима 2019', 18, false);
INSERT INTO public.attributespr VALUES (6, 29, 'Весна-лето 2020', 18, false);
INSERT INTO public.attributespr VALUES (7, 30, '1 мес.', 18, false);
INSERT INTO public.attributespr VALUES (7, 32, '2 мес.', 18, false);
INSERT INTO public.attributespr VALUES (8, 33, '1', 18, false);
INSERT INTO public.attributespr VALUES (8, 34, '2', 18, false);
INSERT INTO public.attributespr VALUES (9, 35, 'реализатор 1', 18, false);
INSERT INTO public.attributespr VALUES (9, 36, 'реализатор 2', 18, false);
INSERT INTO public.attributespr VALUES (10, 37, '2', 18, false);
INSERT INTO public.attributespr VALUES (11, 38, 'мужской', 18, false);
INSERT INTO public.attributespr VALUES (11, 39, 'женский', 18, false);


--
-- TOC entry 5768 (class 0 OID 16682)
-- Dependencies: 224
-- Data for Name: attrlist; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.attrlist VALUES (2, 14, '1', true, 18);
INSERT INTO public.attrlist VALUES (3, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (2, 16, '2025-10-17', true, 18);
INSERT INTO public.attrlist VALUES (3, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (3, 3, '', true, 18);
INSERT INTO public.attrlist VALUES (3, 2, '2025-10-17', true, 18);
INSERT INTO public.attrlist VALUES (5, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (6, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (7, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (8, 6, '', true, 18);
INSERT INTO public.attrlist VALUES (9, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (12, 1, '5', true, 18);
INSERT INTO public.attrlist VALUES (13, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (14, 3, 'апра2', true, 18);
INSERT INTO public.attrlist VALUES (15, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (16, 6, '', true, 18);
INSERT INTO public.attrlist VALUES (17, 3, 'апра2', true, 18);
INSERT INTO public.attrlist VALUES (18, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (18, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (18, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (19, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (19, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (19, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (20, 1, '5', true, 18);
INSERT INTO public.attrlist VALUES (20, 3, 'апра2', true, 18);
INSERT INTO public.attrlist VALUES (21, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (21, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (21, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (22, 3, 'апра2', true, 18);
INSERT INTO public.attrlist VALUES (22, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (23, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (23, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (23, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (24, 3, 'апра2', true, 18);
INSERT INTO public.attrlist VALUES (24, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (25, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (25, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (25, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (26, 3, 'апра2', true, 18);
INSERT INTO public.attrlist VALUES (26, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (27, 1, '3', true, 18);
INSERT INTO public.attrlist VALUES (27, 3, 'йц', true, 18);
INSERT INTO public.attrlist VALUES (28, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (28, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (29, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (29, 3, 'ыва5', true, 18);
INSERT INTO public.attrlist VALUES (30, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (30, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (31, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (31, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (32, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (32, 3, 'ыва5', true, 18);
INSERT INTO public.attrlist VALUES (33, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (33, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (34, 2, '2025-10-20', true, 18);
INSERT INTO public.attrlist VALUES (34, 3, 'ыва5', true, 18);
INSERT INTO public.attrlist VALUES (35, 1, '3', true, 18);
INSERT INTO public.attrlist VALUES (35, 3, 'кек', true, 18);
INSERT INTO public.attrlist VALUES (36, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (36, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (35, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (37, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (37, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (38, 1, '3', true, 18);
INSERT INTO public.attrlist VALUES (38, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (39, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (39, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (40, 1, '3', true, 18);
INSERT INTO public.attrlist VALUES (40, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (41, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (41, 5, '', true, 18);
INSERT INTO public.attrlist VALUES (42, 1, '3', true, 18);
INSERT INTO public.attrlist VALUES (42, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (43, 1, '3', true, 18);
INSERT INTO public.attrlist VALUES (43, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (44, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (44, 3, '', true, 18);
INSERT INTO public.attrlist VALUES (45, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (45, 3, '', true, 18);
INSERT INTO public.attrlist VALUES (46, 1, '3', true, 18);
INSERT INTO public.attrlist VALUES (46, 4, 'зелёный', true, 18);
INSERT INTO public.attrlist VALUES (47, 1, '5', true, 18);
INSERT INTO public.attrlist VALUES (48, 6, '', true, 18);
INSERT INTO public.attrlist VALUES (47, 2, '2025-10-22', true, 18);
INSERT INTO public.attrlist VALUES (48, 2, '2025-10-21', true, 18);
INSERT INTO public.attrlist VALUES (49, 6, '', true, 18);
INSERT INTO public.attrlist VALUES (49, 2, '2025-10-21', true, 18);
INSERT INTO public.attrlist VALUES (50, 1, '5', true, 18);
INSERT INTO public.attrlist VALUES (50, 2, '2025-10-22', true, 18);
INSERT INTO public.attrlist VALUES (52, 3, 'апра2', true, 18);
INSERT INTO public.attrlist VALUES (52, 5, '1 л.', true, 18);
INSERT INTO public.attrlist VALUES (52, 1, '435', true, 18);
INSERT INTO public.attrlist VALUES (53, 3, '3377', true, 18);
INSERT INTO public.attrlist VALUES (53, 4, 'синий', true, 18);
INSERT INTO public.attrlist VALUES (54, 3, 'йцу', true, 18);
INSERT INTO public.attrlist VALUES (55, 4, 'синий', true, 18);
INSERT INTO public.attrlist VALUES (56, 4, 'синий', true, 18);
INSERT INTO public.attrlist VALUES (57, 4, 'синий', false, 18);
INSERT INTO public.attrlist VALUES (58, 4, 'синий', true, 18);
INSERT INTO public.attrlist VALUES (59, 4, 'синий', true, 18);
INSERT INTO public.attrlist VALUES (60, 4, 'синий', false, 18);
INSERT INTO public.attrlist VALUES (61, 4, 'синий', true, 18);
INSERT INTO public.attrlist VALUES (62, 4, 'синий', false, 18);
INSERT INTO public.attrlist VALUES (63, 4, 'синий', false, 18);
INSERT INTO public.attrlist VALUES (64, 4, 'синий', false, 18);
INSERT INTO public.attrlist VALUES (65, 4, 'синий', false, 18);
INSERT INTO public.attrlist VALUES (67, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (66, 6, 'Осень-зима 2019', false, 18);
INSERT INTO public.attrlist VALUES (68, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (69, 3, 'апра2', false, 18);
INSERT INTO public.attrlist VALUES (69, 4, 'зелёный', false, 18);
INSERT INTO public.attrlist VALUES (70, 1, '1', false, 18);
INSERT INTO public.attrlist VALUES (70, 4, 'зелёный', false, 18);
INSERT INTO public.attrlist VALUES (71, 4, 'красный', false, 18);
INSERT INTO public.attrlist VALUES (72, 4, 'зелёный', false, 18);
INSERT INTO public.attrlist VALUES (72, 5, '1 л.', false, 18);
INSERT INTO public.attrlist VALUES (74, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (75, 4, '', true, 18);
INSERT INTO public.attrlist VALUES (73, 3, 'йцу', false, 18);
INSERT INTO public.attrlist VALUES (73, 4, 'зелёный', false, 18);
INSERT INTO public.attrlist VALUES (76, 4, '', true, 18);


--
-- TOC entry 5772 (class 0 OID 16695)
-- Dependencies: 228
-- Data for Name: bonuscardsdiary; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5777 (class 0 OID 16708)
-- Dependencies: 233
-- Data for Name: brands; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.brands VALUES (5, 'Матрёшка', 'Нет', false);
INSERT INTO public.brands VALUES (6, 'Чебурашка', 'Чебурашка', false);
INSERT INTO public.brands VALUES (2, 'Бренд1', 'Бренд1', false);
INSERT INTO public.brands VALUES (0, 'Бренд не указан', 'Бренд не указан', false);
INSERT INTO public.brands VALUES (7, 'RECORD', 'RECORD', false);
INSERT INTO public.brands VALUES (8, 'Aqualine', 'Aqualine', false);
INSERT INTO public.brands VALUES (9, '1цу', '3', true);
INSERT INTO public.brands VALUES (11, 'gfd', '34', true);
INSERT INTO public.brands VALUES (12, 'авап', '45', true);
INSERT INTO public.brands VALUES (10, 'прп3', 'прро', true);
INSERT INTO public.brands VALUES (13, 'hfg99', '23', true);
INSERT INTO public.brands VALUES (16, 'e', '3', true);
INSERT INTO public.brands VALUES (15, 'w', '2', true);
INSERT INTO public.brands VALUES (19, 'w2', '2', true);
INSERT INTO public.brands VALUES (18, 'q1', '1', true);
INSERT INTO public.brands VALUES (20, 'e3', '3', true);
INSERT INTO public.brands VALUES (14, 'q1', '12', true);


--
-- TOC entry 5778 (class 0 OID 16716)
-- Dependencies: 234
-- Data for Name: cashbox_roles; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.cashbox_roles VALUES (1, 'Администратор', NULL, false);
INSERT INTO public.cashbox_roles VALUES (2, 'Заведующий торговой точки', NULL, false);
INSERT INTO public.cashbox_roles VALUES (3, 'Кассир-оператор', NULL, false);
INSERT INTO public.cashbox_roles VALUES (4, 'Продавец-консультант', NULL, false);


--
-- TOC entry 5781 (class 0 OID 16727)
-- Dependencies: 237
-- Data for Name: cashbox_updates; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5783 (class 0 OID 16736)
-- Dependencies: 239
-- Data for Name: cashbox_users; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.cashbox_users VALUES (22, 'qwew', NULL, 1, 23, false, 'lr1mMEn0saK8s8kcPGXDOQ==', false, 0);
INSERT INTO public.cashbox_users VALUES (23, 'qqwe', NULL, 3, 25, false, '9fON5+8JQy5EUPTVfeZNEA==', false, 0);
INSERT INTO public.cashbox_users VALUES (24, 'xcvxccbvctrrtr', NULL, 4, 34, false, 'j8F33qxf0D6+w27izY4Ukw==', false, 0);
INSERT INTO public.cashbox_users VALUES (21, 'tert', NULL, 1, 23, false, '8Mjb99247ZKTc2kgJCHrmg==', false, 0);


--
-- TOC entry 5785 (class 0 OID 16746)
-- Dependencies: 241
-- Data for Name: cashboxdiary; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5789 (class 0 OID 16765)
-- Dependencies: 245
-- Data for Name: cashboxes; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.cashboxes VALUES ('04YHag2qDSJTa3vfcGABEw==', NULL, 46, 19, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('H01nKJww3HthdaE85ru/Cw==', NULL, 23, 20, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('ATeCCTgwUv7jgw5KDArhdg==', NULL, 54, 21, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('NqhSvYn9VqBQqpu3OYP7bw==', NULL, 60, 22, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('0FvCZiFCdxOTzSQjarnCJQ==', NULL, 72, 23, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('bWPyqzEve0+2EwQFa+o5kA==', NULL, 36, 24, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('Ef5iRKp4hKWi+QkZlxvk0A==', NULL, 23, 1, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('2C75iI/ZkaXSxxwIuygdzA==', NULL, 23, 9, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('NyirgfyNxNnqqDxQaamBYQ==', NULL, 30, 10, true, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('NyirgfyNxNnqqDxQaamBYQ==', NULL, 46, 11, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('NyirgfyNxNnqqDxQaamBYQ==', NULL, 56, 13, true, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('ZTXztA9Lkr86stKkTcKSxQ==', NULL, 56, 14, true, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('YZqhEI7J/sd7D8Hh/rNFqQ==', NULL, 56, 15, true, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('L12X1o0tT4w+s0kAQ9rcHQ==', NULL, 56, 17, true, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('M+2do5O7LEO/5gU9jqLfJw==', NULL, 23, 12, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('NyirgfyNxNnqqDxQaamBYQ==', NULL, 58, 16, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);
INSERT INTO public.cashboxes VALUES ('x5Ys7wc28mx7OJJkrXfFiQ==', NULL, 62, 18, false, false, NULL, NULL, false, true, NULL, NULL, false, NULL, NULL, NULL, false, NULL);


--
-- TOC entry 5791 (class 0 OID 16777)
-- Dependencies: 247
-- Data for Name: cashboxtoken; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5793 (class 0 OID 16785)
-- Dependencies: 249
-- Data for Name: categories; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.categories VALUES (42, '34', 0, NULL, true, 18, 0);
INSERT INTO public.categories VALUES (45, 'екн5', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (29, 'йц14а', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (49, 'ке4', 3, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (50, 'лд9', 3, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (12, 'енке', 11, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (13, '7686', 12, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (15, '768', 11, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (17, 'дол', 11, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (18, 'рпо77', 0, NULL, true, 18, 0);
INSERT INTO public.categories VALUES (11, 'авпва225', 0, NULL, true, 18, 0);
INSERT INTO public.categories VALUES (22, '45', 21, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (21, '23', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (1, 'Уведомление', 0, NULL, true, 18, 0);
INSERT INTO public.categories VALUES (3, 'Молочное', 0, NULL, false, 18, 8);
INSERT INTO public.categories VALUES (2, 'Мясное', 0, NULL, false, 18, 7);
INSERT INTO public.categories VALUES (37, 'па', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (4, 'впвап1', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (-1, 'Весовой товар', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (0, 'Без категории', 0, NULL, true, 0, 0);
INSERT INTO public.categories VALUES (51, 'tyuty', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (52, 'tryt', 51, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (54, '8', 0, NULL, true, 18, 0);
INSERT INTO public.categories VALUES (55, 'fdgdf', 51, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (57, '00', 56, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (56, '9', 0, NULL, true, 18, 0);
INSERT INTO public.categories VALUES (58, '77', 52, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (53, '7', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (59, 'апрап', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (60, 'Складные ножи', 0, NULL, false, 18, 0);
INSERT INTO public.categories VALUES (61, '1', 0, NULL, true, 181, 0);


--
-- TOC entry 5795 (class 0 OID 16796)
-- Dependencies: 251
-- Data for Name: changeprice_history; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.changeprice_history VALUES (18, 5, 4000, 1000, '2025-09-29 12:04:19', 0, 2000, 87, 1, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 5, 5000, 4000, '2025-09-29 12:08:29', 0, 0, 88, 2, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 5, 2000, 5000, '2025-09-29 12:09:27', 0, 0, 89, 3, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 7, 2000, 1000, '2025-09-29 12:25:49', 0, 0, 92, 4, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 7, 3000, 2000, '2025-09-29 12:28:14', 0, 0, 93, 5, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 7, 1999, 3000, '2025-09-29 12:30:05', 0, 0, 95, 6, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 5, 300, 2000, '2025-09-29 12:30:38', 0, 0, 96, 7, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 5, 4567, 300, '2025-09-29 12:31:13', 0, 0, 97, 8, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 7, 3000, 1999, '2025-09-29 12:31:36', 0, 0, 98, 9, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 46, 500, NULL, '2025-10-03 17:48:44', 0, NULL, 127, 33, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 47, 10100, NULL, '2025-10-03 17:48:44', 0, NULL, 127, 34, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 7, 1000, 3000, '2025-10-10 12:21:13', 0, 0, 137, 35, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 51, 30, NULL, '2025-10-13 14:47:04', 0, NULL, 154, 36, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 52, 2, NULL, '2025-10-13 14:49:49', 0, NULL, 155, 37, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 53, 50, NULL, '2025-10-13 14:49:49', 0, NULL, 155, 38, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 52, 5, 2, '2025-10-13 15:33:29', 0, 0, 158, 39, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 54, 3, NULL, '2025-10-13 15:34:35', 0, NULL, 159, 40, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 55, 4, NULL, '2025-10-13 16:29:29', 0, NULL, 161, 41, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 56, 3, NULL, '2025-10-13 16:30:45', 0, NULL, 163, 42, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 57, 3, NULL, '2025-10-13 17:03:04', 0, NULL, 165, 43, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 58, 3, NULL, '2025-10-14 09:26:56', 0, NULL, 166, 44, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 59, 34, NULL, '2025-10-14 10:22:28', 0, NULL, 169, 45, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 60, 33, NULL, '2025-10-14 12:35:57', 0, NULL, 173, 46, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 61, 3, NULL, '2025-10-14 14:32:32', 0, NULL, 179, 47, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 62, 200, NULL, '2025-10-23 17:52:29', 0, NULL, 186, 48, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 63, 200, NULL, '2025-10-24 09:59:11', 0, NULL, 188, 49, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 64, 3, NULL, '2025-10-29 09:27:51', 0, NULL, 208, 50, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 65, 5, NULL, '2025-10-29 09:27:51', 0, NULL, 208, 51, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 66, 200, NULL, '2025-10-29 09:27:51', 0, NULL, 208, 52, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 67, 200, NULL, '2025-10-29 09:36:51', 0, NULL, 210, 53, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 68, 200, NULL, '2025-10-29 10:08:41', 0, NULL, 214, 54, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 69, 5, NULL, '2025-10-29 12:57:58', 0, NULL, 221, 55, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 70, 3, NULL, '2025-10-30 10:25:10', 0, NULL, 227, 56, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 71, 2526, NULL, '2025-10-30 10:25:10', 262.6, NULL, 227, 57, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 62, 400, 200, '2025-10-30 10:47:19', 0, 0, 230, 58, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 72, 200, NULL, '2025-10-31 10:39:46', 0, NULL, 238, 59, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 77, 3, NULL, '2025-11-03 10:19:23', 0, NULL, 242, 64, 0, NULL);
INSERT INTO public.changeprice_history VALUES (18, 78, 2526, NULL, '2025-11-03 10:27:24', 0, NULL, 243, 65, 0, NULL);
INSERT INTO public.changeprice_history VALUES (18, 79, 34, NULL, '2025-11-03 14:40:38', 0, NULL, 247, 66, 0, NULL);
INSERT INTO public.changeprice_history VALUES (18, 80, 3, NULL, '2025-11-05 12:27:50', 0, NULL, 266, 67, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 81, 5, NULL, '2025-11-05 12:27:50', 0, NULL, 266, 68, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 82, 34, NULL, '2025-11-07 09:29:15', 0, NULL, 267, 69, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (18, 64, 300, 3, '2025-11-10 14:53:14', 0, 0, 270, 70, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (185, 85, 120, NULL, '2025-11-21 17:02:59', 0, NULL, 280, 71, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (184, 88, 3, NULL, '2025-11-24 09:20:21', 0, NULL, 283, 72, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (184, 89, 4, NULL, '2025-11-24 09:20:21', 0, NULL, 283, 73, NULL, NULL);
INSERT INTO public.changeprice_history VALUES (184, 90, 2, NULL, '2025-11-24 09:20:21', 0, NULL, 283, 74, NULL, NULL);


--
-- TOC entry 5797 (class 0 OID 16802)
-- Dependencies: 253
-- Data for Name: character_entity; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5799 (class 0 OID 16810)
-- Dependencies: 255
-- Data for Name: clients; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5801 (class 0 OID 16819)
-- Dependencies: 257
-- Data for Name: cnofea_exceptions; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5802 (class 0 OID 16825)
-- Dependencies: 258
-- Data for Name: cnofealist; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5803 (class 0 OID 16829)
-- Dependencies: 259
-- Data for Name: companies; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.companies VALUES (57, 'SCAostq0vP3Nkm5Qjykw8A==', 'huRQ24PS1TferYLTtkx4JA==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (59, 'SCAostq0vP3Nkm5Qjykw8A==', 'y2aZATpb6FNMmaB8/rwW4A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (61, 'SCAostq0vP3Nkm5Qjykw8A==', 'p2n6OxVCVkhSr87SxdR0Qw==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (63, 'SCAostq0vP3Nkm5Qjykw8A==', 'SFKw038zZX6WHylESo/XWQ==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (73, '1igCKDXTzcsbY1JImqGp3Q==', '95U1rZjJNg7jXQxbOR0fMA==', 'GeX/RYroddJqgFxjdlrmVw==', 'c+qwrqb6Z9qTLEcYeQUXAg==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (74, 'CI6QOAaEfnJDNCcuVeRApA==', 'wgeJdRtqDUxvFQDlBkQ1Cw==', 'hHuq6VLk4i4p7Fb+7LTenAS/JJjwMQRdy7ji+UdGwZ4=', 'zqQiKEXLKdJxqwATPvBQ3r/g+Ah6iwVuT3h3dAC3BN8=', 'mJRDaBrsCvnFddmqf8CZIQ==', '13uu425nYAgEI95W3z43tQ==', '2rlsntZhAVBZp7B50ACfOA==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (79, '0FZgiXx+UyA06NvvlufdX6rpgVGAJS9+4w6BEMxaJ8E=', 'Y57ITvqw1vZeyvo6gAHHrQ==', '6s6wz5le9T7vLb2OqKkYI9xD5ktJy1eyMA4S6EgyV/HzLxxR09w/tM+QWsGO2EdW', 'Lhr7ax5EJLe+8dogQfPYRPA7xnivqSi51MA+tTTc3Og=', 'Y57ITvqw1vZeyvo6gAHHrQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (39, 'aH9H0Mu9dGUVA1ljJz3mfA==', 'gyeUcDz9aAMNSXxeTzQQOg==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-01-08', 0, false, NULL);
INSERT INTO public.companies VALUES (13, 'eERU+KUyRmKl/zzLanaaRQ==', 'UJ2bu5MBYBdgUZUeOeIaNA==', '61PfrnpigE1/+npjRJQWs430dpcL6vUvmmap6tgWeIw=', 'u7MBOlvUMyC6NoXWKVHheDKNX4ds+9DrqOsw/pvd5KQ=', 'wxl9QLnk/jc4GYNVF1AhRA==', 'XBSEQF/eM02AbrW3+ogp10jseVwPPckDPpqOJ1jxYVw=', 'TBghw8jLatoUN1Fjw3GzBw==', 'ACTIVE', NULL, NULL, NULL, false, NULL, true, 18, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (17, 'ny5LxmyxUzC2obqlbK3Z4BcEhOddJDgR/AK+3ckjGo0=', 'WziOuZpQG6wC/azMAsfdDg==', 'U6fQKJNf044iH2PCRPbMp0VtWES5Fr35RMxLg/0cAa4=', 'liWtgdiMKGIsAdK6hMDGdou4/qTkCsuEGJHqaL9IEe4=', 'WziOuZpQG6wC/azMAsfdDg==', 'liWtgdiMKGIsAdK6hMDGdmna7h3HXZcXQyAGw/TMwA0=', 'WziOuZpQG6wC/azMAsfdDg==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 2);
INSERT INTO public.companies VALUES (41, 'E5sdTo85S7N3AFVGAKK4Vw==', 'WDkem0AR8GeN65XLZuXKWQ==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (42, 'rF8SthbDhvbWRNRkqO6TEg==', 'rF8SthbDhvbWRNRkqO6TEg==', 'rF8SthbDhvbWRNRkqO6TEg==', 'rF8SthbDhvbWRNRkqO6TEg==', 'rF8SthbDhvbWRNRkqO6TEg==', 'rF8SthbDhvbWRNRkqO6TEg==', 'rF8SthbDhvbWRNRkqO6TEg==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (28, 'gHNnD3UhX+UZMwncFm8sOw==', 'gHNnD3UhX+UZMwncFm8sOw==', 'gHNnD3UhX+UZMwncFm8sOw==', 'gHNnD3UhX+UZMwncFm8sOw==', 'gHNnD3UhX+UZMwncFm8sOw==', 'gHNnD3UhX+UZMwncFm8sOw==', 'gHNnD3UhX+UZMwncFm8sOw==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (29, 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (33, 'aH9H0Mu9dGUVA1ljJz3mfA==', 'iOaqVb/O3siXWuBbrd+sbg==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (22, 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (38, 'aH9H0Mu9dGUVA1ljJz3mfA==', 'u1KcIdbEm7HXzo/2Rv0KMQ==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (27, 'SCAostq0vP3Nkm5Qjykw8A==', '4lGOAuuStDtjdSgehmcqDQ==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (30, 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'E5sdTo85S7N3AFVGAKK4Vw==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (35, 'aH9H0Mu9dGUVA1ljJz3mfA==', 'MixnI+7pc/0S0oZ4uC2rEA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (31, 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (26, 'SCAostq0vP3Nkm5Qjykw8A==', 'NfhGSotoga24sJ+VZumrrw==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'SCAostq0vP3Nkm5Qjykw8A==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (21, 'P+hH6KHWBjx6fasYqIxIfw==', 'AQIf3l+4UwAWZxv8U2itpw==', 'cceH67y6EqLLT7skBlRxgA==', 'Kp+WJsez1QBgl+vuSFEZnw==', 'nlouC9ngqZz8rv7EdLS9mw==', 'Kp+WJsez1QBgl+vuSFEZnw==', 'nlouC9ngqZz8rv7EdLS9mw==', 'ACTIVE', NULL, NULL, NULL, true, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (19, '+F7ACbtZeC68A+lZW2FgUB5d+oozql3g9/wksyb6n/k=', 'ICXJo6i1t8VYg4xe7oRR5A==', '3jsU3kRpN4WpqLLuakDBqQ==', 'UmX1zf/8SB15mOZwwTOrVGf9Umir1psUtrgvftK3LBA=', 'ICXJo6i1t8VYg4xe7oRR5A==', 'H9hHEzolGkkeVKHKWFmpEQ==', 'ugaxbM0xKYiCkEn5krhQrw==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (45, 'hIPP7DA5v9OjOb6KINIxCw==', 'XepDNXa+tbf+5gYwx1mBxQ==', 'hIPP7DA5v9OjOb6KINIxCw==', 'hIPP7DA5v9OjOb6KINIxCw==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'hIPP7DA5v9OjOb6KINIxCw==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (47, 'NDbKYbTePrMbHjnaVDqV9g==', 'eSY82e8qMkJwCHzD6l42Mw==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'NDbKYbTePrMbHjnaVDqV9g==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (16, 'eEKQh9le1eFW0P4nJRvLUQ==', 'wLx9IyxQs/lhPJ5bWHDoTw==', '66houBUR7pwg4lAbGt1q9GIzbnCTDjqjYEDzwD65DFYiNsgjsMiQm7wTNgpZMwkb', 'eEKQh9le1eFW0P4nJRvLUQ==', 'wLx9IyxQs/lhPJ5bWHDoTw==', 'eEKQh9le1eFW0P4nJRvLUQ==', 'wLx9IyxQs/lhPJ5bWHDoTw==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (80, 'KaWRpA2zuEBiOrBjEZX2bQ==', 'Pd0NrsyZ+KwDFANvoK723Q==', 'lxN/qKSHdI382K90cP1zZA==', 'Lxo7zQLV71MKJ4E6FXxp1Q==', '9VmiL6pwGjo71AvzUMNKWA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (81, 'At6mvNCWyCLGk7O87MxwnA==', 'FOS/zHTxr9p+7dvC8g09HQ==', 'E7T5hOoPUqGGVPjrHbvqAOSRcTUsvQHZUSiru918PIQ=', 'E7T5hOoPUqGGVPjrHbvqAM9ozSr0YqaLPfrnBFkFG/c=', 'FOS/zHTxr9p+7dvC8g09HQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (64, '5uzFmCm6M9XR3WbjWfqBAw==', 'eBic9CTUVUi1w4WwQBcy0g==', '5uzFmCm6M9XR3WbjWfqBAw==', '5uzFmCm6M9XR3WbjWfqBAw==', 'thRu1sE0PVZEL0LmV2EWQg==', '5uzFmCm6M9XR3WbjWfqBAw==', 'thRu1sE0PVZEL0LmV2EWQg==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (65, 'rqEZi2fks/0EZMsVsqd1mA==', 'x85RfS/Mx9i1az3QsuwUvg==', 'lttH1QOP9jA2DT94JSwUOw==', 'SNlgjwMAsv+KgKMogSMUIg==', 'NjE3tVk6KAcNgWRVsVfa5w==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (71, 'wjZwRX+0DLxJNEsMbln3DQ==', 'Oueg19P8Qb85dYHEzQ5daA==', 'EsBKPuiuVLQpU66qQ6WKSw==', 'wjZwRX+0DLxJNEsMbln3DQ==', '5eRlwLdRvO9ASRFPZnuBDA==', 'eG4fUjvY+uTSHyjvt/6F7g==', 'Oueg19P8Qb85dYHEzQ5daA==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (83, '6ekUczaq5BCw0JEiarTBtg==', 'CimuWDTfA/O02JF/Z9kbEw==', 'K8Tzn/82VvTJ6htbUJK5Lg==', 'AgZKpvWQtHQpkwJUgwyZxGTR1LkHI2Z6qCxPmcs65Po=', 'IBrwVgYlfG7Sk4jj+4cS6w==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (84, 'Wc7j9UVEX/KvGPOsz1jUwg==', 'fiyuiq59hUyEZ113sxXLRQ==', 'HQoO5v2jfKZ/GC+eiEleqg==', 'VMif/PgKAzinNUHIrSlkzQ==', 'fiyuiq59hUyEZ113sxXLRQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (86, '3jUX/x8N1jCValM0G+lgPw==', '7qTu2Pb7CesAYUgeQYsR1g==', 'eveeVqhRYn4TeQ8P0hIp7A==', '3jUX/x8N1jCValM0G+lgPw==', 'NwIP1PDKz7I3pd03PZsFfA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (87, 'M8Pe4bVUYWvyUHZszT2DNA==', 'mh+gHnY0r91R4VOYmiZ9DQ==', 'DuauMyht6jNypxNJNFhskA==', 'tSmyaQiV/NeLMW+U3dJWZXhQ27/TvZs4jJ9hVnxX2+0=', 'mh+gHnY0r91R4VOYmiZ9DQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 7777777, 77777, false, '7777-07-07', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (89, 'Kq9wCFdHymePwNKwiY7A5Q==', 'nFOpLnHkYi/uFRFynx/MCA==', 'GD4LFXNwkh7cMbzTKTSDcQ==', 'n/jKPfM2utnZA3Uw0OaeAw==', 'wLx9IyxQs/lhPJ5bWHDoTw==', 'UJG3bQIQU/Z90qwp0IbocQ==', 'SCAostq0vP3Nkm5Qjykw8A==', 'ACTIVE', NULL, 2222222, 11111, false, '2019-12-12', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (95, 'cic3Aa+nRK/J99Czcy3NF8y+gaZZM8GhFKpBWEabhEw=', '3zcL/FXtXYs3HWqRxJa/sw==', 'LUyiJwbefkQloBnofONDnABePQon3VfsjE18bZCUOVoWG11GUOBeK1Qwn5fcBT/wcFw+IERwsP2Szpz8rXEwXBJxNEibGOefQVAFOa6M51o=', 'bj/2QaAy6+rxUQlt9czPCQ==', 'NDbKYbTePrMbHjnaVDqV9g==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'CLOSE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (97, 'nBozAAFY11uloOiyP5wbrA==', 'oYgF5X4uM3rMbHKaXLc7mA==', 'LUyiJwbefkQloBnofONDnABePQon3VfsjE18bZCUOVoWG11GUOBeK1Qwn5fcBT/wZQ8asfDyG3MNRDtwhNydCn0AEwjFwxyNrRYu4O7BAfY=', 'ZPlLlCVvcTzSrpTmZMVDJQ==', 'nlouC9ngqZz8rv7EdLS9mw==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 2222222, 12342, false, '2020-09-13', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (92, 'zdVDX+RU6CQfsOyDZz23qJuvCFW0smodSxWG05WFlz9WWNZBK1eZhUNWPzL8m7NEQRWm6ps7pyGdl5TXbXLWHA==', 'yILgyknEFimNbtuecvrsDg==', 'v7eaF0prF/K+YsKYD4imRfd+Nz8Z8+h7RsafcpVuUlSTwchg2bJxV8YVV3y4a30SzzNFgYFgG80j19dloddo3I1tWN4Pk2pNQqUUWuY/IoA0il8gHhumDVIEPTBWywqb', 'tTfqp8W0MRRgdOhEbZYGXCb19tRAe3GrUspxIr+k0CPP8XSVilV8CIxY8gIA79JLSDjuf7gm9G11QHWbTKIo3w==', 'yILgyknEFimNbtuecvrsDg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (93, 'r0A+Z1UJkZoPhwXUFKVjGOLx9V+d/Basmy+otiqU1qQ=', 'RtrrWGY0MFuaNPvNAXGe3Q==', 'muge/1iHrd46vePB6/3dpIr9PVTRlTJ7Btg1hx26Yis=', 'nuXU7rYGjLLSA3mLzzk5+JaCcDDMhG9tCGj7s31M16z2YHwRA/misVNYXlNubHl9JSTs3jWRklOAVIv95vRNvQ==', 'cN5J7kRv65DqonTdFPd1/Q==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (96, 'NOjyoxP8aY1z/1jdVWMhswDIwy0E+8dNxxGUAF5u7LU=', 'qnHSEdqqN+S2p8ReM8zECA==', 'U6fQKJNf044iH2PCRPbMp22hpPmG6tWn0Qd089JiQCCfywf9jKkX1rjO5URERvA/F+/L4fQ+OJCxeIxNvnm39vxM8lVBbkAx3be55qI1Mok=', '0V2rwAoyf85neq6zAdv4RuPVbhIiBDM4gmEaDsZoQqC5UmlXeoAZ5NhD6nM/PSWiEVYwSwHf0P/l3ledE/C4oQ==', 'qnHSEdqqN+S2p8ReM8zECA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (109, 'g9zvyUIsqWC4M4j7d7Q1HWWRBV2REXulBuGg6IoLX4o=', 'B9rAJXukCmUgTgUzQd0E/w==', 'LIbWtr3xYx8fL4iPcM2sq8LA1ZYj3QJX7keohQ+V3ag=', 'Lhr7ax5EJLe+8dogQfPYROtbTjofMMyuRjcjgp7xlk8EyT1k4t0YwPyt2ZWw33Y4YjvkCvdALNvV1dvUZbc0Kg==', '1h2HKK/qoWBagljiQUs/jw==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 123456, 123, false, '2020-12-12', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (110, 'A8tfB42Tcm2xrFM7r9CIuvl6d3RTc9YQl3W4bgElcno=', 'tQZJJ803mYpNvSqxy8BrRg==', 'U6fQKJNf044iH2PCRPbMp22hpPmG6tWn0Qd089JiQCCfywf9jKkX1rjO5URERvA/F+/L4fQ+OJCxeIxNvnm39vxM8lVBbkAx3be55qI1Mok=', 'rdA0rbb8TMcqHi1ZTc37gZFcHUMtB+eHWofL7luA5Kj5WU9FOVrZbMnq+L10FCIm', 'tQZJJ803mYpNvSqxy8BrRg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (70, 'Tz2GIxmHeEul1P7Q5KM0aA==', 'NwIP1PDKz7I3pd03PZsFfA==', 'jK1r6sYs/3amdQVR0n66tQ==', 'M+K+0LFWKfTuNebPxHaMIQ==', 'bwqgcheRS0/rv59aRgRYTQ==', 'DR5CYF33tLneElVyLEaBaF/2wft6WVeKDIRrqx35HO8=', 'NjE3tVk6KAcNgWRVsVfa5w==', 'ACTIVE', NULL, NULL, NULL, false, NULL, true, 112, 50, 0, 0, '2020-12-08', 1, false, NULL);
INSERT INTO public.companies VALUES (66, 'pgmgmOVzqateqGmgC0iofRpadlTGgoLNZ/69zpFUuo8=', 'UqNSTQoEqvpP+nIZp0V1bA==', 'Xp1AzeBi98ejSiHmNCsqOB2aZuXliVLuaS9xg810yqI=', 'LdDcjMnHoWKumejC/WWo6KjVpRhT2b22z2PTVho+RS4=', 'IJyqUmGm9tEXTyvUMZTa3g==', 'X5EtNTcx05jAOtrge3tiDSgCFwDgq/9ereOGkA9PEt4=', 'aAZt7Zo9o5yVXut8mx+jDQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, true, 112, 50, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (111, 'UIEnIl9Q1Y2IgESjaxnzaA==', 'bc/ZhWHCiS3J6dX2mhmyPw==', 'U6fQKJNf044iH2PCRPbMp22hpPmG6tWn0Qd089JiQCCfywf9jKkX1rjO5URERvA/F+/L4fQ+OJCxeIxNvnm39vxM8lVBbkAx3be55qI1Mok=', '27drrPdUMUtuiDEM64odLuORgU4JrPSY44v0TetiU+ndmcuOoijHYJfHzb7jp++oImi5dRM1uAJktnm9yAuuIg==', 'bc/ZhWHCiS3J6dX2mhmyPw==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (113, 'nEDvZCcVR9eZ0ZP9Ot2tcA==', 'RPJcnZJ64SfVxaKeJlDY8A==', 'Xp1AzeBi98ejSiHmNCsqOGlMFI2BX+NVIEw08yTruL2BvhLa48hvIY1/7St7NRVurtkNfufyDTE7zdSwlUdW1TMmN7mRYtc+YsKwkODv5YqB+LyAcHClbVy2gXQo8g55', '3VVJvaRnfw2ajdaWWegRPhOOknHOYNTjZhsvGkLvbpKXFqCaf0P+k+KJZCMDwYGMm5ykL6kcaRRuKkteYGHMZg==', 'RPJcnZJ64SfVxaKeJlDY8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (115, 'br35S0BoAGFBcvKYRERD+g==', 'lyFALxlK3JKRNEfQJmjLKg==', 'TKQpXM99YJ07nxVPfISxPg==', 'gZeZR6z0bNTM7sKvwIDtLeTmDBG3GwJhQr+VgwgZPZk=', 'lyFALxlK3JKRNEfQJmjLKg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (37, 'aH9H0Mu9dGUVA1ljJz3mfA==', 'yhyyGG0UuRw0n2a1J+NawA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'aH9H0Mu9dGUVA1ljJz3mfA==', 'CLOSE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-01-08', 0, false, NULL);
INSERT INTO public.companies VALUES (117, 'mW5oFW79HvWmb1bvb9AjOtm0u8sw9t/f7Ixs8IyVrbw=', 'HIS1pHg2C0hCsahVetT0vA==', 'iay5D+G2RZEbFDHYL72Lf/rGKzkUSq3UqNwNjhoyNO/vnkGfK/Y5q9Ctr8zOkIIA7kHCvVWmXDG6noYN130iTA==', 'hKh2+3ewIELHo47ZKvNwuLFWF62hvRhetstYMlFVY2+Ni2hrgoAjBw6VEKPTSLPheCsMuEDyYoOyDLJragcEWA==', 'HIS1pHg2C0hCsahVetT0vA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2021-01-14', 0, false, NULL);
INSERT INTO public.companies VALUES (119, 'S4IWSzyH05qrZtf3RBVCcnzbG7vW/Pq18RyKQhinYl8=', 'Ri/3hKpk8aBX1D7G2F2EHQ==', 'MfpZG1ieL9JssUDLVxAsZT0rZWSE9LoRxN/YF0ci2oY=', 'g7ogMMhYuo9dgf9uE6Nv4Q8A9OUSIhXnH784Bo/q9gQ=', 'Ykcyo2jVBgocKSxcGT0X/w==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'CLOSE', NULL, 11111, 11111, false, '2021-06-03', false, NULL, 0, 0, 0, '2021-06-03', 0, false, NULL);
INSERT INTO public.companies VALUES (152, 'BTB/fRnQAPsrmindpxRsmA==', 'APnuBklPQY0bJn0IDG061w==', 'OIDMbkYbjLY/p3TC3PYMAA==', '1JzeYa/PMoC1eBDZjW1Iyw==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-02-06', 0, false, NULL);
INSERT INTO public.companies VALUES (98, 'dWWyXmSR9t30a6EdY05Hl7BiZXfmwQyoB6vQYq43u/wMjkCfYxPUI6Dnx5s9wgvzpVGOvIgTKhR2oMA+HG7zLA==', 'x05dEUMG4iLy5lHgPw+ydg==', 'dWWyXmSR9t30a6EdY05Hl7BiZXfmwQyoB6vQYq43u/wMjkCfYxPUI6Dnx5s9wgvzpVGOvIgTKhR2oMA+HG7zLA==', 'dWWyXmSR9t30a6EdY05Hl7BiZXfmwQyoB6vQYq43u/wMjkCfYxPUI6Dnx5s9wgvzpVGOvIgTKhR2oMA+HG7zLA==', 'x05dEUMG4iLy5lHgPw+ydg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (120, 'a+RmLafGj4jkvs0HEPF4r43R6UxvfxaehNI6B8cbrbQ=', 'HZ+h9vUY1IGzenYyKynBRQ==', 'U6fQKJNf044iH2PCRPbMp8md/MtkBKtMzexpBEhXkYTEOlfoLogIKlluP8+qrjGMvQSFFLaiPMOqmNh0lqJvAg==', 'FqzNfiHEzRp4Zd1Vey8tE2zCod8K2HBgZHgauAAqTa/yi1k+irkanNdtrfa5j+df', '7z7YPZguwH4qttYJbliLTQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01', false, NULL, 0, 0, 0, '2021-07-28', 1, false, NULL);
INSERT INTO public.companies VALUES (125, 'uzCVof0YWqQ0MI6lzFgm2A==', 'RJ6PcdKkGj9Bhb0m6CMNHw==', 'dDccmJLoXkxkQrCs5kzOEtlUmq+EVaexDdLaidPaFGE8ylBGZmV92Ji+aZdM8Z7J5P9Tgg22mQOnRshfpK+7Qg==', 'RyH0mQdywuqjU90CfVhQ4TcK7patXyK5temWgFU8QJqdHBO2730RQGS5JPRIA9pN', 'RJ6PcdKkGj9Bhb0m6CMNHw==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2021-09-01', 0, false, NULL);
INSERT INTO public.companies VALUES (128, 'TTh2MhwYdEBhxnJg5s9PUrhKGS0UCL02t+DX8WFzKiI=', 'vHciHwKt/0jzHvY3bY/B+w==', 'DLy9VigiHemaf3RLIy3BYIoKVZgXmpM0IQfLNEv9PNBXtsaTAgVAKs7MTd5hwLb4oD0AGhQDyNjcf4GpF8A9bQXRLYMHkCA8llxXd+XSPIo=', 'qHVBkZ5B7NBeB8wevrbqwjThrrI14O8Rz/B3xm4fp/XHwXVlZ7MqOMFAon7yro4Vzw0X7zKvkradx+OCcfOJSg==', 'vHciHwKt/0jzHvY3bY/B+w==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2021-09-01', 0, false, NULL);
INSERT INTO public.companies VALUES (91, '/QCI9ImGrvJ94KIvqksAZQ==', 'DqiUDoAn68tLTJQBEjCHjg==', '/QCI9ImGrvJ94KIvqksAZQ==', '/QCI9ImGrvJ94KIvqksAZQ==', 'm98jjBUEuU81qYVdu6fjSA==', '1ImoKugp3qxVh3waE0jGoQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 1234567, 44, false, '2020-08-01', false, NULL, 0, 0, 0, '2020-12-08', 21, true, NULL);
INSERT INTO public.companies VALUES (121, 'EU89eWQ+4uldAmBDX1y4Fg==', 'FSiGHguUL0m6NiouNqDzcg==', 'iFR2UB4vC/892bgV/vAViki3Zor5fwqHBY7HSeztiGg=', 'vS7iBr0kz3tz0GtC+Q43sg==', 'FSiGHguUL0m6NiouNqDzcg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01', false, NULL, 0, 0, 0, '2021-07-28', 0, true, NULL);
INSERT INTO public.companies VALUES (132, 'gJgXk5ni6v8MtAx1qLX5ZA==', 'SvE3zrOWPB5b7SFvWLoecw==', 'jxpQpUmgg9d11+Bro8qHgHhuN6ZSoXhF7ZxiIohGCFU=', 'Rhxw2ZAE+IOyTRaF9plUETSgrzf5kUwSovnLbwxjB2A=', '7DLsmmGvYEniG4p+WMaN+w==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 123, 123, false, '2021-11-29', false, NULL, 0, 0, 0, '2021-11-29', 0, false, NULL);
INSERT INTO public.companies VALUES (130, '7JyZYdNhV3PYxPUkDPhSdJsv8y7ujC+TnDDZozMU4n8=', 'qkgO0LFImi1RVurxn3u7ww==', 'r4dwg/OdujZjKTjLbEemWpgwJ/vcK4q2PJbpliW+Of8=', '2NhHkzXuOygemfyHCJkadg==', '9Xs6666xz8wmGGpOII2fFQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 123, 123, false, '2021-10-20', false, NULL, 0, 0, 0, '2021-10-20', 0, false, NULL);
INSERT INTO public.companies VALUES (122, 'y2xD3no875bLfDss6AKXBEgIrucSk99+PySRxTOa4Gw=', 'XdU5Qa6XoSHE5/tH+t7TYg==', 'DcmZPYRrCmrPgostDHjZmwjaAqqyi2J9ZsWVk/u6eFG6SdJFJgyeo2kEDXoWH6cwtH9kQgzbggS172mpe1zbeg==', 'g7ogMMhYuo9dgf9uE6Nv4Ve/iPWztXS59JuaQLxjsOo=', 'XdU5Qa6XoSHE5/tH+t7TYg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01', false, NULL, 0, 0, 0, '2021-08-09', 0, false, NULL);
INSERT INTO public.companies VALUES (131, 'gwLLuaaJ1bZP13ftVT2eKw==', 'sHBHGdaHzN1XVi3KFUHHYA==', 'DpZM2rxFnZZNg67yD/wFMw==', '1ElflKrgmXSRpZ1XU8vA2Xa5/IhSoUmYvx0HDTS2DHR3BfD7u9Y/5QRyAoK97uoS', 'sHBHGdaHzN1XVi3KFUHHYA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01', false, NULL, 0, 0, 0, '2021-11-15', 0, false, NULL);
INSERT INTO public.companies VALUES (142, 'YxWOpmGHUu+W8ARPW3WgzUMxSAfOsW/n+ST8+49jDLM=', '/0KnSaLhRun7ZDFHYgB2Pg==', '8s/ybREzn4UI/UeCznsk9Y8vMy0maBUUvewtRPMeLek=', 'Wag/U6S6XmSolqgVTLWJ4Fls8MyS5o9k7+kJnnQEX8sSqLFE2tt7igc9zXapCsvg', '/0KnSaLhRun7ZDFHYgB2Pg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2022-01-21', 0, false, NULL);
INSERT INTO public.companies VALUES (143, 'rB6xO0D9n5ExX8yjRwQ57w==', 'tucKatdU793fhxUBXtv4nw==', 'DpZM2rxFnZZNg67yD/wFMw==', 'ggE3chqNpCMjMwJTRBJ4JiQJAcllVXvEaJpa038btnRJorZKsxC7NAnpQXt6aLKt', 'PT5fNc/IGGRCSGO14PmxGw==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2022-02-16', 0, true, NULL);
INSERT INTO public.companies VALUES (141, 'gwLLuaaJ1bZP13ftVT2eKw==', 'xd2IrHzQ3d4hvtffppg9QQ==', 'DpZM2rxFnZZNg67yD/wFMw==', '0ybiH4TM4cNfdbWdEWMBHw==', 'sHBHGdaHzN1XVi3KFUHHYA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2021-12-13', 2, false, NULL);
INSERT INTO public.companies VALUES (138, 'rIYZnKyuID6Jbktkfs5Kcw==', '26+P1XeW/hqrGN7KH8jp4w==', '8s/ybREzn4UI/UeCznsk9Y8vMy0maBUUvewtRPMeLek=', '244Im6zEjyQ+yKgw5hKdDDVpM40w4L7AYZILRpyZQ2k=', '7DLsmmGvYEniG4p+WMaN+w==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01', false, NULL, 0, 0, 0, '2021-12-07', 5, true, NULL);
INSERT INTO public.companies VALUES (145, 'q2mQJp05zMVlpIlgYk1Baw==', 'mEfs76ktTNkdxI4P9IE1Mg==', 'Lxo7zQLV71MKJ4E6FXxp1Q==', 'KCTTC0pDuFF75GFthKhDBg==', '8XY97anMfps6Ou6iW1Spgg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 123213, 12312, false, '2022-03-02', false, NULL, 0, 0, 0, '2022-03-14', 0, false, NULL);
INSERT INTO public.companies VALUES (148, 'q2mQJp05zMVlpIlgYk1Baw==', 'eLNcuLDrg28KWb0s6hGUMg==', '3ZoBTG83db9famYwiL3GOQ==', 'uLKnQPOen9q9DXZhDKM5CA==', '8XY97anMfps6Ou6iW1Spgg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2022-03-14', 0, false, NULL);
INSERT INTO public.companies VALUES (112, 'kwSU4XrjuG4sptj6TF7JPg==', '3Lqk/dZKTtnpsgTUGhPPSA==', 'Gvy8xM2q8MaJfoYvv06Jnp13nX8GbLkxe+ElxnRaBqJYZ+UDJ7+JmudXEBGwBKVh', 'cwbZ4P9c3kExND/bmhkUIg==', '3Lqk/dZKTtnpsgTUGhPPSA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 1311201, 12355, false, '2022-04-01', true, NULL, 50, 0, 0, '2020-12-08', 0, false, NULL);
INSERT INTO public.companies VALUES (124, 'iQvN/lbYBTk7ZhOGiI9scftA8p6R7VbmgzeL044ohJE=', 'RHmh0hXtzyDkn0yBWohRfQ', '6RnxYwZs8gOQ8P7nVt/TFz0kAJ4O8dJxv1vkHNmaonWbKyDaq6YBt9vC45pJkfE9By+hATTZ4K4tGv/ITnVuvw==', 'XdGnjfJb6V7uC55tdQIkcX3UPK70esIspbdk15iXvR6TFTHmLPNFiMQJO103UzY5NWTMfQdb0dF0RiUSJgULSw==', 'XqRhHvtijKpx8i9UeMuKZw==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01', false, NULL, 0, 0, 0, '2021-08-18', 0, false, NULL);
INSERT INTO public.companies VALUES (5, 'bJ1RHovey/dXwSrUjH7tag==', '+aCLpND3ReOkbJ0afDbYPw==', '66houBUR7pwg4lAbGt1q9AUkIwxYIDhD68llCRADmJA=', 'FgjOiZ4ElIlOv5NwC3lON/xoi7qhElSimE9bjFZxe9s=', 'nKG72LLUR6d0G2yH6nMYyw==', 'aF6lAM5asBtJav8hqLbb6BYu7Yo8cFwA/TtT+KbZFnY=', 'FPI4prjtgSpNjYFzpy9B0g==', 'ACTIVE', NULL, NULL, NULL, false, NULL, true, 18, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (14, 'd9pkNWn1Jz/uk9EMXKaj84t+qhrbJWxKDNPr8Qo8CU0=', 'NyA0982cNdjHld24VorF4w==', '61PfrnpigE1/+npjRJQWs9r/qtT4HXLeeLs/K5Qk8g8=', 'QrLvTcjCoyKmDbBgGfUK9n/4YeJTnrp06Mc56l6w7hE=', 'voaHgkvkEACP4ReijiZnsw==', 'BL6BtnK0122dd6zDlVrNoGmi/gtihD2XQo4xOj1mjoc=', 'Wmmg0zEU/n8BxRsaIOocgg==', 'ACTIVE', NULL, NULL, NULL, false, NULL, true, 15, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (0, 'U2FsdGVkX1+eyfoRPvWhLak3OaFyPqqfzI1hc9YCjq8=', 'U2FsdGVkX1/J4RFU0nGymrbSWwxWuL0cIh+Lbd76UFE=', 'U2FsdGVkX19EsYaWQzS0st9tUo7VRi1FtUW+gbMQeQo=', 'U2FsdGVkX19lE2Bs087ZLEOvuFpuVqDTbbeqOBthr9U=', 'U2FsdGVkX1+zkLlTnyV1ZSAOeuumEtqOIB1qnTrISrc=', 'U2FsdGVkX1+51BHwR9/xVRuxSBuVx0OKjdGTu+94AUo=', 'U2FsdGVkX187zSF1jxAe6nKqFh8xrvEviFR7b+2qQuM=', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2020-12-08', 0, false, 1);
INSERT INTO public.companies VALUES (150, 'DDsHtLl6F2CQMzV/xAnbYw==', '5virbNJyS26uGj0l8hzgSQ==', 'aSU9Y63t9WyBEhBIubVrVA==', 'DL+h+OaTOAwmgQ/r3zCEjA==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-02-06', 0, false, NULL);
INSERT INTO public.companies VALUES (151, '8AbJ9eCHXbeJgprOLpbf7g==', 'VPFWSCFw1dqqxoNLeVaVxw==', '5a8uJHuD2y6+s7p4m0G4iQ==', 'oIQTWD3q/RJ1wqIZ3rTs0Q==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-02-06', 0, false, NULL);
INSERT INTO public.companies VALUES (165, '3r09iHw8f7R6uZU918iQ+g==', 'R/uPKwZdvO8Yn3gAlYJrOw==', 'HtfP0Mu9VUzBU2f11VpQsw==', 'Ufvc4HmwUU33XNl1t902Lg==', 'QiZKfCSXWAHSZ9xTgdq69g==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-05-12', 0, false, 1);
INSERT INTO public.companies VALUES (154, 'qGVH5mv3hcpioPr+5zhHGA==', 's7+V6fI54Sqwxe3byqy4aA==', 'kA1Y805bga6ZlBjvmhDs9g==', 'R/bJy056tG2a9bAOEO32IQ==', 'APnuBklPQY0bJn0IDG061w==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-02-07', 0, false, 1);
INSERT INTO public.companies VALUES (157, 'BiL7ZZqOC+T/7SvoGYgIMA==', '3CVeUNNS9BTmoQkzMMeWkA==', 'BiL7ZZqOC+T/7SvoGYgIMA==', 'BiL7ZZqOC+T/7SvoGYgIMA==', 'fiyuiq59hUyEZ113sxXLRQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-02-08', 0, false, 2);
INSERT INTO public.companies VALUES (159, 'TwhAFuvfFiDUgibr+c4OxlXEvUprmWrekFSQSlBnq6o=', 'C8XS9l2plgJ8HEKA6Ky5Bw==', 'lnkIDSR/YsCEMUhE9hIPzw==', '1kyeAiXDXiC4RUuzsVOIHQ==', 'NwIP1PDKz7I3pd03PZsFfA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-02-09', 0, false, 2);
INSERT INTO public.companies VALUES (15, 'Kq4s06jRMDLm1xxShxqizhDegkpxYrZURQB60nirHZE=', 'WuqdbwsVBAD43AD7Uko9uw==', 'U6fQKJNf044iH2PCRPbMp0VtWES5Fr35RMxLg/0cAa4=', 'UmX1zf/8SB15mOZwwTOrVAGIiu2HIxmXtZq/4PYSsSq9BM7fiPCo6aEM4dXp/oVa4YWk/BqqIW7aPNqLyBfmGA==', 'WuqdbwsVBAD43AD7Uko9uw==', 'OTybM3fiw3slx3I3ivxWwZl7iRce9ZCxA7XR0rb++03WFgS4NjXPPJQkJBG7IkPm', 'iLLI9S+c+ueiX4K8Hstmlg==', 'ACTIVE', NULL, 1204515, 60001, true, '2019-06-29', true, NULL, 0, 1, 0, '2020-12-08', 0, false, 2);
INSERT INTO public.companies VALUES (161, 'uVQmA9C8djNRfWLam+2hJw==', 'TgJjjlc71Ce/lchqQ2yOKQ==', 'w/NLTINR/k2twlTpyW3NLQ==', 'XGRh5kcUpaE7r/HQG5ZuZg==', '8YSygmBZeXI9X52Hnev9eA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-03-29', 0, false, 2);
INSERT INTO public.companies VALUES (162, 'qFcc2JP0X1iQCM0NJ5dNGA==', 'rYLn1eMvhHGWHC2pwfHEFw==', 'y42737qOD0F73BPvaJprhg==', '7WYAQ3AjlsH2+eQXkV5/Rg==', 'uHcNlsaSrr9OfNnFdCn8CQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-04-26', 0, false, 1);
INSERT INTO public.companies VALUES (163, 'fSVEg7GbloHM3Y+0bJLoWQ==', 'cI/TUPzIEJ2ZTJGS2RvBEQ==', 'j1xNVHPl1ZIeiJpGKC5t5A==', '8NB+pMiO2rE4X5jZgFEdDg==', 'dOFq/IMv+5z76qhNg72vRQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-04-26', 0, false, 1);
INSERT INTO public.companies VALUES (167, 'zKf5crBAdZre1mS5z7R+ig==', 'CoTQzSw8VQEjviwvJoJMfw==', 'qunvPXKjBmAz7m/PIm5Tlg==', '2Tc5HtcEf9PQ4s8Elf2k4Q==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-05-19', 0, false, 1);
INSERT INTO public.companies VALUES (158, 'TwhAFuvfFiDUgibr+c4OxgTuf5yZyYpWxR6XFXEfw/c=', 'dhxAZG5etBZT6ehwvhEWWg==', '6cUrNb0Qo/mZm6Uo5IbwUA==', '7+QeINM8f/5DVGzR6ARETg==', 'FOS/zHTxr9p+7dvC8g09HQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-02-09', 0, false, 1);
INSERT INTO public.companies VALUES (169, '5KGravdu+0ys1/h9CH/9Pw==', '1V9apUURBjtwArIFJ2eudw==', 'KWFLoOAv/M4S3yAWfHUD8g==', 'CGD2nMG+g1f+OMFQSOiY1g==', 'qRsdhhSghnH/5qeAtAs2EQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-08-31', 0, false, 1);
INSERT INTO public.companies VALUES (171, 'Bg+2sobXjZGeJZkoLQB1Dg==', 'zb80KR6U7PgkHGne5UHWOg==', 'IcnMg/swfZ1F+pHi94b/qg==', 'y42737qOD0F73BPvaJprhg==', 's3jiRIWIuKhkUohL57ZkKg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-09-01', 0, false, 2);
INSERT INTO public.companies VALUES (178, 'HLRuTAQA7XpIRu71yGscsvVyN2fgFZbOSCDQ+IcDLUY=', 'H58BKDJz5ZJu9cgOwRNARA==', 'nEq7EsbbPM1Zkb7xo+GIXQ==', 'vRu19xK4SRj5489fXIlTsQ==', 'BRpzlFXutY4KzIAMjnLxXA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2025-11-19', 0, false, NULL);
INSERT INTO public.companies VALUES (179, 'xRhG3/8sEDSLiFD0H6d9gQ==', 'Uzt3rRcGIFi+pDiipWIN6A==', 'kSsFUdsDgaV1oMgJ6FBkdQ==', 'kA1Y805bga6ZlBjvmhDs9g==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 2, 1, false, '2025-11-19', false, NULL, 0, 0, 0, '2025-11-19', 0, false, NULL);
INSERT INTO public.companies VALUES (181, 'v7aLhZQ6mRY6rwL/JmBLJA==', '5DAOQzzgXxBzH+irh07iOg==', 'eYakzEtqsAs9XI3jj+JcBg==', 'mFJoQJaSAloAFNmveb40Mw==', 'b26dZ5/pe63etRy0MO+v/g==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2025-11-19', 0, false, NULL);
INSERT INTO public.companies VALUES (172, 'n0Tr5fUJtn9TGdTnrmBYaQ==', 'lSLoqUhnEbHkF/vN1vS6ug==', 'JniG4vHdxfdkb7wZksTjcA==', 'u7oy2d6B3Opd4zpkC10ZkQ==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2025-11-19', 0, false, NULL);
INSERT INTO public.companies VALUES (176, 'n0Tr5fUJtn9TGdTnrmBYaQ==', '852cvUXNTStsDz+ChUGZcw==', 'JniG4vHdxfdkb7wZksTjcA==', 'u7oy2d6B3Opd4zpkC10ZkQ==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2025-11-19', 0, false, NULL);
INSERT INTO public.companies VALUES (182, 'r28GINLcb9v6Ij/cKuYQLw==', '73Ms3IUWhPauyVDeD/tzKA==', 'iuqSoaWgV1bPzFjpvuX3yA==', '7RatA4sLCnNqBYvXcuJx3g==', 'SCAostq0vP3Nkm5Qjykw8A==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2025-11-20', 0, false, NULL);
INSERT INTO public.companies VALUES (183, 'QmllBS6iWRiFIcNd4k6xFQ==', 'TGcld9hHgZeXnbhbgN5onA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2025-11-20', 0, false, NULL);
INSERT INTO public.companies VALUES (184, 'WzNnqZ7182LQLvDCL9svsQ==', 'yjeCkxIVna9yZiSqW8gDrA==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, NULL, false, NULL, false, NULL, 0, 0, 0, '2025-11-20', 0, false, NULL);
INSERT INTO public.companies VALUES (166, 'iMDs+K4NZygHBXtw3lvS1Q==', 'Xy3AQyjpgf+HGeEAWTu+Lw==', 'WX7c8m0i0C4S6bnMW18ADg==', 'MZQ5sfA8RcqF74SD+jEHYg==', '7qTu2Pb7CesAYUgeQYsR1g==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'CLOSE', NULL, NULL, NULL, false, '0001-01-01 BC', false, NULL, 0, 0, 0, '2023-05-12', 0, false, 1);
INSERT INTO public.companies VALUES (185, '6Tuxv59p3KRr9au7kpI47w==', 'BQhrJhCJdwCdk9xgGK96Wg==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, NULL, 1, false, NULL, false, NULL, 0, 0, 0, '2025-11-20', 0, false, NULL);
INSERT INTO public.companies VALUES (18, 'hd2vyhYPGYzsSZwRa4Tbeg==', 'nlouC9ngqZz8rv7EdLS9mw==', 'U6fQKJNf044iH2PCRPbMp0VtWES5Fr35RMxLg/0cAa4=', 'fj0AX2P87ZNYLGJCD0jlsgY4HQXl9w+AM8ZeYoq97jI=', 'nlouC9ngqZz8rv7EdLS9mw==', '13uu425nYAgEI95W3z43tQ==', '13uu425nYAgEI95W3z43tQ==', 'ACTIVE', NULL, 12345, 44, false, '2020-05-31', true, 15, 90, 0, 0, '2020-12-08', 1, true, NULL);


--
-- TOC entry 6086 (class 0 OID 65619)
-- Dependencies: 573
-- Data for Name: company_types; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.company_types VALUES (1, 'Собственные');
INSERT INTO public.company_types VALUES (2, 'Партнерские');


--
-- TOC entry 5805 (class 0 OID 16845)
-- Dependencies: 261
-- Data for Name: consignment; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5806 (class 0 OID 16852)
-- Dependencies: 262
-- Data for Name: consignment_invoicelist; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5807 (class 0 OID 16859)
-- Dependencies: 263
-- Data for Name: consignment_invoices; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5808 (class 0 OID 16863)
-- Dependencies: 264
-- Data for Name: consignment_snapshots; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5810 (class 0 OID 16871)
-- Dependencies: 266
-- Data for Name: counterparties; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.counterparties VALUES (1, 'ertret', '324234235465', false, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (2, 'xcxcvxc11', '768768989901', true, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', 'wwfyri@gmail.com');
INSERT INTO public.counterparties VALUES (3, 'йцук', '123454567876', false, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (4, 'ячсчсм', '436577678987', true, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (5, 'пропр1', '123434546576', false, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (6, 'кенкенкенекн22', '342323478688', false, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (7, 'укуццу77', '132677980985', false, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (8, 'нкенкенкен56', '234353453456', false, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (9, 'еккке98', '234446777777', false, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (0, 'Все', '22325656768', false, 5, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);
INSERT INTO public.counterparties VALUES (10, 'bvc', '111111123243', false, 185, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 'KZ', NULL);


--
-- TOC entry 5812 (class 0 OID 16881)
-- Dependencies: 268
-- Data for Name: counterparty2product; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.counterparty2product VALUES (1, 51, 18);
INSERT INTO public.counterparty2product VALUES (1, 52, 18);
INSERT INTO public.counterparty2product VALUES (0, 66, 18);
INSERT INTO public.counterparty2product VALUES (0, 68, 18);
INSERT INTO public.counterparty2product VALUES (0, 67, 18);
INSERT INTO public.counterparty2product VALUES (0, 69, 18);
INSERT INTO public.counterparty2product VALUES (0, 70, 18);
INSERT INTO public.counterparty2product VALUES (0, 71, 18);
INSERT INTO public.counterparty2product VALUES (0, 72, 18);
INSERT INTO public.counterparty2product VALUES (0, 73, 18);
INSERT INTO public.counterparty2product VALUES (0, 75, 18);
INSERT INTO public.counterparty2product VALUES (0, 80, 18);
INSERT INTO public.counterparty2product VALUES (0, 92, 18);
INSERT INTO public.counterparty2product VALUES (3, 75, 18);
INSERT INTO public.counterparty2product VALUES (0, 151, 18);
INSERT INTO public.counterparty2product VALUES (0, 152, 18);
INSERT INTO public.counterparty2product VALUES (3, 160, 18);
INSERT INTO public.counterparty2product VALUES (3, 114, 18);
INSERT INTO public.counterparty2product VALUES (3, 153, 18);
INSERT INTO public.counterparty2product VALUES (9, 153, 18);
INSERT INTO public.counterparty2product VALUES (8, 153, 18);
INSERT INTO public.counterparty2product VALUES (1, 114, 18);
INSERT INTO public.counterparty2product VALUES (9, 114, 18);
INSERT INTO public.counterparty2product VALUES (3, 110, 18);
INSERT INTO public.counterparty2product VALUES (5, 110, 18);
INSERT INTO public.counterparty2product VALUES (8, 160, 18);
INSERT INTO public.counterparty2product VALUES (8, 111, 18);
INSERT INTO public.counterparty2product VALUES (5, 111, 18);
INSERT INTO public.counterparty2product VALUES (5, 160, 18);
INSERT INTO public.counterparty2product VALUES (3, 164, 18);
INSERT INTO public.counterparty2product VALUES (1, 160, 18);
INSERT INTO public.counterparty2product VALUES (5, 75, 18);
INSERT INTO public.counterparty2product VALUES (9, 160, 18);
INSERT INTO public.counterparty2product VALUES (1, 166, 185);
INSERT INTO public.counterparty2product VALUES (1, 167, 185);


--
-- TOC entry 5813 (class 0 OID 16884)
-- Dependencies: 269
-- Data for Name: couponobjtypes; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.couponobjtypes VALUES (0, 'все', false);
INSERT INTO public.couponobjtypes VALUES (1, 'категория', false);
INSERT INTO public.couponobjtypes VALUES (2, 'бренд', false);
INSERT INTO public.couponobjtypes VALUES (3, 'товар', false);


--
-- TOC entry 5815 (class 0 OID 16890)
-- Dependencies: 271
-- Data for Name: coupons; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.coupons VALUES (4, 18, '1', 12, 5, 3, '2025-09-30', false, 1, 1);
INSERT INTO public.coupons VALUES (5, 18, '3', 3, 5, 2, '2025-09-30', false, 1, 1);
INSERT INTO public.coupons VALUES (10, 18, '8', 4, 6, 3, '2025-10-09', true, 1, 1);
INSERT INTO public.coupons VALUES (7, 18, '5', 2, 5, 2, '2025-09-30', false, 1, 1);
INSERT INTO public.coupons VALUES (6, 18, '4', 10, 5, 3, '2025-09-30', false, 1, 2);
INSERT INTO public.coupons VALUES (9, 18, '7', 4, 0, 0, '2025-09-30', false, 2, 2);
INSERT INTO public.coupons VALUES (11, 18, '11', 7, 5, 3, '2025-10-08', true, 1, 2);
INSERT INTO public.coupons VALUES (12, 18, '12', 11, 5, 2, '2025-10-01', true, 1, 2);
INSERT INTO public.coupons VALUES (15, 18, '22', 44, 3, 1, '2025-10-06', false, 1, 1);
INSERT INTO public.coupons VALUES (13, 18, '14', 77, 7, 3, '2025-10-01', false, 1, 1);
INSERT INTO public.coupons VALUES (14, 18, '33', 11, 7, 3, '2025-10-06', true, 1, 1);


--
-- TOC entry 5816 (class 0 OID 16900)
-- Dependencies: 272
-- Data for Name: couponsdiary; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 11:02:17.513705', 1, 4, NULL, 0, 2);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 11:34:53.891415', 1, 5, NULL, 0, 3);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 11:45:24.711998', 5, 4, NULL, 0, 5);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 11:45:48.424969', 5, 5, NULL, 0, 6);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 11:46:48.555253', 1, 6, NULL, 0, 7);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 11:47:22.486806', 1, 7, NULL, 0, 8);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 12:03:29.096702', 1, 9, NULL, 0, 9);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 12:05:38.40125', 1, 10, NULL, 0, 10);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 12:23:51.044948', 5, 7, NULL, 0, 11);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 16:28:14.638762', 5, 6, NULL, 0, 12);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 16:28:32.674951', 5, 9, NULL, 0, 13);
INSERT INTO public.couponsdiary VALUES (18, '2025-09-30 16:29:26.863989', 1, 11, NULL, 0, 14);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-01 15:04:50.989984', 1, 12, NULL, 0, 15);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-01 15:05:31.76779', 1, 13, NULL, 0, 16);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-06 14:33:02.174799', 1, 14, NULL, 0, 17);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-06 14:34:18.751582', 5, 14, NULL, 0, 18);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-06 14:37:34.834297', 1, 15, NULL, 0, 19);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-06 14:37:45.873885', 5, 15, NULL, 0, 20);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-06 15:14:33.216472', 5, 13, NULL, 0, 21);
INSERT INTO public.couponsdiary VALUES (18, '2025-10-06 15:15:08.153542', 4, 14, NULL, 0, 22);


--
-- TOC entry 5818 (class 0 OID 16906)
-- Dependencies: 274
-- Data for Name: couponsdiaryreasons; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.couponsdiaryreasons VALUES (1, 'Причина1', false);
INSERT INTO public.couponsdiaryreasons VALUES (2, 'Причина2', false);
INSERT INTO public.couponsdiaryreasons VALUES (3, 'Причина3', false);
INSERT INTO public.couponsdiaryreasons VALUES (4, 'Причина4', false);
INSERT INTO public.couponsdiaryreasons VALUES (5, 'Причина5', false);


--
-- TOC entry 5820 (class 0 OID 16912)
-- Dependencies: 276
-- Data for Name: customers; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.customers VALUES (1, 'цукцукуцк33', '123444444456', false, 18, 'негне', 0);
INSERT INTO public.customers VALUES (3, 'екуекуе3пп', '123213435345', false, 18, 'сисмисм', 0);
INSERT INTO public.customers VALUES (2, 'митстс2', '453534656512', true, 18, 'пропро', 0);
INSERT INTO public.customers VALUES (0, 'hgfh', '12354654678', false, 18, 'retret', 0);


--
-- TOC entry 5822 (class 0 OID 16926)
-- Dependencies: 278
-- Data for Name: customers_bonuscards; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.customers_bonuscards VALUES (0, '1', '1', '2', '3', 0, 'ACTIVE', 18, 1);


--
-- TOC entry 5825 (class 0 OID 16940)
-- Dependencies: 281
-- Data for Name: debtorsdiary; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5828 (class 0 OID 16953)
-- Dependencies: 284
-- Data for Name: discounts; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.discounts VALUES (1, 18, 1, 23, 2, '2025-09-06', '2025-09-01', 23, '2025-10-06 12:07:20.520492', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (14, 18, 1, 25, 3, '2025-10-07', '2025-10-07', 25, '2025-10-07 14:57:15.871532', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (3, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:29:33.662478', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (4, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:31:50.252808', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (5, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:36:18.350134', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (6, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:39:09.453332', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (7, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:45:34.355622', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (8, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:49:17.774583', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (9, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:51:23.757023', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (10, 18, 2, 2, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:51:54.8258', true, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (11, 18, 1, 25, 5, '2025-10-07', '2025-10-07', 25, '2025-10-07 14:52:17.288041', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (13, 18, 1, 0, 8, '2025-10-07', '2025-10-07', 25, '2025-10-07 14:52:37.258347', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (12, 18, 1, 0, 8, '2025-10-07', '2025-10-07', 23, '2025-10-07 14:52:37.226842', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (15, 18, 1, 23, 4, '2025-10-30', '2025-10-08', 23, '2025-10-07 15:33:42.528832', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (16, 18, 1, 23, 3, '2025-10-24', '2025-10-08', 23, '2025-10-07 15:39:30.196274', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (17, 18, 1, 23, 9, '2025-10-07', '2025-10-07', 23, '2025-10-07 15:44:24.776242', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (18, 18, 1, 23, 11, '2025-10-07', '2025-10-07', 23, '2025-10-07 15:45:47.142612', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (19, 18, 1, 23, 88, '2025-10-07', '2025-10-07', 23, '2025-10-07 15:50:05.343161', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (20, 18, 1, 23, 11, '2025-10-30', '2025-10-09', 23, '2025-10-07 16:02:15.334995', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (23, 18, 4, 7, 11, '2025-10-07', '2025-10-07', 25, '2025-10-07 16:10:54.634357', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (24, 18, 4, 7, 12, '2025-10-24', '2025-10-15', 25, '2025-10-07 16:18:39.698886', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (25, 18, 4, 7, 10, '2025-10-07', '2025-10-07', 25, '2025-10-07 16:27:54.076026', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (26, 18, 4, 7, 11, '2025-10-30', '2025-10-14', 25, '2025-10-07 16:34:53.702362', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (27, 18, 4, 7, 12, '2025-10-23', '2025-10-14', 25, '2025-10-07 16:37:57.188907', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (2, 18, 2, 3, 3, '2025-12-01', '2025-10-07', 23, '2025-10-06 12:27:29.575645', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (28, 18, 1, 23, 2, '2025-10-23', '2025-10-08', 23, '2025-10-07 17:00:27.152786', true, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (29, 18, 2, 3, 3, '2025-10-17', '2025-10-14', 23, '2025-10-07 17:00:52.628986', true, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (30, 18, 4, 7, 10, '2025-10-29', '2025-10-21', 25, '2025-10-07 17:02:43.979708', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (31, 18, 4, 7, 3, '2025-10-23', '2025-10-15', 25, '2025-10-07 17:07:14.754033', true, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (32, 18, 1, 25, 8, '2025-10-24', '2025-10-09', 25, '2025-10-08 09:45:23.211363', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (33, 18, 1, 25, 2, '2025-10-30', '2025-10-09', 25, '2025-10-08 09:46:26.56682', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (34, 18, 1, 25, 44, '2025-10-31', '2025-10-20', 25, '2025-10-08 09:47:23.482951', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (35, 18, 1, 25, 77, '2025-10-22', '2025-10-12', 25, '2025-10-08 09:56:50.999548', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (36, 18, 1, 25, 5, '2025-10-31', '2025-10-10', 25, '2025-10-08 09:57:24.749007', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (38, 18, 1, 25, 10, '2025-11-28', '2025-10-30', 25, '2025-10-30 09:50:40.259366', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (39, 18, 1, 25, 20, '2025-11-28', '2025-10-30', 25, '2025-10-30 10:38:58.95679', true, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (37, 18, 2, 29, 10, '2025-10-30', '2025-10-30', 25, '2025-10-30 09:49:20.159157', false, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (40, 18, 2, 29, 10, '2025-11-28', '2025-10-30', 25, '2025-10-30 10:40:07.745257', true, false, '00:00:00', '00:00:00', false);
INSERT INTO public.discounts VALUES (41, 18, 4, 64, 10, '2025-11-26', '2025-10-30', 23, '2025-10-30 10:44:57.883785', true, false, '00:00:00', '00:00:00', false);


--
-- TOC entry 5829 (class 0 OID 16963)
-- Dependencies: 285
-- Data for Name: discounttypes; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.discounttypes VALUES (1, 'Торгровая точка');
INSERT INTO public.discounttypes VALUES (2, 'Категория');
INSERT INTO public.discounttypes VALUES (3, 'Бренд');
INSERT INTO public.discounttypes VALUES (4, 'Товар');


--
-- TOC entry 5830 (class 0 OID 16971)
-- Dependencies: 287
-- Data for Name: erp_roles; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.erp_roles VALUES (0, 'Admin', false, '[{"id":"31","code":"setting_gen_info"}]', 0);
INSERT INTO public.erp_roles VALUES (6, 'Ревизор', false, '[{"id":"91","code":"elct_inv_reception"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"31","code":"setting_gen_info"},{"id":"25","code":"whs_consignment"},{"id":"29","code":"whs_reconciliation"},{"id":"38","code":"setting_cash_reg"},{"id":"34","code":"setting_whs"},{"id":"32","code":"setting_store"},{"id":"52","code":"setting_scales"},{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"1","code":"rep_checkout"}]', 0);
INSERT INTO public.erp_roles VALUES (9, 'Руководитель', false, '[{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"15","code":"whs_inv_history"},{"id":"19","code":"whs_prod_move"},{"id":"21","code":"whs_revision"},{"id":"23","code":"whs_holdings"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"25","code":"whs_consignment"}]', 2);
INSERT INTO public.erp_roles VALUES (8, 'Категорийный менеджер', false, '[{"id":"86","code":"market_bonuses"},{"id":"56","code":"contr_prod_new_whr"},{"id":"60","code":"contr_move_between"},{"id":"57","code":"contr_newto_whr"},{"id":"42","code":"setting_portal_user"},{"id":"79","code":"order_treatment"}]', 0);
INSERT INTO public.erp_roles VALUES (4, 'Администратор', false, '[{"id":"42","code":"setting_portal_user"},{"id":"14","code":"whs_leftovers"},{"id":"15","code":"whs_inv_history"},{"id":"19","code":"whs_prod_move"}]', 0);
INSERT INTO public.erp_roles VALUES (5, 'Заведующий торговой точки', false, '[{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"77","code":"price_marginal"},{"id":"75","code":"price_wizard"},{"id":"74","code":"price_change"},{"id":"42","code":"setting_portal_user"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"}]', 0);
INSERT INTO public.erp_roles VALUES (7, 'Заведующий холдинга', false, '[{"id":"81","code":"order_receipt"},{"id":"78","code":"order_create"}]', 0);
INSERT INTO public.erp_roles VALUES (2, 'Бухгалтер', false, '[{"id":"78","code":"order_create"},{"id":"42","code":"setting_portal_user"},{"id":"11","code":"rep_abc_xyz"}]', 0);
INSERT INTO public.erp_roles VALUES (3, 'Снабженец(кладовщик)', false, '[{"id":"15","code":"whs_inv_history"},{"id":"38","code":"setting_cash_reg"},{"id":"11","code":"rep_abc_xyz"},{"id":"42","code":"setting_portal_user"}]', 0);
INSERT INTO public.erp_roles VALUES (1, 'Руководитель', false, '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"}]', 0);
INSERT INTO public.erp_roles VALUES (21, 'Категорийный менеджер', false, '[{"id":"86","code":"market_bonuses"},{"id":"79","code":"order_treatment"},{"id":"14","code":"whs_leftovers"},{"id":"15","code":"whs_inv_history"},{"id":"19","code":"whs_prod_move"},{"id":"27","code":"whs_exp_dates"},{"id":"25","code":"whs_consignment"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"84","code":"market_gift"},{"id":"83","code":"market_coupons"},{"id":"74","code":"price_change"},{"id":"75","code":"price_wizard"},{"id":"77","code":"price_marginal"},{"id":"48","code":"setting_buyers"},{"id":"46","code":"setting_supplies"},{"id":"44","code":"setting_sales_plan"},{"id":"70","code":"contr_nomenclature"}]', 91);
INSERT INTO public.erp_roles VALUES (19, 'Заведующий торговой точки', false, '[{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"12","code":"rep_debt_book"},{"id":"3","code":"rep_checks"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"14","code":"whs_leftovers"},{"id":"15","code":"whs_inv_history"},{"id":"19","code":"whs_prod_move"},{"id":"27","code":"whs_exp_dates"},{"id":"25","code":"whs_consignment"},{"id":"83","code":"market_coupons"},{"id":"64","code":"contr_barcode_print"},{"id":"81","code":"order_receipt"},{"id":"78","code":"order_create"},{"id":"44","code":"setting_sales_plan"},{"id":"52","code":"setting_scales"},{"id":"70","code":"contr_nomenclature"}]', 91);
INSERT INTO public.erp_roles VALUES (35, 'Категорийный менеджер', false, '[{"id":"86","code":"market_bonuses"},{"id":"56","code":"contr_prod_new_whr"},{"id":"60","code":"contr_move_between"},{"id":"57","code":"contr_newto_whr"},{"id":"42","code":"setting_portal_user"},{"id":"79","code":"order_treatment"}]', 112);
INSERT INTO public.erp_roles VALUES (37, 'Руководитель', false, '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":"56","code":"contr_prod_new_whr"},{"id":"60","code":"contr_move_between"},{"id":"57","code":"contr_newto_whr"},{"id":"62","code":"contr_removefrom_whr"},{"id":"64","code":"contr_barcode_print"},{"id":"66","code":"contr_revision"},{"id":"68","code":"contr_weigh_prod"},{"id":"70","code":"contr_nomenclature"},{"id":"72","code":"contr_reconciliation"},{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"74","code":"price_change"},{"id":"75","code":"price_wizard"},{"id":"77","code":"price_marginal"},{"id":"78","code":"order_create"},{"id":"79","code":"order_treatment"},{"id":"81","code":"order_receipt"},{"id":"95","code":"order_weight_prod"},{"id":"91","code":"elct_inv_reception"},{"id":"93","code":"elct_inv_attach_eds"},{"id":"92","code":"elct_inv_broadcast"},{"id":"94","code":"elct_inv_report"}]', 128);
INSERT INTO public.erp_roles VALUES (36, 'Снабженец(складовщик)', false, '[{"id":"15","code":"whs_inv_history"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"27","code":"whs_exp_dates"},{"id":"25","code":"whs_consignment"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"56","code":"contr_prod_new_whr"},{"id":"60","code":"contr_move_between"},{"id":"57","code":"contr_newto_whr"},{"id":"62","code":"contr_removefrom_whr"},{"id":"64","code":"contr_barcode_print"},{"id":"68","code":"contr_weigh_prod"},{"id":"70","code":"contr_nomenclature"},{"id":"74","code":"price_change"},{"id":"77","code":"price_marginal"}]', 91);
INSERT INTO public.erp_roles VALUES (16, 'Бухгалтер', false, '[{"id":"11","code":"rep_abc_xyz"},{"id":"91","code":"elct_inv_reception"},{"id":"93","code":"elct_inv_attach_eds"},{"id":"92","code":"elct_inv_broadcast"},{"id":"94","code":"elct_inv_report"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"14","code":"whs_leftovers"},{"id":"15","code":"whs_inv_history"},{"id":"19","code":"whs_prod_move"},{"id":"21","code":"whs_revision"},{"id":"27","code":"whs_exp_dates"},{"id":"25","code":"whs_consignment"}]', 91);
INSERT INTO public.erp_roles VALUES (20, 'Ревизор', false, '[{"id":"14","code":"whs_leftovers"},{"id":"21","code":"whs_revision"},{"id":"66","code":"contr_revision"}]', 91);
INSERT INTO public.erp_roles VALUES (38, 'Снабженец(складовщик)', false, '[{"id":"15","code":"whs_inv_history"},{"id":"38","code":"setting_cash_reg"},{"id":"11","code":"rep_abc_xyz"},{"id":"42","code":"setting_portal_user"},{"id":"84","code":"market_gift"},{"id":"83","code":"market_coupons"}]', 138);
INSERT INTO public.erp_roles VALUES (18, 'Администратор', false, '[{"id":"42","code":"setting_portal_user"},{"id":"40","code":"setting_user_chekout"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"34","code":"setting_whs"}]', 91);
INSERT INTO public.erp_roles VALUES (17, 'Руководитель', false, '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":"52","code":"setting_scales"},{"id":"99","code":"whs_prod_period"}]', 91);
INSERT INTO public.erp_roles VALUES (41, 'Ревизор', false, '[{"id":"91","code":"elct_inv_reception"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"31","code":"setting_gen_info"},{"id":"25","code":"whs_consignment"},{"id":"29","code":"whs_reconciliation"},{"id":"38","code":"setting_cash_reg"},{"id":"34","code":"setting_whs"},{"id":"32","code":"setting_store"},{"id":"52","code":"setting_scales"},{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"1","code":"rep_checkout"},{"id":"21","code":"whs_revision"},{"id":"66","code":"contr_revision"}]', 138);
INSERT INTO public.erp_roles VALUES (40, 'Шаблон', false, '[{"id":"42","code":"setting_portal_user"},{"id":"40","code":"setting_user_chekout"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"}]', 91);
INSERT INTO public.erp_roles VALUES (39, 'Руководитель', false, '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":"99","code":"whs_prod_period"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"}]', 138);
INSERT INTO public.erp_roles VALUES (42, 'Шаблон', false, '[{"id":"8","code":"rep_discounts"},{"id":"9","code":"rep_consultants"},{"id":"44","code":"setting_sales_plan"},{"id":"11","code":"rep_abc_xyz"},{"id":"7","code":"rep_gross_profit"},{"id":"21","code":"whs_revision"},{"id":"38","code":"setting_cash_reg"},{"id":"34","code":"setting_whs"},{"id":"32","code":"setting_store"},{"id":"15","code":"whs_inv_history"},{"id":"52","code":"setting_scales"},{"id":"27","code":"whs_exp_dates"},{"id":"12","code":"rep_debt_book"},{"id":"4","code":"rep_prod_solds"},{"id":"31","code":"setting_gen_info"},{"id":"6","code":"rep_team_bonus"},{"id":"2","code":"rep_sales"},{"id":"10","code":"rep_certificates"},{"id":"14","code":"whs_leftovers"},{"id":"1","code":"rep_checkout"},{"id":"46","code":"setting_supplies"},{"id":"3","code":"rep_checks"},{"id":"13","code":"rep_buyers"},{"id":"40","code":"setting_user_chekout"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"48","code":"setting_buyers"},{"id":"5","code":"rep_single_bonus"},{"id":"29","code":"whs_reconciliation"},{"id":"42","code":"setting_portal_user"},{"id":"25","code":"whs_consignment"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":66,"code":"contr_revision"},{"id":91,"code":"elct_inv_reception"},{"id":92,"code":"elct_inv_broadcast"},{"id":42,"code":"setting_portal_user"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":81,"code":"order_receipt"},{"id":95,"code":"order_weight_prod"}]', 138);
INSERT INTO public.erp_roles VALUES (43, 'Заведующий торговой точки', false, '[{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"77","code":"price_marginal"},{"id":"75","code":"price_wizard"},{"id":"74","code":"price_change"},{"id":"42","code":"setting_portal_user"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":78,"code":"order_create"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"}]', 112);
INSERT INTO public.erp_roles VALUES (44, 'Бухгалтер', false, '[{"id":"78","code":"order_create"},{"id":"42","code":"setting_portal_user"},{"id":"11","code":"rep_abc_xyz"},{"id":14,"code":"whs_leftovers"}]', 131);
INSERT INTO public.erp_roles VALUES (45, 'Руководитель', false, '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":99,"code":"whs_prod_period"}]', 131);
INSERT INTO public.erp_roles VALUES (46, 'Снабженец(кладовщик)', false, '[{"id":"15","code":"whs_inv_history"},{"id":"38","code":"setting_cash_reg"},{"id":"11","code":"rep_abc_xyz"},{"id":"42","code":"setting_portal_user"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"}]', 18);
INSERT INTO public.erp_roles VALUES (47, 'Ревизор', false, '[{"id":"91","code":"elct_inv_reception"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"31","code":"setting_gen_info"},{"id":"25","code":"whs_consignment"},{"id":"29","code":"whs_reconciliation"},{"id":"38","code":"setting_cash_reg"},{"id":"34","code":"setting_whs"},{"id":"32","code":"setting_store"},{"id":"52","code":"setting_scales"},{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"1","code":"rep_checkout"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"}]', 112);
INSERT INTO public.erp_roles VALUES (48, 'Ревизор', false, '[{"id":"91","code":"elct_inv_reception"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"31","code":"setting_gen_info"},{"id":"25","code":"whs_consignment"},{"id":"29","code":"whs_reconciliation"},{"id":"38","code":"setting_cash_reg"},{"id":"34","code":"setting_whs"},{"id":"32","code":"setting_store"},{"id":"52","code":"setting_scales"},{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"1","code":"rep_checkout"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"}]', 18);
INSERT INTO public.erp_roles VALUES (49, 'Руководитель', false, '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', 18);
INSERT INTO public.erp_roles VALUES (50, 'Руководитель', false, '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', 112);
INSERT INTO public.erp_roles VALUES (51, 'Заведующий торговой точки', false, '[{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"77","code":"price_marginal"},{"id":"75","code":"price_wizard"},{"id":"74","code":"price_change"},{"id":"42","code":"setting_portal_user"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"}]', 18);


--
-- TOC entry 5832 (class 0 OID 16981)
-- Dependencies: 289
-- Data for Name: erp_users; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.erp_users VALUES (11, 'isme', 'iSME', '$2a$10$PpABMS/mk.lcoU6pxCc6neOW5EA6DAtJRt7r1MALdbkaPcICoqriW', 'U2FsdGVkX19U//06Px//tF3r9fFGtXxwHUQHtj5gamQ=', NULL, 16, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (5, 'shaken@gmail.com', 'Орынбек Шакен Бакытулы', '$2a$10$EUrDpVKiti8dcdWoZz42GuuguRUOICNQqCjC1.9PnLsulcgQfTbK6', 'ICXJo6i1t8VYg4xe7oRR5A==', NULL, 5, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (12, 'shorynbek@gmail.com', 'FZQbw3mhDgmwICS/cj/TlmaoJn+s6sP/oZfGlSqcuLQ=', '$2a$10$KbxjuaAEwj7IwwLKzsWQruJDTl7S9C1AhsuULhgHKrjQ8GzZZc8L.', 'wLx9IyxQs/lhPJ5bWHDoTw==', NULL, 13, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (219, 'boneraze@gmail.com', 'HoJHJrJVqXjsNhavqu8CaKUStYGlS2gKNqfZjC6CKJ+01qBKOStDnjZUfinOvO2y1/LN4EbYroW3Qu8lHswBQA==', '$2a$10$14Q3pS1QiV39QHNHDEvSBe1qelD8kG1NaSZOV5RcFe3l.CZsre8ui', 'PT5fNc/IGGRCSGO14PmxGw==', NULL, 143, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (82, 'ghj@mail.ru', 'naVwoIXkGpy0C9gUnT6cDMPIRcFH0MZN0YFvhZ2FzqY=', '$2a$10$CExlkaoYmcB3neYbAA9nGezelStvQsTDC3cdIexwTSK8M/1zC/EtC', 'p8dxUcPL0ToZAtltee5ikQ==', NULL, 74, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (79, 'amir_97', 'wjZwRX+0DLxJNEsMbln3DQ==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 's+MDqEbrYwbjcHKS1EQkGw==', NULL, 66, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (177, 'piko0101@gmail.com', 'gAGnXIC7P1WZVh0TazfqKaGpKgEAn2bvKnXWWAoo/Zxrjg81K/YrTRFpwS1Na9Mi', '$2a$10$YJkK8m6W1w0LCKa3ryOaVeqU2cnnJJHf49G2u/ZP3Bi9EJ8U53arW', 'u8uQn5knbKHooeVZ4JONXw==', NULL, 138, 'DISMISS', '[{"id":"5","code":"rep_single_bonus","name":"Индивидуальный бонус"},{"id":"14","code":"whs_leftovers","name":"Остаток на складе"},{"id":"15","code":"whs_inv_history","name":"История по накладным"},{"id":"3","code":"rep_checks","name":"Чеки"},{"id":"19","code":"whs_prod_move","name":"Движение товара"},{"id":"42","code":"setting_portal_user","name":"Пользователи портала"},{"id":"4","code":"rep_prod_solds","name":"Проданные товары"},{"id":"6","code":"rep_team_bonus","name":"Командный бонус"}]', '[]');
INSERT INTO public.erp_users VALUES (174, 'sabitbekp@magnumtech.kz', 'IcWibP+s9m2gBa9JcLRn6xfSiXfr3hSdOKLZzXCVR83P/lBxUhAkZQxV/fZ7B0re', '$2a$10$TaUQzU8m5Flz3ZVlIH2dqeEY0U5MrUlBo4dR1yZP97unH4texXHYS', '/XTwF+1D3V/i/a8ryrtWgA==', NULL, 138, 'DISMISS', '[{"id":"86","code":"market_bonuses","name":"Бонусы"},{"id":"83","code":"market_coupons","name":"Купоны"},{"id":"84","code":"market_gift","name":"Подарочные сертификаты"},{"id":"90","code":"market_stock","name":"Акции"},{"id":"88","code":"market_create_discount","name":"Создание скидок"}]', '[]');
INSERT INTO public.erp_users VALUES (87, '4444@gmail.com', '4JGeUAL82OOtB9Mj8WSx/A==', '$2a$10$ldyPVho0DBA053jIaLjvv.ydfEO4XZr/d.wh5jk2nRA5NHvsAmmlC', 'fiyuiq59hUyEZ113sxXLRQ==', NULL, 84, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (169, 'im3335219@gmail.com', 'GmJIAs/5qCe8druVw6rKWw==', '$2a$10$2yjYwkPcZZaoMhD5FoAj7uehKR7mPe2oNZpqWJbtuZzGEwhmzr31y', '6iM2ZRffbvRaG4O8OtpgLg==', NULL, 112, 'ACTIVE', '[{"id":78,"code":"order_create"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":78,"code":"order_create"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":79,"code":"order_treatment"},{"id":77,"code":"price_marginal"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":52,"code":"setting_scales"},{"id":40,"code":"setting_user_chekout"},{"id":42,"code":"setting_portal_user"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":66,"code":"contr_revision"},{"id":70,"code":"contr_nomenclature"},{"id":64,"code":"contr_barcode_print"},{"id":60,"code":"contr_move_between"},{"id":57,"code":"contr_newto_whr"},{"id":56,"code":"contr_prod_new_whr"},{"id":72,"code":"contr_reconciliation"},{"id":68,"code":"contr_weigh_prod"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":84,"code":"market_gift"},{"id":88,"code":"market_create_discount"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":21,"code":"whs_revision"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', '[]');
INSERT INTO public.erp_users VALUES (245, 'sone@mail.ru', 'xsDeIbZAEpYJVwQv6EiuRA==', '$2a$10$2DP0YU/XWlUcUw18V31Gee1eIWmFcUjXvo9RaFld1i.c7eHwS6St.', 'kQbURw7PXGtaYx4NKr5I8Q==', NULL, 112, 'ACTIVE', '[{"id":"86","code":"market_bonuses"},{"id":"56","code":"contr_prod_new_whr"},{"id":"60","code":"contr_move_between"},{"id":"57","code":"contr_newto_whr"},{"id":"42","code":"setting_portal_user"},{"id":"79","code":"order_treatment"}]', '[]');
INSERT INTO public.erp_users VALUES (143, 'imartyofleego@gmail.com', 'XdGnjfJb6V7uC55tdQIkcX3UPK70esIspbdk15iXvR6TFTHmLPNFiMQJO103UzY5NWTMfQdb0dF0RiUSJgULSw==', '$2a$10$KsnmZ1ttggFLiMQK9hCxZ.BnSSjbIDI.kN6SEWZG9kLZIkEsa2Vm.', 'IQXslrucEA+vYl5vvHZbrQ==', NULL, 112, 'DISMISS', '[{"id":42,"code":"setting_portal_user","name":"Пользователи портала"}]', '[]');
INSERT INTO public.erp_users VALUES (150, 'rev2@post.is', 'T39chQP+A3jDwCJHDn3wGWN5nlGNjvsntZdOGANYknk=', '$2a$10$DnxCbGbQ5xFy9xl6zuogv.0O8VzRjt6L0zKBmHHZ/IGsqjer4Trlm', 'CW1muiJh+yAHZWuleGBNFg==', NULL, 122, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (135, 'imartyoflego@gmail.com', 'ZFVVzscpBTb2xxi+s4DWLFH3KBWmV9rXzr17cBusuoakEITGcSmoKyJf+W7gvV/3', '$2a$10$5.m8HJPrnUe2v3BwZCUXW.HlgruIXtBqrPJQz/4HR0bFf5NfIJJaW', 'AP0eozWWJ5BJPR4j0VXX/Q==', NULL, 112, 'DISMISS', '[{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"},{"id":9,"code":"rep_consultants","name":"Консультанты"},{"id":7,"code":"rep_gross_profit","name":"Валовая прибыль"},{"id":1,"code":"rep_checkout","name":"Отчет по кассам"},{"id":4,"code":"rep_prod_solds","name":"Проданные товары"},{"id":6,"code":"rep_team_bonus","name":"Командный бонус"},{"id":99,"code":"whs_prod_period","name":"Отчеты по товарам за период"},{"id":25,"code":"whs_consignment","name":"Консигнация"},{"id":29,"code":"whs_reconciliation","name":"Сверка"},{"id":27,"code":"whs_exp_dates","name":"Сроки годности"},{"id":23,"code":"whs_holdings","name":"Холдинги"},{"id":21,"code":"whs_revision","name":"Ревизия"},{"id":19,"code":"whs_prod_move","name":"Движение товара"},{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":14,"code":"whs_leftovers","name":"Остаток на складе"},{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":32,"code":"setting_store","name":"Торговая точка"},{"id":52,"code":"setting_scales","name":"Весы"},{"id":34,"code":"setting_whs","name":"Склад"},{"id":31,"code":"setting_gen_info","name":"Общая информация"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":46,"code":"setting_supplies","name":"Поставщики"},{"id":48,"code":"setting_buyers","name":"Покупатели юр. лица"},{"id":40,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":8,"code":"rep_discounts","name":"Примененные скидки"},{"id":5,"code":"rep_single_bonus","name":"Индивидуальный бонус"},{"id":44,"code":"setting_sales_plan","name":"План продаж"},{"id":10,"code":"rep_certificates","name":"Сертификаты"},{"id":101,"code":"rep_saled_products","name":"Отчеты по проданным товарам"},{"id":3,"code":"rep_checks","name":"Чеки"},{"id":2,"code":"rep_sales","name":"Общие продажи"},{"id":13,"code":"rep_buyers","name":"Отчёт по покупателям(физ. лицо)"},{"id":12,"code":"rep_debt_book","name":"Долговая книга"}]', '[]');
INSERT INTO public.erp_users VALUES (165, 'psabitbek@magnumtech.kz', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$wr3gSm78vlEX8y5T6E8hoeavNsp0v3XsRIhCtKkzjS/4DcHDFr.r2', '/XTwF+1D3V/i/a8ryrtWgA==', NULL, 138, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (170, 'im4442591@gmail.com', 'nMfAiCZ5cxFYssyPqBuOJg==', '$2a$10$1Uu3qCRGTjmt2J4E/L.TcOMgfLrVXA2yxcTL13RLalP4XYU3M0HuG', 's7+V6fI54Sqwxe3byqy4aA==', NULL, 112, 'DISMISS', '[{"id":78,"code":"order_create","name":"Создание"},{"id":79,"code":"order_treatment","name":"Обработка"},{"id":95,"code":"order_weight_prod","name":"Привязка весовых товаров"},{"id":81,"code":"order_receipt","name":"Прием товаров по наряд-заказу"},{"id":75,"code":"price_wizard","name":"Мастер ценообразования"},{"id":74,"code":"price_change","name":"Изменение цен"},{"id":77,"code":"price_marginal","name":"Предельные цены"},{"id":44,"code":"setting_sales_plan","name":"План продаж"},{"id":40,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":48,"code":"setting_buyers","name":"Покупатели юр. лица"},{"id":46,"code":"setting_supplies","name":"Поставщики"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":31,"code":"setting_gen_info","name":"Общая информация"},{"id":34,"code":"setting_whs","name":"Склад"},{"id":52,"code":"setting_scales","name":"Весы"},{"id":32,"code":"setting_store","name":"Торговая точка"},{"id":38,"code":"setting_cash_reg","name":"Касса"}]', '[]');
INSERT INTO public.erp_users VALUES (146, 'rubino@mail.ru', 'e7VkQFS7s6emRK7BOnLM5g==', '$2a$10$tXSWeAtCSy.ZKtvUcm4jbOc9DAK0EpCaqeVZ5hY1j4OiAD6FfOBSu', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 130, 'ACTIVE', '[{"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "57", "code": "contr_newto_whr"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "60", "code": "contr_move_between"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "79", "code": "order_treatment"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}, {"id": "56", "code": "contr_prod_new_whr"}]', '[]');
INSERT INTO public.erp_users VALUES (184, 'rodger@gmail.com', 'LgNsSxpljHKGncpbI4HjHg==', '$2a$10$t3.RUfLf9qlZus.3JlKQG.JElxdFUFlV4kjzSsQM5nk1ySlOLLWXe', 'R2NT+c2NhMPn+szzQ+gNvg==', NULL, 18, 'ACTIVE', '[{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":78,"code":"order_create","name":"Создание"},{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"}]', '[]');
INSERT INTO public.erp_users VALUES (218, 'madina_massanova@mail.com', 'nZ5svCrvD8BwfB341rxIiw==', '$2a$10$qTw6E4CW7g7yShSNVIN6xeBSl7BSFta48OZEjPr5JyJSRBNcN2/bm', '77Eh75aZh8Nre1Bvct8gUg==', NULL, 138, 'ACTIVE', '[{"id":"40","code":"setting_user_chekout"},{"id":"42","code":"setting_portal_user"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":60,"code":"contr_move_between"},{"id":56,"code":"contr_prod_new_whr"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"}]', '[]');
INSERT INTO public.erp_users VALUES (59, '123456', 'hIPP7DA5v9OjOb6KINIxCw==', '$2a$10$Q7.JeM1UD7liKHXOPSa1Z.Aua2TOYM9bjJYxPF/gsVedi77I3fBZi', 'aH9H0Mu9dGUVA1ljJz3mfA==', NULL, 45, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (173, 'sabitbek@magnumtech.kz', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$/Fc8cTfnT.deYuBDSVlv9.kHX/ABkzrX6fr9boVPEpj2qfxsRuBqm', 'MhYIIapeMhKbhOOjV6bPbQ==', NULL, 138, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (37, 'shorynbek@gmail.com1', 'PWbOyHTIO8aRQQZ2cQOBzQ==', '$2a$10$44sbJQwlC.rL9MiOPHy.2O2Gxk5T85qi2LUqJFFYznbd.pW7X7dR.', '3HLOKciWFxlwN5MvDXeFQA==', NULL, 13, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (39, 'admin@mail.zz', 'zDgig8hEkbV70HgOBjAZCg==', '$2a$10$zqf0HI47gr/AJYZbNCjh9OFIZPUZsSyr6SdlXnW/2ncOXcW1Mpaei', 'nlouC9ngqZz8rv7EdLS9mw==', NULL, 17, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (80, 'test@mail.ru', 'c+qwrqb6Z9qTLEcYeQUXAg==', '$2a$10$ng7J.fnYvdbEaaZkPq8dEed7Mq3h77R7C7mDj7icDhDkVGb2nmgQu', 'LEvtnpPiPbN/Eha8KQ7wlA==', NULL, 73, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (98, 'sagimov99@gmail.com', '4nykestIZ1rLZA0X334v1w==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'oYgF5X4uM3rMbHKaXLc7mA==', NULL, 97, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (233, 'im45545@gmail.com', 'TSRPv3BTmN5gkHfzrlnp/GmPvbQsbLWXKE8qiqp/xiAFilxikjRzGqMmNR28Ny+Z', '$2a$10$q3KnaDPpwCKogDA7BoV3Feldl3ntyFND5lnKxNvYlJBftPBQ3TJMK', 'oMSkUvto+IzJ++/DllXjAA==', NULL, 112, 'ACTIVE', '[{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', '[]');
INSERT INTO public.erp_users VALUES (70, 'pazylbekovasylbek', 'zOv3xSvTUk6jGxkgrssa+g==', '$2a$10$19daGW2ovYNESggPsC8MnuWAf0ig6KDgBPTK/D0qh0cY2LdsjKmYu', 'NwIP1PDKz7I3pd03PZsFfA==', NULL, 65, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (228, 'dons@gmail.com', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$dfBHCmaLC2Vo5Z2uJ1uInu7EFXX.eu93YhkHAcapA3/FOC7ZKZZ6y', '7DLsmmGvYEniG4p+WMaN+w==', NULL, 112, 'DISMISS', '[{"id":78,"code":"order_create","name":"Создание"},{"id":93,"code":"elct_inv_attach_eds","name":"Прикрепить ЭЦП"},{"id":91,"code":"elct_inv_reception","name":"Прием"},{"id":94,"code":"elct_inv_report","name":"Отчет"},{"id":92,"code":"elct_inv_broadcast","name":"Передача"},{"id":77,"code":"price_marginal","name":"Предельные цены"},{"id":74,"code":"price_change","name":"Изменение цен"},{"id":75,"code":"price_wizard","name":"Мастер ценообразования"},{"id":29,"code":"whs_reconciliation","name":"Сверка"},{"id":25,"code":"whs_consignment","name":"Консигнация"},{"id":90,"code":"market_stock","name":"Акции"},{"id":88,"code":"market_create_discount","name":"Создание скидок"},{"id":86,"code":"market_bonuses","name":"Бонусы"},{"id":84,"code":"market_gift","name":"Подарочные сертификаты"},{"id":83,"code":"market_coupons","name":"Купоны"},{"id":1,"code":"rep_checkout","name":"Отчет по кассам"},{"id":3,"code":"rep_checks","name":"Чеки"},{"id":6,"code":"rep_team_bonus","name":"Командный бонус"},{"id":5,"code":"rep_single_bonus","name":"Индивидуальный бонус"},{"id":4,"code":"rep_prod_solds","name":"Проданные товары"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":52,"code":"setting_scales","name":"Весы"},{"id":32,"code":"setting_store","name":"Торговая точка"},{"id":34,"code":"setting_whs","name":"Склад"},{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":31,"code":"setting_gen_info","name":"Общая информация"},{"id":81,"code":"order_receipt","name":"Прием товаров по наряд-заказу"},{"id":95,"code":"order_weight_prod","name":"Привязка весовых товаров"},{"id":79,"code":"order_treatment","name":"Обработка"}]', '[]');
INSERT INTO public.erp_users VALUES (213, 'pwt111stg@magnumtech.kz', 'Bs/XNY8yD+77b4PKt7LB1opEqr1j+8U1AWMhGY7hju0=', '$2a$10$6au5pPZqwQLGbWBJ1Up5yuhL9v8lC814szVjLpl8MjykWMv9G/CqC', 'QNxxy6hB1IYlvOpCqge8wVGAWJxRfJe8CAbBcJBivCU=', NULL, 18, 'ACTIVE', '[{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"}]', '[]');
INSERT INTO public.erp_users VALUES (112, 'kismanayazhan@gmail.com', 'l5mUZN1fH8KweJHnk5V0GA==', '$2a$10$XrvXQUcegojl7A6wfT9aW.zY3sKyCWpB4MffOe5..L3jHzFEEG71u', '416kL10bXQwHxIfOqxBQxg==', NULL, 18, 'ACTIVE', '[{"id":46,"code":"setting_supplies","name":"Поставщики"},{"id":84,"code":"market_gift","name":"Подарочные сертификаты"},{"id":25,"code":"whs_consignment","name":"Консигнация"},{"id":83,"code":"market_coupons","name":"Купоны"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":29,"code":"whs_reconciliation","name":"Сверка"},{"id":88,"code":"market_create_discount","name":"Создание скидок"},{"id":5,"code":"rep_single_bonus","name":"Индивидуальный бонус"},{"id":74,"code":"price_change","name":"Изменение цен"},{"id":48,"code":"setting_buyers","name":"Покупатели юр. лица"},{"id":23,"code":"whs_holdings","name":"Холдинги"},{"id":19,"code":"whs_prod_move","name":"Движение товара"},{"id":40,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":13,"code":"rep_buyers","name":"Отчёт по покупателям(физ. лицо)"},{"id":3,"code":"rep_checks","name":"Чеки"},{"id":75,"code":"price_wizard","name":"Мастер ценообразования"},{"id":1,"code":"rep_checkout","name":"Отчет по кассам"},{"id":14,"code":"whs_leftovers","name":"Остаток на складе"},{"id":10,"code":"rep_certificates","name":"Сертификаты"},{"id":2,"code":"rep_sales","name":"Общие продажи"},{"id":6,"code":"rep_team_bonus","name":"Командный бонус"},{"id":91,"code":"elct_inv_reception","name":"Прием"},{"id":31,"code":"setting_gen_info","name":"Общая информация"},{"id":77,"code":"price_marginal","name":"Предельные цены"},{"id":4,"code":"rep_prod_solds","name":"Проданные товары"},{"id":12,"code":"rep_debt_book","name":"Долговая книга"},{"id":27,"code":"whs_exp_dates","name":"Сроки годности"},{"id":52,"code":"setting_scales","name":"Весы"},{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":32,"code":"setting_store","name":"Торговая точка"},{"id":34,"code":"setting_whs","name":"Склад"},{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":21,"code":"whs_revision","name":"Ревизия"},{"id":78,"code":"order_create","name":"Создание"},{"id":7,"code":"rep_gross_profit","name":"Валовая прибыль"},{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"},{"id":44,"code":"setting_sales_plan","name":"План продаж"},{"id":9,"code":"rep_consultants","name":"Консультанты"},{"id":8,"code":"rep_discounts","name":"Примененные скидки"},{"id":86,"code":"market_bonuses","name":"Бонусы"},{"id":90,"code":"market_stock","name":"Акции"}]', '[]');
INSERT INTO public.erp_users VALUES (234, 'asd@gmail.com', 'RIpkJeIw22m2xSeIYNrnWA==', '$2a$10$HCFM2Slk41/kvsaUbIenoesPNTekhXP3Y9DiVTqT6tlClPYrV/g8m', 'mnr8chxUGaYs+3TozmFfiQ==', NULL, 18, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (220, 'anatolas@gmail.com', 'gD8M093I/St9INOKUh4wVq+kwiIZn8YXiwEtr6AfXvY=', '$2a$10$x7Jp8Oargo.2yHkk2Fsc4eqX.1gkbl2bdH8ZbmMpcxj7lkC1PkjMC', 'HXXutlPg97i5BVHYp+4HoQ==', NULL, 18, 'ACTIVE', '[]', '[{"id":2,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":4,"code":"setting_supplies","name":"Поставщики"},{"id":6,"code":"setting_buyers_fiz","name":"Покупатели физ.лица"}]');
INSERT INTO public.erp_users VALUES (224, 'doqwrns@mail.ru', 'DKOSL5pxUV/eY3obRGNCng==', '$2a$10$zp2i/D0RKu7kIXtRgGQiI.XkJFh06cmATHPF0j22s6nNHPozHT/la', 'uiBiHMWGC1A6mRdx+zVUdg==', NULL, 18, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (200, 'psabitbek@magnumtech.com', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$E33fObztRTumu0fTVpS.t.RkSQMoB666pNeVW.fgQI1t2dbRTXF0S', 'x5klSbwP35r8QFym2pldPg==', NULL, 138, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (44, 'isme18@gmail.com', 'gzblDfIkIk9fl1YgLklMFw==', '$2a$10$hMt0x2SfefWpsjslMHxBaeOrwnLaQN5aac0028wgmspTLFrZ0nmxW', 'nlouC9ngqZz8rv7EdLS9mw==', NULL, 21, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (162, 'olga', 'cUkFKjBnL+anCmu4HUUCtw==', '$2a$10$ffBP2xSSeVF80ISe5NytnOyEhpCz3nWbFJyuAqYUHmglGDLuIAJjW', 'j/f3NJADDtXvJ9h5x1m9ZQ==', NULL, 130, 'ACTIVE', '[{"id": "86", "code": "market_bonuses"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "57", "code": "contr_newto_whr"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "15", "code": "whs_inv_history"}, {"id": "60", "code": "contr_move_between"}, {"id": "79", "code": "order_treatment"}, {"id": "42", "code": "setting_portal_user"}, {"id": "56", "code": "contr_prod_new_whr"}]', '[]');
INSERT INTO public.erp_users VALUES (232, 'conan.barbarian@gmail.com', 'FISLgPiO/VCB5LgQvg9epA==', '$2a$10$3YcntBWsSrb8ehiTvmKRuunaHth1HRHHJLrOhYTfuJ1IBxP0n58Iy', '5eRlwLdRvO9ASRFPZnuBDA==', NULL, 148, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (221, 'danil@gmail.com', 'xu5N50onUEVWrddt9FCAfw==', '$2a$10$Yg5TY9l14bZjTDapED7ysuCvQoIiHMI5WD6TEITual5Le/zkt710O', '7/Gu8dFkOPE5AgXqs7RsHw==', NULL, 131, 'ACTIVE', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"}]', '[]');
INSERT INTO public.erp_users VALUES (229, '1@gmail.com', '4yVd5JazO3EnVpejDC4eAA==', '$2a$10$OJBG/cx5qs23tDnkxz60SO7d6yAh4nVPHEK9y7J4jWyqnZLgjXpbq', 'Mwm/fH0VX19hL439gke6vA==', NULL, 18, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (124, '111@mail.ru', '80gNnudyNoaNLZwcm0gUSq5EWD98YyqtoTwjpnU0hz4=', '$2a$10$NnBh3Ko.WXmcH.Z6fCNbHOp7nsz48d08xrQn/tElH5QorVbc9AqGG', 'wO9hEGEk+701qDxS8XamoA==', NULL, 120, 'ACTIVE', '[{"id": "15", "code": "whs_inv_history"}, {"id": "14", "code": "whs_leftovers"}, {"id": "19", "code": "whs_prod_move"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (222, '1', '+5cCc4FNLH3UHEn+5uaqGQ==', '$2a$10$FT5/CwQNPv56rXAqeMYRz.TE6smKT5WhEJrS2QMZm.tb3D3HHSRES', '0FdU3dz6f+BdY2WV33qTuw==', NULL, 131, 'DISMISS', '[{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":14,"code":"whs_leftovers","name":"Остаток на складе"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":19,"code":"whs_prod_move","name":"Движение товара"}]', '[]');
INSERT INTO public.erp_users VALUES (196, 'piko0101@mail.com', '6coEcrOCGZ9XK3OVDlPT9Q==', '$2a$10$vme/FDXnjP4EKRV9x6SkGu7sCoNecS/We65UOCEezecarLfFBjJMi', '4gowYkcznCFP0ucenuQ0CA==', NULL, 138, 'DISMISS', '[{"id":"83","code":"market_coupons","name":"Купоны"}]', '[]');
INSERT INTO public.erp_users VALUES (190, 'psabitbek@mail.ru', 'bF6dMAoc4/G1U3CZT9eWHg==', '$2a$10$B02kpoGU.KmS115DkxQCdepDa1gpkT60r2JAfyHW4oV6RR4mn7GbO', 'E9s7QdCjiYmJ3b+PhYAOoQ==', NULL, 138, 'ACTIVE', '[{"id":44,"code":"setting_sales_plan"},{"id":38,"code":"setting_cash_reg"},{"id":34,"code":"setting_whs"},{"id":32,"code":"setting_store"},{"id":52,"code":"setting_scales"},{"id":31,"code":"setting_gen_info"},{"id":46,"code":"setting_supplies"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":42,"code":"setting_portal_user"},{"id":8,"code":"rep_discounts"},{"id":9,"code":"rep_consultants"},{"id":11,"code":"rep_abc_xyz"},{"id":7,"code":"rep_gross_profit"},{"id":12,"code":"rep_debt_book"},{"id":4,"code":"rep_prod_solds"},{"id":6,"code":"rep_team_bonus"},{"id":2,"code":"rep_sales"},{"id":10,"code":"rep_certificates"},{"id":1,"code":"rep_checkout"},{"id":3,"code":"rep_checks"},{"id":13,"code":"rep_buyers"},{"id":5,"code":"rep_single_bonus"},{"id":21,"code":"whs_revision"},{"id":15,"code":"whs_inv_history"},{"id":27,"code":"whs_exp_dates"},{"id":14,"code":"whs_leftovers"},{"id":19,"code":"whs_prod_move"},{"id":23,"code":"whs_holdings"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', '[]');
INSERT INTO public.erp_users VALUES (84, 'swwwwww@gmail.com', 'fAihtEsgioXKt/9/tpwQcA==', '$2a$10$xXGlzdfNTdKsOBpK1P/aUucHNxIQpcGvfZgERuRa7mommsxFFRq8m', '7GcczgebDTTaWQvpwDfmww==', NULL, 80, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (231, 'don123s@gmail.com', 'Kfl+MyTgdjqVvy8K/ir6O9h++G3IrEhj1yzCVbM8srs=', '$2a$10$.z7EjOe1sAm2E.MbYRjWUeRLT3aBIvvMlj8fU.vdGnmUSu6i01xEG', 'S1va9hFcI15YXUyvM4Beig==', NULL, 145, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (166, 'adil@tezz', 'GaG8RHgmTG1ftj7zAa8/6A==', '$2a$10$akqoCCqFN./ohbKOKfsJve1P.PgHKdi.VZQWpoX01Ty/1BQ1.9BcG', 'Ai5RqVT1tO075w9+pJjdYA==', NULL, 0, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (193, 'piko0101@mail.ru', 'IcWibP+s9m2gBa9JcLRn6xfSiXfr3hSdOKLZzXCVR83P/lBxUhAkZQxV/fZ7B0re', '$2a$10$ar8JRYNHFjIntnpmMt9woe6ConCdhTiHChUNARezIq8ZAVYp59Jj.', 'nO5rivqHQKDeEbacFNyDZQ==', NULL, 138, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (192, 'madina_massanova', 'ilVNgRPnDDeR4yzlCuKzhw==', '$2a$10$gOWJgU3/csfKPZLPW4rPR.vVxnLwRcGJHb89Htvyi.FLpsnAGRYjq', 'sgfYrAxkb3YaGN5wIubbtA==', NULL, 138, 'DISMISS', '[]', '[]');
INSERT INTO public.erp_users VALUES (215, 'sabitbek@magnumtech.ru', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$ETqwlzVPKCBE9sbp.6Xq2OAZFNdyuIrI/2oNPaCbd5XQR950MNpsC', 'Sn220ttLn/h29Msn933i1g==', NULL, 138, 'DISMISS', '[{"id":"42","name":"Пользователи портала","code":"setting_portal_user"},{"id":"14","name":"Остаток на складе","code":"whs_leftovers"},{"id":"15","name":"История по накладным","code":"whs_inv_history"},{"id":"19","name":"Движение товара","code":"whs_prod_move"}]', '[]');
INSERT INTO public.erp_users VALUES (199, 'madina_massanova@mail.ru', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$TWwyB4KVXigw9PkWUQdy5.TTLMHsjoOyW/nsGUwHyfI04g2jsIqS2', 'nO5rivqHQKDeEbacFNyDZQ==', NULL, 138, 'DISMISS', '[{"id":"42","name":"Пользователи портала","code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (191, 'parasat.aldashova', 'IcWibP+s9m2gBa9JcLRn6y19aQHELtHe8ZWlUEWVFwE=', '$2a$10$lUxJyJKviYDI48NX.uNRe.dlX8daR.AjPK12.ekLkE/v0VVdW.G8.', '77Eh75aZh8Nre1Bvct8gUg==', NULL, 138, 'DISMISS', '[{"id":"42","name":"Пользователи портала","code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (126, 'madiartolkybek@yandex.com', 'XdGnjfJb6V7uC55tdQIkcX3UPK70esIspbdk15iXvR6TFTHmLPNFiMQJO103UzY5NWTMfQdb0dF0RiUSJgULSw==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 124, 'ACTIVE', '[{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":44,"code":"setting_sales_plan"},{"id":38,"code":"setting_cash_reg"},{"id":34,"code":"setting_whs"},{"id":32,"code":"setting_store"},{"id":52,"code":"setting_scales"},{"id":31,"code":"setting_gen_info"},{"id":46,"code":"setting_supplies"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":42,"code":"setting_portal_user"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":8,"code":"rep_discounts"},{"id":9,"code":"rep_consultants"},{"id":11,"code":"rep_abc_xyz"},{"id":7,"code":"rep_gross_profit"},{"id":12,"code":"rep_debt_book"},{"id":4,"code":"rep_prod_solds"},{"id":6,"code":"rep_team_bonus"},{"id":2,"code":"rep_sales"},{"id":10,"code":"rep_certificates"},{"id":1,"code":"rep_checkout"},{"id":3,"code":"rep_checks"},{"id":13,"code":"rep_buyers"},{"id":5,"code":"rep_single_bonus"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":21,"code":"whs_revision"},{"id":15,"code":"whs_inv_history"},{"id":27,"code":"whs_exp_dates"},{"id":14,"code":"whs_leftovers"},{"id":19,"code":"whs_prod_move"},{"id":23,"code":"whs_holdings"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"},{"id":84,"code":"market_gift"},{"id":88,"code":"market_create_discount"},{"id":86,"code":"market_bonuses"},{"id":90,"code":"market_stock"},{"id":83,"code":"market_coupons"}]', '[]');
INSERT INTO public.erp_users VALUES (223, '777', 'QTtfJUWT5ap20oBqPRZEGQ==', '$2a$10$2GZc2IAQFOgmVkV9lUCWyOQACmiy5B3YkJovzp6CTTuuN4YY4QVS2', 'mh+gHnY0r91R4VOYmiZ9DQ==', NULL, 131, 'ACTIVE', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"}]', '[]');
INSERT INTO public.erp_users VALUES (71, 'amer_97@mail.ru', 'LdDcjMnHoWKumejC/WWo6Lojc/YMVWr5jWBEtbTJ7egiHT3/e+PdkI9mgckgXF2e', '$2a$10$bXTF9M.WNqKTHN4To7K2reB.abSbnvz.x26I4axWsf9IcX4OJ9Qg2', 'IJyqUmGm9tEXTyvUMZTa3g==', NULL, 66, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (51, '123456123456', 'aH9H0Mu9dGUVA1ljJz3mfA==', '$2a$10$Gh11hZyLECBl082HdIhqU.exkmd3QILEeKnpWKwcUE2NUQJBbAhcu', 'aH9H0Mu9dGUVA1ljJz3mfA==', NULL, 31, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (52, '1234561234561', 'aH9H0Mu9dGUVA1ljJz3mfA==', '$2a$10$hLQz2XzydJdax5ieBq5CqeNoN6b4ak3SalJ1kMiR.aIfbjwD1Qabq', 'aH9H0Mu9dGUVA1ljJz3mfA==', NULL, 33, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (180, 'eagle@gmail.com', 'Z0Y3RT++JvV/i5ZE432dZ75thaMBfdv4D46Uj7e+YQ0=', '$2a$10$Glu6R41kSRQcDZF3axOjWeOGaxmOcsyZO71QcdrGAo9bG1iG..cre', 'WTsUoNnp+51svL42v7GcmQ==', NULL, 18, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (115, 'nurtas.mnn@gmail.com', '3VVJvaRnfw2ajdaWWegRPhOOknHOYNTjZhsvGkLvbpKXFqCaf0P+k+KJZCMDwYGMm5ykL6kcaRRuKkteYGHMZg==', '$2a$10$mxiID6VsHwRAOcZOphTW6O2GNBfWGtG1N7K7DD64N6jc0reyNppYy', 'RPJcnZJ64SfVxaKeJlDY8A==', NULL, 113, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (60, '1231231231231', 'NDbKYbTePrMbHjnaVDqV9g==', '$2a$10$Rz6a9KSGxAcMZg44hxGZCua/hAkT.cpawzpfsMOH791Wq0FM2iOIa', 'NDbKYbTePrMbHjnaVDqV9g==', NULL, 47, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (92, 'cashbox@mail.ru', '/QCI9ImGrvJ94KIvqksAZQ==', '$2a$10$eFV.XJK61iEN8WcQIJ.CjusLDTzarDELGBfJeAbzRUc8ME3P1z/Gi', 'DqiUDoAn68tLTJQBEjCHjg==', NULL, 91, 'ACTIVE', '[{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":42,"code":"setting_portal_user"},{"id":40,"code":"setting_user_chekout"},{"id":31,"code":"setting_gen_info"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":52,"code":"setting_scales"},{"id":34,"code":"setting_whs"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"}]', '[]');
INSERT INTO public.erp_users VALUES (93, 'revisor', 'SVP8Y+3Lcz6/5kQjkHmtqA==', '$2a$10$Ne59ncPxh/JUESAxMRSpoOJQiTWf/UUAnQJEdCvzkXI0WT8aUoham', 'k038RIgRC6810NFdjfPBFQ==', NULL, 91, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "34", "code": "setting_whs"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "32", "code": "setting_store"}, {"id": "52", "code": "setting_scales"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "1", "code": "rep_checkout"}, {"id": "3", "code": "rep_checks"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "42", "code": "setting_portal_user"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (97, 'diablos@mail.ru', '0V2rwAoyf85neq6zAdv4RuPVbhIiBDM4gmEaDsZoQqC5UmlXeoAZ5NhD6nM/PSWiEVYwSwHf0P/l3ledE/C4oQ==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'qnHSEdqqN+S2p8ReM8zECA==', NULL, 96, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "78", "code": "order_create"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "77", "code": "price_marginal"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "75", "code": "price_wizard"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "74", "code": "price_change"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (65, 'alfa', 'lYm0482tocHPxmHKDYtna6Ry9kGZRHl9FcIjewp/naM=', '$2a$10$DBeRGQG1M0X3YojMoV7j0Ock6YYD/HzxOlluQGpdmwuLW0iwba2RK', 'aii7i6zHPLywdavt32sgYA==', NULL, 15, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "15", "code": "whs_inv_history"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (149, 'rev1@post.is', 'J16jtjzaxl8EcSVZlLHodTKwTxQnHGPmxgHD9BIWVc4=', '$2a$10$o61XRNJxchn9O/Bi4fdAuOyrpKmSOvkG5LKoFDwGsiZ90nbhXYaxm', '2y4HGrNQ67Anhv2tVA9ymA==', NULL, 122, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "34", "code": "setting_whs"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "15", "code": "whs_inv_history"}, {"id": "32", "code": "setting_store"}, {"id": "52", "code": "setting_scales"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "1", "code": "rep_checkout"}, {"id": "3", "code": "rep_checks"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "42", "code": "setting_portal_user"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (121, 'jido@stn.st', 'GBJ3TWgf6S+QzUmZz09quwHfGMtDx8yMDXRiO59DNnU=', '$2a$10$3BmepPt.PsiFvF6WYAmTputW99WtiPN/.CHq.btBRPtlzeqslMOkW', 'Ri/3hKpk8aBX1D7G2F2EHQ==', NULL, 119, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "78", "code": "order_create"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "77", "code": "price_marginal"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "75", "code": "price_wizard"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "74", "code": "price_change"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (117, 'test1@mail.ru', 'TKQpXM99YJ07nxVPfISxPg==', '$2a$10$A68dn8IowcGHHa7/nIAAJ./EADNO3DJioZfqMDjf.Tz/tf1Q2srga', 'lyFALxlK3JKRNEfQJmjLKg==', NULL, 115, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (88, '55@gmail.com', '3jUX/x8N1jCValM0G+lgPw==', '$2a$10$pd2WXTTGe4k239T5bIxz6.fMmKvGy5RuNfFkDCknfXi9cBEar1qxW', 'NwIP1PDKz7I3pd03PZsFfA==', NULL, 86, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (119, 'ardak-a@mail.ru', 'hKh2+3ewIELHo47ZKvNwuLFWF62hvRhetstYMlFVY2+Ni2hrgoAjBw6VEKPTSLPheCsMuEDyYoOyDLJragcEWA==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'HIS1pHg2C0hCsahVetT0vA==', NULL, 117, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (113, 'xottab_beach@mail.ru', '27drrPdUMUtuiDEM64odLuORgU4JrPSY44v0TetiU+ndmcuOoijHYJfHzb7jp++oImi5dRM1uAJktnm9yAuuIg==', '$2a$10$xdDSDRfXF0sly3AXo96IA.ovEJXb8vCbS/RLUJpEk7JOlOHpBU.ES', 'Vd7XLyD/yNc5F+W7m1xwHA==', NULL, 111, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "78", "code": "order_create"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "77", "code": "price_marginal"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "75", "code": "price_wizard"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "74", "code": "price_change"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (43, 'shorynbek12@gmail.com', 'MScoI7yzI/DeLpSpHgGYrtLgDe9KlMvj2yEUSpl/H6aiEgXiiprd1FKTh4Obc26F', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'ICXJo6i1t8VYg4xe7oRR5A==', NULL, 19, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (147, 'gulzira', '0fh+tZYWi8AgcMkWFw+TZzr9wTLL1ksXmVKXwdgucgA=', '$2a$10$GYgXWLExl0Qyk8Hb6IFpqOvu1okK2X3t0i/UN46xICoI2j2ioYjB2', 'zU0Z0puDVx/XBksIydBHiA==', NULL, 130, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "57", "code": "contr_newto_whr"}, {"id": "34", "code": "setting_whs"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "77", "code": "price_marginal"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "60", "code": "contr_move_between"}, {"id": "1", "code": "rep_checkout"}, {"id": "75", "code": "price_wizard"}, {"id": "3", "code": "rep_checks"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "74", "code": "price_change"}, {"id": "79", "code": "order_treatment"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "56", "code": "contr_prod_new_whr"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (188, 'roberto1@gmail.com', '+wRip0M2vglnAF3A33H4sw==', '$2a$10$LYi9YKtKWIHdwAhl5kaWLuVwnDvlpWrKqAp/HwIkJwHLlfQQ83cyu', 'ThVCJXEd9zMuG7DRL6/bMg==', NULL, 18, 'DISMISS', '[{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"},{"id":78,"code":"order_create","name":"Создание"}]', '[]');
INSERT INTO public.erp_users VALUES (225, 'dasw21@fmail.co', 'o4gnQtKs0BsIRMc93G8jaw==', '$2a$10$UKwduCBtPDfw9KtWFiRVK.iZYlUWVVpR56fwqZ1JNaMY1A2azEbpW', '3RMGscnuG9q+Np3EqrVApg==', NULL, 18, 'DISMISS', '[{"id":"42","code":"setting_portal_user"},{"id":56,"code":"contr_prod_new_whr"},{"id":99,"code":"whs_prod_period"},{"id":14,"code":"whs_leftovers"},{"id":5,"code":"rep_single_bonus"},{"id":6,"code":"rep_team_bonus"}]', '[]');
INSERT INTO public.erp_users VALUES (151, 'acc@post.is', 'FwK91AWjVgp5ShDd0o6arZob6KSFhXsk08NrehgkgSs=', '$2a$10$cHHMJ3n26kilk/mNYeqXjue/k4is67vpsudoF9mlQNjDHWtrBWxAy', 'f50fGZYMbtUUEcwWw9ebLQ==', NULL, 122, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "15", "code": "whs_inv_history"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (85, 'assds@gmail.com', 'v+Wb8ArA2juAj3+B2EEgtw==', '$2a$10$p/3xdL781XjIy7FL6PH6n.68siO3dGDIgx.KjD5qk79UiaCi71nzW', 'cN5J7kRv65DqonTdFPd1/Q==', NULL, 81, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (95, 'skywalker_alexander@yahoo.com', 'zWPa3NUDDCoOD/tSijeJQA==', '$2a$10$fzfsSsfYU9gM8DnBW4DwCeOuuWwc4ataY9QkQ1up8e3yHudPitoV.', 'bZRcqEIu8yThZlNn90evMA==', NULL, 93, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (57, '1234567891231', 'E5sdTo85S7N3AFVGAKK4Vw==', '$2a$10$qIjWeayRSoDzVS5dBt5ZfeP36H3fqnAR6jHbt/EijKYVX.2xz8iKm', 'E5sdTo85S7N3AFVGAKK4Vw==', NULL, 41, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (81, 'mail96@gmail.com', 'U4YGhr7VSogL+LBt+gNRXZJohBGNXdzvN58WvaGO0uI=', '$2a$10$u0sAdh5mpxlL2uIC2u1dv.SynvpGvKA4FWLOFnoI3iCt.GoDBmQgK', '5Uh57SIfdD13y41wPfrZaQ==', NULL, 74, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (153, 'catman@post.is', 'UHoXi7zP13BxB9LHc1ZBoQ==', '$2a$10$HfqR23PQNUlpjMsaGgdYN.MkIEt/YVZOESOIIrYExsvSCKppMcXmG', 'jlMqC0dJ5/6FvB8wHJbtrQ==', NULL, 122, 'ACTIVE', '[{"id": "86", "code": "market_bonuses"}, {"id": "57", "code": "contr_newto_whr"}, {"id": "60", "code": "contr_move_between"}, {"id": "79", "code": "order_treatment"}, {"id": "42", "code": "setting_portal_user"}, {"id": "56", "code": "contr_prod_new_whr"}]', '[]');
INSERT INTO public.erp_users VALUES (212, 'pwtestg@magnumtech.kz', 'Bs/XNY8yD+77b4PKt7LB1opEqr1j+8U1AWMhGY7hju0=', '$2a$10$C964B.sMqUylR5HyurJDNOHXW.jmypJux5VznnTc0qu8ZbvmmpIQe', 'gV9bX1uTN3Q8cbJd0RKPRsQqNdhNiMCyhxmVUhtOQvI=', NULL, 18, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (56, '1234561234573', 'aH9H0Mu9dGUVA1ljJz3mfA==', '$2a$10$RrbReKIbFS7E7GtZdK4b3O4/5aUrDmDmhgEDT3kXAiTH9CxOSQ6cC', 'aH9H0Mu9dGUVA1ljJz3mfA==', NULL, 39, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (34, 'sasha@gmail.com', 'flT/TQ4IDFabpJKo0bNHvpc5oSBRpsiQAjM2TJYGWe6p8ImaBKxwJt4Vqv+n8yJp', '$2a$10$Si4RermMe6ySHSAncyADsuZ1HSZKg.19lNsw9vvMm20W0TD7PFrpe', 'DhMS/FlgNN29irLZ/mUJTg==', NULL, 13, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (54, '1234561234571', 'aH9H0Mu9dGUVA1ljJz3mfA==', '$2a$10$ZReqvuTqjNe251GygGOsTeLtZUKKIXhUboah8ywI6ex5V.I7cN5DS', 'aH9H0Mu9dGUVA1ljJz3mfA==', NULL, 37, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (181, 'thenotarious@gmail.com', 'XUSOAhnBtT+WpLFvzYWdTKNT/4N7XkaWJKph8DRhqgE=', '$2a$10$WPFlYWdBTrE8b/2PyiUu4OIft5PxEEYt/EMc45OXaYwaJwT8b6gI6', 'twNvofSwxohD9fnGnpI4nA==', NULL, 18, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (96, 'tezhelpdesk@gmail.com', '2ny6l9Ub7QWQjlNZu/Q/Qg==', '$2a$10$1yME9yLoHJSygEXS8N9a0e/tMWrJo9Eghm2eO.0T155iFpCFvFGNO', '8XY97anMfps6Ou6iW1Spgg==', NULL, 95, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (83, '2jzgteje@mail.ru', 'dDnqJ+7ppjD3IDcVkZBNbII+kkS++csczCrSC9i7xq+x2fllCQvhXQcQ0uvlxwp/', '$2a$10$d5O6WNfP2J0qPdOAiFeNBOFDFNlwQtKKQyB2o.oosbFwO4Wqmtnqq', 'Y57ITvqw1vZeyvo6gAHHrQ==', NULL, 79, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (67, 'pazylbekovasylbek@gmail.com', 'ZkbxHYvR5Df1xMPTRCidI5LNikOyq4LH1TXiYRL4Kqj4nxOhOtonh5vsRlNnjuXP', '$2a$10$oDFuuQSs.t9OouNi5/fiPezGZ/MrziMGf.0ng3MBP7.PrLbIjTa1y', 'NjE3tVk6KAcNgWRVsVfa5w==', NULL, 65, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (63, 'admin@mail.ru', 'SCAostq0vP3Nkm5Qjykw8A==', '$2a$10$25dWhObbs1Xw2abft/oLD.wB1VnGc7tS0VBFZJarDN4I34cDLDHSi', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 61, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (198, '0101@mail.com', 'ilVNgRPnDDeR4yzlCuKzhw==', '$2a$10$DSR9oPm1zRo0WhvgJD6TOurDGnqzMLyHfci6qbHquO0BwGuTgEgmS', '69BsIkHFDO9BS0ep/vhU1w==', NULL, 138, 'ACTIVE', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":"99","code":"whs_prod_period"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":84,"code":"market_gift"},{"id":88,"code":"market_create_discount"},{"id":86,"code":"market_bonuses"},{"id":90,"code":"market_stock"},{"id":83,"code":"market_coupons"}]', '[]');
INSERT INTO public.erp_users VALUES (90, '0000@gmail.com', '9qUhYDvMOt5i+kN16yO4PQ==', '$2a$10$0Yy5uHuS8sVlYv0tw2f6EOhpdFLqOtAf2H8BTXXlkMbD90HdU3awO', 'wLx9IyxQs/lhPJ5bWHDoTw==', NULL, 89, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (168, 'adil@tezz.kz', 'gOih2w+QgosHjlAETXws0Q==', '$2a$10$L0ADVnN3q/29e086pktN3.7HVpjpKyh0XquAuca6Q9xZ0RmtVPUXW', 'Ai5RqVT1tO075w9+pJjdYA==', NULL, 112, 'ACTIVE', '[{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":79,"code":"order_treatment"},{"id":78,"code":"order_create"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":38,"code":"setting_cash_reg"},{"id":32,"code":"setting_store"},{"id":52,"code":"setting_scales"},{"id":31,"code":"setting_gen_info"},{"id":46,"code":"setting_supplies"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":42,"code":"setting_portal_user"},{"id":34,"code":"setting_whs"},{"id":44,"code":"setting_sales_plan"},{"id":57,"code":"contr_newto_whr"},{"id":60,"code":"contr_move_between"},{"id":56,"code":"contr_prod_new_whr"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":8,"code":"rep_discounts"},{"id":9,"code":"rep_consultants"},{"id":11,"code":"rep_abc_xyz"},{"id":7,"code":"rep_gross_profit"},{"id":12,"code":"rep_debt_book"},{"id":4,"code":"rep_prod_solds"},{"id":6,"code":"rep_team_bonus"},{"id":2,"code":"rep_sales"},{"id":10,"code":"rep_certificates"},{"id":1,"code":"rep_checkout"},{"id":3,"code":"rep_checks"},{"id":13,"code":"rep_buyers"},{"id":5,"code":"rep_single_bonus"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":86,"code":"market_bonuses"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":21,"code":"whs_revision"},{"id":15,"code":"whs_inv_history"},{"id":27,"code":"whs_exp_dates"},{"id":14,"code":"whs_leftovers"},{"id":19,"code":"whs_prod_move"},{"id":23,"code":"whs_holdings"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', '[]');
INSERT INTO public.erp_users VALUES (10, 'd.bakanbayeva', 'SLQmxHOuZlH4X7hY3tk5BUr/+ZRHgQh3/QC0QosveH8=', '$2a$10$gv/QCT7DB1EWBMqfDOE.TOiJebmX7BWHGhaFJDnvvK8TedWBVgKQm', '8iG0vGtmkpFTR56CucWjJw==', NULL, 15, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "78", "code": "order_create"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (45, 'qwe', 'jJkIXzG3vj2IwqXhGCHeeA==', '$2a$10$ton8wGDrUEgfjW7QiPf9AetLYN8jVuvwk1MMoswzbzw9LQbuBSmbq', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 22, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (86, 'awegawegawegserbserhgergawerg@egweg.ka', 'RUlFlw/DNJkJfTkuOJPnUg==', '$2a$10$BgxG.6D46KEWofh.PbzAJeNj9mafpfdI2t5kVQJxm81cdCVEZwoGq', 'wFe2e/eG3O+1D86P/HgwbQ==', NULL, 83, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (144, 'dimash.kim@gmail.com', 'RyH0mQdywuqjU90CfVhQ4TcK7patXyK5temWgFU8QJqdHBO2730RQGS5JPRIA9pN', '$2a$10$WPpKVWa7RzkV8N5vbUPMiulCsrs5oNj6CRoNh9.nLzyzuXhBYw2Ye', 'RJ6PcdKkGj9Bhb0m6CMNHw==', NULL, 125, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (179, 'madina_massanova@gmail.com', 'RFBQqyz6cIDx9Jh4Zs7vol4K74Nyw49U/9ZI3p9qqoDz+4coCljLBJKJ6ZBsqbdM', '$2a$10$ny0g3Fkvv/91oBQwscIEieJnWHK0FQhTR1WbGZEOxPVXqcvgAIJne', 'oVOTlsd8EfpaHZB1h5KtRA==', NULL, 91, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (89, '7777@gmail.com', 'M8Pe4bVUYWvyUHZszT2DNA==', '$2a$10$2Xaw0ZPBGwBMGTg0MoWdfOO0vNDTvjum1DW1cT3XxkPMhjA3w0F/2', 'mh+gHnY0r91R4VOYmiZ9DQ==', NULL, 87, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (175, 'gigachad123.@mail.ru', 'hJ5K224Jl/1Gg99CD7A56AARpTSqyfp801RMKK0YJaw=', '$2a$10$Vw4HXMjn7Al5g7Ki5MWCAu8FfF2qJOluHIjDC65C48c9wSYtdAUxa', 'IC+vKQi0Dri0YHjubQUlrw==', NULL, 18, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (66, 'testnew@gmail.com', '5uzFmCm6M9XR3WbjWfqBAw==', '$2a$10$z52RLv2vkHSeGMTKBfEC/.jrISDd1cTyWdmDtll89CHzEpFh9WTTm', 'thRu1sE0PVZEL0LmV2EWQg==', NULL, 64, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (155, 'sonepiko@gmail.com', 'Rhxw2ZAE+IOyTRaF9plUETSgrzf5kUwSovnLbwxjB2A=', '$2a$10$4svVLbrPNfcstEoamsSt2.t3anBJyjIc.4s0U6mZD2SlPl3LDac12', 'tRho1qTCzYZBMXTShNPhCQ==', NULL, 132, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (-1, 'support', '5XpKWlcDCDtnJ9KiSdrBeA==', '$2a$10$EwKo0DwKQMlqxGA9W3koKOi6ayNX.SOBLuMB0/8FafzAQ/BQA5SU6', 'nlouC9ngqZz8rv7EdLS9mw==', NULL, 0, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (111, 'margarita.budnikova@mail.ru', 'rdA0rbb8TMcqHi1ZTc37gZFcHUMtB+eHWofL7luA5KhZ59n2U9rNHlkwFK6cxLm+JGH11jpRHhGD7yfv68zYhQ==', '$2a$10$Xhf9jG3.OXd6x7zTHFbXn.wddbptTsVnCqySHEdMqukKw6N/x8HGi', 'tQZJJ803mYpNvSqxy8BrRg==', NULL, 110, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (62, 'ismepos181@gmail.com', 'SCAostq0vP3Nkm5Qjykw8A==', '$2a$10$Z/UbB07IuDKWIeQw4XcntOF/Oa34fz1jDbew8Jvpdn4Lxse4onGgK', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 59, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (182, 'predator@gmail.com', 'v/884kG3FaAaeOy0x7b835kvPEwliyOKjYjUhwoowRI=', '$2a$10$zgbl6YJPDZnCDD2RizIJoelOmrUtM.Yjz/mwB52rKrthilOuoOWKq', '4i+0GZX+LPkLYoKhq/p9Zg==', NULL, 18, 'DISMISS', '[{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"},{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":78,"code":"order_create","name":"Создание"}]', '[]');
INSERT INTO public.erp_users VALUES (123, 'prog@anime.hub', 'vS7iBr0kz3tz0GtC+Q43sg==', '$2a$10$AqvNh7Iy6H/BGs/1y5Y2vOJxSQ8Fm58RoMe6LovSQhFTOApezM13q', 'FSiGHguUL0m6NiouNqDzcg==', NULL, 121, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "57", "code": "contr_newto_whr"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "60", "code": "contr_move_between"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "79", "code": "order_treatment"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "56", "code": "contr_prod_new_whr"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (99, 'malakas@gmail.com', 'dWWyXmSR9t30a6EdY05Hl7BiZXfmwQyoB6vQYq43u/wMjkCfYxPUI6Dnx5s9wgvzpVGOvIgTKhR2oMA+HG7zLA==', '$2a$10$6UrGufY6yLfelHIjspMtXuhvyN88N/CTvTt3Bff4WOoh1Zx2wmHyu', 'x05dEUMG4iLy5lHgPw+ydg==', NULL, 98, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (201, 'donyi@gmail.com', 'IO1vKjp9Oh/CDeqAluylsw==', '$2a$10$3Tzl3N/0kctFow17YY9Mi.ZAbeSqxJhBThl6adm7mReNumezhgXJW', '7DLsmmGvYEniG4p+WMaN+w==', NULL, 18, 'DISMISS', '[{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"},{"id":78,"code":"order_create","name":"Создание"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"}]', '[]');
INSERT INTO public.erp_users VALUES (35, 'a.niyazova', '9WWONNyG+sHtMV2+vO936rOo7r8IUQ7a+Ps8N0nUNI9rzJsW+DNtuQDv/iuva5QM1XAvJ5emMHGFflUeYGOD8w==', '$2a$10$dQWKqRTJH3sV97i2AX0k2.O94/YOeywgHN4Dy6lYj8jupuR.f9zsS', '0SDiY+Ar4BSeu+82xj/zyA==', NULL, 15, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "15", "code": "whs_inv_history"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (41, 'demo_admin', 'SLQmxHOuZlH4X7hY3tk5BUr/+ZRHgQh3/QC0QosveH8=', '$2a$10$TpvwifIAKedXHosA/n/F..fauYnYSBfyRmjqjSvNUQ63gRoSKr9DW', 'nlouC9ngqZz8rv7EdLS9mw==', NULL, 15, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (46, 'qwe1', 'jJkIXzG3vj2IwqXhGCHeeA==', '$2a$10$/3bLT7vJF0Z/X./WjcpQXuTTPLW8A9KMb1WO3/EP8hB0RFc9rAOh6', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 26, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (206, 'psabitbekqwd@magnumtech.kz', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$SrYAC/ODa.PiWCAWrxVUie.JQXLFp016s8eJSCgPxJYT69pUO4WyS', '7DLsmmGvYEniG4p+WMaN+w==', NULL, 18, 'DISMISS', '[{"id":86,"code":"market_bonuses","name":"Бонусы"},{"id":84,"code":"market_gift","name":"Подарочные сертификаты"},{"id":3,"code":"rep_checks","name":"Чеки"},{"id":4,"code":"rep_prod_solds","name":"Проданные товары"},{"id":83,"code":"market_coupons","name":"Купоны"},{"id":90,"code":"market_stock","name":"Акции"},{"id":88,"code":"market_create_discount","name":"Создание скидок"}]', '[]');
INSERT INTO public.erp_users VALUES (53, '123456123457', 'aH9H0Mu9dGUVA1ljJz3mfA==', '$2a$10$gI8b4Plqd.kawJDTwtLxfucDd/4E/OBY3ykv4sDz3Q0HhULUrYoSG', 'aH9H0Mu9dGUVA1ljJz3mfA==', NULL, 35, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (32, 'anar', 'ebGSPSAO7fEd9YXStRMwSDLUMFLibiuYTAttvYLP6qg=', '$2a$10$KbxjuaAEwj7IwwLKzsWQruJDTl7S9C1AhsuULhgHKrjQ8GzZZc8L.', 'p6bykUAiNXk+2upyOOm6Lw==', NULL, 13, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (38, 'k.nurakhunov@gmail.com', 'liWtgdiMKGIsAdK6hMDGdkvJKBTjaCv0SLxYIxYshf1OrhB0nYKcRwzbGqFR3SvWavusFd6r7jc7pFculZ4PjA==', '$2a$10$yhK5Eqz3yzTpwmrCI.LJkeig1HFPxIN8xONTlmCZ4iL9yQhkPRXTm', 'WziOuZpQG6wC/azMAsfdDg==', NULL, 17, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (164, 'raikgurov@gmail.com', 'mzvoxDJqm9sQWw3wymLE4A==', '$2a$10$qz3CFfVLY2Apg2Sv6ZOmc.cV.RlLQSXF3lKX1/mxPZBFYe9IeBfCa', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 141, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (122, 'nurtasnurtasuly@mail.ru', 'FqzNfiHEzRp4Zd1Vey8tE2zCod8K2HBgZHgauAAqTa/yi1k+irkanNdtrfa5j+df', '$2a$10$aKSG5BQGKRqPyAKb3QJkFOGXlqlQJNrpToSs69cQsrSWGuqmNfj16', 'FMiEGdl1XNhtfo4AiDTMsQ==', NULL, 120, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (247, 'sone.piko@mail.ru', 'O6SCWoSQ9DYAnO1CZWfXyQ==', '$2a$10$LTdKN4Srv03/cXuC9CPRA.8ZOx1LbIWksYMz1yCkousvATTUeYjNy', '7DLsmmGvYEniG4p+WMaN+w==', NULL, 18, 'ACTIVE', '[{"id":"83","code":"market_coupons"},{"id":"84","code":"market_gift"},{"id":"86","code":"market_bonuses"},{"id":"88","code":"market_create_discount"},{"id":"90","code":"market_stock"},{"id":"77","code":"price_marginal"},{"id":"75","code":"price_wizard"},{"id":"74","code":"price_change"},{"id":"42","code":"setting_portal_user"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"}]', '[]');
INSERT INTO public.erp_users VALUES (94, 'mergen2407@gmail.com', 'tTfqp8W0MRRgdOhEbZYGXCb19tRAe3GrUspxIr+k0CPP8XSVilV8CIxY8gIA79JLSDjuf7gm9G11QHWbTKIo3w==', '$2a$10$S2x3.VyqZEWYkP3Gcodl.Oeilv.OSKw9eStS/t1KNhu1Pc8T4bf0q', 'yILgyknEFimNbtuecvrsDg==', NULL, 92, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (49, '123123123123', 'NDbKYbTePrMbHjnaVDqV9g==', '$2a$10$BSWvVcdSS6v9zoUXnSbvN.naemZGi0JXa0VGC63KjTi8Y6AObTBT6', 'NDbKYbTePrMbHjnaVDqV9g==', NULL, 29, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (36, 'm.asanova', 'SLQmxHOuZlH4X7hY3tk5BUr/+ZRHgQh3/QC0QosveH8=', '$2a$10$exCBwgL.aBX2SidWi9Smve7S/EjDibgu7okWbhchUgJvGly3PU8yK', 'iLLI9S+c+ueiX4K8Hstmlg==', NULL, 15, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (211, 'pwekk@magnumtech.kz', 'Bs/XNY8yD+77b4PKt7LB1opEqr1j+8U1AWMhGY7hju0=', '$2a$10$nK9/T16Sy.SggX0dxxgfCeEShmB9TvKcuUL1fseqKY9BPv4NFxy3.', 'jjp2GdEMykVm7gwHLffnd5RdzPTSJL499yLLnp9Ekgk=', NULL, 18, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (76, 'amir@hz.ru', 'LdDcjMnHoWKumejC/WWo6KjVpRhT2b22z2PTVho+RS4=', '$2a$10$BCeBmcnUpF9A1EvcLzJqaOvYGIPxF8yc6.fuCvWstJBcuXRLWcFPC', '5eRlwLdRvO9ASRFPZnuBDA==', NULL, 71, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (64, 'ismepos18@gmail.co', 'SCAostq0vP3Nkm5Qjykw8A==', '$2a$10$a4lgdHJ/3X78oKnpFqEhdeX6uKoLL75Tqs71ohAWZr4f4AguukESa', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 63, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (110, 'maria@gmail.com', 'Lhr7ax5EJLe+8dogQfPYROtbTjofMMyuRjcjgp7xlk8EyT1k4t0YwPyt2ZWw33Y4YjvkCvdALNvV1dvUZbc0Kg==', '$2a$10$bc7mBx4grZsPtAcXYxt8y.2a4utAgKdBP5eS3owVj/27TmQ1rhX72', 'ft0mynJiv/L7s2G5Xknw/Q==', NULL, 109, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (176, 'spondi2000@mail.ru', 'Wag/U6S6XmSolqgVTLWJ4Fls8MyS5o9k7+kJnnQEX8sSqLFE2tt7igc9zXapCsvg', '$2a$10$MZebJcDlTXODseSrSh0r1eqdoYSYL9Y7G/uEWciybTrX5j2UTMXcG', '/0KnSaLhRun7ZDFHYgB2Pg==', NULL, 142, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (161, 'sabitbekperizatss@gmail.com', '244Im6zEjyQ+yKgw5hKdDDVpM40w4L7AYZILRpyZQ2k=', '$2a$10$cXD6ByhPnyf8NdRn4oitLOBfZa2FxavvQBk4rbzOrTj.2NUIDURqO', '7DLsmmGvYEniG4p+WMaN+w==', NULL, 138, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (40, 'admin2', 'UmX1zf/8SB15mOZwwTOrVAGIiu2HIxmXtZq/4PYSsSq9BM7fiPCo6aEM4dXp/oVa4YWk/BqqIW7aPNqLyBfmGA==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'nlouC9ngqZz8rv7EdLS9mw==', NULL, 17, 'ACTIVE', '[{"id": "15", "code": "whs_inv_history"}, {"id": "14", "code": "whs_leftovers"}, {"id": "19", "code": "whs_prod_move"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (61, 'ismepos18@gmail.com', 'SCAostq0vP3Nkm5Qjykw8A==', '$2a$10$Fc6o0xOAgJD49FTgBgXnCe7a8oMCOxtui8YBAGu.HchIZZTa8rsIW', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 57, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (227, 'test2', 'COUE905KrLIsk4fIy4Tsfw==', '$2a$10$KeL.u2aIdZc2O9XUYidkyO1fnWEWECX5Gxi.NwOhkjzjfb5lURPnK', 'sAvdY5XWrUd6jzm4xxAv/w==', NULL, 18, 'ACTIVE', '[{"id":"15","code":"whs_inv_history"},{"id":"38","code":"setting_cash_reg"},{"id":"11","code":"rep_abc_xyz"},{"id":"42","code":"setting_portal_user"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"}]', '[]');
INSERT INTO public.erp_users VALUES (78, '98@mail.ru', 'sugw670G3pjC2JCC7WoDv0YlsKHWiQKbIbghtPRO8AQ=', '$2a$10$QLn0JloznH7KEDMDrtnF0OkFW6dUM9IQzrZFmD6C.Bxvs3hclkv6K', 'wLx9IyxQs/lhPJ5bWHDoTw==', NULL, 70, 'ACTIVE', '[{"id": "15", "code": "whs_inv_history"}, {"id": "14", "code": "whs_leftovers"}, {"id": "19", "code": "whs_prod_move"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (186, 'roberto@gmail.com', '+wRip0M2vglnAF3A33H4sw==', '$2a$10$wsHS0m7xZdM5mSzZ4W3Oie55Rmkpj.onJ2lJJhh6r/2qgs8beGLaq', '5KIdhEFZ3RzEwM0B+amUNw==', NULL, 18, 'DISMISS', '[{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"},{"id":78,"code":"order_create","name":"Создание"},{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"}]', '[]');
INSERT INTO public.erp_users VALUES (133, 'revizor', 's4S3+1Y0T0xEzwmi+d32Jw==', '$2a$10$7NgXH30xxoCw//cvlOTfKujDxPoxjP8pq0h7uP7ogyDP7WLp6GXFK', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 96, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "34", "code": "setting_whs"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "32", "code": "setting_store"}, {"id": "52", "code": "setting_scales"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "1", "code": "rep_checkout"}, {"id": "3", "code": "rep_checks"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "42", "code": "setting_portal_user"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (216, 'dons@mail.ru', '7W+jLb4A4TSXFnOUq5MCYQ==', '$2a$10$ZI8q/KxXTfdCt6vCpvYbDuV2uacwku37Z.SRUXjCCP0nWE3/3duHW', 'RqhZNpbalu24So31AbIjFg==', NULL, 18, 'DISMISS', '[{"id":"78","code":"order_create"},{"id":"42","code":"setting_portal_user"},{"id":"11","code":"rep_abc_xyz"}]', '[]');
INSERT INTO public.erp_users VALUES (75, 'pazylbekov.asylbek.98@mail.ru', 'DR5CYF33tLneElVyLEaBaF/2wft6WVeKDIRrqx35HO8=', '$2a$10$s9QhGr8NwUPkiM2BLDD8I.osr2G9YDRhtuHVQE6jHKDM5PaDD8JkO', 'NjE3tVk6KAcNgWRVsVfa5w==', NULL, 70, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (152, 'pointhead@post.is', 'mSOzUvH8jYCXQ8Qu9fpNX3dk7kRsWdOz9jf1aD0uIJM=', '$2a$10$zXQetVzCC1kgp4LqcS2PkeYMBLX5Jo7qKdtomV.q/PefEKrj929qi', '+nUY7t5/QPsc6aWRnOyHqQ==', NULL, 122, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "77", "code": "price_marginal"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "75", "code": "price_wizard"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "74", "code": "price_change"}, {"id": "88", "code": "market_create_discount"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (183, 'tom@gmail.com', 'Na/XyFHmbOSD+GO7w8MseQqvWNp4Y1zCQzm5OlgYQJ4=', '$2a$10$MAsXlJ7Qaw4ckap6CIPzduQl6pH97eEyXfN1IriGas5MRfKS5JEDy', 'Q5bcGzvkRjynZZQ+zTUS1Q==', NULL, 18, 'DISMISS', '[{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":78,"code":"order_create","name":"Создание"},{"id":11,"code":"rep_abc_xyz","name":"ABC/XYZ"},{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"}]', '[]');
INSERT INTO public.erp_users VALUES (47, '111111111111', 'SCAostq0vP3Nkm5Qjykw8A==', '$2a$10$cyFrkqHKl51wgqnP.uNGYemriiVCs8Z2KfWkLpgMmwxm0zsNgMJfy', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 27, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (145, 'jusan@gmail.com', 'qHVBkZ5B7NBeB8wevrbqwjThrrI14O8Rz/B3xm4fp/XHwXVlZ7MqOMFAon7yro4Vzw0X7zKvkradx+OCcfOJSg==', '$2a$10$eSeBjZP/lQbWrVEtCKWFTunW3yRDTEXUecOE1oFt1rMwx90mClnsG', 'vHciHwKt/0jzHvY3bY/B+w==', NULL, 128, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "86", "code": "market_bonuses"}, {"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "91", "code": "elct_inv_reception"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (55, '1234561234572', 'aH9H0Mu9dGUVA1ljJz3mfA==', '$2a$10$bK9poKNi9tSQUuyv7N3TMehDRpU9e7RICUx1.IW5mC7mWggVQPVj.', 'aH9H0Mu9dGUVA1ljJz3mfA==', NULL, 38, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (148, 'nastya', '9mHzg+j2cO83ZHTB9T0RQvxH/UURu0rrc+rnWNMIdiU=', '$2a$10$Dp/U9pQ2n3Qgd8EXEgDBeuRlrdRb0aREs19TzJnjTHdLlgQ2VvrUa', 'hRl9IwtavaQzUkEyHCl7xQ==', NULL, 130, 'ACTIVE', '[{"id": "90", "code": "market_stock"}, {"id": "8", "code": "rep_discounts"}, {"id": "86", "code": "market_bonuses"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "57", "code": "contr_newto_whr"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "77", "code": "price_marginal"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "60", "code": "contr_move_between"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "75", "code": "price_wizard"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "74", "code": "price_change"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "88", "code": "market_create_discount"}, {"id": "79", "code": "order_treatment"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "83", "code": "market_coupons"}, {"id": "25", "code": "whs_consignment"}, {"id": "56", "code": "contr_prod_new_whr"}, {"id": "84", "code": "market_gift"}]', '[]');
INSERT INTO public.erp_users VALUES (58, '455464645654', 'rF8SthbDhvbWRNRkqO6TEg==', '$2a$10$mJnWY8I5ERoWWvWY80tdY.Wjco6FpbGJy.rayLg9nJRfDa14wtlqO', 'rF8SthbDhvbWRNRkqO6TEg==', NULL, 42, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (50, '123456789123', 'E5sdTo85S7N3AFVGAKK4Vw==', '$2a$10$99kKezXT7DAik9NZwZEBz.LTQxmRm7RxEwT9/idmIC3FPA5QFomEK', 'E5sdTo85S7N3AFVGAKK4Vw==', NULL, 30, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (185, 'rodgerme@gmail.com', 'tFnAJy65kPhhkWpDOiud2g==', '$2a$10$pbkfryWr7mE0qt7rZxr5y.5QM3Y0zN8BurDN9RdHOJJuTgKtPNuGy', '+cG7ubIQPXSq0gErw9TJQQ==', NULL, 18, 'ACTIVE', '[{"id": "11", "code": "rep_abc_xyz"}, {"id": "78", "code": "order_create"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "15", "code": "whs_inv_history"}, {"id": "42", "code": "setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (8, 'test@gmail.com', 'MScoI7yzI/DeLpSpHgGYrqsCCCD5koaMdedI0RHQ5VU=', '$2a$10$m8.ddAaEzozHH7vn7JTwDead9wZZqxg6VvNcqWBUadOUl1DZpAB.O', 'ePSP1E3ZsdGb7Lo4buPubw==', NULL, 13, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[]');
INSERT INTO public.erp_users VALUES (154, '7778013729@mail.ru', '1ElflKrgmXSRpZ1XU8vA2Xa5/IhSoUmYvx0HDTS2DHR3BfD7u9Y/5QRyAoK97uoS', '$2a$10$uqirsaUX1RR0iQZLzH8IE.de51L41jv43pn3PBkXdLNscpOaFwXZe', 'sHBHGdaHzN1XVi3KFUHHYA==', NULL, 131, 'ACTIVE', '[{"id":44,"code":"setting_sales_plan"},{"id":38,"code":"setting_cash_reg"},{"id":34,"code":"setting_whs"},{"id":32,"code":"setting_store"},{"id":52,"code":"setting_scales"},{"id":31,"code":"setting_gen_info"},{"id":46,"code":"setting_supplies"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":42,"code":"setting_portal_user"},{"id":8,"code":"rep_discounts"},{"id":9,"code":"rep_consultants"},{"id":11,"code":"rep_abc_xyz"},{"id":7,"code":"rep_gross_profit"},{"id":12,"code":"rep_debt_book"},{"id":4,"code":"rep_prod_solds"},{"id":6,"code":"rep_team_bonus"},{"id":2,"code":"rep_sales"},{"id":10,"code":"rep_certificates"},{"id":1,"code":"rep_checkout"},{"id":3,"code":"rep_checks"},{"id":13,"code":"rep_buyers"},{"id":5,"code":"rep_single_bonus"},{"id":21,"code":"whs_revision"},{"id":15,"code":"whs_inv_history"},{"id":27,"code":"whs_exp_dates"},{"id":14,"code":"whs_leftovers"},{"id":19,"code":"whs_prod_move"},{"id":23,"code":"whs_holdings"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"}]', '[]');
INSERT INTO public.erp_users VALUES (226, 'test', '4o9UELZmgZyVeketEiOrUA==', '$2a$10$cVtraMXOu/yBoFDpdeRVAut8pp3DHevg8Vgc7eG5KndV5kTSfM7mS', 'wO9hEGEk+701qDxS8XamoA==', NULL, 18, 'ACTIVE', '[{"id":91,"code":"elct_inv_reception"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":93,"code":"elct_inv_attach_eds"},{"id":42,"code":"setting_portal_user"},{"id":38,"code":"setting_cash_reg"},{"id":11,"code":"rep_abc_xyz"},{"id":15,"code":"whs_inv_history"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', '[]');
INSERT INTO public.erp_users VALUES (235, 'r@mail.ru', 'XCopcKy2C/w81ALEFkn3nA==', '$2a$10$pPiZkHzaHtA/kmYVzXNWZeRii.EBoeOx3pau2Mk1Te6t2yFZ7VGAa', 'l+nIDmHHrpT2KzAFqdCsLg==', NULL, 150, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (236, 'r1@mail.ru', 'udg8XANvau6JfdP3scahrg==', '$2a$10$P2d8.iFClWOrhCYVkqLo.OOeSrrvM.hAvuEW6MaZeMtfhCpr18OJO', 'MZx6qSj232OzfVuB2Ov1iQ==', NULL, 151, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (114, 'im3332591@gmail.com', 'hxohb4MwWE1PZvcXldYyBatRTp2l2LiFHh24DEuTZN42t5GL2hMKDyAFaQwfxJc9', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', '3Lqk/dZKTtnpsgTUGhPPSA==', NULL, 112, 'ACTIVE', '[{"id":78,"code":"order_create"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":42,"code":"setting_portal_user"},{"id":38,"code":"setting_cash_reg"},{"id":32,"code":"setting_store"},{"id":52,"code":"setting_scales"},{"id":34,"code":"setting_whs"},{"id":31,"code":"setting_gen_info"},{"id":46,"code":"setting_supplies"},{"id":48,"code":"setting_buyers"},{"id":40,"code":"setting_user_chekout"},{"id":44,"code":"setting_sales_plan"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":64,"code":"contr_barcode_print"},{"id":62,"code":"contr_removefrom_whr"},{"id":57,"code":"contr_newto_whr"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":11,"code":"rep_abc_xyz"},{"id":83,"code":"market_coupons"},{"id":84,"code":"market_gift"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":90,"code":"market_stock"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"},{"id":21,"code":"whs_revision"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"}]', '[]');
INSERT INTO public.erp_users VALUES (237, 'r3@mail.ru', 'Q9Gqw1U/mvaTXZTI46xvJQ==', '$2a$10$QzVHmSC0nEaImR9wlyD1VuqqlS1RIu2MQTbTKt2Zj8FYe0ugBhxmG', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 152, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (238, 'r5@mail.ru', '5aXTH1qiH6SVUthJ/L0ilQ==', '$2a$10$jL3gplJb1RjSgcWTckQ/h.8J2aWYeLRdHJg/P0ThSEzztasXxK8My', 'U88uhYL50HIJK4N0eD04Rw==', NULL, 154, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (241, 'pospro@mail.ru', 'BiL7ZZqOC+T/7SvoGYgIMA==', '$2a$10$sRsmXo5jwYsAOxHppj/f7es4naC4pCoqqSmx.ocDSm9jxgi2j9rTy', 'C8XS9l2plgJ8HEKA6Ky5Bw==', NULL, 157, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (242, 'r90@mail.ru', 'TwhAFuvfFiDUgibr+c4OxgTuf5yZyYpWxR6XFXEfw/c=', '$2a$10$6Efn9a9KpG3nPTcUiMiBUeWC9Iv6NKjtb5nP4KpHbSOP6TAwMSUNy', 'DILhgCH+ioMCpUTBSR5Ycw==', NULL, 158, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (243, 'r45@mail.ru', 'TwhAFuvfFiDUgibr+c4OxlXEvUprmWrekFSQSlBnq6o=', '$2a$10$L8NQKxylXi8IZ86lC3O.EeNd1pcTktDeSPmC.1ociNsyv0jW8j8j2', '30xIpOPCp1QXUmPzVmyPqQ==', NULL, 159, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (171, 'im22290@gmail.com', 'NnN3jbaaR5c62fHBsLsa/w==', '$2a$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'FMuoSUUOjn+r3tx5L14QfQ==', NULL, 112, 'ACTIVE', '[{"id":79,"code":"order_treatment"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":52,"code":"setting_scales"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"},{"id":11,"code":"rep_abc_xyz"}]', '[]');
INSERT INTO public.erp_users VALUES (210, 'psabitb12ek@magnumtech.kz', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$8tJJm30HphFO8LRIYLLTe.hCwOIs/YvnvFphHZPKmZPoIjOTKS9s.', '7hRV4/HCTMbMi++Bql8Vgw==', NULL, 18, 'DISMISS', '[{"id":3,"code":"rep_checks","name":"Чеки"},{"id":4,"code":"rep_prod_solds","name":"Проданные товары"}]', '[]');
INSERT INTO public.erp_users VALUES (248, 'fg5@mail.ru', 'ttmijQvDDyNimYnYikNWrQ==', '$2a$10$TYIujEvXzfH6KGyqHHNxhO8Cxz/5H4qgbl.vHdGhHH73aPSNSqVR.', 'GrgR35Tx6Xo/Hw4HSlQD3A==', NULL, 161, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (249, 'g89@mail.ru', 'utCtGRaTNDRdDeGKytOqNw==', '$2a$10$8wjW.Z.R6SMN7ftIfdOPTugk1H4kQcOlWoqap49d3UM4ge7.OSHtu', '+QpN2dhWLdCMayhWE0dw7Q==', NULL, 162, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (250, 'h789@mail.ru', 'QYNSOO7P22dWrM93lkJA+Q==', '$2a$10$wvnpkfY/YS5NWcyyayTOaeKuXZgo17P2hBQXJ9QtHFquB0PeUj1Re', '3hQ0DnAgBNQE09SAxLr9BQ==', NULL, 163, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (252, 'h7894@mail.ru', 'pUPNxl+McVVnNDqNQY85mw==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'WJm8Ok7oCtRFIM+Pz8ZLgQ==', NULL, 165, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (125, 'jews@post.is', 'SLQmxHOuZlH4X7hY3tk5BUr/+ZRHgQh3/QC0QosveH8=', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'XdU5Qa6XoSHE5/tH+t7TYg==', NULL, 122, 'ACTIVE', '[{"id":78,"code":"order_create"},{"id":77,"code":"price_marginal"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":91,"code":"elct_inv_reception"},{"id":44,"code":"setting_sales_plan"},{"id":38,"code":"setting_cash_reg"},{"id":34,"code":"setting_whs"},{"id":32,"code":"setting_store"},{"id":52,"code":"setting_scales"},{"id":31,"code":"setting_gen_info"},{"id":46,"code":"setting_supplies"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":42,"code":"setting_portal_user"},{"id":8,"code":"rep_discounts"},{"id":9,"code":"rep_consultants"},{"id":11,"code":"rep_abc_xyz"},{"id":7,"code":"rep_gross_profit"},{"id":12,"code":"rep_debt_book"},{"id":4,"code":"rep_prod_solds"},{"id":6,"code":"rep_team_bonus"},{"id":2,"code":"rep_sales"},{"id":10,"code":"rep_certificates"},{"id":1,"code":"rep_checkout"},{"id":3,"code":"rep_checks"},{"id":13,"code":"rep_buyers"},{"id":5,"code":"rep_single_bonus"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":83,"code":"market_coupons"},{"id":84,"code":"market_gift"},{"id":21,"code":"whs_revision"},{"id":15,"code":"whs_inv_history"},{"id":27,"code":"whs_exp_dates"},{"id":14,"code":"whs_leftovers"},{"id":19,"code":"whs_prod_move"},{"id":23,"code":"whs_holdings"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]', '[]');
INSERT INTO public.erp_users VALUES (255, 'bnm234@mail.ru', 'GwSvWumX0h1nUCRvNleEjw==', '$2a$10$iWo4fkp8cfp3.yk6IO7haeaa69eUayrzwrghxFE6/89y8s.5z9JDG', 'vnk7zZGSJhC6oEzjGanIng==', NULL, 167, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (256, 'с34@mail.ru', 'sE7LDxv3Th8OrQutJ68bdQ==', '$2a$10$sJVBbYFfSFMiyVSy1zy.M.xrN/IQPt4oFntS4SIlYgkR0z4gQDpI6', 'iOHOE6i++6BDV+iTrOHGpA==', NULL, 169, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (257, 'vb7843@mail.ru', 'vtwhcPxGZ/67aOFFL5qb0A==', '$2a$10$B88pjW9T1m80lQ8BPiHpj.7y6dQvXvmcH9A6AZOKsJGoBQ5YwX6ru', 'XYNkDZeHDbDV03VVBfA1SQ==', NULL, 171, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (208, 'psabitbek12qwd@magnumtech.kz', 'SpOPSc+emP8AtnYZ189SjwnV6PLghFy5hKVgibaINcQ=', '$2a$10$N1wyowQdoV7/4kwRhZCd/evCeFq.vXiymWQo3tKou.H1rPdPGxCDa', '55ZgmWIEKnHgoXDjjfaqtg==', NULL, 18, 'ACTIVE', '[{"id":4,"code":"rep_prod_solds","name":"Проданные товары"},{"id":3,"code":"rep_checks","name":"Чеки"}]', '[]');
INSERT INTO public.erp_users VALUES (254, 'пр78@mail.ru', 'Rvwf9ScPTcQK2Zlz7+aS+Q==', '$2a$10$4FsviMVlgDPeo1KyN1eaEuQedY470jglZMMSbDUjIqF9avSJT85Sq', 'WJm8Ok7oCtRFIM+Pz8ZLgQ==', NULL, 18, 'ACTIVE', '[{"id":75,"code":"price_wizard","name":"Мастер ценообразования"},{"id":90,"code":"market_stock","name":"Акции"},{"id":21,"code":"whs_revision","name":"Ревизия"},{"id":29,"code":"whs_reconciliation","name":"Сверка"},{"id":95,"code":"order_weight_prod","name":"Привязка весовых товаров"}]', '[]');
INSERT INTO public.erp_users VALUES (253, 'm890@mail.ru', 'KxgTLqIagmFySh8DeUk9bw==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'dY0MMr9o5POa2A5Xn4pBlw==', NULL, 166, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (282, 'апапр99@mail.ru', 'Ywp46NhHpB0OfbDMZmy/sA==', '$2a$10$kv3mw4uGWw26JZi3fG8s1e4dYCKP7Yd/6y366GiiFBJEtv0OOOMny', 'nEAM7jqQFFO11pOPuZyOWA==', NULL, 18, 'DISMISS', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (260, 'ф201378@mail.ru', 'E/Trh3CZkOEaNpcVWUkrJg==', '$2a$10$G5jFgDREs6TLQvJ8U8zeselIFvWPmpr89za1s3kJ6UdrHatN1EEPe', 'gy2krtMukw9m/JmFyxqEPw==', NULL, 18, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (91, 'tester', '3qbc826GvLuZ6X0MIFkR6Gpig1mFECUKg39yuRkWDFk=', '$2a$10$ck86vpJ56OX0ted0WttHEulLKt1ZTCjc0GJWCfgdAEiCPL9Pi9rii', 'w+foAaKv9MKnOG91O98QGA==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":6,"code":"rep_team_bonus","name":"Командный бонус"},{"id":1,"code":"rep_checkout","name":"Отчет по кассам"},{"id":5,"code":"rep_single_bonus","name":"Индивидуальный бонус"},{"id":3,"code":"rep_checks","name":"Чеки"},{"id":90,"code":"market_stock","name":"Акции"},{"id":86,"code":"market_bonuses","name":"Бонусы"},{"id":83,"code":"market_coupons","name":"Купоны"},{"id":88,"code":"market_create_discount","name":"Создание скидок"},{"id":84,"code":"market_gift","name":"Подарочные сертификаты"},{"id":15,"code":"whs_inv_history","name":"История по накладным"},{"id":19,"code":"whs_prod_move","name":"Движение товара"},{"id":14,"code":"whs_leftovers","name":"Остаток на складе"},{"id":29,"code":"whs_reconciliation","name":"Сверка"},{"id":25,"code":"whs_consignment","name":"Консигнация"},{"id":10,"code":"rep_certificates","name":"Сертификаты"},{"id":91,"code":"elct_inv_reception","name":"Прием"},{"id":34,"code":"setting_whs","name":"Склад"},{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":32,"code":"setting_store","name":"Торговая точка"},{"id":52,"code":"setting_scales","name":"Весы"},{"id":31,"code":"setting_gen_info","name":"Общая информация"},{"id":4,"code":"rep_prod_solds","name":"Проданные товары"}]', '[]');
INSERT INTO public.erp_users VALUES (120, 'zxc', 'bj/2QaAy6+rxUQlt9czPCQ==', '$2a$10$BvpGHAfBZJsaWjWWMdFHU.f/iItk3NYBxEaA4yIHweXdFyIriJ.Hy', 'cVyPTJBXN4cQnYM1dLlJrg==', NULL, 18, 'ACTIVE', '[{"id":52,"code":"setting_scales","name":"Весы"},{"id":74,"code":"price_change","name":"Изменение цен"},{"id":77,"code":"price_marginal","name":"Предельные цены"},{"id":78,"code":"order_create","name":"Создание"},{"id":42,"code":"setting_portal_user","name":"Пользователи портала"},{"id":91,"code":"elct_inv_reception","name":"Прием"},{"id":46,"code":"setting_supplies","name":"Поставщики"},{"id":81,"code":"order_receipt","name":"Прием товаров по наряд-заказу"},{"id":95,"code":"order_weight_prod","name":"Привязка весовых товаров"},{"id":79,"code":"order_treatment","name":"Обработка"},{"id":48,"code":"setting_buyers","name":"Покупатели юр. лица"},{"id":14,"code":"whs_leftovers","name":"Остаток на складе"},{"id":84,"code":"market_gift","name":"Подарочные сертификаты"},{"id":83,"code":"market_coupons","name":"Купоны"},{"id":88,"code":"market_create_discount","name":"Создание скидок"},{"id":86,"code":"market_bonuses","name":"Бонусы"},{"id":90,"code":"market_stock","name":"Акции"},{"id":64,"code":"contr_barcode_print","name":"Печать штрих кода"},{"id":62,"code":"contr_removefrom_whr","name":"Списание товара со склада"},{"id":57,"code":"contr_newto_whr","name":"Прием нового товара на склад"},{"id":72,"code":"contr_reconciliation","name":"Сверка"},{"id":70,"code":"contr_nomenclature","name":"Номенклатура"},{"id":68,"code":"contr_weigh_prod","name":"Весовые товары"},{"id":66,"code":"contr_revision","name":"Ревизия"},{"id":60,"code":"contr_move_between","name":"Перемещение между складами"},{"id":56,"code":"contr_prod_new_whr","name":"Управление товарами"},{"id":56,"code":"contr_prod_new_whr","name":"Управление товарами"},{"id":44,"code":"setting_sales_plan","name":"План продаж"},{"id":38,"code":"setting_cash_reg","name":"Касса"},{"id":34,"code":"setting_whs","name":"Склад"},{"id":32,"code":"setting_store","name":"Торговая точка"},{"id":31,"code":"setting_gen_info","name":"Общая информация"},{"id":94,"code":"elct_inv_report","name":"Отчет"},{"id":92,"code":"elct_inv_broadcast","name":"Передача"},{"id":93,"code":"elct_inv_attach_eds","name":"Прикрепить ЭЦП"},{"id":75,"code":"price_wizard","name":"Мастер ценообразования"},{"id":40,"code":"setting_user_chekout","name":"Пользователи касс"}]', '[]');
INSERT INTO public.erp_users VALUES (262, 'ф201379@mail.ru', 'Il62H8g7+Skmoh5ibG3EWQ==', '$2a$10$k4b1kwGI.1GseRrYw88uL.VdMM//6e6ksiaRM7yinJiczqN8Hcbba', 'ri/1d6AThyMdMCAMcHLaYw==', NULL, 18, 'ACTIVE', '[]', '[]');
INSERT INTO public.erp_users VALUES (265, 'ф20137977558@mail.ru', 'AfeeRjYBqhcUPCvHXqIreOBNds6Ue0nzpXrBI7pM/RE=', '$2a$10$AE8ShsY77Aj.fYIqQcbI4eMoq9IOR8iUXGRT6TtRxkGX73UfMX/Mq', 'RL0gl0miisJXoHmJmjBOxA==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":2,"code":"setting_user_chekout","category":"Пользователи","name":"Пользователи касс"}]');
INSERT INTO public.erp_users VALUES (266, 'ф201379778@mail.ru', '/ygZfDp1OkPaaWzJlLfyMw==', '$2a$10$tMrgKdQz9MlEDpw7Nu9l5uM7pJ5tsuh6bSaJeGOFyHvgO0TwYnIcq', 'kyllodPPGjEdPKtRvSvwkg==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":1,"code":"setting_portal_user","category":"Пользователи","name":"Пользователи программы"},{"id":2,"code":"setting_user_chekout","category":"Пользователи","name":"Пользователи касс"}]');
INSERT INTO public.erp_users VALUES (263, 'ф20137977@mail.ru', 'MOZASVe2Zoaun0dxk/IIPQ==', '$2a$10$zLOd.LvnrLD0RcNooY9fFeRdAEY24tSLI.atIp72LdzPz80zaH8nu', 'KQl3zHpb8Te2ybN8qOSpEw==', NULL, 18, 'DISMISS', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (281, 'werwewe@mail.ru', '+WUXdNjOTASLLe6BwS2Hbg==', '$2a$10$xNESZR6vxnnw2cFaB0HVA.5POX2TRnRGqWkSlZu2LlfyQmG2G/Vg2', 'SOdg23hg2iD67kLe7/mJlQ==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (267, 'ф2013797733@mail.ru', 'rxYfhhPXnHBK8PsoEmW3IA==', '$2a$10$21x2Lq9YxAeAaI.KfxSB6uN1Ex1L2llXgkCo69iLrkK7tQ75V75Aq', '+oMq5akS4DgTUarNzIPPDg==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":3,"code":"setting_sales_plan","name":"План продаж"}]');
INSERT INTO public.erp_users VALUES (274, 'dsfh@mail.ru', 'G9zt704iF4ftVqwf07HVjw==', '$2a$10$CSDLjUyPX5LpCH/kFh8FUe/rJIihggsfHATqy8lnGKfYAR8p9.scq', 'yL5d5wwgoFr8/W90klZXxA==', NULL, 182, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (268, 'фыва1@mail.ru', 'FTXv8ApvB0gO6rznWX0baA==', '$2a$10$JrjFDsH1EIZvHaP1drGd5.uCRhhn9DaE4BPpsMuyA9vj1VQefjU/2', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 172, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (270, 'фыва12@mail.ru', 'FTXv8ApvB0gO6rznWX0baA==', '$2a$10$MBY0JIH7V8iwSIl1GPSFYectV34Y0Y9uIN30CyKM1r3w7Uh0RJ1Rq', 'SCAostq0vP3Nkm5Qjykw8A==', NULL, 176, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (271, 'цуке1@mail.ru', '99vAIE21fDeTezcQowzGbQ==', '$2a$10$ENk3B29fnupfAbqy4bOpsuvZR5X5D.yqKw/QvLtHzV5YFpB5Hp2iW', 'yB0wy6Ml8NaqWEJIyJcekA==', NULL, 178, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (272, 'wqeqwe@mail.ru', 'TofVfwBAamK5BA6wm2j8cA==', '$2a$10$G4DPLz12TEnMSj24HkcLhuMVhZzpA9pqP8IvGaJWAd.bmE5aWcklq', 'qzYD6xW6FsUfq6GzuNGNDw==', NULL, 179, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (276, 'qwerr@mail.ru', '/7jOORQftelbG3UCfdVbmw==', '$2a$10$rtAO7c3l033gVCJ33.lB.OWPu4snh0aszNA94EZrSBEf1vmUMjfiW', 'Tk5XmciJuqVAdb6OKflRHA==', NULL, 184, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":11,"code":"price_change","name":"Изменение цен"},{"id":12,"code":"price_wizard","name":"Мастер ценообразования"},{"id":13,"code":"price_marginal","name":"Предельные цены"},{"id":1,"code":"setting_portal_user","name":"Пользователи программы"},{"id":2,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":3,"code":"setting_sales_plan","name":"План продаж"},{"id":19,"code":"contr_newto_whr","name":"Прием товара"},{"id":20,"code":"contr_move_between","name":"Перемещение товара"},{"id":21,"code":"contr_removefrom_whr","name":"Списание товара"},{"id":22,"code":"contr_barcode_print","name":"Печать штрих кода"},{"id":23,"code":"contr_weigh_prod","name":"Весовые товары"},{"id":24,"code":"contr_nomenclature","name":"Товар"},{"id":26,"code":"contr_revision","name":"Ревизия"},{"id":25,"code":"contr_reconciliation","name":"Наряд-заказ"},{"id":4,"code":"setting_supplies","name":"Поставщики"},{"id":5,"code":"setting_buyers","name":"Покупатели юр.лица"},{"id":6,"code":"setting_buyers_fiz","name":"Покупатели физ.лица"},{"id":7,"code":"setting_whs","name":"Склад"},{"id":8,"code":"setting_store","name":"Торговая точка"},{"id":9,"code":"setting_cash_reg","name":"Кассы"},{"id":10,"code":"setting_scales","name":"Весы"},{"id":14,"code":"market_coupons","name":"Купоны"},{"id":15,"code":"market_gift","name":"Подарочные сертификаты"},{"id":16,"code":"market_bonuses","name":"Бонусы"},{"id":17,"code":"market_create_discount","name":"Создание скидок"},{"id":18,"code":"market_stock","name":"Акции"}]');
INSERT INTO public.erp_users VALUES (275, 'eewrw@mail.ru', '8ZTo/MpQC/PWKcaZs740Eg==', '$2a$10$S9R.65r3HSetZxcFPd0RVOGYU1NkuvVcYdJeURSnuGiocyDjqd5Ae', '4OaMy9PT9iIdQzat6wSJNw==', NULL, 183, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[]');
INSERT INTO public.erp_users VALUES (273, 'testdemo@mail.ru', 'UvQIBnQE3b7ZGviKbPoP8YFVy6EhJ6oi210K/B/SlkQ=', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'xdfcsdAkGoCvpZYOLklyig==', NULL, 181, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":11,"code":"price_change","name":"Изменение цен"},{"id":12,"code":"price_wizard","name":"Мастер ценообразования"},{"id":13,"code":"price_marginal","name":"Предельные цены"},{"id":1,"code":"setting_portal_user","name":"Пользователи программы"},{"id":2,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":3,"code":"setting_sales_plan","name":"План продаж"},{"id":19,"code":"contr_newto_whr","name":"Прием товара"},{"id":20,"code":"contr_move_between","name":"Перемещение товара"},{"id":21,"code":"contr_removefrom_whr","name":"Списание товара"},{"id":22,"code":"contr_barcode_print","name":"Печать штрих кода"},{"id":23,"code":"contr_weigh_prod","name":"Весовые товары"},{"id":24,"code":"contr_nomenclature","name":"Товар"},{"id":26,"code":"contr_revision","name":"Ревизия"},{"id":25,"code":"contr_reconciliation","name":"Наряд-заказ"},{"id":4,"code":"setting_supplies","name":"Поставщики"},{"id":5,"code":"setting_buyers","name":"Покупатели юр.лица"},{"id":6,"code":"setting_buyers_fiz","name":"Покупатели физ.лица"},{"id":7,"code":"setting_whs","name":"Склад"},{"id":8,"code":"setting_store","name":"Торговая точка"},{"id":9,"code":"setting_cash_reg","name":"Кассы"},{"id":10,"code":"setting_scales","name":"Весы"},{"id":14,"code":"market_coupons","name":"Купоны"},{"id":15,"code":"market_gift","name":"Подарочные сертификаты"},{"id":16,"code":"market_bonuses","name":"Бонусы"},{"id":17,"code":"market_create_discount","name":"Создание скидок"},{"id":18,"code":"market_stock","name":"Акции"}]');
INSERT INTO public.erp_users VALUES (0, 'admin', 'SLQmxHOuZlH4X7hY3tk5BZWhjDAqOIdHA5QecILfyNk=', '$2a$10$EQOiMcGDFB21WfByvcghlODLYkc957UvChxlitMEUi7UYtLSS2AcG', 'nlouC9ngqZz8rv7EdLS9mw==', NULL, 18, 'ACTIVE', '[{"id":"42","code":"setting_portal_user"}]', '[{"id":11,"code":"price_change","name":"Изменение цен"},{"id":12,"code":"price_wizard","name":"Мастер ценообразования"},{"id":13,"code":"price_marginal","name":"Предельные цены"},{"id":1,"code":"setting_portal_user","name":"Пользователи программы"},{"id":2,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":3,"code":"setting_sales_plan","name":"План продаж"},{"id":19,"code":"contr_newto_whr","name":"Прием товара"},{"id":20,"code":"contr_move_between","name":"Перемещение товара"},{"id":21,"code":"contr_removefrom_whr","name":"Списание товара"},{"id":22,"code":"contr_barcode_print","name":"Печать штрих кода"},{"id":23,"code":"contr_weigh_prod","name":"Весовые товары"},{"id":24,"code":"contr_nomenclature","name":"Товар"},{"id":26,"code":"contr_revision","name":"Ревизия"},{"id":25,"code":"contr_reconciliation","name":"Наряд-заказ"},{"id":4,"code":"setting_supplies","name":"Поставщики"},{"id":5,"code":"setting_buyers","name":"Покупатели юр.лица"},{"id":6,"code":"setting_buyers_fiz","name":"Покупатели физ.лица"},{"id":7,"code":"setting_whs","name":"Склад"},{"id":8,"code":"setting_store","name":"Торговая точка"},{"id":9,"code":"setting_cash_reg","name":"Кассы"},{"id":10,"code":"setting_scales","name":"Весы"},{"id":14,"code":"market_coupons","name":"Купоны"},{"id":15,"code":"market_gift","name":"Подарочные сертификаты"},{"id":16,"code":"market_bonuses","name":"Бонусы"},{"id":17,"code":"market_create_discount","name":"Создание скидок"},{"id":18,"code":"market_stock","name":"Акции"}]');
INSERT INTO public.erp_users VALUES (277, 'dsfdsfh@mail.ru', '6Tuxv59p3KRr9au7kpI47w==', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', '9EsdVYqcSnGdUdYU5Kz3eA==', NULL, 185, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":11,"code":"price_change","name":"Изменение цен"},{"id":12,"code":"price_wizard","name":"Мастер ценообразования"},{"id":13,"code":"price_marginal","name":"Предельные цены"},{"id":1,"code":"setting_portal_user","name":"Пользователи программы"},{"id":2,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":3,"code":"setting_sales_plan","name":"План продаж"},{"id":19,"code":"contr_newto_whr","name":"Прием товара"},{"id":20,"code":"contr_move_between","name":"Перемещение товара"},{"id":21,"code":"contr_removefrom_whr","name":"Списание товара"},{"id":22,"code":"contr_barcode_print","name":"Печать штрих кода"},{"id":23,"code":"contr_weigh_prod","name":"Весовые товары"},{"id":24,"code":"contr_nomenclature","name":"Товар"},{"id":26,"code":"contr_revision","name":"Ревизия"},{"id":25,"code":"contr_reconciliation","name":"Наряд-заказ"},{"id":4,"code":"setting_supplies","name":"Поставщики"},{"id":5,"code":"setting_buyers","name":"Покупатели юр.лица"},{"id":6,"code":"setting_buyers_fiz","name":"Покупатели физ.лица"},{"id":7,"code":"setting_whs","name":"Склад"},{"id":8,"code":"setting_store","name":"Торговая точка"},{"id":9,"code":"setting_cash_reg","name":"Кассы"},{"id":10,"code":"setting_scales","name":"Весы"},{"id":14,"code":"market_coupons","name":"Купоны"},{"id":15,"code":"market_gift","name":"Подарочные сертификаты"},{"id":16,"code":"market_bonuses","name":"Бонусы"},{"id":17,"code":"market_create_discount","name":"Создание скидок"},{"id":18,"code":"market_stock","name":"Акции"}]');
INSERT INTO public.erp_users VALUES (280, 'undefined', 'dmD50ikq1YxJWMU1pqxUYhRIq8YhkVOqhkk7ZJrv2Rg=', '$2a$10$9NUlTwZyzFlpo1lf4W8VleUyoZX7fvfPm65jSskKfr2btrxX5ZqnK', 'W8LJzc/fuG1tIAppwqUplQ==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (283, 'dffdgdf4@mail.ru', '8cNuep1h2vBZfx3L7hPBqw==', '$2a$10$ASiGZ6uLgSU8VQ88Jz7AzuC85zBNL1mbpYaM38D1/x2sxChUah5QK', 'PR2ibaPzzFL4ZYxCS0b6zA==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (284, 'йцук@mail.tu', 'CLjrYC68c86qcVRfuuI0Ie3HLVwue1MI2/8Qpwx3dnM=', '$2a$10$JkhaMJqfug602bnyL5xn7eTw58wK4dMegmfVy572/BL7vw3vmU8V6', 'ry1fPExNh1otvKXnk0fYFw==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (9, 'test-1@gmail.com', 'J2j7CUrAMiC1ak/L7ZsZwQ==', '$2a$10$aHuoWbRnKvB4uc7lcb9rdui6jxSkbbhMV.CDIYxMH2M3yHWHlZsOC', 'PWIIQmXwmL7RRbg+ATMpGg==', NULL, 14, 'ACTIVE', '[]', '[{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (285, 'апвпвап99@mail.ru', 'mT6E5DwBcwtSK4GWSuHneQ==', '$2a$10$TrEUkXEvv0H0ryEqEq6k2uu6hxM3OstwZFdnse7EQPO5FeQN2lKie', 'gA3J89yHsAKk8rlKGxjRsA==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (286, 'qaz11@mail.ru', 'hPbsINjkrl4OPY1yx7KEwg==', '$2a$10$i1XCY4M/BuYlDmOSHnPhIO7xYWRVXk1kz/NIk9vZxl6AutHfk60F6', 'dmb8maJPVSOdzdWpZDP9NQ==', NULL, 18, 'DISMISS', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (287, 'qaz22@mail.ru', '9a79KDeNJqpjI1n4dLIz82rFpRHJ+HxSZcYQXe7Y7b4=', '$2a$10$./A4PvmzL67iTpg8fjELgOITvANXOuNBVir0gnFU63RW6lKf54wrO', 'M7YDZhKslt4Jo2gXc+21+g==', NULL, 18, 'ACTIVE', '[{"id":42,"code":"setting_portal_user"}]', '[{"id":"15","code":"whs_inv_history"},{"id":"42","code":"setting_portal_user"},{"id":"3","code":"rep_checks"},{"id":"4","code":"rep_prod_solds"},{"id":"5","code":"rep_single_bonus"},{"id":"6","code":"rep_team_bonus"},{"id":"1","code":"rep_checkout"},{"id":"7","code":"rep_gross_profit"},{"id":"9","code":"rep_consultants"},{"id":"10","code":"rep_certificates"},{"id":"11","code":"rep_abc_xyz"},{"id":"12","code":"rep_debt_book"},{"id":"8","code":"rep_discounts"},{"id":"13","code":"rep_buyers"},{"id":"2","code":"rep_sales"},{"id":"40","code":"setting_user_chekout"},{"id":"44","code":"setting_sales_plan"},{"id":"46","code":"setting_supplies"},{"id":"48","code":"setting_buyers"},{"id":"31","code":"setting_gen_info"},{"id":"32","code":"setting_store"},{"id":"34","code":"setting_whs"},{"id":"38","code":"setting_cash_reg"},{"id":"52","code":"setting_scales"},{"id":"14","code":"whs_leftovers"},{"id":"19","code":"whs_prod_move"},{"id":"23","code":"whs_holdings"},{"id":"25","code":"whs_consignment"},{"id":"27","code":"whs_exp_dates"},{"id":"29","code":"whs_reconciliation"},{"id":"21","code":"whs_revision"},{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":62,"code":"contr_removefrom_whr"},{"id":64,"code":"contr_barcode_print"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"}]');
INSERT INTO public.erp_users VALUES (42, 'demo', 'LqYI8o7pnL7VxbgvTS56iOWDChlJF/CO5sbQe59VOGPoF0PI6aAQpmSxfxNybcOD', '$2a$10$zKCvTObtPuRnDlUKDBw27uPvmI/hRauU8eag6sFSf3VYCRrcWA7SW', 'nlouC9ngqZz8rv7EdLS9mw==', NULL, 18, 'ACTIVE', '[{"id":78,"code":"order_create"},{"id":79,"code":"order_treatment"},{"id":95,"code":"order_weight_prod"},{"id":81,"code":"order_receipt"},{"id":75,"code":"price_wizard"},{"id":74,"code":"price_change"},{"id":77,"code":"price_marginal"},{"id":92,"code":"elct_inv_broadcast"},{"id":92,"code":"elct_inv_broadcast"},{"id":94,"code":"elct_inv_report"},{"id":91,"code":"elct_inv_reception"},{"id":93,"code":"elct_inv_attach_eds"},{"id":42,"code":"setting_portal_user"},{"id":44,"code":"setting_sales_plan"},{"id":40,"code":"setting_user_chekout"},{"id":48,"code":"setting_buyers"},{"id":46,"code":"setting_supplies"},{"id":42,"code":"setting_portal_user"},{"id":31,"code":"setting_gen_info"},{"id":34,"code":"setting_whs"},{"id":52,"code":"setting_scales"},{"id":32,"code":"setting_store"},{"id":38,"code":"setting_cash_reg"},{"id":56,"code":"contr_prod_new_whr"},{"id":56,"code":"contr_prod_new_whr"},{"id":60,"code":"contr_move_between"},{"id":66,"code":"contr_revision"},{"id":68,"code":"contr_weigh_prod"},{"id":70,"code":"contr_nomenclature"},{"id":72,"code":"contr_reconciliation"},{"id":57,"code":"contr_newto_whr"},{"id":64,"code":"contr_barcode_print"},{"id":62,"code":"contr_removefrom_whr"},{"id":83,"code":"market_coupons"},{"id":90,"code":"market_stock"},{"id":86,"code":"market_bonuses"},{"id":88,"code":"market_create_discount"},{"id":84,"code":"market_gift"},{"id":14,"code":"whs_leftovers"},{"id":15,"code":"whs_inv_history"},{"id":19,"code":"whs_prod_move"},{"id":21,"code":"whs_revision"},{"id":23,"code":"whs_holdings"},{"id":27,"code":"whs_exp_dates"},{"id":29,"code":"whs_reconciliation"},{"id":25,"code":"whs_consignment"},{"id":99,"code":"whs_prod_period"},{"id":6,"code":"rep_team_bonus"},{"id":4,"code":"rep_prod_solds"},{"id":1,"code":"rep_checkout"},{"id":7,"code":"rep_gross_profit"},{"id":9,"code":"rep_consultants"},{"id":10,"code":"rep_certificates"},{"id":11,"code":"rep_abc_xyz"},{"id":12,"code":"rep_debt_book"},{"id":13,"code":"rep_buyers"},{"id":2,"code":"rep_sales"},{"id":3,"code":"rep_checks"},{"id":5,"code":"rep_single_bonus"},{"id":8,"code":"rep_discounts"},{"id":101,"code":"rep_illiquid_products"}]', '[{"id":11,"code":"price_change","name":"Изменение цен"},{"id":12,"code":"price_wizard","name":"Мастер ценообразования"},{"id":13,"code":"price_marginal","name":"Предельные цены"},{"id":1,"code":"setting_portal_user","name":"Пользователи программы"},{"id":2,"code":"setting_user_chekout","name":"Пользователи касс"},{"id":3,"code":"setting_sales_plan","name":"План продаж"},{"id":19,"code":"contr_newto_whr","name":"Прием товара"},{"id":20,"code":"contr_move_between","name":"Перемещение товара"},{"id":21,"code":"contr_removefrom_whr","name":"Списание товара"},{"id":22,"code":"contr_barcode_print","name":"Печать штрих кода"},{"id":23,"code":"contr_weigh_prod","name":"Весовые товары"},{"id":24,"code":"contr_nomenclature","name":"Товар"},{"id":26,"code":"contr_revision","name":"Ревизия"},{"id":25,"code":"contr_reconciliation","name":"Наряд-заказ"},{"id":4,"code":"setting_supplies","name":"Поставщики"},{"id":5,"code":"setting_buyers","name":"Покупатели юр.лица"},{"id":6,"code":"setting_buyers_fiz","name":"Покупатели физ.лица"},{"id":7,"code":"setting_whs","name":"Склад"},{"id":8,"code":"setting_store","name":"Торговая точка"},{"id":9,"code":"setting_cash_reg","name":"Кассы"},{"id":10,"code":"setting_scales","name":"Весы"},{"id":14,"code":"market_coupons","name":"Купоны"},{"id":15,"code":"market_gift","name":"Подарочные сертификаты"},{"id":16,"code":"market_bonuses","name":"Бонусы"},{"id":17,"code":"market_create_discount","name":"Создание скидок"},{"id":18,"code":"market_stock","name":"Акции"},{"id":27,"code":"rep_checks","name":"Чеки"}]');
INSERT INTO public.erp_users VALUES (48, '11111122213', 'gHNnD3UhX+UZMwncFm8sOw==', '$2a$10$590ShdDKBBRn7mNYglQOHOXQ4yzGAlgUigEM8sO0VtoqoLREPkTaC', 'gHNnD3UhX+UZMwncFm8sOw==', NULL, 28, 'ACTIVE', '[{"id": "8", "code": "rep_discounts"}, {"id": "9", "code": "rep_consultants"}, {"id": "44", "code": "setting_sales_plan"}, {"id": "11", "code": "rep_abc_xyz"}, {"id": "7", "code": "rep_gross_profit"}, {"id": "21", "code": "whs_revision"}, {"id": "38", "code": "setting_cash_reg"}, {"id": "34", "code": "setting_whs"}, {"id": "32", "code": "setting_store"}, {"id": "15", "code": "whs_inv_history"}, {"id": "52", "code": "setting_scales"}, {"id": "27", "code": "whs_exp_dates"}, {"id": "12", "code": "rep_debt_book"}, {"id": "4", "code": "rep_prod_solds"}, {"id": "31", "code": "setting_gen_info"}, {"id": "6", "code": "rep_team_bonus"}, {"id": "2", "code": "rep_sales"}, {"id": "10", "code": "rep_certificates"}, {"id": "14", "code": "whs_leftovers"}, {"id": "1", "code": "rep_checkout"}, {"id": "46", "code": "setting_supplies"}, {"id": "3", "code": "rep_checks"}, {"id": "13", "code": "rep_buyers"}, {"id": "40", "code": "setting_user_chekout"}, {"id": "19", "code": "whs_prod_move"}, {"id": "23", "code": "whs_holdings"}, {"id": "48", "code": "setting_buyers"}, {"id": "5", "code": "rep_single_bonus"}, {"id": "29", "code": "whs_reconciliation"}, {"id": "42", "code": "setting_portal_user"}, {"id": "25", "code": "whs_consignment"}]', '[{"id":1,"code":"setting_portal_user"},{"id":2,"code":"setting_user_chekout"},{"id":3,"code":"setting_sales_plan"},{"id":19,"code":"contr_newto_whr"},{"id":20,"code":"contr_move_between"},{"id":21,"code":"contr_removefrom_whr"},{"id":22,"code":"contr_barcode_print"},{"id":23,"code":"contr_weigh_prod"},{"id":24,"code":"contr_nomenclature"},{"id":26,"code":"contr_revision"},{"id":25,"code":"contr_reconciliation"},{"id":4,"code":"setting_supplies"},{"id":5,"code":"setting_buyers"},{"id":6,"code":"setting_buyers_fiz"},{"id":7,"code":"setting_whs"},{"id":8,"code":"setting_store"},{"id":9,"code":"setting_cash_reg"},{"id":10,"code":"setting_scales"},{"id":14,"code":"market_coupons"},{"id":15,"code":"market_gift"},{"id":16,"code":"market_bonuses"},{"id":17,"code":"market_create_discount"},{"id":18,"code":"market_stock"},{"id":27,"code":"rep_checks"}]');


--
-- TOC entry 5834 (class 0 OID 16990)
-- Dependencies: 291
-- Data for Name: esf; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5835 (class 0 OID 17003)
-- Dependencies: 292
-- Data for Name: esf_details; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5837 (class 0 OID 17013)
-- Dependencies: 294
-- Data for Name: esf_errors; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5839 (class 0 OID 17022)
-- Dependencies: 296
-- Data for Name: esf_statuses; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5841 (class 0 OID 17031)
-- Dependencies: 298
-- Data for Name: expdate_discount; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.expdate_discount VALUES (1, 18, 1, 4, 1, 2, false, 0, 0);
INSERT INTO public.expdate_discount VALUES (2, 18, 1, 5, 2, 11, true, 0, 0);


--
-- TOC entry 5842 (class 0 OID 17041)
-- Dependencies: 299
-- Data for Name: fiz_customers; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.fiz_customers VALUES (1, '45646545', 'ljklkl', 'sdf', 18, 0, false);
INSERT INTO public.fiz_customers VALUES (2, '789090', 'zxcvb', 'qwer2277', 18, 0, true);


--
-- TOC entry 5843 (class 0 OID 17049)
-- Dependencies: 300
-- Data for Name: format; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.format VALUES ('1', '1');
INSERT INTO public.format VALUES ('SPR', 'Справочники');
INSERT INTO public.format VALUES ('TEXT', 'TEXT');
INSERT INTO public.format VALUES ('DATE', 'DATE');


--
-- TOC entry 5844 (class 0 OID 17055)
-- Dependencies: 301
-- Data for Name: ftpservers; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5845 (class 0 OID 17058)
-- Dependencies: 302
-- Data for Name: gen_class_of_economic_act; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5846 (class 0 OID 17064)
-- Dependencies: 303
-- Data for Name: giftcertificates; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.giftcertificates VALUES (3, 18, 51, '2561', 500, 1, NULL, false, 1, 500, '2025-09-16');
INSERT INTO public.giftcertificates VALUES (4, 18, 52, '2572', 10100, 1, NULL, false, 4, 10100, '2025-09-14');
INSERT INTO public.giftcertificates VALUES (5, 18, 51, '25611', 500, 1, NULL, false, 1, 500, '2025-09-16');
INSERT INTO public.giftcertificates VALUES (6, 18, 52, '25721', 10100, 1, NULL, false, 4, 10100, '2025-09-14');


--
-- TOC entry 5848 (class 0 OID 17071)
-- Dependencies: 305
-- Data for Name: giftcertificates_writeoff_balances; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5850 (class 0 OID 17078)
-- Dependencies: 307
-- Data for Name: giftcertificatesdiary; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.giftcertificatesdiary VALUES (18, '2025-10-03 17:48:43.781413', 1, 3, 500, NULL, NULL, NULL, 0, 2);
INSERT INTO public.giftcertificatesdiary VALUES (18, '2025-10-03 17:48:43.781413', 1, 4, 10100, NULL, NULL, NULL, 0, 3);
INSERT INTO public.giftcertificatesdiary VALUES (18, '2025-10-03 17:52:56.858432', 1, 5, 500, NULL, NULL, NULL, 0, 4);
INSERT INTO public.giftcertificatesdiary VALUES (18, '2025-10-03 17:52:56.858432', 1, 6, 10100, NULL, NULL, NULL, 0, 5);


--
-- TOC entry 5852 (class 0 OID 17084)
-- Dependencies: 309
-- Data for Name: giftcertificatesdiaryreasons; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.giftcertificatesdiaryreasons VALUES (1, 'Причина1', false);
INSERT INTO public.giftcertificatesdiaryreasons VALUES (2, 'Причина2', false);
INSERT INTO public.giftcertificatesdiaryreasons VALUES (3, 'Причина3', false);
INSERT INTO public.giftcertificatesdiaryreasons VALUES (4, 'Причина4', false);
INSERT INTO public.giftcertificatesdiaryreasons VALUES (5, 'Причина5', false);


--
-- TOC entry 5853 (class 0 OID 17088)
-- Dependencies: 310
-- Data for Name: giftcertificatetypes; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.giftcertificatetypes VALUES (1, 'Тип1', false);


--
-- TOC entry 5860 (class 0 OID 17146)
-- Dependencies: 319
-- Data for Name: invoice_object; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5855 (class 0 OID 17094)
-- Dependencies: 312
-- Data for Name: invoicelist; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.invoicelist VALUES (179, 92, 0, 5, 3, 2, true, NULL, 61, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 3, NULL, NULL, NULL, NULL, 189);
INSERT INTO public.invoicelist VALUES (182, 93, 0, 1, 33, 22, true, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 191);
INSERT INTO public.invoicelist VALUES (235, 114, 0, 0, 5, 2, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 3, 0, '[]', NULL, NULL, 340);
INSERT INTO public.invoicelist VALUES (239, 165, 0, 0, 0, 0, true, NULL, NULL, false, NULL, NULL, true, 18, NULL, 0, false, NULL, NULL, '[]', 0, 3, 0, '[]', NULL, NULL, 349);
INSERT INTO public.invoicelist VALUES (285, 22, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 440);
INSERT INTO public.invoicelist VALUES (185, 54, 0, 0, 0, 0, false, NULL, 54, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 199);
INSERT INTO public.invoicelist VALUES (186, 151, 0, 2, 200, 100, true, NULL, 62, false, NULL, NULL, false, 18, 2, 4, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 201);
INSERT INTO public.invoicelist VALUES (188, 152, 0, 1, 200, 100, true, NULL, 63, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 202);
INSERT INTO public.invoicelist VALUES (209, 153, 0, 0, 200, 100, false, NULL, 66, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, 0, '[]', NULL, NULL, 247);
INSERT INTO public.invoicelist VALUES (215, 110, 0, 4, 200, 100, false, NULL, 68, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[{"id":"3","value":"3377"},{"id":"4","value":"синий"}]', 0, 1, NULL, NULL, 0, 0, 255);
INSERT INTO public.invoicelist VALUES (70, 5, 0, 0, 1234, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 52);
INSERT INTO public.invoicelist VALUES (71, 5, 0, 0, 1288, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 53);
INSERT INTO public.invoicelist VALUES (72, 5, 0, 0, 1234, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 54);
INSERT INTO public.invoicelist VALUES (73, 5, 0, 0, 123, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 55);
INSERT INTO public.invoicelist VALUES (74, 5, 0, 0, 123, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 56);
INSERT INTO public.invoicelist VALUES (75, 5, 0, 0, 1239, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 57);
INSERT INTO public.invoicelist VALUES (76, 5, 0, 0, 1234, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 58);
INSERT INTO public.invoicelist VALUES (77, 5, 0, 0, 1299, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 59);
INSERT INTO public.invoicelist VALUES (78, 5, 0, 0, 1055, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 60);
INSERT INTO public.invoicelist VALUES (79, 5, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 61);
INSERT INTO public.invoicelist VALUES (80, 5, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 62);
INSERT INTO public.invoicelist VALUES (81, 5, 0, 0, 2000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 63);
INSERT INTO public.invoicelist VALUES (82, 6, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 64);
INSERT INTO public.invoicelist VALUES (83, 6, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 65);
INSERT INTO public.invoicelist VALUES (84, 5, 0, 0, 9000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 66);
INSERT INTO public.invoicelist VALUES (85, 6, 0, 0, 9000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 67);
INSERT INTO public.invoicelist VALUES (86, 5, 0, 0, 5000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 68);
INSERT INTO public.invoicelist VALUES (87, 5, 0, 0, 4000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 69);
INSERT INTO public.invoicelist VALUES (88, 5, 0, 0, 5000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 1000, NULL, NULL, NULL, NULL, NULL, 70);
INSERT INTO public.invoicelist VALUES (89, 5, 0, 0, 2000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 500, NULL, NULL, NULL, NULL, NULL, 71);
INSERT INTO public.invoicelist VALUES (90, 5, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 72);
INSERT INTO public.invoicelist VALUES (91, 5, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 73);
INSERT INTO public.invoicelist VALUES (92, 7, 0, 0, 2000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 74);
INSERT INTO public.invoicelist VALUES (93, 7, 0, 0, 3000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 500, NULL, NULL, NULL, NULL, NULL, 75);
INSERT INTO public.invoicelist VALUES (155, 68, 0, 3, 2, 1, true, NULL, 52, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 144);
INSERT INTO public.invoicelist VALUES (156, 51, 0, 0, 0, 0, false, NULL, 51, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 145);
INSERT INTO public.invoicelist VALUES (127, 51, 0, 1, 500, 500, true, NULL, 46, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 112);
INSERT INTO public.invoicelist VALUES (127, 52, 0, 1, 10100, 10100, true, NULL, 47, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 113);
INSERT INTO public.invoicelist VALUES (128, 51, 0, 1, 500, 500, false, NULL, 46, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 114);
INSERT INTO public.invoicelist VALUES (128, 52, 0, 1, 10100, 10100, false, NULL, 47, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 115);
INSERT INTO public.invoicelist VALUES (129, 21, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 116);
INSERT INTO public.invoicelist VALUES (130, 23, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 117);
INSERT INTO public.invoicelist VALUES (136, 31, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 123);
INSERT INTO public.invoicelist VALUES (137, 7, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 2000, NULL, NULL, NULL, NULL, NULL, 124);
INSERT INTO public.invoicelist VALUES (153, 55, 0, 1, 31, 21, false, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 127);
INSERT INTO public.invoicelist VALUES (153, 59, 0, 2, 32, 21, false, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 4, NULL, NULL, NULL, NULL, 134);
INSERT INTO public.invoicelist VALUES (153, 64, 0, 2, 31, 21, true, NULL, NULL, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 6, NULL, NULL, NULL, NULL, 140);
INSERT INTO public.invoicelist VALUES (163, 71, 0, 4, 3, 2, true, NULL, 56, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 152);
INSERT INTO public.invoicelist VALUES (164, 56, 0, 0, 0, 0, false, NULL, 56, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 153);
INSERT INTO public.invoicelist VALUES (167, 57, 0, 0, 0, 0, false, NULL, 57, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 156);
INSERT INTO public.invoicelist VALUES (168, 52, 0, 0, 0, 0, false, NULL, 52, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 157);
INSERT INTO public.invoicelist VALUES (170, 58, 0, 0, 0, 0, false, NULL, 58, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 161);
INSERT INTO public.invoicelist VALUES (173, 75, 0, 4, 34, 23, false, NULL, 59, false, NULL, '-1,0,,0,0,6,false,false,0', true, 18, 2, 6, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 170);
INSERT INTO public.invoicelist VALUES (173, 80, 0, 7, 33, 22, true, NULL, 60, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 3, NULL, NULL, NULL, NULL, 171);
INSERT INTO public.invoicelist VALUES (174, 60, 0, 0, 0, 0, false, NULL, 60, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 172);
INSERT INTO public.invoicelist VALUES (178, 84, 0, 1, 3, 2, true, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 179);
INSERT INTO public.invoicelist VALUES (94, 5, 0, 0, 1000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 76);
INSERT INTO public.invoicelist VALUES (95, 7, 0, 0, 1999, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 77);
INSERT INTO public.invoicelist VALUES (96, 5, 0, 0, 300, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 78);
INSERT INTO public.invoicelist VALUES (97, 5, 0, 0, 4567, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 500, NULL, NULL, NULL, NULL, NULL, 79);
INSERT INTO public.invoicelist VALUES (98, 7, 0, 0, 3000, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 2000, NULL, NULL, NULL, NULL, NULL, 80);
INSERT INTO public.invoicelist VALUES (131, 24, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 118);
INSERT INTO public.invoicelist VALUES (132, 25, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 119);
INSERT INTO public.invoicelist VALUES (133, 26, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 120);
INSERT INTO public.invoicelist VALUES (134, 27, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 121);
INSERT INTO public.invoicelist VALUES (135, 30, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 122);
INSERT INTO public.invoicelist VALUES (181, 61, 0, 0, 0, 0, false, NULL, 61, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 190);
INSERT INTO public.invoicelist VALUES (153, 57, 0, 2, 31, 21, false, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 130);
INSERT INTO public.invoicelist VALUES (153, 58, 0, 2, 31, 21, false, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 3, NULL, NULL, NULL, NULL, 132);
INSERT INTO public.invoicelist VALUES (153, 60, 0, 2, 32, 21, false, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 5, NULL, NULL, NULL, NULL, 136);
INSERT INTO public.invoicelist VALUES (153, 65, 0, 2, 12, 11, true, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 7, NULL, NULL, NULL, NULL, 141);
INSERT INTO public.invoicelist VALUES (154, 66, 0, 1, 30, 20, true, NULL, 51, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 142);
INSERT INTO public.invoicelist VALUES (155, 67, 0, 2, 50, 40, true, NULL, 53, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 143);
INSERT INTO public.invoicelist VALUES (157, 68, 0, 1, 2, 1, false, NULL, 52, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 146);
INSERT INTO public.invoicelist VALUES (158, 68, 0, 3, 5, 4, false, NULL, 52, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 147);
INSERT INTO public.invoicelist VALUES (159, 69, 0, 4, 3, 2, true, NULL, 54, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 148);
INSERT INTO public.invoicelist VALUES (160, 69, 0, 33, 3, 2, false, NULL, 54, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 149);
INSERT INTO public.invoicelist VALUES (161, 70, 0, 2, 4, 3, true, NULL, 55, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 150);
INSERT INTO public.invoicelist VALUES (162, 55, 0, 0, 0, 0, false, NULL, 55, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 151);
INSERT INTO public.invoicelist VALUES (165, 72, 0, 3, 3, 2, true, NULL, 57, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 154);
INSERT INTO public.invoicelist VALUES (183, 75, 0, 5, 34, 23, false, NULL, 59, false, NULL, '-1,1,,0,0,6,false,false,0', false, 18, 2, 6, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 196);
INSERT INTO public.invoicelist VALUES (166, 73, 0, 2, 3, 2, true, NULL, 58, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 155);
INSERT INTO public.invoicelist VALUES (169, 75, 0, 1, 34, 23, true, NULL, 59, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 160);
INSERT INTO public.invoicelist VALUES (184, 75, 0, 3, 34, 23, false, NULL, 59, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 198);
INSERT INTO public.invoicelist VALUES (240, 62, 0, 1, 400, NULL, false, NULL, NULL, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 500, 1, NULL, NULL, NULL, NULL, 351);
INSERT INTO public.invoicelist VALUES (238, 160, 0, 1, 3, 2, false, NULL, 64, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 2, 0, '[]', NULL, NULL, 342);
INSERT INTO public.invoicelist VALUES (176, 75, 0, 8, 34, 23, false, NULL, NULL, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 176);
INSERT INTO public.invoicelist VALUES (176, 83, 0, 3, 2, 1, true, NULL, NULL, false, NULL, NULL, false, 18, 2, 6, false, 0, NULL, '[]', 0, 3, NULL, NULL, NULL, NULL, 177);
INSERT INTO public.invoicelist VALUES (177, 53, 0, 0, 0, 0, false, NULL, 53, false, NULL, NULL, false, 18, NULL, 0, true, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 178);
INSERT INTO public.invoicelist VALUES (221, 114, 65, 1, 5, 2, false, NULL, 69, false, NULL, NULL, true, 18, NULL, 0, false, 0, NULL, '[{"code":"4","value":"синий"}]', 0, 1, NULL, NULL, 0, 0, 276);
INSERT INTO public.invoicelist VALUES (207, 159, 0, 0, 0, 0, true, NULL, NULL, false, NULL, NULL, true, 18, NULL, 0, false, NULL, NULL, '[]', 0, 1, 0, '[]', NULL, NULL, 231);
INSERT INTO public.invoicelist VALUES (208, 114, 0, 3, 5, 2, false, NULL, 65, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 5, NULL, NULL, 0, 0, 244);
INSERT INTO public.invoicelist VALUES (213, 114, 0, 3, 5, 2, false, NULL, 65, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, 0, 0, 252);
INSERT INTO public.invoicelist VALUES (244, 64, 0, 1, 3, 2, false, NULL, 77, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 366);
INSERT INTO public.invoicelist VALUES (255, 62, 0, 1, 400, NULL, false, NULL, NULL, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 500, 1, NULL, NULL, NULL, NULL, 390);
INSERT INTO public.invoicelist VALUES (257, 59, 0, 1, 34, NULL, false, NULL, NULL, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 391);
INSERT INTO public.invoicelist VALUES (208, 153, 0, 3, 200, 100, false, NULL, 66, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 4, NULL, NULL, 0, 0, 242);
INSERT INTO public.invoicelist VALUES (210, 153, 0, 0, 200, 100, false, NULL, 67, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, 0, '[]', NULL, NULL, 248);
INSERT INTO public.invoicelist VALUES (227, 160, 70, 2, 3, 2, false, NULL, 70, false, NULL, NULL, true, 18, NULL, 0, false, 0, NULL, '[{"code":"1","value":"1"},{"code":"4","value":"зелёный"}]', 0, 2, NULL, NULL, 0, 0, 319);
INSERT INTO public.invoicelist VALUES (208, 160, 0, 4, 3, 2, false, NULL, 64, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 6, NULL, NULL, 0, 0, 246);
INSERT INTO public.invoicelist VALUES (258, 59, 0, 1, 0, 23, false, NULL, 79, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 394);
INSERT INTO public.invoicelist VALUES (214, 110, 0, 3, 200, 100, false, NULL, 68, false, NULL, NULL, true, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, '[]', NULL, NULL, 253);
INSERT INTO public.invoicelist VALUES (259, 59, 0, 1, 34, 23, false, NULL, 79, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 395);
INSERT INTO public.invoicelist VALUES (225, 152, 0, 2, 200, 100, false, NULL, 63, false, NULL, NULL, true, 18, 2, 6, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 302);
INSERT INTO public.invoicelist VALUES (229, 41, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 323);
INSERT INTO public.invoicelist VALUES (230, 62, 0, 0, 400, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 500, NULL, NULL, NULL, NULL, NULL, 324);
INSERT INTO public.invoicelist VALUES (227, 111, 0, 2, 2526, 2105, false, NULL, 71, false, NULL, '0,1,1,0,0,2,false,true,10', false, 18, NULL, 0, false, 262.6, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 316);
INSERT INTO public.invoicelist VALUES (211, 114, 0, 0, 5, 2, false, NULL, 65, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, '[]', NULL, NULL, 249);
INSERT INTO public.invoicelist VALUES (212, 114, 0, 0, 5, 2, false, NULL, 65, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, '[]', NULL, NULL, 250);
INSERT INTO public.invoicelist VALUES (233, 114, 71, 2, 8, 4, false, NULL, NULL, false, NULL, NULL, true, 18, NULL, 0, false, 0, NULL, '[{"code":"4","value":"красный"}]', 0, 1, NULL, NULL, 0, 0, 330);
INSERT INTO public.invoicelist VALUES (234, 111, 0, 2, 2526, 2105, false, NULL, 71, false, NULL, NULL, true, 18, NULL, 0, false, 262.6, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 331);
INSERT INTO public.invoicelist VALUES (235, 111, 0, 2, 2526, 2105, false, NULL, 71, false, NULL, NULL, true, 18, NULL, 0, false, 262.6, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 336);
INSERT INTO public.invoicelist VALUES (238, 164, 73, 1, 200, 100, false, NULL, 72, false, NULL, NULL, true, 18, NULL, 0, false, 0, NULL, '[{"code":"3","value":"йцу"},{"code":"4","value":"зелёный"}]', 0, 3, NULL, NULL, 0, 0, 346);
INSERT INTO public.invoicelist VALUES (234, 160, 0, 2, 3, 2, false, NULL, 64, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 3, NULL, '[]', NULL, NULL, 334);
INSERT INTO public.invoicelist VALUES (235, 160, 72, 2, 3, 2, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[{"code":"4","value":"зелёный"},{"code":"5","value":"1 л."}]', 0, 2, NULL, NULL, 0, 0, 338);
INSERT INTO public.invoicelist VALUES (239, 160, 0, 1, 3, 2, false, NULL, 64, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 2, 0, '[]', NULL, NULL, 347);
INSERT INTO public.invoicelist VALUES (239, 164, 73, 1, 200, 100, false, NULL, 72, false, NULL, NULL, true, 18, NULL, 0, false, 0, NULL, '[{"code":"3","value":"йцу"},{"code":"4","value":"зелёный"}]', 0, 3, NULL, NULL, 0, 0, 348);
INSERT INTO public.invoicelist VALUES (252, 59, 0, 1, 34, 23, false, NULL, 79, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 384);
INSERT INTO public.invoicelist VALUES (242, 64, 0, 1, 3, 2, false, NULL, 77, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 364);
INSERT INTO public.invoicelist VALUES (243, 71, 0, 1, 2526, 2105, false, NULL, 78, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 365);
INSERT INTO public.invoicelist VALUES (245, 64, 0, 1, 3, 2, false, NULL, 77, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 375);
INSERT INTO public.invoicelist VALUES (246, 64, 0, 1, 3, 2, false, NULL, 77, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 376);
INSERT INTO public.invoicelist VALUES (247, 59, 0, 1, 34, 23, false, NULL, 79, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 378);
INSERT INTO public.invoicelist VALUES (247, 64, 0, 1, 3, 2, false, NULL, 77, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 377);
INSERT INTO public.invoicelist VALUES (253, 71, 0, 1, 2526, 2105, false, NULL, 78, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 385);
INSERT INTO public.invoicelist VALUES (260, 59, 0, 1, 34, 23, false, NULL, 79, false, NULL, NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 409);
INSERT INTO public.invoicelist VALUES (262, 59, 0, 1, 34, NULL, false, NULL, NULL, false, 'авпва', NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 411);
INSERT INTO public.invoicelist VALUES (264, 59, 0, 1, 34, NULL, false, NULL, NULL, false, 'екн', NULL, NULL, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, NULL, NULL, NULL, NULL, 417);
INSERT INTO public.invoicelist VALUES (284, 187, 0, 1, 1, 1, true, NULL, NULL, false, NULL, NULL, true, 184, 2, 9, false, 0, NULL, '[]', 0, 3, NULL, NULL, NULL, NULL, 438);
INSERT INTO public.invoicelist VALUES (284, 192, 0, 2, 4, 3, true, NULL, NULL, false, NULL, NULL, true, 184, 2, 9, false, 0, NULL, '[]', 0, 4, NULL, NULL, NULL, NULL, 439);
INSERT INTO public.invoicelist VALUES (266, 160, 0, 5, 3, 2, false, NULL, 80, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 2, 0, '[]', NULL, NULL, 419);
INSERT INTO public.invoicelist VALUES (266, 114, 0, 10, 5, 2, false, NULL, 81, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, 0, '[]', NULL, NULL, 418);
INSERT INTO public.invoicelist VALUES (286, 23, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 441);
INSERT INTO public.invoicelist VALUES (267, 75, 0, 5, 34, 23, false, NULL, 82, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, 0, '[]', NULL, NULL, 420);
INSERT INTO public.invoicelist VALUES (268, 81, 0, 0, 0, 0, false, NULL, 81, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 421);
INSERT INTO public.invoicelist VALUES (269, 81, 0, 0, 0, 0, false, NULL, 81, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 422);
INSERT INTO public.invoicelist VALUES (280, 178, 0, 2, 120, 100, true, NULL, 85, false, NULL, NULL, true, 185, NULL, 0, false, NULL, NULL, '[]', 0, 1, 0, '[]', NULL, NULL, 431);
INSERT INTO public.invoicelist VALUES (270, 160, 0, 1, 300, 200, false, NULL, 64, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, '[]', 0, 1, 0, '[]', NULL, NULL, 423);
INSERT INTO public.invoicelist VALUES (271, 64, 0, 0, 300, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, 0, NULL, NULL, 400, NULL, NULL, NULL, NULL, NULL, 424);
INSERT INTO public.invoicelist VALUES (278, 175, 0, 1, 2, 1, true, NULL, NULL, false, NULL, NULL, true, 181, 2, 8, false, 0, NULL, '[]', 0, 4, NULL, NULL, NULL, NULL, 428);
INSERT INTO public.invoicelist VALUES (278, 176, 0, 1, 2, 1, true, NULL, NULL, false, NULL, NULL, true, 181, 2, 8, false, 0, NULL, '[]', 0, 5, NULL, NULL, NULL, NULL, 429);
INSERT INTO public.invoicelist VALUES (278, 177, 0, 1, 2, 1, true, NULL, NULL, false, NULL, NULL, true, 181, 2, 8, false, 0, NULL, '[]', 0, 6, NULL, NULL, NULL, NULL, 430);
INSERT INTO public.invoicelist VALUES (283, 182, 0, 1, 3, 2, true, NULL, 88, false, NULL, NULL, true, 184, 2, 9, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 433);
INSERT INTO public.invoicelist VALUES (283, 183, 0, 1, 4, 3, true, NULL, 89, false, NULL, NULL, true, 184, 2, 9, false, 0, NULL, '[]', 0, 3, NULL, NULL, NULL, NULL, 434);
INSERT INTO public.invoicelist VALUES (283, 184, 0, 3, 2, 1, true, NULL, 90, false, NULL, NULL, true, 184, 2, 9, false, 0, NULL, '[]', 0, 4, NULL, NULL, NULL, NULL, 435);
INSERT INTO public.invoicelist VALUES (284, 186, 0, 2, 2, 1, true, NULL, NULL, false, NULL, NULL, true, 184, 2, 9, false, 0, NULL, '[]', 0, 2, NULL, NULL, NULL, NULL, 437);
INSERT INTO public.invoicelist VALUES (287, 24, 0, NULL, NULL, NULL, false, NULL, NULL, false, NULL, NULL, false, 18, NULL, 0, false, NULL, NULL, NULL, 0, NULL, NULL, NULL, NULL, NULL, 442);


--
-- TOC entry 5862 (class 0 OID 17154)
-- Dependencies: 321
-- Data for Name: invoices; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.invoices VALUES (98, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:31:36.285403', NULL, '2025-09-29 12:31:36.285403', false, false, NULL);
INSERT INTO public.invoices VALUES (234, '88', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-30', '2025-10-30 15:11:02.980783', 5, '2025-10-30 15:06:35.085248', false, false, NULL);
INSERT INTO public.invoices VALUES (235, '', 42, NULL, 'FORMATION', 18, 24, 24, NULL, 2, '2025-10-30', NULL, 5, '2025-10-30 15:11:20.256632', false, false, NULL);
INSERT INTO public.invoices VALUES (239, '', 42, NULL, 'FORMATION', 18, 24, 24, NULL, 2, '2025-10-31', NULL, 3, '2025-10-31 10:39:54.71827', false, false, NULL);
INSERT INTO public.invoices VALUES (170, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-14', NULL, NULL, '2025-10-14 10:47:00.11494', false, false, NULL);
INSERT INTO public.invoices VALUES (240, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-10-31', NULL, NULL, '2025-10-31 15:29:31.490373', false, false, NULL);
INSERT INTO public.invoices VALUES (174, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-14', NULL, NULL, '2025-10-14 12:36:23.617952', false, false, NULL);
INSERT INTO public.invoices VALUES (241, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-10-31', NULL, NULL, '2025-10-31 16:56:30.987299', false, false, NULL);
INSERT INTO public.invoices VALUES (181, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-14', NULL, NULL, '2025-10-14 14:35:09.287591', false, false, NULL);
INSERT INTO public.invoices VALUES (242, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-10-31', '2025-11-03 10:19:23.109435', NULL, '2025-10-31 16:57:07.241545', false, false, NULL);
INSERT INTO public.invoices VALUES (243, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 10:27:23.530607', NULL, '2025-11-03 10:26:39.869333', false, false, NULL);
INSERT INTO public.invoices VALUES (185, NULL, 42, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-16', NULL, NULL, '2025-10-16 15:49:48.529272', false, false, NULL);
INSERT INTO public.invoices VALUES (165, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 17:03:04.384033', 3, '2025-10-13 17:02:40.536159', false, true, 6);
INSERT INTO public.invoices VALUES (166, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-14 09:26:56.275695', 3, '2025-10-13 17:07:09.572272', false, true, 6);
INSERT INTO public.invoices VALUES (171, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-14', NULL, 3, '2025-10-14 10:47:09.965748', false, true, 6);
INSERT INTO public.invoices VALUES (175, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-14', NULL, 3, '2025-10-14 12:36:34.888933', false, true, 6);
INSERT INTO public.invoices VALUES (176, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-14', NULL, 3, '2025-10-14 12:36:48.739263', false, true, 6);
INSERT INTO public.invoices VALUES (179, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-14', '2025-10-14 14:32:31.932543', 3, '2025-10-14 14:08:10.364801', false, true, 6);
INSERT INTO public.invoices VALUES (182, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-14', NULL, 3, '2025-10-14 14:35:54.864128', false, true, 6);
INSERT INTO public.invoices VALUES (244, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 10:36:37.147187', NULL, '2025-11-03 10:28:43.311532', false, false, NULL);
INSERT INTO public.invoices VALUES (139, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-10', NULL, 3, '2025-10-10 17:48:51.08971', false, true, 6);
INSERT INTO public.invoices VALUES (183, '3', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-14', '2025-10-14 14:37:55.829054', 3, '2025-10-14 14:36:32.238728', false, true, 6);
INSERT INTO public.invoices VALUES (245, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 14:21:13.618197', NULL, '2025-11-03 10:38:07.788367', false, false, NULL);
INSERT INTO public.invoices VALUES (188, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-24', '2025-10-24 09:59:11.426127', 0, '2025-10-24 09:46:29.464089', false, true, 6);
INSERT INTO public.invoices VALUES (169, '7', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-14', '2025-10-14 10:22:27.91282', 9, '2025-10-14 09:44:50.645526', false, true, 6);
INSERT INTO public.invoices VALUES (246, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 14:39:07.692179', NULL, '2025-11-03 14:21:48.893789', false, false, NULL);
INSERT INTO public.invoices VALUES (186, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-23', '2025-10-23 17:52:28.970194', 0, '2025-10-23 17:52:00.421759', false, true, 4);
INSERT INTO public.invoices VALUES (247, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 14:40:38.363048', NULL, '2025-11-03 14:39:17.762924', false, false, NULL);
INSERT INTO public.invoices VALUES (248, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 14:40:51.589683', false, false, NULL);
INSERT INTO public.invoices VALUES (249, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 14:41:37.4695', false, false, NULL);
INSERT INTO public.invoices VALUES (252, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 15:31:27.798682', NULL, '2025-11-03 15:27:38.660205', false, false, NULL);
INSERT INTO public.invoices VALUES (208, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-28', '2025-10-29 09:27:50.802768', 3, '2025-10-28 14:55:31.103688', false, false, NULL);
INSERT INTO public.invoices VALUES (253, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 15:32:58.105112', NULL, '2025-11-03 15:31:40.329302', false, false, NULL);
INSERT INTO public.invoices VALUES (209, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-29', '2025-10-29 09:35:31.92819', 9, '2025-10-29 09:35:02.017572', false, false, NULL);
INSERT INTO public.invoices VALUES (254, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 15:33:04.429429', false, false, NULL);
INSERT INTO public.invoices VALUES (210, '', 42, 42, 'ACCEPTED', 18, 26, 26, 'ERP', 2, '2025-10-29', '2025-10-29 09:36:51.236905', 8, '2025-10-29 09:36:28.2325', false, false, NULL);
INSERT INTO public.invoices VALUES (256, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 17:11:19.686056', false, false, NULL);
INSERT INTO public.invoices VALUES (211, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-29', '2025-10-29 09:40:01.102676', 1, '2025-10-29 09:39:36.964793', false, false, NULL);
INSERT INTO public.invoices VALUES (261, '', 42, 42, 'CANCELED', 18, 26, 26, 'ERP', 7, '2025-11-04', NULL, NULL, '2025-11-04 10:55:25.111804', false, false, NULL);
INSERT INTO public.invoices VALUES (213, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-29', '2025-10-29 09:50:02.783892', 9, '2025-10-29 09:49:39.856987', false, false, NULL);
INSERT INTO public.invoices VALUES (262, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 7, '2025-11-04', '2025-11-04 14:48:04.390915', NULL, '2025-11-04 11:18:56.585333', false, false, NULL);
INSERT INTO public.invoices VALUES (265, '', 42, NULL, 'FORMATION', 18, 24, 24, NULL, 7, '2025-11-04', NULL, NULL, '2025-11-04 15:30:27.110791', false, false, NULL);
INSERT INTO public.invoices VALUES (214, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-29', '2025-10-29 10:08:40.793341', 3, '2025-10-29 09:53:28.643579', false, false, NULL);
INSERT INTO public.invoices VALUES (215, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-29', '2025-10-29 10:14:39.347074', 5, '2025-10-29 10:09:56.720243', false, false, NULL);
INSERT INTO public.invoices VALUES (268, NULL, 0, NULL, 'IN_PROCESS', 18, 30, 30, NULL, 8, '2025-11-07', NULL, NULL, '2025-11-07 12:47:36.826431', false, false, NULL);
INSERT INTO public.invoices VALUES (269, NULL, 0, NULL, 'IN_PROCESS', 18, 30, 30, NULL, 8, '2025-11-07', NULL, NULL, '2025-11-07 12:53:20.009898', false, false, NULL);
INSERT INTO public.invoices VALUES (272, NULL, 0, NULL, 'IN_PROCESS', 18, 46, 46, NULL, 15, '2025-11-18', NULL, NULL, '2025-11-18 11:21:30.844788', false, false, NULL);
INSERT INTO public.invoices VALUES (221, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-29', '2025-10-29 12:57:58.047838', 3, '2025-10-29 12:56:27.918451', false, false, NULL);
INSERT INTO public.invoices VALUES (227, '3', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-30', '2025-10-30 10:25:10.354687', 8, '2025-10-30 10:22:21.772337', false, false, NULL);
INSERT INTO public.invoices VALUES (229, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 10, '2025-10-30', '2025-10-30 10:44:57.883785', NULL, '2025-10-30 10:44:57.883785', false, false, NULL);
INSERT INTO public.invoices VALUES (230, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-10-30', '2025-10-30 10:47:18.594901', NULL, '2025-10-30 10:47:18.594901', false, false, NULL);
INSERT INTO public.invoices VALUES (233, '98', 42, NULL, 'FORMATION', 18, 24, 24, NULL, 2, '2025-10-30', NULL, 8, '2025-10-30 11:52:12.696424', false, false, NULL);
INSERT INTO public.invoices VALUES (167, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-14', NULL, NULL, '2025-10-14 09:26:03.144191', false, false, NULL);
INSERT INTO public.invoices VALUES (140, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-10', NULL, 3, '2025-10-10 17:49:21.417193', false, true, 6);
INSERT INTO public.invoices VALUES (141, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:27:07.495643', false, true, 6);
INSERT INTO public.invoices VALUES (142, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:27:24.493116', false, true, 6);
INSERT INTO public.invoices VALUES (143, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:27:48.397143', false, true, 6);
INSERT INTO public.invoices VALUES (144, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:28:16.110903', false, true, 6);
INSERT INTO public.invoices VALUES (145, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:28:46.420202', false, true, 6);
INSERT INTO public.invoices VALUES (146, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:35:37.438781', false, true, 6);
INSERT INTO public.invoices VALUES (147, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:39:04.652651', false, true, 6);
INSERT INTO public.invoices VALUES (148, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:40:34.058019', false, true, 6);
INSERT INTO public.invoices VALUES (149, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:42:55.090476', false, true, 6);
INSERT INTO public.invoices VALUES (150, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:44:46.805415', false, true, 6);
INSERT INTO public.invoices VALUES (70, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 12:29:46.019969', NULL, '2025-09-25 12:29:46.019969', false, false, NULL);
INSERT INTO public.invoices VALUES (71, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 12:31:04.616576', NULL, '2025-09-25 12:31:04.616576', false, false, NULL);
INSERT INTO public.invoices VALUES (72, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 12:31:47.465717', NULL, '2025-09-25 12:31:47.465717', false, false, NULL);
INSERT INTO public.invoices VALUES (73, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 12:31:57.166826', NULL, '2025-09-25 12:31:57.166826', false, false, NULL);
INSERT INTO public.invoices VALUES (266, '', 42, 42, 'ACCEPTED', 18, 31, 31, 'ERP', 2, '2025-11-05', '2025-11-05 12:27:50.011433', 1, '2025-11-05 12:27:11.546982', false, false, NULL);
INSERT INTO public.invoices VALUES (74, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 14:33:40.086353', NULL, '2025-09-25 14:33:40.086353', false, false, NULL);
INSERT INTO public.invoices VALUES (75, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 14:33:51.499109', NULL, '2025-09-25 14:33:51.499109', false, false, NULL);
INSERT INTO public.invoices VALUES (76, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 14:34:08.022404', NULL, '2025-09-25 14:34:08.022404', false, false, NULL);
INSERT INTO public.invoices VALUES (77, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 14:58:38.34131', NULL, '2025-09-25 14:58:38.34131', false, false, NULL);
INSERT INTO public.invoices VALUES (127, NULL, 42, 42, 'ACCEPTED', 18, 26, 26, 'ERP', 2, '2025-10-03', '2025-10-03 17:48:43.781413', 1, '2025-10-03 17:48:43.781413', false, false, NULL);
INSERT INTO public.invoices VALUES (78, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-25', '2025-09-25 14:59:02.074365', NULL, '2025-09-25 14:59:02.074365', false, false, NULL);
INSERT INTO public.invoices VALUES (79, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-26', '2025-09-26 17:35:57.394703', NULL, '2025-09-26 17:35:57.394703', false, false, NULL);
INSERT INTO public.invoices VALUES (80, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 09:20:30.163723', NULL, '2025-09-29 09:20:30.163723', false, false, NULL);
INSERT INTO public.invoices VALUES (128, NULL, 42, 42, 'ACCEPTED', 18, 26, 26, 'ERP', 2, '2025-10-03', '2025-10-03 17:52:56.858432', 1, '2025-10-03 17:52:56.858432', false, false, NULL);
INSERT INTO public.invoices VALUES (81, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 10:24:42.778226', NULL, '2025-09-29 10:24:42.778226', false, false, NULL);
INSERT INTO public.invoices VALUES (82, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-09-29', '2025-09-29 10:36:58.365903', NULL, '2025-09-29 10:36:58.365903', false, false, NULL);
INSERT INTO public.invoices VALUES (129, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 4, '2025-10-06', '2025-10-06 15:01:37.578539', NULL, '2025-10-06 15:01:37.578539', false, false, NULL);
INSERT INTO public.invoices VALUES (83, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-09-29', '2025-09-29 10:59:03.676782', NULL, '2025-09-29 10:59:03.676782', false, false, NULL);
INSERT INTO public.invoices VALUES (84, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 11:19:05.393444', NULL, '2025-09-29 11:19:05.393444', false, false, NULL);
INSERT INTO public.invoices VALUES (130, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 10, '2025-10-07', '2025-10-07 16:10:54.634357', NULL, '2025-10-07 16:10:54.634357', false, false, NULL);
INSERT INTO public.invoices VALUES (85, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-09-29', '2025-09-29 11:19:05.393444', NULL, '2025-09-29 11:19:05.393444', false, false, NULL);
INSERT INTO public.invoices VALUES (86, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 11:40:37.171678', NULL, '2025-09-29 11:40:37.171678', false, false, NULL);
INSERT INTO public.invoices VALUES (131, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 10, '2025-10-07', '2025-10-07 16:18:39.698886', NULL, '2025-10-07 16:18:39.698886', false, false, NULL);
INSERT INTO public.invoices VALUES (87, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:04:18.574238', NULL, '2025-09-29 12:04:18.574238', false, false, NULL);
INSERT INTO public.invoices VALUES (88, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:08:28.552822', NULL, '2025-09-29 12:08:28.552822', false, false, NULL);
INSERT INTO public.invoices VALUES (132, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 10, '2025-10-07', '2025-10-07 16:27:54.076026', NULL, '2025-10-07 16:27:54.076026', false, false, NULL);
INSERT INTO public.invoices VALUES (89, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:09:26.931541', NULL, '2025-09-29 12:09:26.931541', false, false, NULL);
INSERT INTO public.invoices VALUES (90, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-09-29', '2025-09-29 12:18:01.590276', NULL, '2025-09-29 12:18:01.590276', false, false, NULL);
INSERT INTO public.invoices VALUES (133, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 10, '2025-10-07', '2025-10-07 16:34:53.702362', NULL, '2025-10-07 16:34:53.702362', false, false, NULL);
INSERT INTO public.invoices VALUES (91, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-09-29', '2025-09-29 12:20:19.778717', NULL, '2025-09-29 12:20:19.778717', false, false, NULL);
INSERT INTO public.invoices VALUES (92, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:25:49.023024', NULL, '2025-09-29 12:25:49.023024', false, false, NULL);
INSERT INTO public.invoices VALUES (134, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 10, '2025-10-07', '2025-10-07 16:37:57.188907', NULL, '2025-10-07 16:37:57.188907', false, false, NULL);
INSERT INTO public.invoices VALUES (93, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:28:14.373325', NULL, '2025-09-29 12:28:14.373325', false, false, NULL);
INSERT INTO public.invoices VALUES (94, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-09-29', '2025-09-29 12:28:34.78948', NULL, '2025-09-29 12:28:34.78948', false, false, NULL);
INSERT INTO public.invoices VALUES (135, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 10, '2025-10-07', '2025-10-07 17:02:43.979708', NULL, '2025-10-07 17:02:43.979708', false, false, NULL);
INSERT INTO public.invoices VALUES (95, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:30:05.463902', NULL, '2025-09-29 12:30:05.463902', false, false, NULL);
INSERT INTO public.invoices VALUES (96, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:30:38.33927', NULL, '2025-09-29 12:30:38.33927', false, false, NULL);
INSERT INTO public.invoices VALUES (136, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 10, '2025-10-07', '2025-10-07 17:07:14.754033', NULL, '2025-10-07 17:07:14.754033', false, false, NULL);
INSERT INTO public.invoices VALUES (97, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-09-29', '2025-09-29 12:31:13.204289', NULL, '2025-09-29 12:31:13.204289', false, false, NULL);
INSERT INTO public.invoices VALUES (137, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 0, '2025-10-10', '2025-10-10 12:21:13.103182', NULL, '2025-10-10 12:21:13.103182', false, false, NULL);
INSERT INTO public.invoices VALUES (168, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-14', NULL, NULL, '2025-10-14 09:26:19.815692', false, false, NULL);
INSERT INTO public.invoices VALUES (238, '7', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-31', '2025-10-31 10:39:46.179933', 3, '2025-10-31 10:36:10.742807', false, false, NULL);
INSERT INTO public.invoices VALUES (156, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-13', NULL, NULL, '2025-10-13 15:20:09.024502', false, false, NULL);
INSERT INTO public.invoices VALUES (250, '1', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 14:43:56.328227', false, false, NULL);
INSERT INTO public.invoices VALUES (177, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-14', NULL, NULL, '2025-10-14 12:59:02.828673', false, false, NULL);
INSERT INTO public.invoices VALUES (251, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 15:08:06.162454', false, false, NULL);
INSERT INTO public.invoices VALUES (255, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 16:10:53.841713', false, false, NULL);
INSERT INTO public.invoices VALUES (159, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 15:34:34.885704', 3, '2025-10-13 15:33:44.575331', false, true, 6);
INSERT INTO public.invoices VALUES (180, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-14', NULL, 3, '2025-10-14 14:33:04.640943', false, true, 6);
INSERT INTO public.invoices VALUES (160, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 16:28:32.572785', 3, '2025-10-13 15:35:35.76034', false, true, 6);
INSERT INTO public.invoices VALUES (257, '', 42, 42, 'CANCELED', 18, 24, 26, 'ERP', 1, '2025-11-03', NULL, NULL, '2025-11-03 17:11:35.505054', false, false, NULL);
INSERT INTO public.invoices VALUES (162, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-13', NULL, NULL, '2025-10-13 16:30:21.004453', false, false, NULL);
INSERT INTO public.invoices VALUES (184, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-14', '2025-10-23 17:51:34.51209', 3, '2025-10-14 15:21:36.627375', false, true, 6);
INSERT INTO public.invoices VALUES (163, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 16:30:44.897163', 3, '2025-10-13 16:30:27.416436', false, true, 6);
INSERT INTO public.invoices VALUES (164, NULL, 0, NULL, 'IN_PROCESS', 18, 23, 23, NULL, 8, '2025-10-13', NULL, NULL, '2025-10-13 16:31:01.238506', false, false, NULL);
INSERT INTO public.invoices VALUES (154, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 14:47:03.54515', 3, '2025-10-13 14:46:47.597125', false, true, 6);
INSERT INTO public.invoices VALUES (155, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 14:49:49.477109', 3, '2025-10-13 14:47:37.579011', false, true, 6);
INSERT INTO public.invoices VALUES (157, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 15:32:24.678594', 3, '2025-10-13 15:20:59.840363', false, true, 6);
INSERT INTO public.invoices VALUES (158, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 15:33:28.618392', 3, '2025-10-13 15:33:06.412828', false, true, 6);
INSERT INTO public.invoices VALUES (178, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-14', NULL, 3, '2025-10-14 12:59:37.784229', false, true, 6);
INSERT INTO public.invoices VALUES (152, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:47:11.6159', false, true, 6);
INSERT INTO public.invoices VALUES (153, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:47:57.811583', false, true, 6);
INSERT INTO public.invoices VALUES (172, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-14', NULL, 3, '2025-10-14 10:47:21.203683', false, true, 6);
INSERT INTO public.invoices VALUES (151, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 2, '2025-10-13', NULL, 3, '2025-10-13 09:46:57.238964', false, true, 6);
INSERT INTO public.invoices VALUES (161, '1', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-13', '2025-10-13 16:29:29.074864', 3, '2025-10-13 16:28:46.773119', false, true, 6);
INSERT INTO public.invoices VALUES (173, '8', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-14', '2025-10-14 12:35:57.413179', 3, '2025-10-14 11:33:04.855795', false, true, 6);
INSERT INTO public.invoices VALUES (258, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 17:14:09.568168', NULL, '2025-11-03 17:12:21.352625', false, false, NULL);
INSERT INTO public.invoices VALUES (259, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-03 17:14:45.124143', NULL, '2025-11-03 17:14:22.643777', false, false, NULL);
INSERT INTO public.invoices VALUES (260, '', 42, 42, 'ACCEPTED', 18, 24, 26, 'ERP', 1, '2025-11-03', '2025-11-04 12:33:51.667936', NULL, '2025-11-03 17:14:46.764574', false, false, NULL);
INSERT INTO public.invoices VALUES (263, '', 42, 42, 'CANCELED', 18, 24, 24, 'ERP', 7, '2025-11-04', NULL, NULL, '2025-11-04 14:58:52.127307', false, false, NULL);
INSERT INTO public.invoices VALUES (264, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 7, '2025-11-04', '2025-11-04 15:30:21.772386', NULL, '2025-11-04 14:59:49.345488', false, false, NULL);
INSERT INTO public.invoices VALUES (267, '', 42, 42, 'ACCEPTED', 18, 31, 31, 'ERP', 2, '2025-11-07', '2025-11-07 09:29:14.687802', 5, '2025-11-07 09:28:52.160507', false, false, NULL);
INSERT INTO public.invoices VALUES (270, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-11-10', '2025-11-10 14:53:13.785081', 9, '2025-11-10 14:52:11.400488', false, false, NULL);
INSERT INTO public.invoices VALUES (207, '55', 42, NULL, 'FORMATION', 18, 26, 26, NULL, 2, '2025-10-24', NULL, 6, '2025-10-24 15:27:13.663902', false, false, NULL);
INSERT INTO public.invoices VALUES (271, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 0, '2025-11-10', '2025-11-10 14:54:43.935819', NULL, '2025-11-10 14:54:43.935819', false, false, NULL);
INSERT INTO public.invoices VALUES (212, '', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-28', '2025-10-29 09:40:59.887262', 9, '2025-10-29 09:40:32.091533', false, false, NULL);
INSERT INTO public.invoices VALUES (273, NULL, 0, NULL, 'IN_PROCESS', 18, 46, 46, NULL, 15, '2025-11-18', NULL, NULL, '2025-11-18 11:49:36.755974', false, false, NULL);
INSERT INTO public.invoices VALUES (274, NULL, 0, NULL, 'IN_PROCESS', 18, 46, 46, NULL, 15, '2025-11-18', NULL, NULL, '2025-11-18 15:24:53.502095', false, false, NULL);
INSERT INTO public.invoices VALUES (275, NULL, 0, NULL, 'IN_PROCESS', 18, 25, 25, NULL, 15, '2025-11-18', NULL, NULL, '2025-11-18 17:11:19.009728', false, false, NULL);
INSERT INTO public.invoices VALUES (276, '', 277, NULL, 'FORMATION', 185, 86, 86, NULL, 7, '2025-11-21', NULL, NULL, '2025-11-21 13:10:37.76561', false, false, NULL);
INSERT INTO public.invoices VALUES (225, '77', 42, 42, 'ACCEPTED', 18, 24, 24, 'ERP', 2, '2025-10-30', '2025-10-30 09:56:21.457358', 0, '2025-10-30 09:56:03.487454', false, true, 6);
INSERT INTO public.invoices VALUES (278, '', 273, 273, 'CANCELED', 181, 82, 82, 'ERP', 2, '2025-11-21', NULL, 0, '2025-11-21 14:29:41.582239', false, true, 8);
INSERT INTO public.invoices VALUES (279, '', 273, 273, 'CANCELED', 181, 82, 82, 'ERP', 2, '2025-11-21', NULL, 0, '2025-11-21 16:38:48.946295', false, true, 8);
INSERT INTO public.invoices VALUES (280, '', 277, 277, 'ACCEPTED', 185, 86, 86, 'ERP', 2, '2025-11-21', '2025-11-21 17:02:58.921781', 10, '2025-11-21 17:02:10.951256', false, false, NULL);
INSERT INTO public.invoices VALUES (277, '', 277, 277, 'CANCELED', 185, 86, 88, 'ERP', 1, '2025-11-21', NULL, NULL, '2025-11-21 13:12:54.048931', false, false, NULL);
INSERT INTO public.invoices VALUES (281, '', 277, NULL, 'FORMATION', 185, 90, 88, NULL, 1, '2025-11-21', NULL, NULL, '2025-11-21 17:09:08.702177', false, false, NULL);
INSERT INTO public.invoices VALUES (282, '', 277, NULL, 'FORMATION', 185, 90, 90, NULL, 2, '2025-11-21', NULL, 10, '2025-11-21 17:18:51.768505', false, false, NULL);
INSERT INTO public.invoices VALUES (283, '', 276, 276, 'ACCEPTED', 184, 85, 85, 'ERP', 2, '2025-11-24', '2025-11-24 09:20:20.811252', 0, '2025-11-24 09:18:19.991805', false, true, 9);
INSERT INTO public.invoices VALUES (284, '', 276, NULL, 'FORMATION', 184, 85, 85, NULL, 2, '2025-11-24', NULL, 0, '2025-11-24 09:20:38.134067', false, true, 9);
INSERT INTO public.invoices VALUES (285, NULL, 42, 42, 'ACCEPTED', 18, 23, 23, 'ERP', 4, '2025-11-26', '2025-11-26 14:45:56.141294', NULL, '2025-11-26 14:45:56.141294', false, false, NULL);
INSERT INTO public.invoices VALUES (286, NULL, 42, 42, 'ACCEPTED', 18, 25, 25, 'ERP', 4, '2025-11-26', '2025-11-26 14:55:55.892914', NULL, '2025-11-26 14:55:55.892914', false, false, NULL);
INSERT INTO public.invoices VALUES (287, NULL, 42, 42, 'ACCEPTED', 18, 34, 34, 'ERP', 4, '2025-11-26', '2025-11-26 14:56:35.107155', NULL, '2025-11-26 14:56:35.107155', false, false, NULL);


--
-- TOC entry 5864 (class 0 OID 17165)
-- Dependencies: 323
-- Data for Name: invoicetypes; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.invoicetypes VALUES (1, 'Тип1', NULL);
INSERT INTO public.invoicetypes VALUES (3, 'Тип3', NULL);
INSERT INTO public.invoicetypes VALUES (4, 'Тип4', NULL);
INSERT INTO public.invoicetypes VALUES (5, 'Тип5', NULL);
INSERT INTO public.invoicetypes VALUES (6, 'Тип6', NULL);
INSERT INTO public.invoicetypes VALUES (7, 'Тип7', NULL);
INSERT INTO public.invoicetypes VALUES (8, 'Тип8', NULL);
INSERT INTO public.invoicetypes VALUES (9, 'Тип9', NULL);
INSERT INTO public.invoicetypes VALUES (10, 'Тип10', NULL);
INSERT INTO public.invoicetypes VALUES (11, 'Тип11', NULL);
INSERT INTO public.invoicetypes VALUES (12, 'Тип12', NULL);
INSERT INTO public.invoicetypes VALUES (13, 'Тип13', NULL);
INSERT INTO public.invoicetypes VALUES (14, 'Тип14', NULL);
INSERT INTO public.invoicetypes VALUES (15, 'Тип15', NULL);
INSERT INTO public.invoicetypes VALUES (2, 'Добавление товара', NULL);
INSERT INTO public.invoicetypes VALUES (0, 'Смена цен', NULL);


--
-- TOC entry 5865 (class 0 OID 17171)
-- Dependencies: 324
-- Data for Name: jobcheck; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5997 (class 0 OID 24578)
-- Dependencies: 463
-- Data for Name: locales; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5867 (class 0 OID 17178)
-- Dependencies: 326
-- Data for Name: margin_plan; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.margin_plan VALUES (18, 5, 0, 3, '2025-09-26 09:50:46.749847', true, 5, 7);
INSERT INTO public.margin_plan VALUES (18, 5, 0, 2, '2025-09-26 10:37:36.223583', true, 5, 10);
INSERT INTO public.margin_plan VALUES (18, 10, 0, 1, '2025-09-26 09:43:31.825298', false, 2, 5);
INSERT INTO public.margin_plan VALUES (18, 0, 200, 1, '2025-09-26 11:16:05.011293', true, 2, 14);
INSERT INTO public.margin_plan VALUES (18, 7, 0, 3, '2025-09-26 10:36:29.851918', false, 6, 8);
INSERT INTO public.margin_plan VALUES (18, 3, 0, 1, '2025-09-26 10:38:07.328391', false, 3, 11);
INSERT INTO public.margin_plan VALUES (18, 0, 1, 1, '2025-09-26 12:21:14.655484', false, 3, 15);
INSERT INTO public.margin_plan VALUES (18, 0, 2, 1, '2025-09-26 12:21:26.127003', true, 3, 16);
INSERT INTO public.margin_plan VALUES (18, 0, 200, 2, '2025-09-26 09:48:59.838541', false, 6, 6);
INSERT INTO public.margin_plan VALUES (18, 1, 0, 2, '2025-09-26 12:21:38.359369', true, 6, 17);
INSERT INTO public.margin_plan VALUES (18, 0, 7, 3, '2025-09-26 10:37:16.241094', false, 7, 9);
INSERT INTO public.margin_plan VALUES (18, 3, 0, 3, '2025-09-26 10:52:10.26829', false, 7, 12);
INSERT INTO public.margin_plan VALUES (18, 3, 0, 3, '2025-09-26 11:15:26.982803', false, 7, 13);
INSERT INTO public.margin_plan VALUES (18, 0, 11, 3, '2025-09-26 12:21:53.7079', true, 7, 18);


--
-- TOC entry 5868 (class 0 OID 17185)
-- Dependencies: 327
-- Data for Name: margin_plan_types; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.margin_plan_types VALUES (1, 'Категории', false);
INSERT INTO public.margin_plan_types VALUES (2, 'Бренд', false);
INSERT INTO public.margin_plan_types VALUES (3, 'Продукт', false);


--
-- TOC entry 5869 (class 0 OID 17189)
-- Dependencies: 328
-- Data for Name: news; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.news VALUES (1, '2025-01-11 00:00:00', 1, 'Новость1', 'Новость1');
INSERT INTO public.news VALUES (2, '2025-03-03 00:00:00', 1, 'Профилактика1', 'Профилактика1');
INSERT INTO public.news VALUES (5, '2025-11-14 11:30:30', 0, 'fgh', '2323');
INSERT INTO public.news VALUES (6, '2025-11-14 11:48:49', 2, 'ирти', '435345');
INSERT INTO public.news VALUES (7, '2025-11-14 14:12:36', 2, 'weqe', '# Добро пожаловать в мой превьюер Markdown на React!



  ## Это подзаголовок...
  ### А вот еще несколько крутых штук:
    
  Вот немного кода, `<div></div>`, между двумя обратными кавычками.
  
  ```javascript
  // это многострочный код:
  
  function ещеОдинПример(перваяСтрока, последняяСтрока) {
    if (перваяСтрока == ''```'' && последняяСтрока == ''```'') {
      return многострочныйКод;
    }
  }
  ```
    
  Вы также можете сделать текст **жирным**... вот это да!
  Или _курсивом_.
  Или... ждите... **_обоими!_**
  И не стесняйтесь ~~перечеркивать текст~~.
  
  Здесь также есть [ссылки](https://www.freecodecamp.com), и
  > Блочные цитаты!
  
  А если хотите по-настоящему развлечься, то даже таблицы:
  
  Дикий Заголовок | Безумный Заголовок | Еще один Заголовок?
  ------------ | ------------- | ------------- 
  Ваше содержимое может | быть здесь, и оно | может быть здесь....
  И здесь. | Ладно. | Думаю, мы поняли.
  
  - И, конечно, есть списки.
    - Некоторые из них маркированные.
       - С разными уровнями отступов.
          - Которые выглядят так.
  
  
  1. И есть также нумерованные списки.
  1. Используйте только 1, если хотите! 
  1. Но список продолжается...
  - Даже если вы используете дефисы или звездочки.
  * И, наконец, не забудем о встроенных изображениях:

![Пример](https://picsum.photos/400/300 "400x300")
');
INSERT INTO public.news VALUES (10, '2025-11-17 09:06:25', 1, 'dfdfg444', '
# Добро пожаловать в мой превьюер Markdown на React!


## Это подзаголовок...
### А вот еще несколько крутых штук:
  
Вот немного кода: `<div></div>`, 
  
```javascript
// это многострочный код:
  
function anotherExample(firstLine, lastLine) {
  if (firstLine == ''```'' && lastLine == ''```'') {
    return multilineCode;
  }
}
```
  
Вы также можете сделать текст **жирным**!
Или _курсивом_.
Или... ждите... **_обоими!_**!
И не стесняйтесь ~~перечеркивать текст~~.
  
Здесь также есть [ссылки](https://www.freecodecamp.com), и
> Блочные цитаты!
  
А если хотите по-настоящему развлечься, то даже таблицы:
  
Дикий Заголовок | Безумный Заголовок | Еще один Заголовок?
------------ | ------------- | ------------- 
Ваше содержимое может | быть здесь, и оно | может быть здесь....
И здесь. | Ладно. | Думаю, мы поняли.
  
- И, конечно, есть списки.
  - Некоторые из них маркированные.
     - С разными уровнями отступов.
        - Которые выглядят так.
  
  
1. И есть также нумерованные списки.
1. Используйте только 1, если хотите! 
1. Но список продолжается.
- Даже если вы используете дефисы или звездочки.
* И, наконец, не забудем о встроенных изображениях:

![Пример](https://picsum.photos/400/300 "400x300")
');


--
-- TOC entry 5870 (class 0 OID 17195)
-- Dependencies: 329
-- Data for Name: news_diary; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5873 (class 0 OID 17202)
-- Dependencies: 332
-- Data for Name: newtable1; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.newtable1 OVERRIDING SYSTEM VALUE VALUES (1, 'fgdf');
INSERT INTO public.newtable1 OVERRIDING SYSTEM VALUE VALUES (2, 'fdgdfg');


--
-- TOC entry 5787 (class 0 OID 16757)
-- Dependencies: 243
-- Data for Name: opercodes; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5875 (class 0 OID 17210)
-- Dependencies: 334
-- Data for Name: origincodes; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5877 (class 0 OID 17219)
-- Dependencies: 336
-- Data for Name: p_warehouse; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5878 (class 0 OID 17222)
-- Dependencies: 337
-- Data for Name: partners; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5880 (class 0 OID 17230)
-- Dependencies: 339
-- Data for Name: pluproducts_scale; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5882 (class 0 OID 17236)
-- Dependencies: 341
-- Data for Name: point_types; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.point_types VALUES (2, 'Торговая точка', NULL);
INSERT INTO public.point_types VALUES (0, 'Центральный склад', NULL);
INSERT INTO public.point_types VALUES (1, 'Склад', NULL);


--
-- TOC entry 5884 (class 0 OID 17245)
-- Dependencies: 343
-- Data for Name: points; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.points VALUES (56, '13uu425nYAgEI95W3z43tQ==', 'NCn+GyXJGCFuDShopEDREw==', 18, 2, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (37, 'Склад точки "N2ytKHq6wEn/Xxw/srq7Vg=="', 'ZDh1MtENpgIoqjf7ohM0iw==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (53, 'Склад точки "2ChzjQ2DPghvnmii/p6NWg=="', '6meSJPWT+BzEXhCy/JOpKw==', 18, 1, NULL, NULL, NULL, true, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (39, 'Склад точки "/oX3ysg14GaCBh/jMqAVwA=="', 'Lt898lpyvBbc/BZRm2E+Eg==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (55, 'Склад точки "Z+XXl4S1AmONAvu90xErBt7XhuLWyH5GJEH6QO0uJx4="', '/Q6S9Ntwo3STx59sEriAzA==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (59, 'Склад точки "4SbsLMITPvrrnOYmexIBOg=="', '/dQZs2G6lx99uG1m1g1qiw==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (61, 'Склад точки "Q6hY5H6Dk2cbT2/44tVDOg=="', '868sovPNr/j8DdNi8/pdlg==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (57, 'Склад точки "CA6j8t4M871ExPZfM5M2lQ=="', 'NCn+GyXJGCFuDShopEDREw==', 18, 1, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (25, 'vywe8l2qxIDL+ZFiiylaRg==', 'zl25M9DAbVIZjCwQNTwUcw==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-09-23');
INSERT INTO public.points VALUES (26, 'Склад точки "vywe8l2qxIDL+ZFiiylaRg=="', 'zl25M9DAbVIZjCwQNTwUcw==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-09-23');
INSERT INTO public.points VALUES (46, 'n2FPU9N+40TNZfS8l+Nt1g==', 'FhfatmVPb5o4kHVCnDXGjA==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (29, 'Цетральный склад', NULL, 18, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-10-30');
INSERT INTO public.points VALUES (52, 'n2FPU9N+40TNZfS8l+Nt1g==', '6meSJPWT+BzEXhCy/JOpKw==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (31, 'Склад точки "Dxvn1vTQhH/uN1RfvDkKRQ=="', 'F3X/2yJxnfbUjMq0XTFbdw==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-04');
INSERT INTO public.points VALUES (62, 'nf0nEAiCPMNQD3Hvg6/YoQ==', 'ONdkCi3I+awPl2VgdpLizA==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (58, 'dpCqUoEMnN4Z2GstBD8LUA==', 'sZLQvfGb9b9D+zgwRyvZqw==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (63, 'Склад точки "/C/+eVQhnlhq+Vlq5S8wng=="', 'ONdkCi3I+awPl2VgdpLizA==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (32, '0AFcp+9jFmI95NP7apI0Jw==', '+5qEHi110HSElCwC5X4mCw==', 18, 2, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-17');
INSERT INTO public.points VALUES (33, 'Склад точки "0kbsNXK/o9qNgPYX3GSDGg=="', '+5qEHi110HSElCwC5X4mCw==', 18, 1, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-17');
INSERT INTO public.points VALUES (65, 'Склад точки "Tb8xi/KGMRVijffwGV6Bqw=="', 'TDb6QVCz9OhzS6xVsh03Ig==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (64, 'RRV8laLq1hdcexSZRbLIhJjkDRE5FgCAKeLqp2OsJvc=', 'TDb6QVCz9OhzS6xVsh03Ig==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (34, 'VmlWiP5F2+s0zcaHQt5KiQ==', 'cBAXN5nQO+KFXcjOvwMZWQ==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (35, 'Склад точки "VmlWiP5F2+s0zcaHQt5KiQ=="', 'cBAXN5nQO+KFXcjOvwMZWQ==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (67, 'Склад точки "kzKMRw5eFiKgJoZVk3y1rw=="', 'paLGrY6vin1VkFuNfh6VCg==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (40, 'rQfv5qAfv4uFVjC0yR1+TA==', 'y3AJX9fSYC0dOiGjiob8ig==', 18, 2, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (41, 'Склад точки "rQfv5qAfv4uFVjC0yR1+TA=="', 'y3AJX9fSYC0dOiGjiob8ig==', 18, 1, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (38, '/thnKcjD4ooemFUDw6UJ8g==', 'Lt898lpyvBbc/BZRm2E+Eg==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (66, 'vyRibIyz6R14vuDImlNhsg==', 'paLGrY6vin1VkFuNfh6VCg==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (23, 'rOs6Tf8PjgNHEuap+Hb/ug==', 'oufYyVBX2/LqJtLk1mbuYg==', 18, 2, NULL, NULL, NULL, true, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-09-23');
INSERT INTO public.points VALUES (48, 'OWXmGBXli0pv96JB+Jf389U+5IBpe3Hj/BMSbM47Q/Q=', 'F9Y3UlwLP0xBK8WbKu+f2Q==', 18, 2, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (24, 'Склад точки "4lGxLWNwOKzUFsMkO6Xx/g=="', 'oufYyVBX2/LqJtLk1mbuYg==', 18, 1, NULL, NULL, NULL, true, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-09-23');
INSERT INTO public.points VALUES (30, 'r+GUFkLRV7DLESIAu81ArQ==', 'F3X/2yJxnfbUjMq0XTFbdw==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-04');
INSERT INTO public.points VALUES (68, 'LCGSKo8NyV78F8atjFcDpQ==', 'lukZxl4vzFDXADzBnV77NQ==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (69, 'Склад точки "Rm5jwNES1Vots1L7HupZHQ=="', 'lukZxl4vzFDXADzBnV77NQ==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (54, 'Z+XXl4S1AmONAvu90xErBt7XhuLWyH5GJEH6QO0uJx4=', '/Q6S9Ntwo3STx59sEriAzA==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (42, 'qKeLu+/fgX5qXUJFXd/A4A==', 'SBiOa9ZD96wozpAcCsMslw==', 18, 2, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (43, 'Склад точки "qKeLu+/fgX5qXUJFXd/A4A=="', 'SBiOa9ZD96wozpAcCsMslw==', 18, 1, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (44, 'ZnrZPv4XfE+ZaNa2RMrJOQ==', 'lvkPGtqps4qa3haFI3jh7g==', 18, 2, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (45, 'Склад точки "C8/b/M9AyT2eEuBMVMe/sg=="', 'lvkPGtqps4qa3haFI3jh7g==', 18, 1, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (47, 'Склад точки "urans6tmzKF48u8nW0H+iQ=="', 'FhfatmVPb5o4kHVCnDXGjA==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (70, '8XdKbgMoBwx4Hd2YFdA31w==', 'qFcc2JP0X1iQCM0NJ5dNGA==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (71, 'Склад точки "YIeyGoZxZQ8Ev3t1GdwTeg=="', 'qFcc2JP0X1iQCM0NJ5dNGA==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (60, 'Q6hY5H6Dk2cbT2/44tVDOg==', '868sovPNr/j8DdNi8/pdlg==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (73, 'Склад точки "C5raLWIVVk4JX4BYmW0I1w=="', '6hP9SYGQQ6vodu5o/Gxxwg==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (49, 'Склад точки "yz6wCsQFqfsdoO3bzJog8w=="', 'F9Y3UlwLP0xBK8WbKu+f2Q==', 18, 1, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (74, 'fijQW5pOLNbs4V2Z7H67fQ==', 'aSyswzz3CO1vYQwx3PX2ow==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (50, 'D8FF8WvV/Kqj2ORVM4y+Pg==', 'lvkPGtqps4qa3haFI3jh7g==', 18, 2, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (51, 'Склад точки "s33xEOkBgn4CdA7jeqcBzw=="', 'lvkPGtqps4qa3haFI3jh7g==', 18, 1, NULL, NULL, NULL, false, 'CLOSE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (75, 'Склад точки "z2Vphf1TaMG5+4i8NUM1kA=="', 'aSyswzz3CO1vYQwx3PX2ow==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (72, 'C5raLWIVVk4JX4BYmW0I1w==', '6hP9SYGQQ6vodu5o/Gxxwg==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (76, 'BoNSU+2NpV4Ss+S+TfUb4A==', 'lPqFuBJvUGbr/0pAKBJ66g==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (77, 'Склад точки "Xrn4EseHhYsW2GDW44e5vA=="', 'lPqFuBJvUGbr/0pAKBJ66g==', 18, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (36, 'N2ytKHq6wEn/Xxw/srq7Vg==', 'ZDh1MtENpgIoqjf7ohM0iw==', 18, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-18');
INSERT INTO public.points VALUES (78, 'Центральный склад', 'JniG4vHdxfdkb7wZksTjcA==', 172, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-19');
INSERT INTO public.points VALUES (79, 'Центральный склад', 'JniG4vHdxfdkb7wZksTjcA==', 176, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-19');
INSERT INTO public.points VALUES (80, 'Центральный склад', 'nEq7EsbbPM1Zkb7xo+GIXQ==', 178, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-19');
INSERT INTO public.points VALUES (82, 'Центральный склад', 'eYakzEtqsAs9XI3jj+JcBg==', 181, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-19');
INSERT INTO public.points VALUES (81, 'Центральный склад', 'kSsFUdsDgaV1oMgJ6FBkdQ==', 179, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-19');
INSERT INTO public.points VALUES (83, 'Центральный склад', 'iuqSoaWgV1bPzFjpvuX3yA==', 182, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-20');
INSERT INTO public.points VALUES (84, 'Центральный склад', '13uu425nYAgEI95W3z43tQ==', 183, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-20');
INSERT INTO public.points VALUES (85, 'Центральный склад', '13uu425nYAgEI95W3z43tQ==', 184, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-20');
INSERT INTO public.points VALUES (86, 'Центральный склад', '13uu425nYAgEI95W3z43tQ==', 185, 0, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-20');
INSERT INTO public.points VALUES (87, 'vX4wnnH9WEYJZCHq/ej27w==', 'pV/06D2slXiZdSpliduNbw==', 185, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-21');
INSERT INTO public.points VALUES (88, 'Склад точки "vX4wnnH9WEYJZCHq/ej27w=="', 'pV/06D2slXiZdSpliduNbw==', 185, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-21');
INSERT INTO public.points VALUES (89, 'fusVp7bMPKMqIHycIv3JVA==', 'zKBpRKWLeaaHt4HAqytJ6A==', 185, 2, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-21');
INSERT INTO public.points VALUES (90, 'Склад точки "fusVp7bMPKMqIHycIv3JVA=="', 'zKBpRKWLeaaHt4HAqytJ6A==', 185, 1, NULL, NULL, NULL, false, 'ACTIVE', false, false, NULL, NULL, NULL, NULL, '2025-11-21');


--
-- TOC entry 5886 (class 0 OID 17257)
-- Dependencies: 345
-- Data for Name: pointset; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.pointset VALUES (23, 24);
INSERT INTO public.pointset VALUES (25, 26);
INSERT INTO public.pointset VALUES (30, 31);
INSERT INTO public.pointset VALUES (32, 33);
INSERT INTO public.pointset VALUES (34, 35);
INSERT INTO public.pointset VALUES (36, 37);
INSERT INTO public.pointset VALUES (38, 39);
INSERT INTO public.pointset VALUES (40, 41);
INSERT INTO public.pointset VALUES (42, 43);
INSERT INTO public.pointset VALUES (44, 45);
INSERT INTO public.pointset VALUES (46, 47);
INSERT INTO public.pointset VALUES (48, 49);
INSERT INTO public.pointset VALUES (50, 51);
INSERT INTO public.pointset VALUES (52, 53);
INSERT INTO public.pointset VALUES (54, 55);
INSERT INTO public.pointset VALUES (56, 57);
INSERT INTO public.pointset VALUES (58, 59);
INSERT INTO public.pointset VALUES (60, 61);
INSERT INTO public.pointset VALUES (62, 63);
INSERT INTO public.pointset VALUES (64, 65);
INSERT INTO public.pointset VALUES (66, 67);
INSERT INTO public.pointset VALUES (68, 69);
INSERT INTO public.pointset VALUES (70, 71);
INSERT INTO public.pointset VALUES (72, 73);
INSERT INTO public.pointset VALUES (74, 75);
INSERT INTO public.pointset VALUES (76, 77);
INSERT INTO public.pointset VALUES (78, 78);
INSERT INTO public.pointset VALUES (79, 79);
INSERT INTO public.pointset VALUES (80, 80);
INSERT INTO public.pointset VALUES (81, 81);
INSERT INTO public.pointset VALUES (82, 82);
INSERT INTO public.pointset VALUES (29, 29);
INSERT INTO public.pointset VALUES (83, 83);
INSERT INTO public.pointset VALUES (84, 84);
INSERT INTO public.pointset VALUES (85, 85);
INSERT INTO public.pointset VALUES (86, 86);
INSERT INTO public.pointset VALUES (87, 88);
INSERT INTO public.pointset VALUES (89, 90);


--
-- TOC entry 5887 (class 0 OID 17260)
-- Dependencies: 346
-- Data for Name: prices; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5889 (class 0 OID 17266)
-- Dependencies: 348
-- Data for Name: prices_log; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5894 (class 0 OID 17322)
-- Dependencies: 356
-- Data for Name: product_accounting; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.product_accounting VALUES (23, 500, 51, 1, '2025-10-03 17:48:43.7814', 0, 18);
INSERT INTO public.product_accounting VALUES (24, 10100, 52, 1, '2025-10-03 17:48:43.7814', 0, 18);
INSERT INTO public.product_accounting VALUES (25, 500, 51, 1, '2025-10-03 17:52:56.8584', 0, 18);
INSERT INTO public.product_accounting VALUES (26, 10100, 52, 1, '2025-10-03 17:52:56.8584', 0, 18);
INSERT INTO public.product_accounting VALUES (27, 20, 66, 1, '2025-10-13 14:47:03.5452', 0, 18);
INSERT INTO public.product_accounting VALUES (28, 1, 68, 3, '2025-10-13 14:49:49.4771', 0, 18);
INSERT INTO public.product_accounting VALUES (29, 40, 67, 2, '2025-10-13 14:49:49.4771', 0, 18);
INSERT INTO public.product_accounting VALUES (30, 1, 68, 1, '2025-10-13 15:32:24.6786', 0, 18);
INSERT INTO public.product_accounting VALUES (31, 4, 68, 3, '2025-10-13 15:33:28.6184', 0, 18);
INSERT INTO public.product_accounting VALUES (32, 2, 69, 4, '2025-10-13 15:34:34.8857', 0, 18);
INSERT INTO public.product_accounting VALUES (33, 2, 69, 33, '2025-10-13 16:28:32.5728', 0, 18);
INSERT INTO public.product_accounting VALUES (34, 3, 70, 2, '2025-10-13 16:29:29.0749', 0, 18);
INSERT INTO public.product_accounting VALUES (35, 2, 71, 4, '2025-10-13 16:30:44.8972', 0, 18);
INSERT INTO public.product_accounting VALUES (36, 2, 72, 3, '2025-10-13 17:03:04.384', 0, 18);
INSERT INTO public.product_accounting VALUES (37, 2, 73, 2, '2025-10-14 09:26:56.2757', 0, 18);
INSERT INTO public.product_accounting VALUES (38, 23, 75, 1, '2025-10-14 10:22:27.9128', 0, 18);
INSERT INTO public.product_accounting VALUES (39, 23, 75, 4, '2025-10-14 12:35:57.4132', 0, 18);
INSERT INTO public.product_accounting VALUES (40, 22, 80, 7, '2025-10-14 12:35:57.4132', 0, 18);
INSERT INTO public.product_accounting VALUES (41, 2, 92, 5, '2025-10-14 14:32:31.9325', 0, 18);
INSERT INTO public.product_accounting VALUES (42, 23, 75, 5, '2025-10-14 14:37:55.8291', 0, 18);
INSERT INTO public.product_accounting VALUES (43, 23, 75, 3, '2025-10-23 17:51:34.5121', 0, 18);
INSERT INTO public.product_accounting VALUES (44, 100, 151, 2, '2025-10-23 17:52:28.9702', 0, 18);
INSERT INTO public.product_accounting VALUES (45, 100, 152, 1, '2025-10-24 09:59:11.4261', 0, 18);
INSERT INTO public.product_accounting VALUES (46, 2, 160, 4, '2025-10-29 09:27:50.8028', 0, 18);
INSERT INTO public.product_accounting VALUES (47, 2, 114, 3, '2025-10-29 09:27:50.8028', 0, 18);
INSERT INTO public.product_accounting VALUES (48, 100, 153, 3, '2025-10-29 09:27:50.8028', 0, 18);
INSERT INTO public.product_accounting VALUES (49, 100, 153, 0, '2025-10-29 09:35:31.9282', 0, 18);
INSERT INTO public.product_accounting VALUES (50, 100, 153, 0, '2025-10-29 09:36:51.2369', 0, 18);
INSERT INTO public.product_accounting VALUES (51, 2, 114, 0, '2025-10-29 09:40:01.1027', 0, 18);
INSERT INTO public.product_accounting VALUES (52, 2, 114, 0, '2025-10-29 09:40:59.8873', 0, 18);
INSERT INTO public.product_accounting VALUES (53, 2, 114, 3, '2025-10-29 09:50:02.7839', 0, 18);
INSERT INTO public.product_accounting VALUES (54, 100, 110, 3, '2025-10-29 10:08:40.7933', 0, 18);
INSERT INTO public.product_accounting VALUES (55, 100, 110, 4, '2025-10-29 10:14:39.3471', 0, 18);
INSERT INTO public.product_accounting VALUES (56, 2, 114, 1, '2025-10-29 12:57:58.0478', 65, 18);
INSERT INTO public.product_accounting VALUES (61, 100, 152, 2, '2025-10-30 09:56:21.4574', 0, 18);
INSERT INTO public.product_accounting VALUES (62, 2, 160, 2, '2025-10-30 10:25:10.3547', 70, 18);
INSERT INTO public.product_accounting VALUES (63, 2105, 111, 2, '2025-10-30 10:25:10.3547', 0, 18);
INSERT INTO public.product_accounting VALUES (64, 2105, 111, 2, '2025-10-30 15:11:02.9808', 0, 18);
INSERT INTO public.product_accounting VALUES (65, 2, 160, 2, '2025-10-30 15:11:02.9808', 0, 18);
INSERT INTO public.product_accounting VALUES (66, 2, 160, 1, '2025-10-31 10:39:46.1799', 0, 18);
INSERT INTO public.product_accounting VALUES (67, 100, 164, 1, '2025-10-31 10:39:46.1799', 73, 18);
INSERT INTO public.product_accounting VALUES (68, 2, 160, 5, '2025-11-05 12:27:50.0114', 0, 18);
INSERT INTO public.product_accounting VALUES (69, 2, 114, 10, '2025-11-05 12:27:50.0114', 0, 18);
INSERT INTO public.product_accounting VALUES (70, 23, 75, 5, '2025-11-07 09:29:14.6878', 0, 18);
INSERT INTO public.product_accounting VALUES (71, 200, 160, 1, '2025-11-10 14:53:13.7851', 0, 18);
INSERT INTO public.product_accounting VALUES (72, 500, 166, 10, '2025-11-21 12:55:55.0542', 0, 185);
INSERT INTO public.product_accounting VALUES (73, 150, 167, 5, '2025-11-21 12:55:55.0542', 0, 185);
INSERT INTO public.product_accounting VALUES (74, 100, 178, 2, '2025-11-21 17:02:58.9218', 0, 185);
INSERT INTO public.product_accounting VALUES (75, 2, 182, 1, '2025-11-24 09:20:20.8113', 0, 184);
INSERT INTO public.product_accounting VALUES (76, 3, 183, 1, '2025-11-24 09:20:20.8113', 0, 184);
INSERT INTO public.product_accounting VALUES (77, 1, 184, 3, '2025-11-24 09:20:20.8113', 0, 184);


--
-- TOC entry 6084 (class 0 OID 57427)
-- Dependencies: 571
-- Data for Name: product_count; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.product_count VALUES (0);


--
-- TOC entry 5896 (class 0 OID 17327)
-- Dependencies: 358
-- Data for Name: product_static_prices; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.product_static_prices VALUES (5, 1055, 18);
INSERT INTO public.product_static_prices VALUES (66, 30, 18);


--
-- TOC entry 5857 (class 0 OID 17108)
-- Dependencies: 314
-- Data for Name: products; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.products VALUES (157, '200000000087', 'егнгн8', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (158, '200000000089', 'екнке', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (159, '200000000090', 'ененг7', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (66, '0000001', 'ertert', 0, 0, NULL, 18, NULL, 0, 0, 0, false, true, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (161, '200000000092', 'рпопро', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (162, '200000000093', 'tyhgj7', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (111, '200000000049', 'fdgfd', 0, 1, NULL, 18, '1', 0, 0, 0, true, false, 2, false, true, 10, 0, 0);
INSERT INTO public.products VALUES (164, '200000000095', 'gfhfg9', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (165, '200000000096', 'rtyrty7', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (160, '200000000091', 'Продукт2 один два три четыре пять шесть семь восемь девять 1', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 76, 0);
INSERT INTO public.products VALUES (166, '200000000097', 'Тестовый товар 2', 0, 0, NULL, 185, NULL, 7, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (167, '200000000098', 'Вода газированная', 0, 0, NULL, 185, NULL, 8, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (168, '200000000098', 'паввапва', 0, 0, NULL, 181, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (169, '200000000099', 'авав', 0, 0, NULL, 181, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (51, '2000000000452', 'Подарочный сертификат 500', 0, 0, NULL, 18, NULL, 0, 0, 1, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (52, '2000000000462', 'Подарочный сертификат 10100', 0, 0, NULL, 18, NULL, 0, 0, 1, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (171, '200000000102', 'впа', 0, 0, NULL, 181, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (170, '200000000101', 'прар', 0, 0, NULL, 181, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (178, '200000000106', 'bfghgf', 0, 0, NULL, 185, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (179, '200000000107', 'erewr', 0, 0, NULL, 184, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (180, '0000001', 'fghfgh', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (182, '0000003', '4', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (183, '0000002', 'fgh', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (184, '0000004', 'retretre', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (190, '0000007', 'кекук', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (191, '0000008', '56', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (5, '2000013330462', 'Продукт1', -1, 1, NULL, 18, NULL, 2, 7, 0, true, true, 2, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (69, '0000001', 'tghf11', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (7, '4602565038991', 'Лекарство1', 2, 1, NULL, 18, NULL, 2, 8, 0, false, false, 2, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (75, '0000004', 'jutyuty', 3, 1, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (53, '0000003', 'пр', 49, 1, NULL, 18, NULL, 2, 0, 0, false, false, 2, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (70, '0000005', 'аврапр', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (71, '0000005', 'апрпар', 0, 1, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (72, '0000005', 'fdf7689', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (68, '0000004', 'jhkk', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (73, '0000006', 'ghjgh22', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (80, '0000005', 'fgddfg25', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (67, '0000002', 'tyutyu', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (92, '0000002', 'цуку5', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (98, '100005', 'rty22', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (6, '6971144013901', 'Мясо', -1, 1, NULL, 18, NULL, 2, 8, 0, true, false, 2, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (99, '100005', 'куеук55', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (101, '100005', 'рпроп', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (100, '100005', 'рапр', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (102, '100005', 'екнк4', 0, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (138, '200000000081', 'енгенг8', 3, 0, NULL, 18, '3234', 6, 0, 0, true, false, 1, false, false, 0, 49, 50);
INSERT INTO public.products VALUES (137, '200000000078', 'апрпа7', 3, 1, NULL, 18, '3', 6, 8, 0, true, false, 2, true, true, 2, 45, 46);
INSERT INTO public.products VALUES (132, '200000000073', 'пгнге778', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 2, true, true, 4, 33, 34);
INSERT INTO public.products VALUES (133, '200000000074', 'weq8877y', 0, 0, NULL, 18, NULL, 0, 8, 0, true, false, 1, false, false, 0, 41, 42);
INSERT INTO public.products VALUES (104, '100001', 'ert1447787г56п', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (129, '200000000070', 'fghfg7', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (134, '200000000075', 'ранек', 0, 1, NULL, 18, NULL, 6, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (105, '100003', 'авпав1', -1, 1, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (103, '100006', 'гншг7', 2, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (109, '200000000047', 'ене', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (110, '200000000048', 'fghfghfg', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (112, '200000000051', 'yut78', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (113, '200000000052', 'jghjg', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (135, '100003', 'енген', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (114, '200000000053', 'fdg', 3, 1, NULL, 18, '23', 6, 0, 0, true, false, 2, false, true, 2, 0, 0);
INSERT INTO public.products VALUES (136, '200000000077', 'енгенгне8', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (121, '200000000061', 'екен', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (120, '200000000060', 'имти', 29, 1, NULL, 18, '3', 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (119, '200000000059', 'прпо', 22, 1, NULL, 18, NULL, 6, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (139, '200000000082', 'пропр', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (122, '200000000062', 'нген', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (118, '200000000058', 'прапр', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (117, '200000000057', 'рапр', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 2, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (116, '200000000056', 'ене1', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 2, true, true, 2, 0, 0);
INSERT INTO public.products VALUES (115, '200000000055', 'fg', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 2, true, true, 2, 0, 0);
INSERT INTO public.products VALUES (123, '200000000063', 'уке', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (140, '100003', 'пав', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (141, '100004', 'екн', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (142, '100005', '1', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (143, '100006', '2', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (144, '100007', '3', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (145, '100008', '4', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (126, '200000000066', 'цук7788', 3, 1, NULL, 18, '77', 5, 0, 0, true, false, 1, true, false, 0, 25, 26);
INSERT INTO public.products VALUES (125, '200000000065', 'рорпо9', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (124, '200000000064', 'уке33', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 3, 2);
INSERT INTO public.products VALUES (127, '200000000067', 'rtet', 0, 0, NULL, 18, NULL, 0, 7, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (128, '200000000069', 'генг', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (147, '100010', '8', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (130, '200000000071', 'опро', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (146, '100009', '5', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (131, '200000000072', 'нгшн', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, true, false, 0, 0, 0);
INSERT INTO public.products VALUES (148, '100009', '435', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (149, '100010', '768', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (151, '0000002', '34er', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (152, '0000011', 'куекуе909', -1, 0, NULL, 18, NULL, 0, 0, 0, false, false, 6, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (153, '200000000083', 'hfgh77', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (154, '200000000084', 'retert88', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (155, '200000000085', 'tghf9', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (156, '200000000086', 'гншнг9', 0, 1, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);
INSERT INTO public.products VALUES (163, '200000000094', 'utyty99', 0, 0, NULL, 18, NULL, 0, 0, 0, true, false, 1, false, false, 0, 0, 0);


--
-- TOC entry 5897 (class 0 OID 17331)
-- Dependencies: 359
-- Data for Name: products_barcode; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.products_barcode VALUES (27, 51, '2000000000452', 18);
INSERT INTO public.products_barcode VALUES (28, 52, '2000000000462', 18);
INSERT INTO public.products_barcode VALUES (29, 66, '0000001', 18);
INSERT INTO public.products_barcode VALUES (30, 68, '0000004', 18);
INSERT INTO public.products_barcode VALUES (31, 67, '0000002', 18);
INSERT INTO public.products_barcode VALUES (32, 69, '0000001', 18);
INSERT INTO public.products_barcode VALUES (33, 70, '0000005', 18);
INSERT INTO public.products_barcode VALUES (34, 71, '0000005', 18);
INSERT INTO public.products_barcode VALUES (35, 72, '0000005', 18);
INSERT INTO public.products_barcode VALUES (36, 73, '0000006', 18);
INSERT INTO public.products_barcode VALUES (37, 75, '0000004', 18);
INSERT INTO public.products_barcode VALUES (38, 80, '0000005', 18);
INSERT INTO public.products_barcode VALUES (39, 92, '0000002', 18);
INSERT INTO public.products_barcode VALUES (40, 109, '200000000047', 18);
INSERT INTO public.products_barcode VALUES (41, 110, '200000000048', 18);
INSERT INTO public.products_barcode VALUES (42, 111, '200000000049', 18);
INSERT INTO public.products_barcode VALUES (43, 112, '200000000051', 18);
INSERT INTO public.products_barcode VALUES (44, 113, '200000000052', 18);
INSERT INTO public.products_barcode VALUES (45, 114, '200000000053', 18);
INSERT INTO public.products_barcode VALUES (46, 115, '200000000055', 18);
INSERT INTO public.products_barcode VALUES (47, 116, '200000000056', 18);
INSERT INTO public.products_barcode VALUES (48, 117, '200000000057', 18);
INSERT INTO public.products_barcode VALUES (49, 118, '200000000058', 18);
INSERT INTO public.products_barcode VALUES (50, 119, '200000000059', 18);
INSERT INTO public.products_barcode VALUES (51, 120, '200000000060', 18);
INSERT INTO public.products_barcode VALUES (52, 121, '200000000061', 18);
INSERT INTO public.products_barcode VALUES (53, 122, '200000000062', 18);
INSERT INTO public.products_barcode VALUES (54, 123, '200000000063', 18);
INSERT INTO public.products_barcode VALUES (55, 124, '200000000064', 18);
INSERT INTO public.products_barcode VALUES (56, 125, '200000000065', 18);
INSERT INTO public.products_barcode VALUES (57, 126, '200000000066', 18);
INSERT INTO public.products_barcode VALUES (59, 126, '78789', 18);
INSERT INTO public.products_barcode VALUES (61, 126, '67667', 18);
INSERT INTO public.products_barcode VALUES (65, 127, '200000000067', 18);
INSERT INTO public.products_barcode VALUES (66, 127, '576', 18);
INSERT INTO public.products_barcode VALUES (67, 128, '200000000069', 18);
INSERT INTO public.products_barcode VALUES (68, 129, '200000000070', 18);
INSERT INTO public.products_barcode VALUES (69, 130, '200000000071', 18);
INSERT INTO public.products_barcode VALUES (70, 131, '200000000072', 18);
INSERT INTO public.products_barcode VALUES (71, 132, '200000000073', 18);
INSERT INTO public.products_barcode VALUES (72, 132, '213', 18);
INSERT INTO public.products_barcode VALUES (73, 133, '200000000074', 18);
INSERT INTO public.products_barcode VALUES (74, 133, '789789', 18);
INSERT INTO public.products_barcode VALUES (75, 133, '3454', 18);
INSERT INTO public.products_barcode VALUES (76, 134, '200000000075', 18);
INSERT INTO public.products_barcode VALUES (77, 136, '200000000077', 18);
INSERT INTO public.products_barcode VALUES (78, 137, '200000000078', 18);
INSERT INTO public.products_barcode VALUES (79, 138, '200000000081', 18);
INSERT INTO public.products_barcode VALUES (80, 138, '345', 18);
INSERT INTO public.products_barcode VALUES (81, 138, '787898', 18);
INSERT INTO public.products_barcode VALUES (82, 139, '200000000082', 18);
INSERT INTO public.products_barcode VALUES (83, 151, '0000002', 18);
INSERT INTO public.products_barcode VALUES (84, 152, '0000011', 18);
INSERT INTO public.products_barcode VALUES (85, 153, '200000000083', 18);
INSERT INTO public.products_barcode VALUES (86, 154, '200000000084', 18);
INSERT INTO public.products_barcode VALUES (87, 155, '200000000085', 18);
INSERT INTO public.products_barcode VALUES (88, 156, '200000000086', 18);
INSERT INTO public.products_barcode VALUES (89, 157, '200000000087', 18);
INSERT INTO public.products_barcode VALUES (90, 158, '200000000089', 18);
INSERT INTO public.products_barcode VALUES (91, 159, '200000000090', 18);
INSERT INTO public.products_barcode VALUES (92, 160, '200000000091', 18);
INSERT INTO public.products_barcode VALUES (93, 161, '200000000092', 18);
INSERT INTO public.products_barcode VALUES (94, 162, '200000000093', 18);
INSERT INTO public.products_barcode VALUES (95, 163, '200000000094', 18);
INSERT INTO public.products_barcode VALUES (96, 164, '200000000095', 18);
INSERT INTO public.products_barcode VALUES (97, 165, '200000000096', 18);
INSERT INTO public.products_barcode VALUES (98, 168, '200000000098', 181);
INSERT INTO public.products_barcode VALUES (99, 169, '200000000099', 181);
INSERT INTO public.products_barcode VALUES (100, 170, '200000000101', 181);
INSERT INTO public.products_barcode VALUES (101, 171, '200000000102', 181);
INSERT INTO public.products_barcode VALUES (102, 178, '200000000106', 185);
INSERT INTO public.products_barcode VALUES (103, 179, '200000000107', 184);
INSERT INTO public.products_barcode VALUES (104, 182, '0000003', 184);
INSERT INTO public.products_barcode VALUES (105, 183, '0000002', 184);
INSERT INTO public.products_barcode VALUES (106, 184, '0000004', 184);


--
-- TOC entry 5901 (class 0 OID 17343)
-- Dependencies: 363
-- Data for Name: products_spr; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5902 (class 0 OID 17350)
-- Dependencies: 364
-- Data for Name: products_temp; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.products_temp VALUES (186, '0000006', 'fdgfdgf', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, '[]', 0, 0);
INSERT INTO public.products_temp VALUES (187, '0000005', 'ert', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, '[]', 0, 0);
INSERT INTO public.products_temp VALUES (192, '0000009', 'вапв', -1, 0, NULL, 184, NULL, 0, 0, 0, false, false, 6, false, false, 0, '[]', 0, 0);


--
-- TOC entry 5904 (class 0 OID 17370)
-- Dependencies: 366
-- Data for Name: products_weight; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5906 (class 0 OID 17379)
-- Dependencies: 368
-- Data for Name: promconditions; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.promconditions VALUES (1, 2, 5, 3, 18);
INSERT INTO public.promconditions VALUES (2, 1, 6, 1, 18);
INSERT INTO public.promconditions VALUES (8, 2, 0, 2, 18);
INSERT INTO public.promconditions VALUES (9, 1, 6, 3, 18);
INSERT INTO public.promconditions VALUES (10, 2, 0, 3, 18);
INSERT INTO public.promconditions VALUES (11, 2, 0, 2, 18);
INSERT INTO public.promconditions VALUES (12, 2, 0, 4, 18);
INSERT INTO public.promconditions VALUES (13, 2, 0, 2, 18);
INSERT INTO public.promconditions VALUES (14, 2, 0, 4, 18);
INSERT INTO public.promconditions VALUES (15, 2, 0, 4, 18);
INSERT INTO public.promconditions VALUES (16, 1, 6, 2, 18);
INSERT INTO public.promconditions VALUES (16, 1, 51, 3, 18);
INSERT INTO public.promconditions VALUES (17, 1, 6, 2, 18);
INSERT INTO public.promconditions VALUES (18, 2, 0, 2, 18);
INSERT INTO public.promconditions VALUES (19, 1, 80, 1, 18);


--
-- TOC entry 5907 (class 0 OID 17383)
-- Dependencies: 369
-- Data for Name: promconditionstype; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.promconditionstype VALUES (1, 'За комплект', false);
INSERT INTO public.promconditionstype VALUES (2, 'За разовый объем продаж', false);


--
-- TOC entry 5908 (class 0 OID 17387)
-- Dependencies: 370
-- Data for Name: promdiscounts; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.promdiscounts VALUES (1, 2, 6, 1, 18);
INSERT INTO public.promdiscounts VALUES (2, 1, 5, 2, 18);
INSERT INTO public.promdiscounts VALUES (8, 2, 0, 4, 18);
INSERT INTO public.promdiscounts VALUES (9, 1, 5, 4, 18);
INSERT INTO public.promdiscounts VALUES (10, 2, 0, 4, 18);
INSERT INTO public.promdiscounts VALUES (11, 3, 5, 1, 18);
INSERT INTO public.promdiscounts VALUES (12, 2, 0, 5, 18);
INSERT INTO public.promdiscounts VALUES (13, 2, 0, 3, 18);
INSERT INTO public.promdiscounts VALUES (14, 2, 0, 5, 18);
INSERT INTO public.promdiscounts VALUES (15, 2, 0, 5, 18);
INSERT INTO public.promdiscounts VALUES (16, 1, 5, 3, 18);
INSERT INTO public.promdiscounts VALUES (17, 1, 5, 4, 18);
INSERT INTO public.promdiscounts VALUES (18, 2, 0, 3, 18);
INSERT INTO public.promdiscounts VALUES (19, 1, 153, 2, 18);


--
-- TOC entry 5909 (class 0 OID 17391)
-- Dependencies: 371
-- Data for Name: promdiscountstype; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.promdiscountstype VALUES (1, 'Скидка на позицию', false);
INSERT INTO public.promdiscountstype VALUES (2, 'Скидка(в тенге) на общую сумму чека', false);
INSERT INTO public.promdiscountstype VALUES (3, 'Подарок', false);


--
-- TOC entry 5913 (class 0 OID 17401)
-- Dependencies: 375
-- Data for Name: promotions; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.promotions VALUES (1, 18, 23, 'йц', '2025-10-08', '2025-10-18', 1, 1, true, 0);
INSERT INTO public.promotions VALUES (2, 18, 25, 'цук', '2025-10-09', '2025-10-24', 2, 2, false, 0);
INSERT INTO public.promotions VALUES (3, 18, 25, 'нрег', '2025-10-09', '2025-10-24', 3, 3, false, 0);
INSERT INTO public.promotions VALUES (4, 18, 25, 'yutu', '2025-10-09', '2025-10-23', 4, 4, false, 0);
INSERT INTO public.promotions VALUES (8, 18, 25, 'ewrw', '2025-10-09', '2025-10-24', 8, 8, false, 0);
INSERT INTO public.promotions VALUES (9, 18, 25, 'куе', '2025-10-09', '2025-10-31', 9, 9, false, 0);
INSERT INTO public.promotions VALUES (10, 18, 25, 'апва', '2025-10-09', '2025-10-31', 10, 10, false, 0);
INSERT INTO public.promotions VALUES (11, 18, 25, 'апр', '2025-10-09', '2025-10-24', 11, 11, false, 0);
INSERT INTO public.promotions VALUES (12, 18, 25, 'авп', '2025-10-09', '2025-10-24', 12, 12, false, 0);
INSERT INTO public.promotions VALUES (13, 18, 25, 'wer', '2025-10-09', '2025-10-31', 13, 13, false, 0);
INSERT INTO public.promotions VALUES (14, 18, 25, 'rtyr', '2025-10-09', '2025-10-31', 14, 14, false, 0);
INSERT INTO public.promotions VALUES (15, 18, 25, 'кен', '2025-10-09', '2025-10-09', 15, 15, false, 0);
INSERT INTO public.promotions VALUES (16, 18, 25, 'уцкцу', '2025-10-09', '2025-10-09', 16, 16, false, 0);
INSERT INTO public.promotions VALUES (17, 18, 25, 'ыкаы', '2025-10-09', '2025-10-09', 17, 17, true, 1);
INSERT INTO public.promotions VALUES (18, 18, 25, 'кен', '2025-10-10', '2025-10-10', 18, 18, false, 0);
INSERT INTO public.promotions VALUES (19, 18, 23, 'рап', '2025-10-16', '2025-11-12', 19, 19, false, 0);


--
-- TOC entry 5914 (class 0 OID 17409)
-- Dependencies: 376
-- Data for Name: reasontypes; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.reasontypes VALUES (100, 'Причина', false, true);
INSERT INTO public.reasontypes VALUES (1, 'Причина1', false, true);
INSERT INTO public.reasontypes VALUES (-3, 'Причина-3', false, true);
INSERT INTO public.reasontypes VALUES (-400, 'Причина4', false, true);
INSERT INTO public.reasontypes VALUES (-4, 'Причина5', false, true);
INSERT INTO public.reasontypes VALUES (-1, 'Причина6', false, true);
INSERT INTO public.reasontypes VALUES (4, 'Причина7', false, true);
INSERT INTO public.reasontypes VALUES (400, 'Причина8', false, true);
INSERT INTO public.reasontypes VALUES (2, 'Причина9', false, true);
INSERT INTO public.reasontypes VALUES (-2, 'Причина10', false, true);
INSERT INTO public.reasontypes VALUES (3, 'Причина11', false, true);
INSERT INTO public.reasontypes VALUES (-100, 'Причина12', false, true);
INSERT INTO public.reasontypes VALUES (300, 'Причина13', false, true);
INSERT INTO public.reasontypes VALUES (-300, 'Причина14', false, true);
INSERT INTO public.reasontypes VALUES (5, 'Причина15', false, true);
INSERT INTO public.reasontypes VALUES (-5, 'Причина16', false, true);
INSERT INTO public.reasontypes VALUES (500, 'Причина17', false, true);
INSERT INTO public.reasontypes VALUES (-500, 'Причина18', false, true);


--
-- TOC entry 5916 (class 0 OID 17417)
-- Dependencies: 378
-- Data for Name: reconciliation; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5917 (class 0 OID 17426)
-- Dependencies: 379
-- Data for Name: result; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5920 (class 0 OID 17436)
-- Dependencies: 382
-- Data for Name: reviselist; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5922 (class 0 OID 17444)
-- Dependencies: 384
-- Data for Name: revision_diary; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5923 (class 0 OID 17454)
-- Dependencies: 385
-- Data for Name: revision_difference; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5925 (class 0 OID 17462)
-- Dependencies: 387
-- Data for Name: revision_list; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.revision_list VALUES (1, 2, 30, 18, '2025-11-05 12:28:28.760554', NULL, 'CANCELLED', NULL, 42, 4, NULL);
INSERT INTO public.revision_list VALUES (2, 3, 30, 18, '2025-11-05 12:52:29.820757', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (3, 4, 30, 18, '2025-11-05 12:54:02.991933', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (4, 5, 30, 18, '2025-11-05 12:56:08.367797', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (5, 6, 30, 18, '2025-11-05 12:59:50.664987', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (6, 7, 31, 18, '2025-11-05 14:11:39.796605', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (7, 8, 31, 18, '2025-11-05 14:16:36.532123', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (8, 9, 31, 18, '2025-11-05 14:20:35.340617', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (9, 10, 31, 18, '2025-11-05 14:30:26.758566', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (10, 11, 31, 18, '2025-11-05 14:32:13.460592', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (11, 12, 31, 18, '2025-11-05 14:33:12.329149', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (12, 13, 31, 18, '2025-11-05 14:33:29.284399', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (13, 14, 31, 18, '2025-11-05 14:34:23.011103', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (14, 15, 31, 18, '2025-11-05 14:37:37.168044', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (15, 16, 31, 18, '2025-11-05 14:43:14.640675', NULL, 'CANCELLED', NULL, 42, 1, NULL);
INSERT INTO public.revision_list VALUES (16, 17, 31, 18, '2025-11-05 16:50:00.899971', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (17, 18, 31, 18, '2025-11-05 16:52:03.240286', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (18, 19, 31, 18, '2025-11-05 16:53:20.357279', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (19, 20, 31, 18, '2025-11-05 17:00:31.654864', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (20, 21, 31, 18, '2025-11-05 17:03:05.203982', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (21, 22, 31, 18, '2025-11-05 17:03:19.73769', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (22, 23, 31, 18, '2025-11-05 17:08:07.473696', NULL, 'CANCELLED', NULL, 42, 1, NULL);
INSERT INTO public.revision_list VALUES (23, 24, 31, 18, '2025-11-05 17:08:29.936519', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (24, 25, 31, 18, '2025-11-05 17:12:07.315581', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (25, 26, 31, 18, '2025-11-05 17:14:55.305749', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (26, 27, 31, 18, '2025-11-05 17:15:07.015429', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (27, 28, 31, 18, '2025-11-05 17:19:27.954896', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (28, 29, 31, 18, '2025-11-05 17:28:04.505035', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (29, 30, 31, 18, '2025-11-05 17:28:19.489425', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (30, 31, 31, 18, '2025-11-05 17:29:34.748637', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (31, 32, 31, 18, '2025-11-05 17:30:00.311061', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (32, 33, 31, 18, '2025-11-05 17:51:04.844806', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (33, 34, 31, 18, '2025-11-05 17:52:14.333664', NULL, 'CANCELLED', NULL, 42, 2, NULL);
INSERT INTO public.revision_list VALUES (34, 35, 31, 18, '2025-11-05 17:56:21.758273', NULL, 'CANCELLED', NULL, 42, 3, 2);
INSERT INTO public.revision_list VALUES (35, 36, 31, 18, '2025-11-05 17:57:45.313641', NULL, 'CANCELLED', NULL, 42, 4, 6);
INSERT INTO public.revision_list VALUES (36, 37, 31, 18, '2025-11-06 09:36:44.645584', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (37, 38, 31, 18, '2025-11-06 09:37:48.685916', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (39, 40, 24, 18, '2025-11-06 09:44:00.116774', NULL, 'CANCELLED', NULL, 42, 4, 8);
INSERT INTO public.revision_list VALUES (40, 41, 24, 18, '2025-11-06 09:53:35.795696', NULL, 'CANCELLED', NULL, 42, 3, 58);
INSERT INTO public.revision_list VALUES (41, 42, 24, 18, '2025-11-06 09:59:48.033896', NULL, 'CANCELLED', NULL, 42, 3, 58);
INSERT INTO public.revision_list VALUES (38, 39, 31, 18, '2025-11-06 09:39:23.556051', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (42, 43, 24, 18, '2025-11-06 14:47:42.002307', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (43, 44, 31, 18, '2025-11-06 14:52:44.115582', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (44, 45, 31, 18, '2025-11-06 15:04:56.456668', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (45, 46, 31, 18, '2025-11-07 11:22:19.708614', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (46, 47, 31, 18, '2025-11-07 11:22:38.78143', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (47, 48, 31, 18, '2025-11-07 11:34:44.95792', NULL, 'CANCELLED', NULL, 42, 3, NULL);
INSERT INTO public.revision_list VALUES (48, 49, 31, 18, '2025-11-07 12:12:58.784399', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (49, 50, 31, 18, '2025-11-07 12:46:13.549057', '2025-11-07 12:47:36.826431', 'COMPLETED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (50, 51, 31, 18, '2025-11-07 12:48:50.633335', '2025-11-07 12:53:20.009898', 'COMPLETED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (51, 52, 31, 18, '2025-11-07 12:54:03.679277', '2025-11-07 12:54:46.347752', 'COMPLETED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (52, 53, 31, 18, '2025-11-07 12:55:15.707624', '2025-11-07 12:58:03.96838', 'COMPLETED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (54, 55, 26, 18, '2025-11-07 15:04:34.304899', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (55, 56, 26, 18, '2025-11-07 15:17:12.447329', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (56, 57, 26, 18, '2025-11-07 15:18:11.481377', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (57, 58, 26, 18, '2025-11-07 15:18:23.409073', NULL, 'CANCELLED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (53, 54, 31, 18, '2025-11-07 14:09:11.482572', '2025-11-07 16:07:31.399357', 'COMPLETED', NULL, 42, 0, NULL);
INSERT INTO public.revision_list VALUES (58, 59, 31, 18, '2025-11-07 16:10:59.537901', NULL, 'ACTIVE', NULL, 42, 0, NULL);


--
-- TOC entry 5927 (class 0 OID 17470)
-- Dependencies: 389
-- Data for Name: revision_temp; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.revision_temp VALUES ('2025-11-07 16:11:16.889333', 5, 31, 42, 18, 160, 0, 5, 59, 2, '2025-11-07 16:11:16.889333', 5, 24);
INSERT INTO public.revision_temp VALUES ('2025-11-07 17:23:51.719744', 2, 31, 42, 18, 114, 0, 3, 59, 2, '2025-11-07 17:23:51.719744', 2, 27);


--
-- TOC entry 5928 (class 0 OID 17477)
-- Dependencies: 390
-- Data for Name: revisiondiary; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.revisiondiary VALUES ('2025-11-07 12:46:37.099972', '2025-11-07 12:46:37.099972', 5, 5, 31, 42, 18, 160, 0, '42', '2025-11-07 12:47:36', 3, 50, 2, '2025-11-07 12:46:37.099972', 5, 3);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 12:47:26.398614', '2025-11-07 12:47:26.398614', 4, 10, 31, 42, 18, 114, 0, '42', '2025-11-07 12:47:36', 5, 50, 2, '2025-11-07 12:47:26.398614', 4, 4);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 12:52:51.127843', '2025-11-07 12:52:51.127843', 3, 4, 31, 42, 18, 114, 0, '42', '2025-11-07 12:53:20', 5, 51, 2, '2025-11-07 12:52:51.127843', 4, 5);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 12:53:01.734859', '2025-11-07 12:53:01.734859', 5, 5, 31, 42, 18, 160, 0, '42', '2025-11-07 12:53:20', 3, 51, 2, '2025-11-07 12:53:01.734859', 5, 6);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 12:54:15.032945', '2025-11-07 12:54:15.032945', 3, 3, 31, 42, 18, 114, 0, '42', '2025-11-07 12:54:46', 5, 52, 2, '2025-11-07 12:54:15.032945', 3, 7);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 12:54:22.300542', '2025-11-07 12:54:22.300542', 5, 5, 31, 42, 18, 160, 0, '42', '2025-11-07 12:54:46', 3, 52, 2, '2025-11-07 12:54:22.300542', 5, 8);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 12:57:55.324004', '2025-11-07 12:57:55.324004', 3, 3, 31, 42, 18, 114, 0, '42', '2025-11-07 12:58:03', 5, 53, 2, '2025-11-07 12:57:55.324004', 3, 9);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 14:09:40.672857', '2025-11-07 14:09:40.672857', 5, 5, 31, 42, 18, 160, 0, '42', '2025-11-07 16:07:31', 3, 54, 2, '2025-11-07 14:09:40.672857', 3, 10);
INSERT INTO public.revisiondiary VALUES ('2025-11-07 15:59:49.543255', '2025-11-07 15:59:49.543255', 3, 3, 31, 42, 18, 114, 0, '42', '2025-11-07 16:07:31', 5, 54, 2, '2025-11-07 15:59:49.543255', 3, 11);


--
-- TOC entry 5930 (class 0 OID 17489)
-- Dependencies: 392
-- Data for Name: revisiondiary_old; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5932 (class 0 OID 17497)
-- Dependencies: 394
-- Data for Name: revisiontemp; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5933 (class 0 OID 17505)
-- Dependencies: 395
-- Data for Name: salesplan; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.salesplan VALUES (18, 1, 2, 3, 4, 1, 3, 4, 5, 6);
INSERT INTO public.salesplan VALUES (2, 1, 2, 3, 0, 3, 4, 5, 6, 0);
INSERT INTO public.salesplan VALUES (4, 1, 2, 0, 0, 1, 0, 0, 0, 0);
INSERT INTO public.salesplan VALUES (17, 2, 0, 0, 0, 3, 0, 0, 0, 0);
INSERT INTO public.salesplan VALUES (21, 2, 0, 0, 0, 1, 0, 0, 0, 0);


--
-- TOC entry 5934 (class 0 OID 17512)
-- Dependencies: 396
-- Data for Name: salesplan_types; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.salesplan_types VALUES (1, 'Индивидуальный', false);
INSERT INTO public.salesplan_types VALUES (2, 'Командный', true);
INSERT INTO public.salesplan_types VALUES (3, 'Командный', false);


--
-- TOC entry 5937 (class 0 OID 17523)
-- Dependencies: 399
-- Data for Name: scale; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.scale VALUES (1, 'ц3388', false, 18, 26);
INSERT INTO public.scale VALUES (3, 'укее', false, 18, 24);
INSERT INTO public.scale VALUES (4, 'длж89', false, 18, 24);
INSERT INTO public.scale VALUES (2, 'тии988л', false, 18, 24);
INSERT INTO public.scale VALUES (6, 'yuiyi', false, 18, 24);
INSERT INTO public.scale VALUES (5, 'екнке88шщ7ро77', true, 18, 24);
INSERT INTO public.scale VALUES (0, 'наименование', false, 18, 24);
INSERT INTO public.scale VALUES (7, 'укее1', false, 18, 24);
INSERT INTO public.scale VALUES (8, '312', false, 181, 82);
INSERT INTO public.scale VALUES (9, 'tyr', false, 184, 85);


--
-- TOC entry 5938 (class 0 OID 17527)
-- Dependencies: 400
-- Data for Name: schema_migrations; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.schema_migrations VALUES (20241011071208, false);


--
-- TOC entry 5939 (class 0 OID 17530)
-- Dependencies: 401
-- Data for Name: seizurelist; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5940 (class 0 OID 17536)
-- Dependencies: 402
-- Data for Name: settings; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.settings VALUES ('check_average_purchaseprice', 'false', 18, 2);
INSERT INTO public.settings VALUES ('bottom_limit', '0', 18, 3);
INSERT INTO public.settings VALUES ('top_limit', '0', 18, 1);


--
-- TOC entry 5942 (class 0 OID 17541)
-- Dependencies: 404
-- Data for Name: songs; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.songs OVERRIDING SYSTEM VALUE VALUES (1, '12', '23', '{"textall":"Куплет1  Припев  Куплет2  Припев  Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-23 12:29:28.604082');
INSERT INTO public.songs OVERRIDING SYSTEM VALUE VALUES (2, '1', '2', '{"textall":"Куплет1  Припев  Куплет2  Припев  Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-23 12:29:34.869454');


--
-- TOC entry 5943 (class 0 OID 17548)
-- Dependencies: 405
-- Data for Name: songs1; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5944 (class 0 OID 17554)
-- Dependencies: 406
-- Data for Name: songs10; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.songs10 VALUES (1, '2024-10-22 13:10:20.534329+06', '2024-10-22 13:10:20.534329+06', NULL, '2s4', '3f4', NULL, '1
2
3
4
5', '');
INSERT INTO public.songs10 VALUES (2, '2024-10-22 13:11:31.24681+06', '2024-10-22 15:08:41.250192+06', NULL, '44a23dr1381qz1', '33z14ft2492wz2', '2024-10-22 18:20:00+06', '1 2 3', 'ty');


--
-- TOC entry 5946 (class 0 OID 17562)
-- Dependencies: 408
-- Data for Name: songs2; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5947 (class 0 OID 17568)
-- Dependencies: 409
-- Data for Name: songs3; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.songs3 OVERRIDING SYSTEM VALUE VALUES (1, 'vcb', NULL, NULL, NULL, NULL);
INSERT INTO public.songs3 OVERRIDING SYSTEM VALUE VALUES (2, 'bvmnvb', NULL, NULL, NULL, NULL);
INSERT INTO public.songs3 OVERRIDING SYSTEM VALUE VALUES (3, ' bnvbn', NULL, NULL, NULL, NULL);


--
-- TOC entry 5949 (class 0 OID 17576)
-- Dependencies: 411
-- Data for Name: songs4; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.songs4 OVERRIDING SYSTEM VALUE VALUES (18, '1', '2', '{"textall":" Куплет1  Припев  Куплет2  Припев   Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-15 12:01:35.888493');
INSERT INTO public.songs4 OVERRIDING SYSTEM VALUE VALUES (19, '1', '2', '{"textall":" Куплет1  Припев  Куплет2  Припев   Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-15 12:35:43.337738');
INSERT INTO public.songs4 OVERRIDING SYSTEM VALUE VALUES (20, '1', '2', '{"textall":" Куплет1  Припев  Куплет2  Припев   Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-15 16:04:22.428378');
INSERT INTO public.songs4 OVERRIDING SYSTEM VALUE VALUES (21, '1', '2', '{"textall":"Куплет1  Припев  Куплет2  Припев  Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-16 10:26:05.08744');


--
-- TOC entry 5950 (class 0 OID 17583)
-- Dependencies: 412
-- Data for Name: songs5; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.songs5 OVERRIDING SYSTEM VALUE VALUES (1, '1', '2', '{"textall":"Куплет1  Припев  Куплет2  Припев  Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-16 16:18:19.74708', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.songs5 OVERRIDING SYSTEM VALUE VALUES (2, '1', '2', '{"textall":"Куплет1  Припев  Куплет2  Припев  Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-16 16:18:20.79211', NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.songs5 OVERRIDING SYSTEM VALUE VALUES (3, '13', '23', '{"textall":"Куплет1  Припев  Куплет2  Припев  Куплет3","kuplet":[{"id":"1","kupletst":"Куплет1"},{"id":"2","kupletst":"Куплет2"},{"id":"3","kupletst":"Куплет3"}]}', '2021-01-01', '2024-10-16 16:18:22.409423', NULL, NULL, NULL, NULL, NULL, NULL);


--
-- TOC entry 5951 (class 0 OID 17590)
-- Dependencies: 413
-- Data for Name: songs8; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5953 (class 0 OID 17599)
-- Dependencies: 415
-- Data for Name: songs9; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.songs9 VALUES (2, NULL, NULL, NULL, '1', '2', '01.01.2020', NULL, NULL);
INSERT INTO public.songs9 VALUES (4, NULL, NULL, NULL, '3', '4', '02.02.2024', '1
2
3
4
5', NULL);
INSERT INTO public.songs9 VALUES (6, '2024-10-21 12:08:59.086271+06', '2024-10-21 12:08:59.086271+06', NULL, '11', '2333', '01.01.2020', 'Текст', '');
INSERT INTO public.songs9 VALUES (7, '2024-10-21 12:17:08.31948+06', '2024-10-21 12:17:08.31948+06', NULL, '', '', '', '', '');
INSERT INTO public.songs9 VALUES (5, '2024-10-21 12:03:32.853237+06', '2024-10-22 11:41:07.148226+06', NULL, '44a23d', '33z14f', '01.01.2020', '1 2 3', 'ty');


--
-- TOC entry 5959 (class 0 OID 17615)
-- Dependencies: 421
-- Data for Name: stock_minmax; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5859 (class 0 OID 17128)
-- Dependencies: 316
-- Data for Name: stockcurrent; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.stockcurrent VALUES (79, 26, 75, 5.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (59, 24, 75, 6.000, 0, NULL, 18, 2, 6);
INSERT INTO public.stockcurrent VALUES (80, 31, 160, 5.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (82, 31, 75, 5.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (81, 31, 114, 3.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (64, 24, 160, 3.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (83, 29, 166, 10.000, 0, NULL, 185, NULL, 0);
INSERT INTO public.stockcurrent VALUES (84, 29, 167, 5.000, 0, NULL, 185, NULL, 0);
INSERT INTO public.stockcurrent VALUES (7, 26, 6, 3.000, 0, NULL, 18, NULL, 1);
INSERT INTO public.stockcurrent VALUES (85, 86, 178, 2.000, 0, NULL, 185, NULL, 0);
INSERT INTO public.stockcurrent VALUES (5, 26, 5, 1.000, 0, NULL, 18, NULL, 1);
INSERT INTO public.stockcurrent VALUES (86, 90, 166, 10.000, 0, NULL, 185, NULL, 0);
INSERT INTO public.stockcurrent VALUES (87, 90, 167, 5.000, 0, NULL, 185, NULL, 0);
INSERT INTO public.stockcurrent VALUES (88, 85, 182, 1.000, 0, NULL, 184, 2, 9);
INSERT INTO public.stockcurrent VALUES (89, 85, 183, 1.000, 0, NULL, 184, 2, 9);
INSERT INTO public.stockcurrent VALUES (90, 85, 184, 3.000, 0, NULL, 184, 2, 9);
INSERT INTO public.stockcurrent VALUES (66, 24, 153, 3.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (48, 24, 51, 0.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (49, 24, 52, 0.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (46, 26, 51, 2.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (47, 26, 52, 2.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (67, 26, 153, 0.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (65, 24, 114, 6.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (51, 24, 66, 0.000, 0, NULL, 18, 3, 6);
INSERT INTO public.stockcurrent VALUES (68, 24, 110, 7.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (69, 24, 114, 1.000, 65, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (77, 26, 160, 5.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (71, 24, 111, 2.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (63, 24, 152, 3.000, 0, NULL, 18, 2, 6);
INSERT INTO public.stockcurrent VALUES (55, 24, 70, 0.000, 0, NULL, 18, 2, 6);
INSERT INTO public.stockcurrent VALUES (56, 24, 71, 0.000, 0, NULL, 18, 2, 6);
INSERT INTO public.stockcurrent VALUES (57, 24, 72, 0.000, 0, NULL, 18, 2, 6);
INSERT INTO public.stockcurrent VALUES (52, 24, 68, 0.000, 0, NULL, 18, 2, 6);
INSERT INTO public.stockcurrent VALUES (70, 24, 160, 2.000, 70, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (78, 26, 111, 2.000, 0, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (58, 24, 73, 0.000, 0, NULL, 18, 4, 6);
INSERT INTO public.stockcurrent VALUES (72, 24, 164, 1.000, 73, NULL, 18, NULL, 0);
INSERT INTO public.stockcurrent VALUES (60, 24, 80, 0.000, 0, NULL, 18, 2, 6);
INSERT INTO public.stockcurrent VALUES (53, 24, 67, 0.000, 0, NULL, 18, 5, 6);
INSERT INTO public.stockcurrent VALUES (61, 24, 92, 0.000, 0, NULL, 18, 3, 6);
INSERT INTO public.stockcurrent VALUES (54, 24, 69, 0.000, 0, NULL, 18, 3, 6);
INSERT INTO public.stockcurrent VALUES (62, 24, 151, 2.000, 0, NULL, 18, 2, 4);


--
-- TOC entry 5961 (class 0 OID 17620)
-- Dependencies: 423
-- Data for Name: stockcurrent_part; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.stockcurrent_part VALUES (18, 24, 51, 0, 0.000, '2025-10-03', 500, 28);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 52, 0, 0.000, '2025-10-03', 10100, 29);
INSERT INTO public.stockcurrent_part VALUES (18, 26, 51, 0, 2.000, '2025-10-03', 500, 26);
INSERT INTO public.stockcurrent_part VALUES (18, 26, 52, 0, 2.000, '2025-10-03', 10100, 27);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 66, 0, 0.000, '2025-10-13', 20, 32);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 70, 0, 0.000, '2025-10-13', 3, 39);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 71, 0, 0.000, '2025-10-13', 2, 40);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 72, 0, 0.000, '2025-10-13', 2, 41);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 68, 0, 0.000, '2025-10-13', 1, 33);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 68, 0, 0.000, '2025-10-13', 4, 36);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 73, 0, 0.000, '2025-10-13', 2, 42);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 80, 0, 0.000, '2025-10-14', 22, 45);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 67, 0, 0.000, '2025-10-13', 40, 34);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 92, 0, 0.000, '2025-10-14', 2, 46);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 69, 0, 0.000, '2025-10-13', 2, 37);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 151, 0, 2.000, '2025-10-23', 100, 49);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 152, 0, 1.000, '2025-10-24', 100, 50);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 114, 0, 3.000, '2025-10-28', 2, 52);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 153, 0, 3.000, '2025-10-28', 100, 53);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 153, 0, 0.000, '2025-10-29', 100, 54);
INSERT INTO public.stockcurrent_part VALUES (18, 26, 153, 0, 0.000, '2025-10-29', 100, 55);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 160, 0, 1.000, '2025-10-31', 2, 71);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 114, 0, 3.000, '2025-10-29', 2, 56);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 110, 0, 7.000, '2025-10-29', 100, 59);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 114, 65, 1.000, '2025-10-29', 2, 61);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 152, 0, 2.000, '2025-10-30', 100, 66);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 160, 70, 2.000, '2025-10-30', 2, 67);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 164, 73, 1.000, '2025-10-31', 100, 72);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 160, 0, 0.000, '2025-10-28', 2, 51);
INSERT INTO public.stockcurrent_part VALUES (18, 26, 160, 0, 4.000, '2025-10-28', 2, 73);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 160, 0, 1.000, '2025-10-30', 2, 70);
INSERT INTO public.stockcurrent_part VALUES (18, 26, 160, 0, 1.000, '2025-10-30', 2, 78);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 111, 0, 2.000, '2025-10-30', 2105, 68);
INSERT INTO public.stockcurrent_part VALUES (18, 26, 111, 0, 2.000, '2025-10-30', 2105, 74);
INSERT INTO public.stockcurrent_part VALUES (18, 26, 75, 0, 5.000, '2025-10-14', 23, 79);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 75, 0, 6.000, '2025-10-14', 23, 43);
INSERT INTO public.stockcurrent_part VALUES (18, 31, 160, 0, 5.000, '2025-11-05', 2, 85);
INSERT INTO public.stockcurrent_part VALUES (18, 31, 75, 0, 5.000, '2025-11-07', 23, 87);
INSERT INTO public.stockcurrent_part VALUES (18, 31, 114, 0, 3.000, '2025-11-05', 2, 86);
INSERT INTO public.stockcurrent_part VALUES (18, 24, 160, 0, 1.000, '2025-11-10', 200, 88);
INSERT INTO public.stockcurrent_part VALUES (185, 29, 166, 0, 10.000, '2025-11-21', 500, 89);
INSERT INTO public.stockcurrent_part VALUES (185, 29, 167, 0, 5.000, '2025-11-21', 150, 90);
INSERT INTO public.stockcurrent_part VALUES (185, 86, 178, 0, 2.000, '2025-11-21', 100, 91);
INSERT INTO public.stockcurrent_part VALUES (185, 90, 166, 0, 10.000, '2025-11-21', 500, 92);
INSERT INTO public.stockcurrent_part VALUES (185, 90, 167, 0, 5.000, '2025-11-21', 150, 93);
INSERT INTO public.stockcurrent_part VALUES (184, 85, 182, 0, 1.000, '2025-11-24', 2, 94);
INSERT INTO public.stockcurrent_part VALUES (184, 85, 183, 0, 1.000, '2025-11-24', 3, 95);
INSERT INTO public.stockcurrent_part VALUES (184, 85, 184, 0, 3.000, '2025-11-24', 1, 96);


--
-- TOC entry 5963 (class 0 OID 17626)
-- Dependencies: 425
-- Data for Name: stockdiary; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.stockdiary VALUES ('2025-10-03 17:48:43.781413', 100, 26, 1.000, 500, 51, 0, NULL, NULL, 18, 500, NULL, '2025-10-03', NULL, NULL, NULL, NULL, 0, 68, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:48:43.781413', 100, 26, 1.000, 10100, 52, 0, NULL, NULL, 18, 10100, NULL, '2025-10-03', NULL, NULL, NULL, NULL, 0, 69, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:48:43.781413', 100, 26, 1.000, 500, 51, 0, NULL, 127, 18, 500, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 70, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:48:43.781413', 1, 26, 1.000, 500, 51, 0, NULL, 127, 18, 500, NULL, '2025-10-03', NULL, NULL, NULL, NULL, NULL, 71, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:48:43.781413', 100, 26, 1.000, 10100, 52, 0, NULL, 127, 18, 10100, NULL, '2025-10-03', NULL, NULL, NULL, NULL, NULL, 72, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:48:43.781413', 1, 26, 1.000, 10100, 52, 0, NULL, 127, 18, 10100, NULL, '2025-10-03', NULL, NULL, NULL, NULL, NULL, 73, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:52:56.858432', 100, 26, 1.000, 500, 51, 0, NULL, 128, 18, 500, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 74, NULL, NULL, 1.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:52:56.858432', 1, 26, 1.000, 500, 51, 0, NULL, 128, 18, 500, NULL, '2025-10-03', NULL, NULL, NULL, NULL, NULL, 75, 1.000, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:52:56.858432', 100, 26, 1.000, 10100, 52, 0, NULL, 128, 18, 10100, NULL, '2025-10-03', NULL, NULL, NULL, NULL, NULL, 76, NULL, NULL, 1.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-03 17:52:56.858432', 1, 26, 1.000, 10100, 52, 0, NULL, 128, 18, 10100, NULL, '2025-10-03', NULL, NULL, NULL, NULL, NULL, 77, 1.000, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:47:03.54515', 100, 24, 1.000, 30, 66, 0, NULL, NULL, 18, 20, NULL, '2025-10-13', NULL, NULL, NULL, NULL, 0, 78, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:47:03.54515', 100, 24, 1.000, 30, 66, 0, NULL, 154, 18, 20, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 79, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:47:03.54515', 1, 24, 1.000, 30, 66, 0, NULL, 154, 18, 20, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 80, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:49:49.477109', 100, 24, 3.000, 2, 68, 0, NULL, NULL, 18, 1, NULL, '2025-10-13', NULL, NULL, NULL, NULL, 0, 81, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:49:49.477109', 100, 24, 2.000, 50, 67, 0, NULL, NULL, 18, 40, NULL, '2025-10-13', NULL, NULL, NULL, NULL, 0, 82, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:49:49.477109', 100, 24, 3.000, 2, 68, 0, NULL, 155, 18, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 83, NULL, NULL, 0.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:49:49.477109', 1, 24, 3.000, 2, 68, 0, NULL, 155, 18, 1, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 84, NULL, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:49:49.477109', 100, 24, 2.000, 50, 67, 0, NULL, 155, 18, 40, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 85, NULL, NULL, 0.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 14:49:49.477109', 1, 24, 2.000, 50, 67, 0, NULL, 155, 18, 40, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 86, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:20:09.024502', -3, 24, 1.000, 0, 66, 0, NULL, NULL, 18, 20, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 88, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:32:24.678594', 100, 24, 1.000, 2, 68, 0, NULL, 157, 18, 1, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 89, NULL, NULL, 3.000, 4.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:32:24.678594', 1, 24, 1.000, 2, 68, 0, NULL, 157, 18, 1, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 90, 3.000, 4.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:33:28.618392', 100, 24, 3.000, 5, 68, 0, NULL, 158, 18, 4, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 91, NULL, NULL, 4.000, 7.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:33:28.618392', 1, 24, 3.000, 5, 68, 0, NULL, 158, 18, 4, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 92, NULL, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:34:34.885704', 100, 24, 4.000, 3, 69, 0, NULL, NULL, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, 0, 93, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:34:34.885704', 100, 24, 4.000, 3, 69, 0, NULL, 159, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 94, NULL, NULL, 0.000, 4.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 15:34:34.885704', 1, 24, 4.000, 3, 69, 0, NULL, 159, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 95, NULL, 4.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:28:32.572785', 100, 24, 33.000, 3, 69, 0, NULL, 160, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 96, NULL, NULL, 4.000, 37.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:28:32.572785', 1, 24, 33.000, 3, 69, 0, NULL, 160, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 97, 4.000, 37.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:29:29.074864', 100, 24, 2.000, 4, 70, 0, NULL, NULL, 18, 3, NULL, '2025-10-13', NULL, NULL, NULL, NULL, 0, 98, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:29:29.074864', 100, 24, 2.000, 4, 70, 0, NULL, 161, 18, 3, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 99, NULL, NULL, 0.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:29:29.074864', 1, 24, 2.000, 4, 70, 0, NULL, 161, 18, 3, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 100, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:30:21.004453', -3, 24, 2.000, 0, 70, 0, NULL, NULL, 18, 3, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 101, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:30:44.897163', 100, 24, 4.000, 3, 71, 0, NULL, NULL, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, 0, 102, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:30:44.897163', 100, 24, 4.000, 3, 71, 0, NULL, 163, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 103, NULL, NULL, 0.000, 4.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:30:44.897163', 1, 24, 4.000, 3, 71, 0, NULL, 163, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 104, NULL, 4.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 16:31:01.238506', -3, 24, 4.000, 0, 71, 0, NULL, NULL, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 105, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 17:03:04.384033', 100, 24, 3.000, 3, 72, 0, NULL, NULL, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, 0, 106, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 17:03:04.384033', 100, 24, 3.000, 3, 72, 0, NULL, 165, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 107, NULL, NULL, 0.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-13 17:03:04.384033', 1, 24, 3.000, 3, 72, 0, NULL, 165, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 108, NULL, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 09:26:03.144191', -3, 24, 3.000, 0, 72, 0, NULL, NULL, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 109, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 09:26:19.815692', -3, 24, 4.000, 0, 68, 0, NULL, NULL, 18, 1, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 110, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 09:26:19.815692', -3, 24, 3.000, 0, 68, 0, NULL, NULL, 18, 4, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 111, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 09:26:56.275695', 100, 24, 2.000, 3, 73, 0, NULL, NULL, 18, 2, NULL, '2025-10-14', NULL, NULL, NULL, NULL, 0, 112, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 09:26:56.275695', 100, 24, 2.000, 3, 73, 0, NULL, 166, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 113, NULL, NULL, 0.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 09:26:56.275695', 1, 24, 2.000, 3, 73, 0, NULL, 166, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 114, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 10:22:27.91282', 100, 24, 1.000, 34, 75, 0, NULL, NULL, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, 0, 115, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 10:22:27.91282', 100, 24, 1.000, 34, 75, 0, NULL, 169, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 116, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 10:22:27.91282', 1, 24, 1.000, 34, 75, 0, NULL, 169, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 117, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 10:47:00.11494', -3, 24, 2.000, 0, 73, 0, NULL, NULL, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 118, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 12:35:57.413179', 100, 24, 7.000, 33, 80, 0, NULL, NULL, 18, 22, NULL, '2025-10-14', NULL, NULL, NULL, NULL, 0, 119, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 12:35:57.413179', 100, 24, 4.000, 34, 75, 0, NULL, 173, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 120, NULL, NULL, 1.000, 5.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 12:35:57.413179', 1, 24, 4.000, 34, 75, 0, NULL, 173, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 121, 1.000, 5.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 12:35:57.413179', 100, 24, 7.000, 33, 80, 0, NULL, 173, 18, 22, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 122, NULL, NULL, 0.000, 7.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 12:35:57.413179', 1, 24, 7.000, 33, 80, 0, NULL, 173, 18, 22, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 123, NULL, 7.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 12:36:23.617952', -3, 24, 7.000, 0, 80, 0, NULL, NULL, 18, 22, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 124, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 12:59:02.828673', -3, 24, 2.000, 0, 67, 0, NULL, NULL, 18, 40, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 125, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 14:32:31.932543', 100, 24, 5.000, 3, 92, 0, NULL, NULL, 18, 2, NULL, '2025-10-14', NULL, NULL, NULL, NULL, 0, 126, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 14:32:31.932543', 100, 24, 5.000, 3, 92, 0, NULL, 179, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 127, NULL, NULL, 0.000, 5.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 14:32:31.932543', 1, 24, 5.000, 3, 92, 0, NULL, 179, 18, 2, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 128, NULL, 5.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 14:35:09.287591', -3, 24, 5.000, 0, 92, 0, NULL, NULL, 18, 2, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 129, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 14:37:55.829054', 100, 24, 5.000, 34, 75, 0, NULL, 183, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 130, NULL, NULL, 5.000, 10.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-14 14:37:55.829054', 1, 24, 5.000, 34, 75, 0, NULL, 183, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 131, 5.000, 10.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-16 15:49:48.529272', -3, 24, 37.000, 0, 69, 0, NULL, NULL, 18, 2, NULL, '2025-10-13', NULL, NULL, NULL, NULL, NULL, 132, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-23 17:51:34.51209', 100, 24, 3.000, 34, 75, 0, NULL, 184, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 133, NULL, NULL, 10.000, 13.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-23 17:51:34.51209', 1, 24, 3.000, 34, 75, 0, NULL, 184, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 134, 10.000, 13.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-23 17:52:28.970194', 100, 24, 2.000, 200, 151, 0, NULL, NULL, 18, 100, NULL, '2025-10-23', NULL, NULL, NULL, NULL, 0, 135, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-23 17:52:28.970194', 100, 24, 2.000, 200, 151, 0, NULL, 186, 18, 100, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 136, NULL, NULL, 0.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-23 17:52:28.970194', 1, 24, 2.000, 200, 151, 0, NULL, 186, 18, 100, NULL, '2025-10-23', NULL, NULL, NULL, NULL, NULL, 137, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-24 09:59:11.426127', 100, 24, 1.000, 200, 152, 0, NULL, NULL, 18, 100, NULL, '2025-10-24', NULL, NULL, NULL, NULL, 0, 138, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-24 09:59:11.426127', 100, 24, 1.000, 200, 152, 0, NULL, 188, 18, 100, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 139, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-24 09:59:11.426127', 1, 24, 1.000, 200, 152, 0, NULL, 188, 18, 100, NULL, '2025-10-24', NULL, NULL, NULL, NULL, NULL, 140, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 100, 24, 4.000, 3, 160, 0, NULL, NULL, 18, 2, NULL, '2025-10-29', NULL, NULL, NULL, NULL, 0, 141, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 100, 24, 3.000, 5, 114, 0, NULL, NULL, 18, 2, NULL, '2025-10-29', NULL, NULL, NULL, NULL, 0, 142, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 100, 24, 3.000, 200, 153, 0, NULL, NULL, 18, 100, NULL, '2025-10-29', NULL, NULL, NULL, NULL, 0, 143, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 100, 24, 4.000, 3, 160, 0, NULL, 208, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 144, NULL, NULL, 0.000, 4.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 1, 24, 4.000, 3, 160, 0, NULL, 208, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 145, NULL, 4.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 100, 24, 3.000, 5, 114, 0, NULL, 208, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 146, NULL, NULL, 0.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 1, 24, 3.000, 5, 114, 0, NULL, 208, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 147, NULL, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 100, 24, 3.000, 200, 153, 0, NULL, 208, 18, 100, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 148, NULL, NULL, 0.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:27:50.802768', 1, 24, 3.000, 200, 153, 0, NULL, 208, 18, 100, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 149, NULL, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:35:31.92819', 100, 24, 0.000, 200, 153, 0, NULL, 209, 18, 100, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 150, NULL, NULL, 3.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:35:31.92819', 1, 24, 0.000, 200, 153, 0, NULL, 209, 18, 100, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 151, NULL, 0.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:36:51.236905', 100, 26, 0.000, 200, 153, 0, NULL, NULL, 18, 100, NULL, '2025-10-29', NULL, NULL, NULL, NULL, 0, 152, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:36:51.236905', 100, 26, 0.000, 200, 153, 0, NULL, 210, 18, 100, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 153, NULL, NULL, 0.000, 0.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:36:51.236905', 1, 26, 0.000, 200, 153, 0, NULL, 210, 18, 100, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 154, NULL, 0.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:40:01.102676', 100, 24, 0.000, 5, 114, 0, NULL, 211, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 155, NULL, NULL, 3.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:40:01.102676', 1, 24, 0.000, 5, 114, 0, NULL, 211, 18, 2, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 156, NULL, 0.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:40:59.887262', 100, 24, 0.000, 5, 114, 0, NULL, 212, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 157, NULL, NULL, 3.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:40:59.887262', 1, 24, 0.000, 5, 114, 0, NULL, 212, 18, 2, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 158, 0.000, 0.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:50:02.783892', 100, 24, 3.000, 5, 114, 0, NULL, 213, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 159, NULL, NULL, 3.000, 6.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 09:50:02.783892', 1, 24, 3.000, 5, 114, 0, NULL, 213, 18, 2, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 160, 0.000, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 10:08:40.793341', 100, 24, 3.000, 200, 110, 0, NULL, NULL, 18, 100, NULL, '2025-10-29', NULL, NULL, NULL, NULL, 0, 161, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 10:08:40.793341', 100, 24, 3.000, 200, 110, 0, NULL, 214, 18, 100, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 162, NULL, NULL, 0.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 10:08:40.793341', 1, 24, 3.000, 200, 110, 0, NULL, 214, 18, 100, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 163, NULL, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 10:14:39.347074', 100, 24, 4.000, 200, 110, 0, NULL, 215, 18, 100, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 164, NULL, NULL, 3.000, 7.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 10:14:39.347074', 1, 24, 4.000, 200, 110, 0, NULL, 215, 18, 100, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 165, 3.000, 7.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 12:57:58.047838', 100, 24, 1.000, 5, 114, 65, NULL, NULL, 18, 2, NULL, '2025-10-29', NULL, NULL, NULL, NULL, 0, 166, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 12:57:58.047838', 100, 24, 1.000, 5, 114, 65, NULL, 221, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 167, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-29 12:57:58.047838', 1, 24, 1.000, 5, 114, 65, NULL, 221, 18, 2, NULL, '2025-10-29', NULL, NULL, NULL, NULL, NULL, 168, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 09:56:21.457358', 100, 24, 2.000, 200, 152, 0, NULL, 225, 18, 100, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 177, NULL, NULL, 1.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 09:56:21.457358', 1, 24, 2.000, 200, 152, 0, NULL, 225, 18, 100, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 178, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 10:25:10.354687', 100, 24, 2.000, 3, 160, 70, NULL, NULL, 18, 2, NULL, '2025-10-30', NULL, NULL, NULL, NULL, 0, 179, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 10:25:10.354687', 100, 24, 2.000, 2526, 111, 0, NULL, NULL, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, 262.6, 180, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 10:25:10.354687', 100, 24, 2.000, 3, 160, 70, NULL, 227, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 181, NULL, NULL, 0.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 10:25:10.354687', 1, 24, 2.000, 3, 160, 70, NULL, 227, 18, 2, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 182, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 10:25:10.354687', 100, 24, 2.000, 2526, 111, 0, NULL, 227, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 183, NULL, NULL, 0.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 10:25:10.354687', 1, 24, 2.000, 2526, 111, 0, NULL, 227, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 184, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 15:11:02.980783', 100, 24, 2.000, 2526, 111, 0, NULL, 234, 18, 2105, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 185, NULL, NULL, 2.000, 4.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 15:11:02.980783', 1, 24, 2.000, 2526, 111, 0, NULL, 234, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 186, 2.000, 4.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 15:11:02.980783', 100, 24, 2.000, 3, 160, 0, NULL, 234, 18, 2, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 187, NULL, NULL, 4.000, 6.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-30 15:11:02.980783', 1, 24, 2.000, 3, 160, 0, NULL, 234, 18, 2, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 188, NULL, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-31 10:39:46.179933', 100, 24, 1.000, 200, 164, 73, NULL, NULL, 18, 100, NULL, '2025-10-31', NULL, NULL, NULL, NULL, 0, 189, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-31 10:39:46.179933', 100, 24, 1.000, 3, 160, 0, NULL, 238, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 190, NULL, NULL, 6.000, 7.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-31 10:39:46.179933', 1, 24, 1.000, 3, 160, 0, NULL, 238, 18, 2, NULL, '2025-10-31', NULL, NULL, NULL, NULL, NULL, 191, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-31 10:39:46.179933', 100, 24, 1.000, 200, 164, 73, NULL, 238, 18, 100, NULL, '2025-10-31', NULL, NULL, NULL, NULL, NULL, 192, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-10-31 10:39:46.179933', 1, 24, 1.000, 200, 164, 73, NULL, 238, 18, 100, NULL, '2025-10-31', NULL, NULL, NULL, NULL, NULL, 193, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:19:23.109435', -400, 24, 1.000, NULL, 160, 0, NULL, 242, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 207, NULL, NULL, 7.000, 6.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:19:23.109435', -4, 24, 1.000, 3, 160, 0, NULL, 242, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 208, 4.000, 3.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:19:23.109435', 400, 26, 1.000, 3, 160, 0, NULL, 242, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 209, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:19:23.109435', 4, 26, 1.000, 3, 160, 0, NULL, 242, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 210, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:27:23.530607', -400, 24, 1.000, 2526, 111, 0, NULL, 243, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 211, NULL, NULL, 4.000, 3.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:27:23.530607', -4, 24, 1.000, 2526, 111, 0, NULL, 243, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 212, 4.000, 3.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:27:23.530607', 400, 26, 1.000, 2526, 111, 0, NULL, 243, 18, 2105, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 213, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:27:23.530607', 4, 26, 1.000, 2526, 111, 0, NULL, 243, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 214, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:36:37.147187', -400, 24, 1.000, 3, 160, 0, NULL, 244, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 215, NULL, NULL, 6.000, 5.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:36:37.147187', -4, 24, 1.000, 3, 160, 0, NULL, 244, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 216, 3.000, 2.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:36:37.147187', 400, 26, 1.000, 3, 160, 0, NULL, 244, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 217, NULL, NULL, 1.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 10:36:37.147187', 4, 26, 1.000, 3, 160, 0, NULL, 244, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 218, 1.000, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:21:13.618197', -400, 24, 1.000, NULL, 160, 0, NULL, 245, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 219, NULL, NULL, 5.000, 4.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:21:13.618197', -4, 24, 1.000, 3, 160, 0, NULL, 245, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 220, 2.000, 1.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:21:13.618197', 400, 26, 1.000, 3, 160, 0, NULL, 245, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 221, NULL, NULL, 2.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:21:13.618197', 4, 26, 1.000, 3, 160, 0, NULL, 245, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 222, 2.000, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:39:07.692179', -400, 24, 1.000, 3, 160, 0, NULL, 246, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 223, NULL, NULL, 4.000, 3.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:39:07.692179', -4, 24, 1.000, 3, 160, 0, NULL, 246, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 224, 1.000, 0.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 246', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:39:07.692179', 400, 26, 1.000, 3, 160, 0, NULL, 246, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 225, NULL, NULL, 3.000, 4.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:39:07.692179', 4, 26, 1.000, 3, 160, 0, NULL, 246, 18, 2, NULL, '2025-10-28', NULL, NULL, NULL, NULL, NULL, 226, 3.000, 4.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', -400, 24, 1.000, NULL, 75, 0, NULL, 247, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 227, NULL, NULL, 13.000, 12.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', -4, 24, 1.000, 34, 75, 0, NULL, 247, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 228, 13.000, 12.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', -400, 24, 1.000, NULL, 160, 0, NULL, 247, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 229, NULL, NULL, 3.000, 2.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', -4, 24, 1.000, 3, 160, 0, NULL, 247, 18, 2, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 230, 2.000, 1.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', 400, 26, 1.000, 3, 160, 0, NULL, 247, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 231, NULL, NULL, 4.000, 5.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', 4, 26, 1.000, 3, 160, 0, NULL, 247, 18, 2, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 232, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', 400, 26, 1.000, 34, 75, 0, NULL, 247, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 233, NULL, NULL, 0.000, 1.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 14:40:38.363048', 4, 26, 1.000, 34, 75, 0, NULL, 247, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 234, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:31:27.798682', -400, 24, 1.000, NULL, 75, 0, NULL, 252, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 235, NULL, NULL, 12.000, 11.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:31:27.798682', -4, 24, 1.000, 34, 75, 0, NULL, 252, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 236, 12.000, 11.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:31:27.798682', 400, 26, 1.000, 34, 75, 0, NULL, 252, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 237, NULL, NULL, 1.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:31:27.798682', 4, 26, 1.000, 34, 75, 0, NULL, 252, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 238, 1.000, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:32:58.105112', -400, 24, 1.000, 2526, 111, 0, NULL, 253, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 239, NULL, NULL, 3.000, 2.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:32:58.105112', -4, 24, 1.000, 2526, 111, 0, NULL, 253, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 240, 3.000, 2.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:32:58.105112', 400, 26, 1.000, 2526, 111, 0, NULL, 253, 18, 2105, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 241, NULL, NULL, 1.000, 2.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 15:32:58.105112', 4, 26, 1.000, 2526, 111, 0, NULL, 253, 18, 2105, NULL, '2025-10-30', NULL, NULL, NULL, NULL, NULL, 242, 1.000, 2.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:09.568168', -400, 24, 1.000, 0, 75, 0, NULL, 258, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 243, NULL, NULL, 11.000, 10.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:09.568168', -4, 24, 1.000, 0, 75, 0, NULL, 258, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 244, 11.000, 10.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:09.568168', 400, 26, 1.000, 0, 75, 0, NULL, 258, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 245, NULL, NULL, 2.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:09.568168', 4, 26, 1.000, 0, 75, 0, NULL, 258, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 246, 2.000, 3.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:45.124143', -400, 24, 1.000, NULL, 75, 0, NULL, 259, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 247, NULL, NULL, 10.000, 9.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:45.124143', -4, 24, 1.000, 34, 75, 0, NULL, 259, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 248, 10.000, 9.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:45.124143', 400, 26, 1.000, 34, 75, 0, NULL, 259, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 249, NULL, NULL, 3.000, 4.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-03 17:14:45.124143', 4, 26, 1.000, 34, 75, 0, NULL, 259, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 250, 3.000, 4.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 12:33:51.667936', -400, 24, 1.000, 34, 75, 0, NULL, 260, 18, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 251, NULL, NULL, 9.000, 8.000, 'stockcurrent updated by goods_movement line 141, reason = -400 because want to avoid duplication of movement in invoice_processing line 301', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 12:33:51.667936', -4, 24, 1.000, 34, 75, 0, NULL, 260, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 252, 9.000, 8.000, NULL, NULL, 'stockcurrent_part updated by goods_movement, line 228', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 12:33:51.667936', 400, 26, 1.000, 34, 75, 0, NULL, 260, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 253, NULL, NULL, 4.000, 5.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 12:33:51.667936', 4, 26, 1.000, 34, 75, 0, NULL, 260, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 254, 4.000, 5.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 368', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 14:48:04.390915', -3, 24, 1.000, 34, 75, 0, NULL, 262, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 257, 8.000, 7.000, NULL, NULL, 'stockcurrent_part updated by goods_writeoff, line 143', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 14:48:04.390915', -300, 24, 1.000, 34, 75, 0, NULL, 262, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 258, NULL, NULL, 8.000, 7.000, 'stockcurrent updated by goods_writeoff, line 225', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 15:30:21.772386', -3, 24, 1.000, 34, 75, 0, NULL, 264, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 259, 7.000, 6.000, NULL, NULL, 'stockcurrent_part updated by goods_writeoff, line 143', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-04 15:30:21.772386', -300, 24, 1.000, 34, 75, 0, NULL, 264, 18, 23, NULL, '2025-10-14', NULL, NULL, NULL, NULL, NULL, 260, NULL, NULL, 7.000, 6.000, 'stockcurrent updated by goods_writeoff, line 225', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-05 12:27:50.011433', 100, 31, 5.000, 3, 160, 0, NULL, NULL, 18, 2, NULL, '2025-11-05', NULL, NULL, NULL, NULL, 0, 261, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-05 12:27:50.011433', 100, 31, 10.000, 5, 114, 0, NULL, NULL, 18, 2, NULL, '2025-11-05', NULL, NULL, NULL, NULL, 0, 262, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-05 12:27:50.011433', 100, 31, 5.000, 3, 160, 0, NULL, 266, 18, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 263, NULL, NULL, 0.000, 5.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-05 12:27:50.011433', 1, 31, 5.000, 3, 160, 0, NULL, 266, 18, 2, NULL, '2025-11-05', NULL, NULL, NULL, NULL, NULL, 264, NULL, 5.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-05 12:27:50.011433', 100, 31, 10.000, 5, 114, 0, NULL, 266, 18, 2, NULL, '2025-11-05', NULL, NULL, NULL, NULL, NULL, 265, NULL, NULL, 0.000, 10.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-05 12:27:50.011433', 1, 31, 10.000, 5, 114, 0, NULL, 266, 18, 2, NULL, '2025-11-05', NULL, NULL, NULL, NULL, NULL, 266, NULL, 10.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-07 09:29:14.687802', 100, 31, 5.000, 34, 75, 0, NULL, NULL, 18, 23, NULL, '2025-11-07', NULL, NULL, NULL, NULL, 0, 267, NULL, NULL, 0.000, 0.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-07 09:29:14.687802', 100, 31, 5.000, 34, 75, 0, NULL, 267, 18, 23, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 268, NULL, NULL, 0.000, 5.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-07 09:29:14.687802', 1, 31, 5.000, 34, 75, 0, NULL, 267, 18, 23, NULL, '2025-11-07', NULL, NULL, NULL, NULL, NULL, 269, NULL, 5.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-07 12:47:36.826431', -5, 31, -6.000, 0, 114, 0, NULL, NULL, 18, 2, NULL, '2025-11-05', NULL, NULL, NULL, NULL, NULL, 271, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-07 12:53:20.009898', -5, 31, -1.000, 0, 114, 0, NULL, NULL, 18, 2, NULL, '2025-11-05', NULL, NULL, NULL, NULL, NULL, 272, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-10 14:53:13.785081', 100, 24, 1.000, 300, 160, 0, NULL, 270, 18, 200, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 273, NULL, NULL, 2.000, 3.000, 'stockcurrent changed by invoice_processing line 172', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-10 14:53:13.785081', 1, 24, 1.000, 300, 160, 0, NULL, 270, 18, 200, NULL, '2025-11-10', NULL, NULL, NULL, NULL, NULL, 274, NULL, 1.000, NULL, NULL, 'stockcurrent_part changed by invoice_processing line 311', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-21 12:55:55.054198', 5, 29, 10.000, 650, 166, 0, NULL, NULL, 185, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 275, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-21 12:55:55.054198', 5, 29, 5.000, 220, 167, 0, NULL, NULL, 185, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 276, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-21 17:02:58.921781', 1, 86, 2.000, 120, 178, 0, NULL, NULL, 185, 100, NULL, '2025-11-21', NULL, NULL, NULL, NULL, 0, 277, NULL, 2.000, NULL, NULL, 'stockcurrent_part updated by goods_add, only for central warehouse', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-21 17:02:58.921781', 100, 86, 2.000, 120, 178, 0, NULL, NULL, 185, 100, NULL, '2025-11-21', NULL, NULL, NULL, NULL, 0, 278, NULL, NULL, 0.000, 2.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-21 17:08:34.183262', 5, 90, 10.000, 650, 166, 0, NULL, NULL, 185, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 279, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-21 17:08:34.183262', 5, 90, 5.000, 220, 167, 0, NULL, NULL, 185, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 280, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-24 09:20:20.811252', 1, 85, 1.000, 3, 182, 0, NULL, NULL, 184, 2, NULL, '2025-11-24', NULL, NULL, NULL, NULL, 0, 281, NULL, 1.000, NULL, NULL, 'stockcurrent_part updated by goods_add, only for central warehouse', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-24 09:20:20.811252', 100, 85, 1.000, 3, 182, 0, NULL, NULL, 184, 2, NULL, '2025-11-24', NULL, NULL, NULL, NULL, 0, 282, NULL, NULL, 0.000, 1.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-24 09:20:20.811252', 1, 85, 1.000, 4, 183, 0, NULL, NULL, 184, 3, NULL, '2025-11-24', NULL, NULL, NULL, NULL, 0, 283, NULL, 1.000, NULL, NULL, 'stockcurrent_part updated by goods_add, only for central warehouse', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-24 09:20:20.811252', 100, 85, 1.000, 4, 183, 0, NULL, NULL, 184, 3, NULL, '2025-11-24', NULL, NULL, NULL, NULL, 0, 284, NULL, NULL, 0.000, 1.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-24 09:20:20.811252', 1, 85, 3.000, 2, 184, 0, NULL, NULL, 184, 1, NULL, '2025-11-24', NULL, NULL, NULL, NULL, 0, 285, NULL, 3.000, NULL, NULL, 'stockcurrent_part updated by goods_add, only for central warehouse', NULL, NULL);
INSERT INTO public.stockdiary VALUES ('2025-11-24 09:20:20.811252', 100, 85, 3.000, 2, 184, 0, NULL, NULL, 184, 1, NULL, '2025-11-24', NULL, NULL, NULL, NULL, 0, 286, NULL, NULL, 0.000, 3.000, 'stockcurrent insert by goods_add, line 218', NULL, NULL);


--
-- TOC entry 5969 (class 0 OID 17648)
-- Dependencies: 432
-- Data for Name: storeprices; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.storeprices VALUES (23, 61, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 59, 34, 18, 0, 0);
INSERT INTO public.storeprices VALUES (30, 80, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (30, 81, 5, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 5, 4567, 18, 0, 500);
INSERT INTO public.storeprices VALUES (30, 82, 34, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 64, 300, 18, 0, 400);
INSERT INTO public.storeprices VALUES (29, 83, 650, 185, 0, 0);
INSERT INTO public.storeprices VALUES (29, 84, 220, 185, 0, 0);
INSERT INTO public.storeprices VALUES (86, 85, 120, 185, 0, 0);
INSERT INTO public.storeprices VALUES (89, 86, 650, 185, 0, 0);
INSERT INTO public.storeprices VALUES (89, 87, 220, 185, 0, 0);
INSERT INTO public.storeprices VALUES (85, 88, 3, 184, 0, 0);
INSERT INTO public.storeprices VALUES (85, 89, 4, 184, 0, 0);
INSERT INTO public.storeprices VALUES (85, 90, 2, 184, 0, 0);
INSERT INTO public.storeprices VALUES (23, 66, 200, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 67, 200, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 65, 5, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 68, 200, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 69, 5, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 63, 200, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 48, 500, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 49, 10100, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 46, 500, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 47, 10100, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 7, 1000, 18, 0, 2000);
INSERT INTO public.storeprices VALUES (23, 51, 30, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 70, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 53, 50, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 62, 400, 18, 0, 500);
INSERT INTO public.storeprices VALUES (23, 52, 5, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 71, 2526, 18, 262.6, 0);
INSERT INTO public.storeprices VALUES (23, 54, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 55, 4, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 56, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 57, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 58, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 60, 33, 18, 0, 0);
INSERT INTO public.storeprices VALUES (23, 72, 200, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 77, 3, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 78, 2526, 18, 0, 0);
INSERT INTO public.storeprices VALUES (25, 79, 34, 18, 0, 0);


--
-- TOC entry 5970 (class 0 OID 17654)
-- Dependencies: 433
-- Data for Name: systemmessage; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5973 (class 0 OID 17665)
-- Dependencies: 436
-- Data for Name: taxes; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.taxes VALUES (1, 'Стандартный НДС', '2001-01-01 00:00:00', 1, NULL, 0.12, false, NULL);
INSERT INTO public.taxes VALUES (0, 'Без НДС', '2001-01-01 00:00:00', 0, NULL, 0, false, NULL);


--
-- TOC entry 5975 (class 0 OID 17687)
-- Dependencies: 441
-- Data for Name: tezmodules; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5977 (class 0 OID 17696)
-- Dependencies: 443
-- Data for Name: tezmodules_access; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5978 (class 0 OID 17700)
-- Dependencies: 444
-- Data for Name: ticket_format; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.ticket_format VALUES (18, '{"BIN": true, "NDS": true, "RNM": true, "ZNM": true, "point": "й", "address": "ц", "company": "TOO", "displayFile": "", "thanksMessage": "Спасибо за покупку.", "advertisementMessage": ""}', 19, 8);
INSERT INTO public.ticket_format VALUES (18, '{"BIN": true, "NDS": true, "RNM": true, "ZNM": true, "point": "Точка12к", "address": "Адрес13е", "company": "ТОО14н", "displayFile": "http://localhost:3030/public/companyLogos/24.09.2025_14_34_36_blob", "thanksMessage": "3", "advertisementMessage": "4\nоне\nвыа"}', 17, 3);
INSERT INTO public.ticket_format VALUES (18, '{"BIN": false, "NDS": true, "RNM": false, "ZNM": true, "point": "апрап9900", "address": "тиь", "company": "ролол", "displayFile": "", "thanksMessage": "Спасибо за покупку.", "advertisementMessage": "рор"}', 46, 16);
INSERT INTO public.ticket_format VALUES (18, '{"BIN": true, "NDS": false, "RNM": true, "ZNM": true, "point": "кекуе55", "address": "56756", "company": "7667", "displayFile": "", "thanksMessage": "куеу", "advertisementMessage": "енке"}', 25, 19);


--
-- TOC entry 5891 (class 0 OID 17276)
-- Dependencies: 351
-- Data for Name: transaction_details; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.transaction_details VALUES (6, 163, 2, 200, 400, NULL, 0, 1, NULL, NULL, 0, 0, 0, 0, 0, 18, 0, 0, false, NULL, 0, NULL);
INSERT INTO public.transaction_details VALUES (6, 156, 2, 100, 200, NULL, 0, 2, NULL, NULL, 0, 0, 0, 0, 0, 18, 0, 0, false, NULL, 0, NULL);


--
-- TOC entry 5982 (class 0 OID 17712)
-- Dependencies: 448
-- Data for Name: transaction_promotions; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5893 (class 0 OID 17294)
-- Dependencies: 353
-- Data for Name: transactions; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.transactions VALUES (6, 1, 600, 23, 24, NULL, 0, NULL, NULL, NULL, 36, '2025-11-26 06:46:59', 0, 'cash', NULL, 600, NULL, NULL, NULL, 0, 0, 18, 1, 1, 0, NULL, NULL, 0, 0, 0, false, NULL, false, NULL);


--
-- TOC entry 5985 (class 0 OID 17719)
-- Dependencies: 451
-- Data for Name: unit_spr; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.unit_spr VALUES (0, NULL, 'Наименование', NULL, 2, false);
INSERT INTO public.unit_spr VALUES (2, NULL, 'Упаковка', 'упак', 2, false);
INSERT INTO public.unit_spr VALUES (1, NULL, 'Штуки', 'шт', 2, false);
INSERT INTO public.unit_spr VALUES (3, NULL, 'Услуга', NULL, 2, false);
INSERT INTO public.unit_spr VALUES (4, NULL, 'Час', NULL, 2, false);
INSERT INTO public.unit_spr VALUES (5, NULL, 'Грамм', 'г', 3, false);
INSERT INTO public.unit_spr VALUES (6, NULL, 'Килограмм', 'кг', 3, false);
INSERT INTO public.unit_spr VALUES (7, NULL, 'Тонна', 'т', 3, false);
INSERT INTO public.unit_spr VALUES (8, NULL, 'Литр', 'л', 3, false);
INSERT INTO public.unit_spr VALUES (9, NULL, 'Кубический метр', 'м3', 3, false);
INSERT INTO public.unit_spr VALUES (10, NULL, 'Километр', 'км', 4, false);
INSERT INTO public.unit_spr VALUES (11, NULL, 'Метр', 'м', 4, false);
INSERT INTO public.unit_spr VALUES (12, NULL, 'Метр погонный', NULL, 4, false);
INSERT INTO public.unit_spr VALUES (13, NULL, 'Квадратный метр', 'м2', 4, false);
INSERT INTO public.unit_spr VALUES (16, NULL, 'Коробка', NULL, 2, false);
INSERT INTO public.unit_spr VALUES (17, NULL, 'Одна пачка', NULL, 2, false);
INSERT INTO public.unit_spr VALUES (18, NULL, 'Комплект', 'компл', 2, false);
INSERT INTO public.unit_spr VALUES (19, NULL, 'Пара', 'пара', 2, false);
INSERT INTO public.unit_spr VALUES (20, NULL, 'Рулон', 'рул', 2, false);


--
-- TOC entry 5986 (class 0 OID 17727)
-- Dependencies: 452
-- Data for Name: user2roles; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.user2roles VALUES (37, 1);
INSERT INTO public.user2roles VALUES (37, 3);
INSERT INTO public.user2roles VALUES (34, 2);
INSERT INTO public.user2roles VALUES (32, 1);
INSERT INTO public.user2roles VALUES (32, 4);
INSERT INTO public.user2roles VALUES (8, 1);
INSERT INTO public.user2roles VALUES (8, 3);
INSERT INTO public.user2roles VALUES (114, 1);
INSERT INTO public.user2roles VALUES (114, 6);
INSERT INTO public.user2roles VALUES (114, 5);
INSERT INTO public.user2roles VALUES (114, 8);
INSERT INTO public.user2roles VALUES (38, 1);
INSERT INTO public.user2roles VALUES (39, 4);
INSERT INTO public.user2roles VALUES (40, 4);
INSERT INTO public.user2roles VALUES (114, 3);
INSERT INTO public.user2roles VALUES (36, 2);
INSERT INTO public.user2roles VALUES (177, 1);
INSERT INTO public.user2roles VALUES (179, 2);
INSERT INTO public.user2roles VALUES (170, 5);
INSERT INTO public.user2roles VALUES (180, 2);
INSERT INTO public.user2roles VALUES (43, 1);
INSERT INTO public.user2roles VALUES (182, 2);
INSERT INTO public.user2roles VALUES (44, 1);
INSERT INTO public.user2roles VALUES (45, 1);
INSERT INTO public.user2roles VALUES (46, 1);
INSERT INTO public.user2roles VALUES (47, 1);
INSERT INTO public.user2roles VALUES (48, 1);
INSERT INTO public.user2roles VALUES (49, 1);
INSERT INTO public.user2roles VALUES (50, 1);
INSERT INTO public.user2roles VALUES (51, 1);
INSERT INTO public.user2roles VALUES (52, 1);
INSERT INTO public.user2roles VALUES (53, 1);
INSERT INTO public.user2roles VALUES (54, 1);
INSERT INTO public.user2roles VALUES (55, 1);
INSERT INTO public.user2roles VALUES (56, 1);
INSERT INTO public.user2roles VALUES (57, 1);
INSERT INTO public.user2roles VALUES (58, 1);
INSERT INTO public.user2roles VALUES (59, 1);
INSERT INTO public.user2roles VALUES (60, 1);
INSERT INTO public.user2roles VALUES (61, 1);
INSERT INTO public.user2roles VALUES (62, 1);
INSERT INTO public.user2roles VALUES (63, 1);
INSERT INTO public.user2roles VALUES (64, 1);
INSERT INTO public.user2roles VALUES (182, 3);
INSERT INTO public.user2roles VALUES (183, 2);
INSERT INTO public.user2roles VALUES (35, 3);
INSERT INTO public.user2roles VALUES (183, 3);
INSERT INTO public.user2roles VALUES (185, 2);
INSERT INTO public.user2roles VALUES (185, 3);
INSERT INTO public.user2roles VALUES (188, 2);
INSERT INTO public.user2roles VALUES (188, 3);
INSERT INTO public.user2roles VALUES (75, 1);
INSERT INTO public.user2roles VALUES (75, 4);
INSERT INTO public.user2roles VALUES (75, 6);
INSERT INTO public.user2roles VALUES (76, 1);
INSERT INTO public.user2roles VALUES (76, 6);
INSERT INTO public.user2roles VALUES (76, 4);
INSERT INTO public.user2roles VALUES (42, 1);
INSERT INTO public.user2roles VALUES (42, 4);
INSERT INTO public.user2roles VALUES (166, 4);
INSERT INTO public.user2roles VALUES (166, 1);
INSERT INTO public.user2roles VALUES (42, 6);
INSERT INTO public.user2roles VALUES (175, 1);
INSERT INTO public.user2roles VALUES (175, 6);
INSERT INTO public.user2roles VALUES (78, 4);
INSERT INTO public.user2roles VALUES (71, 1);
INSERT INTO public.user2roles VALUES (71, 4);
INSERT INTO public.user2roles VALUES (71, 6);
INSERT INTO public.user2roles VALUES (66, 1);
INSERT INTO public.user2roles VALUES (193, 1);
INSERT INTO public.user2roles VALUES (70, 2);
INSERT INTO public.user2roles VALUES (67, 1);
INSERT INTO public.user2roles VALUES (67, 4);
INSERT INTO public.user2roles VALUES (192, 1);
INSERT INTO public.user2roles VALUES (173, 5);
INSERT INTO public.user2roles VALUES (10, 2);
INSERT INTO public.user2roles VALUES (10, 1);
INSERT INTO public.user2roles VALUES (80, 1);
INSERT INTO public.user2roles VALUES (176, 1);
INSERT INTO public.user2roles VALUES (200, 1);
INSERT INTO public.user2roles VALUES (81, 1);
INSERT INTO public.user2roles VALUES (81, 4);
INSERT INTO public.user2roles VALUES (82, 4);
INSERT INTO public.user2roles VALUES (83, 1);
INSERT INTO public.user2roles VALUES (83, 4);
INSERT INTO public.user2roles VALUES (174, 5);
INSERT INTO public.user2roles VALUES (169, 5);
INSERT INTO public.user2roles VALUES (169, 6);
INSERT INTO public.user2roles VALUES (169, 8);
INSERT INTO public.user2roles VALUES (169, 3);
INSERT INTO public.user2roles VALUES (84, 1);
INSERT INTO public.user2roles VALUES (219, 1);
INSERT INTO public.user2roles VALUES (231, 1);
INSERT INTO public.user2roles VALUES (85, 1);
INSERT INTO public.user2roles VALUES (86, 1);
INSERT INTO public.user2roles VALUES (87, 1);
INSERT INTO public.user2roles VALUES (88, 1);
INSERT INTO public.user2roles VALUES (89, 1);
INSERT INTO public.user2roles VALUES (90, 1);
INSERT INTO public.user2roles VALUES (-1, 0);
INSERT INTO public.user2roles VALUES (93, 6);
INSERT INTO public.user2roles VALUES (94, 1);
INSERT INTO public.user2roles VALUES (95, 1);
INSERT INTO public.user2roles VALUES (96, 1);
INSERT INTO public.user2roles VALUES (97, 1);
INSERT INTO public.user2roles VALUES (97, 2);
INSERT INTO public.user2roles VALUES (97, 3);
INSERT INTO public.user2roles VALUES (97, 4);
INSERT INTO public.user2roles VALUES (97, 5);
INSERT INTO public.user2roles VALUES (97, 6);
INSERT INTO public.user2roles VALUES (98, 1);
INSERT INTO public.user2roles VALUES (99, 1);
INSERT INTO public.user2roles VALUES (110, 1);
INSERT INTO public.user2roles VALUES (111, 1);
INSERT INTO public.user2roles VALUES (112, 1);
INSERT INTO public.user2roles VALUES (112, 2);
INSERT INTO public.user2roles VALUES (112, 3);
INSERT INTO public.user2roles VALUES (112, 4);
INSERT INTO public.user2roles VALUES (112, 5);
INSERT INTO public.user2roles VALUES (112, 6);
INSERT INTO public.user2roles VALUES (113, 1);
INSERT INTO public.user2roles VALUES (113, 2);
INSERT INTO public.user2roles VALUES (113, 3);
INSERT INTO public.user2roles VALUES (113, 4);
INSERT INTO public.user2roles VALUES (113, 5);
INSERT INTO public.user2roles VALUES (113, 6);
INSERT INTO public.user2roles VALUES (115, 1);
INSERT INTO public.user2roles VALUES (117, 1);
INSERT INTO public.user2roles VALUES (119, 1);
INSERT INTO public.user2roles VALUES (65, 3);
INSERT INTO public.user2roles VALUES (91, 4);
INSERT INTO public.user2roles VALUES (91, 6);
INSERT INTO public.user2roles VALUES (79, 4);
INSERT INTO public.user2roles VALUES (79, 1);
INSERT INTO public.user2roles VALUES (-1, 1);
INSERT INTO public.user2roles VALUES (-1, 4);
INSERT INTO public.user2roles VALUES (0, 0);
INSERT INTO public.user2roles VALUES (0, 1);
INSERT INTO public.user2roles VALUES (0, 4);
INSERT INTO public.user2roles VALUES (41, 1);
INSERT INTO public.user2roles VALUES (41, 4);
INSERT INTO public.user2roles VALUES (121, 1);
INSERT INTO public.user2roles VALUES (121, 3);
INSERT INTO public.user2roles VALUES (121, 2);
INSERT INTO public.user2roles VALUES (121, 4);
INSERT INTO public.user2roles VALUES (121, 5);
INSERT INTO public.user2roles VALUES (121, 6);
INSERT INTO public.user2roles VALUES (124, 4);
INSERT INTO public.user2roles VALUES (126, 1);
INSERT INTO public.user2roles VALUES (122, 1);
INSERT INTO public.user2roles VALUES (122, 6);
INSERT INTO public.user2roles VALUES (133, 6);
INSERT INTO public.user2roles VALUES (135, 6);
INSERT INTO public.user2roles VALUES (144, 1);
INSERT INTO public.user2roles VALUES (145, 1);
INSERT INTO public.user2roles VALUES (145, 6);
INSERT INTO public.user2roles VALUES (123, 1);
INSERT INTO public.user2roles VALUES (123, 6);
INSERT INTO public.user2roles VALUES (123, 8);
INSERT INTO public.user2roles VALUES (148, 8);
INSERT INTO public.user2roles VALUES (148, 1);
INSERT INTO public.user2roles VALUES (148, 3);
INSERT INTO public.user2roles VALUES (148, 5);
INSERT INTO public.user2roles VALUES (165, 5);
INSERT INTO public.user2roles VALUES (152, 5);
INSERT INTO public.user2roles VALUES (149, 6);
INSERT INTO public.user2roles VALUES (149, 3);
INSERT INTO public.user2roles VALUES (151, 2);
INSERT INTO public.user2roles VALUES (151, 3);
INSERT INTO public.user2roles VALUES (153, 8);
INSERT INTO public.user2roles VALUES (154, 1);
INSERT INTO public.user2roles VALUES (150, 6);
INSERT INTO public.user2roles VALUES (125, 1);
INSERT INTO public.user2roles VALUES (125, 3);
INSERT INTO public.user2roles VALUES (125, 2);
INSERT INTO public.user2roles VALUES (125, 5);
INSERT INTO public.user2roles VALUES (125, 4);
INSERT INTO public.user2roles VALUES (125, 6);
INSERT INTO public.user2roles VALUES (155, 1);
INSERT INTO public.user2roles VALUES (146, 1);
INSERT INTO public.user2roles VALUES (146, 8);
INSERT INTO public.user2roles VALUES (147, 2);
INSERT INTO public.user2roles VALUES (147, 3);
INSERT INTO public.user2roles VALUES (147, 5);
INSERT INTO public.user2roles VALUES (147, 6);
INSERT INTO public.user2roles VALUES (147, 8);
INSERT INTO public.user2roles VALUES (162, 3);
INSERT INTO public.user2roles VALUES (162, 8);
INSERT INTO public.user2roles VALUES (164, 1);
INSERT INTO public.user2roles VALUES (171, 8);
INSERT INTO public.user2roles VALUES (171, 1);
INSERT INTO public.user2roles VALUES (181, 2);
INSERT INTO public.user2roles VALUES (184, 2);
INSERT INTO public.user2roles VALUES (184, 3);
INSERT INTO public.user2roles VALUES (186, 2);
INSERT INTO public.user2roles VALUES (186, 3);
INSERT INTO public.user2roles VALUES (196, 1);
INSERT INTO public.user2roles VALUES (198, 1);
INSERT INTO public.user2roles VALUES (199, 1);
INSERT INTO public.user2roles VALUES (191, 1);
INSERT INTO public.user2roles VALUES (191, 2);
INSERT INTO public.user2roles VALUES (168, 3);
INSERT INTO public.user2roles VALUES (168, 2);
INSERT INTO public.user2roles VALUES (201, 2);
INSERT INTO public.user2roles VALUES (168, 1);
INSERT INTO public.user2roles VALUES (168, 4);
INSERT INTO public.user2roles VALUES (168, 8);
INSERT INTO public.user2roles VALUES (190, 1);
INSERT INTO public.user2roles VALUES (190, 3);
INSERT INTO public.user2roles VALUES (211, 1);
INSERT INTO public.user2roles VALUES (212, 1);
INSERT INTO public.user2roles VALUES (143, 6);
INSERT INTO public.user2roles VALUES (232, 1);
INSERT INTO public.user2roles VALUES (235, 1);
INSERT INTO public.user2roles VALUES (236, 1);
INSERT INTO public.user2roles VALUES (237, 1);
INSERT INTO public.user2roles VALUES (238, 1);
INSERT INTO public.user2roles VALUES (241, 1);
INSERT INTO public.user2roles VALUES (241, 0);
INSERT INTO public.user2roles VALUES (241, 4);
INSERT INTO public.user2roles VALUES (242, 1);
INSERT INTO public.user2roles VALUES (243, 1);
INSERT INTO public.user2roles VALUES (248, 1);
INSERT INTO public.user2roles VALUES (249, 1);
INSERT INTO public.user2roles VALUES (250, 1);
INSERT INTO public.user2roles VALUES (252, 1);
INSERT INTO public.user2roles VALUES (253, 1);
INSERT INTO public.user2roles VALUES (255, 1);
INSERT INTO public.user2roles VALUES (256, 1);
INSERT INTO public.user2roles VALUES (257, 1);
INSERT INTO public.user2roles VALUES (268, 1);
INSERT INTO public.user2roles VALUES (270, 1);
INSERT INTO public.user2roles VALUES (271, 1);
INSERT INTO public.user2roles VALUES (272, 1);
INSERT INTO public.user2roles VALUES (273, 1);
INSERT INTO public.user2roles VALUES (274, 1);
INSERT INTO public.user2roles VALUES (275, 1);
INSERT INTO public.user2roles VALUES (276, 1);
INSERT INTO public.user2roles VALUES (277, 1);
INSERT INTO public.user2roles VALUES (42, 0);


--
-- TOC entry 5987 (class 0 OID 17730)
-- Dependencies: 453
-- Data for Name: versions; Type: TABLE DATA; Schema: public; Owner: postgres
--

INSERT INTO public.versions OVERRIDING SYSTEM VALUE VALUES (1, '0001_create_table.sql', NULL);


--
-- TOC entry 5990 (class 0 OID 17740)
-- Dependencies: 456
-- Data for Name: workorder; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5991 (class 0 OID 17748)
-- Dependencies: 457
-- Data for Name: workorder_details; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 5995 (class 0 OID 17762)
-- Dependencies: 461
-- Data for Name: zreportdiary; Type: TABLE DATA; Schema: public; Owner: postgres
--



--
-- TOC entry 6465 (class 0 OID 0)
-- Dependencies: 464
-- Name: access_table_copy_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.access_table_copy_id_seq', 1, false);


--
-- TOC entry 6466 (class 0 OID 0)
-- Dependencies: 206
-- Name: access_table_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.access_table_id_seq', 1, false);


--
-- TOC entry 6467 (class 0 OID 0)
-- Dependencies: 466
-- Name: access_tableu_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.access_tableu_id_seq', 27, true);


--
-- TOC entry 6468 (class 0 OID 0)
-- Dependencies: 209
-- Name: action_logs_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.action_logs_id_seq', 1, false);


--
-- TOC entry 6469 (class 0 OID 0)
-- Dependencies: 211
-- Name: admin_accesspartner_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.admin_accesspartner_id_seq', 1, true);


--
-- TOC entry 6470 (class 0 OID 0)
-- Dependencies: 214
-- Name: admincompanies_report_details_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.admincompanies_report_details_id_seq', 1, false);


--
-- TOC entry 6471 (class 0 OID 0)
-- Dependencies: 215
-- Name: attribcode_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.attribcode_id_seq', 1, false);


--
-- TOC entry 6472 (class 0 OID 0)
-- Dependencies: 217
-- Name: attributecat_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.attributecat_id_seq', 1, false);


--
-- TOC entry 6473 (class 0 OID 0)
-- Dependencies: 219
-- Name: attributelistcode_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.attributelistcode_id_seq', 76, true);


--
-- TOC entry 6474 (class 0 OID 0)
-- Dependencies: 221
-- Name: attributenames_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.attributenames_id_seq', 29, true);


--
-- TOC entry 6475 (class 0 OID 0)
-- Dependencies: 222
-- Name: attributespr_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.attributespr_id_seq', 39, true);


--
-- TOC entry 6476 (class 0 OID 0)
-- Dependencies: 225
-- Name: attrset_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.attrset_id_seq', 1, false);


--
-- TOC entry 6477 (class 0 OID 0)
-- Dependencies: 226
-- Name: barcode_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.barcode_seq', 107, true);


--
-- TOC entry 6478 (class 0 OID 0)
-- Dependencies: 227
-- Name: bonuscards_diary_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.bonuscards_diary_id_seq', 1, false);


--
-- TOC entry 6479 (class 0 OID 0)
-- Dependencies: 229
-- Name: bonuscardsdiary_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.bonuscardsdiary_id_seq', 1, false);


--
-- TOC entry 6480 (class 0 OID 0)
-- Dependencies: 230
-- Name: bonusgroup_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.bonusgroup_seq', 1, false);


--
-- TOC entry 6481 (class 0 OID 0)
-- Dependencies: 231
-- Name: bonustypes_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.bonustypes_id_seq', 1, false);


--
-- TOC entry 6482 (class 0 OID 0)
-- Dependencies: 232
-- Name: brands_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.brands_id_seq', 20, true);


--
-- TOC entry 6483 (class 0 OID 0)
-- Dependencies: 235
-- Name: cashbox_roles_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.cashbox_roles_id_seq', 4, true);


--
-- TOC entry 6484 (class 0 OID 0)
-- Dependencies: 236
-- Name: cashbox_update_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.cashbox_update_id_seq', 1, false);


--
-- TOC entry 6485 (class 0 OID 0)
-- Dependencies: 238
-- Name: cashbox_updates_pk_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.cashbox_updates_pk_id_seq', 1, false);


--
-- TOC entry 6486 (class 0 OID 0)
-- Dependencies: 240
-- Name: cashbox_users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.cashbox_users_id_seq', 24, true);


--
-- TOC entry 6487 (class 0 OID 0)
-- Dependencies: 242
-- Name: cashboxdiary_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.cashboxdiary_id_seq', 1, false);


--
-- TOC entry 6488 (class 0 OID 0)
-- Dependencies: 244
-- Name: cashboxdiary_types_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.cashboxdiary_types_id_seq', 1, false);


--
-- TOC entry 6489 (class 0 OID 0)
-- Dependencies: 246
-- Name: cashboxes_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.cashboxes_id_seq', 24, true);


--
-- TOC entry 6490 (class 0 OID 0)
-- Dependencies: 248
-- Name: categories_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.categories_id_seq', 61, true);


--
-- TOC entry 6491 (class 0 OID 0)
-- Dependencies: 250
-- Name: certificategroup_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.certificategroup_seq', 1, false);


--
-- TOC entry 6492 (class 0 OID 0)
-- Dependencies: 252
-- Name: changeprice_history_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.changeprice_history_id_seq', 74, true);


--
-- TOC entry 6493 (class 0 OID 0)
-- Dependencies: 254
-- Name: clients_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.clients_seq', 1, false);


--
-- TOC entry 6494 (class 0 OID 0)
-- Dependencies: 256
-- Name: closedcash_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.closedcash_id_seq', 1, false);


--
-- TOC entry 6495 (class 0 OID 0)
-- Dependencies: 260
-- Name: companies_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.companies_id_seq', 185, true);


--
-- TOC entry 6496 (class 0 OID 0)
-- Dependencies: 572
-- Name: company_types_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.company_types_id_seq', 2, true);


--
-- TOC entry 6497 (class 0 OID 0)
-- Dependencies: 265
-- Name: consignment_snapshots_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.consignment_snapshots_id_seq', 1, false);


--
-- TOC entry 6498 (class 0 OID 0)
-- Dependencies: 267
-- Name: counterparties_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.counterparties_id_seq', 10, true);


--
-- TOC entry 6499 (class 0 OID 0)
-- Dependencies: 270
-- Name: coupons_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.coupons_id_seq', 15, true);


--
-- TOC entry 6500 (class 0 OID 0)
-- Dependencies: 273
-- Name: couponsdiary_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.couponsdiary_id_seq', 22, true);


--
-- TOC entry 6501 (class 0 OID 0)
-- Dependencies: 277
-- Name: customers_bonuscards_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.customers_bonuscards_id_seq', 1, false);


--
-- TOC entry 6502 (class 0 OID 0)
-- Dependencies: 275
-- Name: customers_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.customers_id_seq', 4, true);


--
-- TOC entry 6503 (class 0 OID 0)
-- Dependencies: 279
-- Name: debtors_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.debtors_id_seq', 2, true);


--
-- TOC entry 6504 (class 0 OID 0)
-- Dependencies: 280
-- Name: debtorsdiary_id; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.debtorsdiary_id', 1, false);


--
-- TOC entry 6505 (class 0 OID 0)
-- Dependencies: 282
-- Name: discount_types_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.discount_types_id_seq', 4, true);


--
-- TOC entry 6506 (class 0 OID 0)
-- Dependencies: 283
-- Name: discounts_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.discounts_id_seq', 41, true);


--
-- TOC entry 6507 (class 0 OID 0)
-- Dependencies: 288
-- Name: erp_roles_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.erp_roles_id_seq', 51, true);


--
-- TOC entry 6508 (class 0 OID 0)
-- Dependencies: 290
-- Name: erp_users_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.erp_users_id_seq', 287, true);


--
-- TOC entry 6509 (class 0 OID 0)
-- Dependencies: 293
-- Name: esf_details_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.esf_details_id_seq', 1, false);


--
-- TOC entry 6510 (class 0 OID 0)
-- Dependencies: 295
-- Name: esf_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.esf_id_seq', 1, false);


--
-- TOC entry 6511 (class 0 OID 0)
-- Dependencies: 297
-- Name: expdate_discount_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.expdate_discount_id_seq', 2, true);


--
-- TOC entry 6512 (class 0 OID 0)
-- Dependencies: 304
-- Name: giftcertificates_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.giftcertificates_id_seq', 6, true);


--
-- TOC entry 6513 (class 0 OID 0)
-- Dependencies: 306
-- Name: giftcertificates_write-off_balances_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public."giftcertificates_write-off_balances_id_seq"', 1, false);


--
-- TOC entry 6514 (class 0 OID 0)
-- Dependencies: 308
-- Name: giftcertificatesdiary_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.giftcertificatesdiary_id_seq', 7, true);


--
-- TOC entry 6515 (class 0 OID 0)
-- Dependencies: 311
-- Name: giftcertificatetypes_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.giftcertificatetypes_id_seq', 1, true);


--
-- TOC entry 6516 (class 0 OID 0)
-- Dependencies: 320
-- Name: invoicelist_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.invoicelist_id_seq', 442, true);


--
-- TOC entry 6517 (class 0 OID 0)
-- Dependencies: 322
-- Name: invoices_invoicenumber_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.invoices_invoicenumber_seq', 287, true);


--
-- TOC entry 6518 (class 0 OID 0)
-- Dependencies: 462
-- Name: locales_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.locales_id_seq', 1, false);


--
-- TOC entry 6519 (class 0 OID 0)
-- Dependencies: 325
-- Name: margin_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.margin_id_seq', 18, true);


--
-- TOC entry 6520 (class 0 OID 0)
-- Dependencies: 330
-- Name: news_diary_pk_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.news_diary_pk_id_seq', 1, false);


--
-- TOC entry 6521 (class 0 OID 0)
-- Dependencies: 331
-- Name: news_id_sequence; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.news_id_sequence', 11, true);


--
-- TOC entry 6522 (class 0 OID 0)
-- Dependencies: 333
-- Name: newtable1_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.newtable1_id_seq', 2, true);


--
-- TOC entry 6523 (class 0 OID 0)
-- Dependencies: 335
-- Name: origincodes_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.origincodes_id_seq', 1, false);


--
-- TOC entry 6524 (class 0 OID 0)
-- Dependencies: 338
-- Name: payments_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.payments_id_seq', 1, false);


--
-- TOC entry 6525 (class 0 OID 0)
-- Dependencies: 340
-- Name: pluproducts_scale_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.pluproducts_scale_id_seq', 1, false);


--
-- TOC entry 6526 (class 0 OID 0)
-- Dependencies: 342
-- Name: point_types_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.point_types_id_seq', 1, true);


--
-- TOC entry 6527 (class 0 OID 0)
-- Dependencies: 344
-- Name: points_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.points_id_seq', 90, true);


--
-- TOC entry 6528 (class 0 OID 0)
-- Dependencies: 347
-- Name: prices_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.prices_id_seq', 1, false);


--
-- TOC entry 6529 (class 0 OID 0)
-- Dependencies: 349
-- Name: prices_log_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.prices_log_id_seq', 1, false);


--
-- TOC entry 6530 (class 0 OID 0)
-- Dependencies: 357
-- Name: product_accounting_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.product_accounting_id_seq', 77, true);


--
-- TOC entry 6531 (class 0 OID 0)
-- Dependencies: 360
-- Name: products_barcode_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.products_barcode_id_seq', 106, true);


--
-- TOC entry 6532 (class 0 OID 0)
-- Dependencies: 313
-- Name: products_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.products_id_seq', 192, true);


--
-- TOC entry 6533 (class 0 OID 0)
-- Dependencies: 361
-- Name: products_id_temp_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.products_id_temp_seq', 1, false);


--
-- TOC entry 6534 (class 0 OID 0)
-- Dependencies: 362
-- Name: products_spr_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.products_spr_id_seq', 1, false);


--
-- TOC entry 6535 (class 0 OID 0)
-- Dependencies: 365
-- Name: products_weight_productsweight_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.products_weight_productsweight_id_seq', 1, false);


--
-- TOC entry 6536 (class 0 OID 0)
-- Dependencies: 367
-- Name: productsweight_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.productsweight_id_seq', 1, false);


--
-- TOC entry 6537 (class 0 OID 0)
-- Dependencies: 372
-- Name: promotions_condlist_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.promotions_condlist_seq', 19, true);


--
-- TOC entry 6538 (class 0 OID 0)
-- Dependencies: 373
-- Name: promotions_disclist_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.promotions_disclist_seq', 19, true);


--
-- TOC entry 6539 (class 0 OID 0)
-- Dependencies: 374
-- Name: promotions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.promotions_id_seq', 19, true);


--
-- TOC entry 6540 (class 0 OID 0)
-- Dependencies: 377
-- Name: reconciliation_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.reconciliation_id_seq', 1, false);


--
-- TOC entry 6541 (class 0 OID 0)
-- Dependencies: 380
-- Name: result_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.result_id_seq', 1, false);


--
-- TOC entry 6542 (class 0 OID 0)
-- Dependencies: 381
-- Name: rev_temp_id; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.rev_temp_id', 27, true);


--
-- TOC entry 6543 (class 0 OID 0)
-- Dependencies: 383
-- Name: reviselist_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.reviselist_id_seq', 1, false);


--
-- TOC entry 6544 (class 0 OID 0)
-- Dependencies: 386
-- Name: revision_difference_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.revision_difference_id_seq', 1, false);


--
-- TOC entry 6545 (class 0 OID 0)
-- Dependencies: 388
-- Name: revision_list_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.revision_list_id_seq', 58, true);


--
-- TOC entry 6546 (class 0 OID 0)
-- Dependencies: 391
-- Name: revisiondiary_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.revisiondiary_id_seq', 11, true);


--
-- TOC entry 6547 (class 0 OID 0)
-- Dependencies: 393
-- Name: revisiondiary_old_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.revisiondiary_old_id_seq', 1, false);


--
-- TOC entry 6548 (class 0 OID 0)
-- Dependencies: 397
-- Name: salesplan_types_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.salesplan_types_id_seq', 3, true);


--
-- TOC entry 6549 (class 0 OID 0)
-- Dependencies: 398
-- Name: scale_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.scale_id_seq', 9, true);


--
-- TOC entry 6550 (class 0 OID 0)
-- Dependencies: 403
-- Name: settings_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.settings_id_seq', 3, true);


--
-- TOC entry 6551 (class 0 OID 0)
-- Dependencies: 407
-- Name: songs1_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs1_id_seq', 1, false);


--
-- TOC entry 6552 (class 0 OID 0)
-- Dependencies: 410
-- Name: songs3_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs3_id_seq', 3, true);


--
-- TOC entry 6553 (class 0 OID 0)
-- Dependencies: 414
-- Name: songs8_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs8_id_seq', 1, false);


--
-- TOC entry 6554 (class 0 OID 0)
-- Dependencies: 416
-- Name: songs_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs_id_seq', 21, true);


--
-- TOC entry 6555 (class 0 OID 0)
-- Dependencies: 417
-- Name: songs_id_seq1; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs_id_seq1', 3, true);


--
-- TOC entry 6556 (class 0 OID 0)
-- Dependencies: 418
-- Name: songs_id_seq2; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs_id_seq2', 7, true);


--
-- TOC entry 6557 (class 0 OID 0)
-- Dependencies: 419
-- Name: songs_id_seq3; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs_id_seq3', 3, true);


--
-- TOC entry 6558 (class 0 OID 0)
-- Dependencies: 420
-- Name: songs_id_seq4; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.songs_id_seq4', 2, true);


--
-- TOC entry 6559 (class 0 OID 0)
-- Dependencies: 422
-- Name: stock_minmax_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stock_minmax_id_seq', 1, false);


--
-- TOC entry 6560 (class 0 OID 0)
-- Dependencies: 315
-- Name: stockcurrent_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stockcurrent_id_seq', 90, true);


--
-- TOC entry 6561 (class 0 OID 0)
-- Dependencies: 424
-- Name: stockcurrent_part_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stockcurrent_part_id_seq', 96, true);


--
-- TOC entry 6562 (class 0 OID 0)
-- Dependencies: 426
-- Name: stockdiary_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stockdiary_id_seq', 1, false);


--
-- TOC entry 6563 (class 0 OID 0)
-- Dependencies: 427
-- Name: stockdiary_id_seq1; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stockdiary_id_seq1', 286, true);


--
-- TOC entry 6564 (class 0 OID 0)
-- Dependencies: 428
-- Name: stockdiary_sc_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stockdiary_sc_id_seq', 1, false);


--
-- TOC entry 6565 (class 0 OID 0)
-- Dependencies: 429
-- Name: stockdiary_scp_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stockdiary_scp_id_seq', 1, false);


--
-- TOC entry 6566 (class 0 OID 0)
-- Dependencies: 430
-- Name: stocklevel_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.stocklevel_id_seq', 1, false);


--
-- TOC entry 6567 (class 0 OID 0)
-- Dependencies: 434
-- Name: systemmessage_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.systemmessage_id_seq', 1, false);


--
-- TOC entry 6568 (class 0 OID 0)
-- Dependencies: 435
-- Name: taxcategories_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.taxcategories_id_seq', 1, false);


--
-- TOC entry 6569 (class 0 OID 0)
-- Dependencies: 442
-- Name: tezmodules_access_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.tezmodules_access_seq', 1, false);


--
-- TOC entry 6570 (class 0 OID 0)
-- Dependencies: 440
-- Name: tezmodules_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.tezmodules_seq', 1, false);


--
-- TOC entry 6571 (class 0 OID 0)
-- Dependencies: 445
-- Name: ticket_format_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.ticket_format_id_seq', 19, true);


--
-- TOC entry 6572 (class 0 OID 0)
-- Dependencies: 446
-- Name: ticketlines_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.ticketlines_id_seq', 1, false);


--
-- TOC entry 6573 (class 0 OID 0)
-- Dependencies: 447
-- Name: tickets_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.tickets_id_seq', 1, false);


--
-- TOC entry 6574 (class 0 OID 0)
-- Dependencies: 449
-- Name: transaction_promotions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.transaction_promotions_id_seq', 1, false);


--
-- TOC entry 6575 (class 0 OID 0)
-- Dependencies: 352
-- Name: transactions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.transactions_id_seq', 6, true);


--
-- TOC entry 6576 (class 0 OID 0)
-- Dependencies: 450
-- Name: unit_spr_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.unit_spr_id_seq', 21, true);


--
-- TOC entry 6577 (class 0 OID 0)
-- Dependencies: 454
-- Name: versions_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.versions_id_seq', 1, true);


--
-- TOC entry 6578 (class 0 OID 0)
-- Dependencies: 455
-- Name: versions_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.versions_seq', 1, false);


--
-- TOC entry 6579 (class 0 OID 0)
-- Dependencies: 458
-- Name: workorder_details_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.workorder_details_id_seq', 1, false);


--
-- TOC entry 6580 (class 0 OID 0)
-- Dependencies: 459
-- Name: workorder_id_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.workorder_id_seq', 1, false);


--
-- TOC entry 6581 (class 0 OID 0)
-- Dependencies: 460
-- Name: workorder_seq; Type: SEQUENCE SET; Schema: public; Owner: postgres
--

SELECT pg_catalog.setval('public.workorder_seq', 1, false);


--
-- TOC entry 5241 (class 2606 OID 49771)
-- Name: jobcheck jobcheck_pkey; Type: CONSTRAINT; Schema: analytics; Owner: postgres
--

ALTER TABLE ONLY analytics.jobcheck
    ADD CONSTRAINT jobcheck_pkey PRIMARY KEY (jobname);


--
-- TOC entry 5339 (class 2606 OID 49773)
-- Name: function_calls tabl_vuzov_pkey; Type: CONSTRAINT; Schema: functioncalls; Owner: postgres
--

ALTER TABLE ONLY functioncalls.function_calls
    ADD CONSTRAINT tabl_vuzov_pkey PRIMARY KEY (id);


--
-- TOC entry 4864 (class 2606 OID 17833)
-- Name: action_logs action_logs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.action_logs
    ADD CONSTRAINT action_logs_pkey PRIMARY KEY (id);


--
-- TOC entry 4866 (class 2606 OID 17835)
-- Name: admin_accesspartner admin_accesspartner_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.admin_accesspartner
    ADD CONSTRAINT admin_accesspartner_pkey PRIMARY KEY (id);


--
-- TOC entry 4871 (class 2606 OID 17837)
-- Name: admincompanies_report_details admincompanies_report_details_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.admincompanies_report_details
    ADD CONSTRAINT admincompanies_report_details_pkey PRIMARY KEY (id);


--
-- TOC entry 4868 (class 2606 OID 17839)
-- Name: admincompanies_report admincompanies_report_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.admincompanies_report
    ADD CONSTRAINT admincompanies_report_pkey PRIMARY KEY (date);


--
-- TOC entry 4873 (class 2606 OID 17841)
-- Name: attributecat attributecat_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributecat
    ADD CONSTRAINT attributecat_pkey PRIMARY KEY (id);


--
-- TOC entry 4876 (class 2606 OID 17843)
-- Name: attributelistcode attributelistcode_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributelistcode
    ADD CONSTRAINT attributelistcode_pkey PRIMARY KEY (id);


--
-- TOC entry 4878 (class 2606 OID 17845)
-- Name: attributenames attributenames_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributenames
    ADD CONSTRAINT attributenames_pkey PRIMARY KEY (id);


--
-- TOC entry 4881 (class 2606 OID 17847)
-- Name: attributespr attributespr_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributespr
    ADD CONSTRAINT attributespr_pkey PRIMARY KEY (attributeid, id, company);


--
-- TOC entry 4884 (class 2606 OID 17849)
-- Name: attrlist attrlist_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attrlist
    ADD CONSTRAINT attrlist_pkey PRIMARY KEY (listcode, attribute, company);


--
-- TOC entry 4887 (class 2606 OID 17851)
-- Name: bonuscardsdiary bonuscardsdiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.bonuscardsdiary
    ADD CONSTRAINT bonuscardsdiary_pkey PRIMARY KEY (id);


--
-- TOC entry 4891 (class 2606 OID 17853)
-- Name: brands brands_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.brands
    ADD CONSTRAINT brands_pkey PRIMARY KEY (id);


--
-- TOC entry 4893 (class 2606 OID 17855)
-- Name: cashbox_roles cashbox_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_roles
    ADD CONSTRAINT cashbox_roles_pkey PRIMARY KEY (id);


--
-- TOC entry 4895 (class 2606 OID 17857)
-- Name: cashbox_updates cashbox_updates_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_updates
    ADD CONSTRAINT cashbox_updates_pkey PRIMARY KEY (pk_id);


--
-- TOC entry 4897 (class 2606 OID 17859)
-- Name: cashbox_users cashbox_users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_users
    ADD CONSTRAINT cashbox_users_pkey PRIMARY KEY (id);


--
-- TOC entry 4903 (class 2606 OID 17861)
-- Name: cashboxdiary cashboxdiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxdiary
    ADD CONSTRAINT cashboxdiary_pkey PRIMARY KEY (id);


--
-- TOC entry 4905 (class 2606 OID 17863)
-- Name: opercodes cashboxdiary_types_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.opercodes
    ADD CONSTRAINT cashboxdiary_types_pkey PRIMARY KEY (id);


--
-- TOC entry 4908 (class 2606 OID 17865)
-- Name: cashboxes cashboxes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxes
    ADD CONSTRAINT cashboxes_pkey PRIMARY KEY (id);


--
-- TOC entry 4910 (class 2606 OID 17867)
-- Name: cashboxtoken cashboxtoken_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxtoken
    ADD CONSTRAINT cashboxtoken_pkey PRIMARY KEY (cashbox);


--
-- TOC entry 4913 (class 2606 OID 17869)
-- Name: categories categories_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_pkey PRIMARY KEY (id);


--
-- TOC entry 4917 (class 2606 OID 17871)
-- Name: changeprice_history changeprice_history_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.changeprice_history
    ADD CONSTRAINT changeprice_history_pkey PRIMARY KEY (id);


--
-- TOC entry 4920 (class 2606 OID 17873)
-- Name: character_entity character_entity_ch_key; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.character_entity
    ADD CONSTRAINT character_entity_ch_key UNIQUE (ch);


--
-- TOC entry 4922 (class 2606 OID 17875)
-- Name: character_entity character_entity_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.character_entity
    ADD CONSTRAINT character_entity_pkey PRIMARY KEY (name);


--
-- TOC entry 4924 (class 2606 OID 17877)
-- Name: clients clients_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.clients
    ADD CONSTRAINT clients_pkey PRIMARY KEY (id);


--
-- TOC entry 4926 (class 2606 OID 17879)
-- Name: cnofea_exceptions cnofea_exceptions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cnofea_exceptions
    ADD CONSTRAINT cnofea_exceptions_pkey PRIMARY KEY (code);


--
-- TOC entry 4929 (class 2606 OID 17881)
-- Name: cnofealist cnofealist_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cnofealist
    ADD CONSTRAINT cnofealist_pkey PRIMARY KEY (transactionid, product, attributes);


--
-- TOC entry 4931 (class 2606 OID 17883)
-- Name: companies companies_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.companies
    ADD CONSTRAINT companies_pkey PRIMARY KEY (id);


--
-- TOC entry 5341 (class 2606 OID 65627)
-- Name: company_types company_types_pk; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.company_types
    ADD CONSTRAINT company_types_pk PRIMARY KEY (id);


--
-- TOC entry 5118 (class 2606 OID 17885)
-- Name: promconditionstype conditionstype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promconditionstype
    ADD CONSTRAINT conditionstype_pkey PRIMARY KEY (id);


--
-- TOC entry 4938 (class 2606 OID 17887)
-- Name: consignment_invoicelist consignment_invoicelist_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_invoicelist
    ADD CONSTRAINT consignment_invoicelist_pkey PRIMARY KEY (invoice, company, stockid);


--
-- TOC entry 4940 (class 2606 OID 17889)
-- Name: consignment_invoices consignment_invoices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_invoices
    ADD CONSTRAINT consignment_invoices_pkey PRIMARY KEY (invoicenumber, company);


--
-- TOC entry 4936 (class 2606 OID 17891)
-- Name: consignment consignment_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment
    ADD CONSTRAINT consignment_pkey PRIMARY KEY (customer, company, stockid, invoice);


--
-- TOC entry 4945 (class 2606 OID 17893)
-- Name: consignment_snapshots consignment_snapshots_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_snapshots
    ADD CONSTRAINT consignment_snapshots_pkey PRIMARY KEY (id);


--
-- TOC entry 4949 (class 2606 OID 17895)
-- Name: counterparties counterparties_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.counterparties
    ADD CONSTRAINT counterparties_pkey PRIMARY KEY (id);


--
-- TOC entry 4952 (class 2606 OID 17897)
-- Name: counterparty2product counterparty2product_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.counterparty2product
    ADD CONSTRAINT counterparty2product_pkey PRIMARY KEY (counterparty, product, company);


--
-- TOC entry 4958 (class 2606 OID 17899)
-- Name: coupons coupons_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.coupons
    ADD CONSTRAINT coupons_pkey PRIMARY KEY (id);


--
-- TOC entry 4961 (class 2606 OID 17901)
-- Name: couponsdiary couponsdiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.couponsdiary
    ADD CONSTRAINT couponsdiary_pkey PRIMARY KEY (id);


--
-- TOC entry 4963 (class 2606 OID 17903)
-- Name: couponsdiaryreasons couponsdiaryreasons_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.couponsdiaryreasons
    ADD CONSTRAINT couponsdiaryreasons_pkey PRIMARY KEY (id);


--
-- TOC entry 4954 (class 2606 OID 17905)
-- Name: couponobjtypes coupontypes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.couponobjtypes
    ADD CONSTRAINT coupontypes_pkey PRIMARY KEY (id);


--
-- TOC entry 4971 (class 2606 OID 17907)
-- Name: customers_bonuscards customers_bonuscards_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customers_bonuscards
    ADD CONSTRAINT customers_bonuscards_pkey PRIMARY KEY (id);


--
-- TOC entry 4967 (class 2606 OID 17909)
-- Name: customers customers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customers
    ADD CONSTRAINT customers_pkey PRIMARY KEY (id);


--
-- TOC entry 5005 (class 2606 OID 17911)
-- Name: fiz_customers debtors_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.fiz_customers
    ADD CONSTRAINT debtors_pkey PRIMARY KEY (id);


--
-- TOC entry 4974 (class 2606 OID 17913)
-- Name: debtorsdiary debtorsdiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.debtorsdiary
    ADD CONSTRAINT debtorsdiary_pkey PRIMARY KEY (id);


--
-- TOC entry 4980 (class 2606 OID 17915)
-- Name: discounttypes discount_types_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.discounttypes
    ADD CONSTRAINT discount_types_pkey PRIMARY KEY (id);


--
-- TOC entry 4978 (class 2606 OID 17917)
-- Name: discounts discounts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.discounts
    ADD CONSTRAINT discounts_pkey PRIMARY KEY (id);


--
-- TOC entry 4982 (class 2606 OID 17919)
-- Name: erp_roles erp_roles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.erp_roles
    ADD CONSTRAINT erp_roles_pkey PRIMARY KEY (id);


--
-- TOC entry 4984 (class 2606 OID 17921)
-- Name: erp_users erp_users_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.erp_users
    ADD CONSTRAINT erp_users_pkey PRIMARY KEY (id);


--
-- TOC entry 4994 (class 2606 OID 17923)
-- Name: esf_details esf_details_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf_details
    ADD CONSTRAINT esf_details_pkey PRIMARY KEY (esfid, rowid, company);


--
-- TOC entry 4996 (class 2606 OID 17925)
-- Name: esf_errors esf_errors_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf_errors
    ADD CONSTRAINT esf_errors_pkey PRIMARY KEY (code);


--
-- TOC entry 4992 (class 2606 OID 17927)
-- Name: esf esf_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf
    ADD CONSTRAINT esf_pkey PRIMARY KEY (id);


--
-- TOC entry 4998 (class 2606 OID 17929)
-- Name: esf_statuses esf_statuses_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf_statuses
    ADD CONSTRAINT esf_statuses_pkey PRIMARY KEY (code);


--
-- TOC entry 5000 (class 2606 OID 17931)
-- Name: expdate_discount expdate_discount_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.expdate_discount
    ADD CONSTRAINT expdate_discount_pkey PRIMARY KEY (id, company);


--
-- TOC entry 5010 (class 2606 OID 17933)
-- Name: ftpservers ftpservers_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ftpservers
    ADD CONSTRAINT ftpservers_pkey PRIMARY KEY (id);


--
-- TOC entry 5012 (class 2606 OID 17935)
-- Name: gen_class_of_economic_act gen_class_of_economic_act_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.gen_class_of_economic_act
    ADD CONSTRAINT gen_class_of_economic_act_pkey PRIMARY KEY (code);


--
-- TOC entry 5016 (class 2606 OID 17937)
-- Name: giftcertificates giftcertificates_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificates
    ADD CONSTRAINT giftcertificates_pkey PRIMARY KEY (id);


--
-- TOC entry 5019 (class 2606 OID 17939)
-- Name: giftcertificates_writeoff_balances giftcertificates_write-off_balances_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificates_writeoff_balances
    ADD CONSTRAINT "giftcertificates_write-off_balances_pkey" PRIMARY KEY (id, company);


--
-- TOC entry 5022 (class 2606 OID 17941)
-- Name: giftcertificatesdiary giftcertificatesdiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatesdiary
    ADD CONSTRAINT giftcertificatesdiary_pkey PRIMARY KEY (id);


--
-- TOC entry 5024 (class 2606 OID 17943)
-- Name: giftcertificatesdiaryreasons giftcertificatesdiaryreasons_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatesdiaryreasons
    ADD CONSTRAINT giftcertificatesdiaryreasons_pkey PRIMARY KEY (id);


--
-- TOC entry 5026 (class 2606 OID 17945)
-- Name: giftcertificatetypes giftcertificatetypes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatetypes
    ADD CONSTRAINT giftcertificatetypes_pkey PRIMARY KEY (id);


--
-- TOC entry 5028 (class 2606 OID 17947)
-- Name: invoicelist invoicelist_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoicelist
    ADD CONSTRAINT invoicelist_pkey PRIMARY KEY (invoice, stock, attributes, company);


--
-- TOC entry 5045 (class 2606 OID 17949)
-- Name: invoices invoices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_pkey PRIMARY KEY (invoicenumber);


--
-- TOC entry 5048 (class 2606 OID 17951)
-- Name: invoicetypes invoicetype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoicetypes
    ADD CONSTRAINT invoicetype_pkey PRIMARY KEY (id);


--
-- TOC entry 5050 (class 2606 OID 17953)
-- Name: jobcheck jobcheck_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.jobcheck
    ADD CONSTRAINT jobcheck_pkey PRIMARY KEY (jobname);


--
-- TOC entry 5235 (class 2606 OID 24586)
-- Name: locales locales_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.locales
    ADD CONSTRAINT locales_pkey PRIMARY KEY (id);


--
-- TOC entry 5052 (class 2606 OID 17955)
-- Name: margin_plan margin_plan_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.margin_plan
    ADD CONSTRAINT margin_plan_pkey PRIMARY KEY (id);


--
-- TOC entry 5056 (class 2606 OID 17957)
-- Name: margin_plan_types margin_plan_types_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.margin_plan_types
    ADD CONSTRAINT margin_plan_types_pkey PRIMARY KEY (id);


--
-- TOC entry 5061 (class 2606 OID 17959)
-- Name: news_diary news_diary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.news_diary
    ADD CONSTRAINT news_diary_pkey PRIMARY KEY (pk_id);


--
-- TOC entry 5058 (class 2606 OID 17961)
-- Name: news news_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.news
    ADD CONSTRAINT news_pkey PRIMARY KEY (id);


--
-- TOC entry 5063 (class 2606 OID 17963)
-- Name: newtable1 newtable1_pk; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.newtable1
    ADD CONSTRAINT newtable1_pk PRIMARY KEY (id);


--
-- TOC entry 5065 (class 2606 OID 17965)
-- Name: origincodes origincodes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.origincodes
    ADD CONSTRAINT origincodes_pkey PRIMARY KEY (id);


--
-- TOC entry 5067 (class 2606 OID 17967)
-- Name: partners partners_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.partners
    ADD CONSTRAINT partners_pkey PRIMARY KEY (id);


--
-- TOC entry 5069 (class 2606 OID 17969)
-- Name: pluproducts_scale pluproducts_scale_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pluproducts_scale
    ADD CONSTRAINT pluproducts_scale_pkey PRIMARY KEY (id);


--
-- TOC entry 5071 (class 2606 OID 17971)
-- Name: point_types point_types_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.point_types
    ADD CONSTRAINT point_types_pkey PRIMARY KEY (id);


--
-- TOC entry 5075 (class 2606 OID 17973)
-- Name: points points_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.points
    ADD CONSTRAINT points_pkey PRIMARY KEY (id);


--
-- TOC entry 5077 (class 2606 OID 17975)
-- Name: pointset pointset_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pointset
    ADD CONSTRAINT pointset_pkey PRIMARY KEY (point, stock);


--
-- TOC entry 5082 (class 2606 OID 17977)
-- Name: prices_log prices_log_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices_log
    ADD CONSTRAINT prices_log_pkey PRIMARY KEY (id);


--
-- TOC entry 5080 (class 2606 OID 17979)
-- Name: prices prices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices
    ADD CONSTRAINT prices_pkey PRIMARY KEY (id);


--
-- TOC entry 5095 (class 2606 OID 17981)
-- Name: product_accounting product_accounting_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_accounting
    ADD CONSTRAINT product_accounting_pkey PRIMARY KEY (id);


--
-- TOC entry 5101 (class 2606 OID 17983)
-- Name: products_barcode products_barcode_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_barcode
    ADD CONSTRAINT products_barcode_pkey PRIMARY KEY (product, barcode);


--
-- TOC entry 5039 (class 2606 OID 17985)
-- Name: products products_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_pkey PRIMARY KEY (id);


--
-- TOC entry 5103 (class 2606 OID 17987)
-- Name: products_spr products_spr_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_spr
    ADD CONSTRAINT products_spr_pkey PRIMARY KEY (id);


--
-- TOC entry 5112 (class 2606 OID 17989)
-- Name: products_temp products_temp_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_temp
    ADD CONSTRAINT products_temp_pkey PRIMARY KEY (id);


--
-- TOC entry 5114 (class 2606 OID 17991)
-- Name: products_weight products_weight_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_weight
    ADD CONSTRAINT products_weight_pkey PRIMARY KEY (productsweight_id);


--
-- TOC entry 5116 (class 2606 OID 17993)
-- Name: promconditions promconditions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promconditions
    ADD CONSTRAINT promconditions_pkey PRIMARY KEY (listcode, type, object);


--
-- TOC entry 5120 (class 2606 OID 17995)
-- Name: promdiscounts promdiscounts_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promdiscounts
    ADD CONSTRAINT promdiscounts_pkey PRIMARY KEY (listcode, type, object);


--
-- TOC entry 5122 (class 2606 OID 17997)
-- Name: promdiscountstype promdiscountstype_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promdiscountstype
    ADD CONSTRAINT promdiscountstype_pkey PRIMARY KEY (id);


--
-- TOC entry 5126 (class 2606 OID 17999)
-- Name: promotions promotions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promotions
    ADD CONSTRAINT promotions_pkey PRIMARY KEY (id);


--
-- TOC entry 5128 (class 2606 OID 18001)
-- Name: reasontypes reasontypes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reasontypes
    ADD CONSTRAINT reasontypes_pkey PRIMARY KEY (id);


--
-- TOC entry 5130 (class 2606 OID 18003)
-- Name: reconciliation reconciliation_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reconciliation
    ADD CONSTRAINT reconciliation_pkey PRIMARY KEY (id);


--
-- TOC entry 5132 (class 2606 OID 18005)
-- Name: result result_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.result
    ADD CONSTRAINT result_pkey PRIMARY KEY (id);


--
-- TOC entry 5136 (class 2606 OID 18007)
-- Name: reviselist reviselist_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviselist
    ADD CONSTRAINT reviselist_pkey PRIMARY KEY (id);


--
-- TOC entry 5139 (class 2606 OID 18009)
-- Name: revision_difference revision_difference_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_difference
    ADD CONSTRAINT revision_difference_pkey PRIMARY KEY (id);


--
-- TOC entry 5143 (class 2606 OID 18011)
-- Name: revision_list revision_list_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_list
    ADD CONSTRAINT revision_list_pkey PRIMARY KEY (id);


--
-- TOC entry 5147 (class 2606 OID 18013)
-- Name: revision_temp revision_temp_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_temp
    ADD CONSTRAINT revision_temp_pkey PRIMARY KEY (id);


--
-- TOC entry 5154 (class 2606 OID 18015)
-- Name: revisiondiary_old revisiondiary_old_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary_old
    ADD CONSTRAINT revisiondiary_old_pkey PRIMARY KEY (id);


--
-- TOC entry 5152 (class 2606 OID 18017)
-- Name: revisiondiary revisiondiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary
    ADD CONSTRAINT revisiondiary_pkey PRIMARY KEY (id);


--
-- TOC entry 5157 (class 2606 OID 18019)
-- Name: salesplan salesplan_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.salesplan
    ADD CONSTRAINT salesplan_pkey PRIMARY KEY (object);


--
-- TOC entry 5160 (class 2606 OID 18021)
-- Name: salesplan_types salesplan_types_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.salesplan_types
    ADD CONSTRAINT salesplan_types_pkey PRIMARY KEY (id);


--
-- TOC entry 5163 (class 2606 OID 18023)
-- Name: scale scale_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scale
    ADD CONSTRAINT scale_pkey PRIMARY KEY (id);


--
-- TOC entry 5165 (class 2606 OID 18025)
-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.schema_migrations
    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);


--
-- TOC entry 5167 (class 2606 OID 18027)
-- Name: seizurelist seizurelist_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.seizurelist
    ADD CONSTRAINT seizurelist_pkey PRIMARY KEY (code);


--
-- TOC entry 5170 (class 2606 OID 18029)
-- Name: settings settings_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.settings
    ADD CONSTRAINT settings_pkey PRIMARY KEY (id);


--
-- TOC entry 5176 (class 2606 OID 18031)
-- Name: songs2 songs2_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs2
    ADD CONSTRAINT songs2_pkey PRIMARY KEY (id);


--
-- TOC entry 5178 (class 2606 OID 18033)
-- Name: songs3 songs3_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs3
    ADD CONSTRAINT songs3_pkey PRIMARY KEY (id);


--
-- TOC entry 5185 (class 2606 OID 18035)
-- Name: songs8 songs8_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs8
    ADD CONSTRAINT songs8_pkey PRIMARY KEY (id);


--
-- TOC entry 5172 (class 2606 OID 18037)
-- Name: songs songs_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs
    ADD CONSTRAINT songs_pkey PRIMARY KEY (id);


--
-- TOC entry 5174 (class 2606 OID 18039)
-- Name: songs10 songs_pkey10; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs10
    ADD CONSTRAINT songs_pkey10 PRIMARY KEY (id);


--
-- TOC entry 5180 (class 2606 OID 18041)
-- Name: songs4 songs_pkey4; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs4
    ADD CONSTRAINT songs_pkey4 PRIMARY KEY (id);


--
-- TOC entry 5183 (class 2606 OID 18043)
-- Name: songs5 songs_pkey5; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs5
    ADD CONSTRAINT songs_pkey5 PRIMARY KEY (id);


--
-- TOC entry 5187 (class 2606 OID 18045)
-- Name: songs9 songs_pkey9; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.songs9
    ADD CONSTRAINT songs_pkey9 PRIMARY KEY (id);


--
-- TOC entry 5008 (class 2606 OID 18047)
-- Name: format spr_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.format
    ADD CONSTRAINT spr_pkey PRIMARY KEY (name);


--
-- TOC entry 5190 (class 2606 OID 18049)
-- Name: stock_minmax stock_minmax_pk; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stock_minmax
    ADD CONSTRAINT stock_minmax_pk PRIMARY KEY (id);


--
-- TOC entry 5195 (class 2606 OID 18051)
-- Name: stockcurrent_part stockcurrent_part_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent_part
    ADD CONSTRAINT stockcurrent_part_pkey PRIMARY KEY (id);


--
-- TOC entry 5042 (class 2606 OID 18053)
-- Name: stockcurrent stockcurrent_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent
    ADD CONSTRAINT stockcurrent_pkey PRIMARY KEY (id);


--
-- TOC entry 5200 (class 2606 OID 18055)
-- Name: stockdiary stockdiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_pkey PRIMARY KEY (id);


--
-- TOC entry 5098 (class 2606 OID 18057)
-- Name: product_static_prices storeprices_copy_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_static_prices
    ADD CONSTRAINT storeprices_copy_pkey PRIMARY KEY (product, company);


--
-- TOC entry 5202 (class 2606 OID 18059)
-- Name: storeprices storeprices_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.storeprices
    ADD CONSTRAINT storeprices_pkey PRIMARY KEY (store, stock, company);


--
-- TOC entry 5206 (class 2606 OID 18061)
-- Name: systemmessage systemmessage_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.systemmessage
    ADD CONSTRAINT systemmessage_pkey PRIMARY KEY (id);


--
-- TOC entry 5208 (class 2606 OID 18063)
-- Name: taxes taxes_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.taxes
    ADD CONSTRAINT taxes_pkey PRIMARY KEY (id);


--
-- TOC entry 4862 (class 2606 OID 18065)
-- Name: access_table test_access_table_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.access_table
    ADD CONSTRAINT test_access_table_pkey PRIMARY KEY (id);


--
-- TOC entry 5237 (class 2606 OID 24614)
-- Name: access_table_copy test_access_tablea_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.access_table_copy
    ADD CONSTRAINT test_access_tablea_pkey PRIMARY KEY (id);


--
-- TOC entry 5239 (class 2606 OID 24626)
-- Name: access_tableu test_access_tableu1_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.access_tableu
    ADD CONSTRAINT test_access_tableu1_pkey PRIMARY KEY (id);


--
-- TOC entry 5212 (class 2606 OID 18067)
-- Name: tezmodules_access tezmodules_access_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tezmodules_access
    ADD CONSTRAINT tezmodules_access_pkey PRIMARY KEY (id);


--
-- TOC entry 5210 (class 2606 OID 18069)
-- Name: tezmodules tezmodules_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tezmodules
    ADD CONSTRAINT tezmodules_pkey PRIMARY KEY (id);


--
-- TOC entry 5215 (class 2606 OID 18071)
-- Name: ticket_format ticket_format_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.ticket_format
    ADD CONSTRAINT ticket_format_pkey PRIMARY KEY (id);


--
-- TOC entry 5218 (class 2606 OID 18073)
-- Name: transaction_promotions transaction_promotions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_promotions
    ADD CONSTRAINT transaction_promotions_pkey PRIMARY KEY (id);


--
-- TOC entry 5084 (class 2606 OID 18075)
-- Name: transaction_details transactions_details_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_details
    ADD CONSTRAINT transactions_details_pkey PRIMARY KEY (transactionid, product, attributes, company, invoice);


--
-- TOC entry 5090 (class 2606 OID 18077)
-- Name: transactions transactions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_pkey PRIMARY KEY (id);


--
-- TOC entry 5226 (class 2606 OID 18079)
-- Name: workorder unique_workorder_number; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT unique_workorder_number UNIQUE (workorder_number);


--
-- TOC entry 5220 (class 2606 OID 18081)
-- Name: unit_spr unit_spr_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.unit_spr
    ADD CONSTRAINT unit_spr_pkey PRIMARY KEY (id);


--
-- TOC entry 5222 (class 2606 OID 18083)
-- Name: user2roles user2roles_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user2roles
    ADD CONSTRAINT user2roles_pkey PRIMARY KEY ("user", role);


--
-- TOC entry 5224 (class 2606 OID 18085)
-- Name: versions versions_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.versions
    ADD CONSTRAINT versions_pkey PRIMARY KEY (id);


--
-- TOC entry 5230 (class 2606 OID 18087)
-- Name: workorder_details workorder_details_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder_details
    ADD CONSTRAINT workorder_details_pkey PRIMARY KEY (id);


--
-- TOC entry 5228 (class 2606 OID 18089)
-- Name: workorder workorder_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT workorder_pkey PRIMARY KEY (id);


--
-- TOC entry 5233 (class 2606 OID 18091)
-- Name: zreportdiary zreportdiary_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.zreportdiary
    ADD CONSTRAINT zreportdiary_pkey PRIMARY KEY (cashboxdiaryid);


--
-- TOC entry 5242 (class 1259 OID 49774)
-- Name: sellingday_det_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX sellingday_det_idx ON analytics.sellinginfo_day USING btree (company, product, date);


--
-- TOC entry 5243 (class 1259 OID 49775)
-- Name: sellingmonth_det_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX sellingmonth_det_idx ON analytics.sellinginfo_month USING btree (company, product, date);


--
-- TOC entry 5244 (class 1259 OID 49776)
-- Name: sellingweek_det_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX sellingweek_det_idx ON analytics.sellinginfo_week USING btree (company, product, date);


--
-- TOC entry 5245 (class 1259 OID 49777)
-- Name: stockcurrent_part_snap_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snap_idx ON ONLY analytics.stockcurrent_part_snapshots USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5246 (class 1259 OID 49778)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_0_100 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5251 (class 1259 OID 49779)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_0_100_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5250 (class 1259 OID 49780)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_0_100_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5249 (class 1259 OID 49781)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_0_100_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5248 (class 1259 OID 49782)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_0_100_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5247 (class 1259 OID 49783)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_0_100_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5252 (class 1259 OID 49784)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1 ON ONLY analytics.stockcurrent_part_snapshots_1001_1100 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5264 (class 1259 OID 49785)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2 ON ONLY analytics.stockcurrent_part_snapshots_1101_1200 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5270 (class 1259 OID 49786)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3 ON ONLY analytics.stockcurrent_part_snapshots_1201_1300 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5276 (class 1259 OID 49787)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4 ON ONLY analytics.stockcurrent_part_snapshots_1301_1400 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5282 (class 1259 OID 49788)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5 ON ONLY analytics.stockcurrent_part_snapshots_1401_1500 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5258 (class 1259 OID 49789)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_101_200 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5263 (class 1259 OID 49790)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx6; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx6 ON analytics.stockcurrent_part_snapshots_101_200_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5262 (class 1259 OID 49791)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx7; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx7 ON analytics.stockcurrent_part_snapshots_101_200_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5261 (class 1259 OID 49792)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx8; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx8 ON analytics.stockcurrent_part_snapshots_101_200_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5260 (class 1259 OID 49793)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx9; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx9 ON analytics.stockcurrent_part_snapshots_101_200_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5288 (class 1259 OID 49794)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_201_300 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5293 (class 1259 OID 49795)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_201_300_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5292 (class 1259 OID 49796)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_201_300_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5291 (class 1259 OID 49797)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_201_300_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5290 (class 1259 OID 49798)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_201_300_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5289 (class 1259 OID 49799)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_201_300_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5294 (class 1259 OID 49800)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_301_400 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5299 (class 1259 OID 49801)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_301_400_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5298 (class 1259 OID 49802)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_301_400_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5297 (class 1259 OID 49803)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_301_400_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5296 (class 1259 OID 49804)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_301_400_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5295 (class 1259 OID 49805)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_301_400_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5300 (class 1259 OID 49806)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_401_500 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5305 (class 1259 OID 49807)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_401_500_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5304 (class 1259 OID 49808)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_401_500_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5303 (class 1259 OID 49809)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_401_500_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5302 (class 1259 OID 49810)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_401_500_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5301 (class 1259 OID 49811)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_401_500_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5306 (class 1259 OID 49812)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_501_600 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5307 (class 1259 OID 49813)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_501_600_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5311 (class 1259 OID 49814)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_501_600_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5310 (class 1259 OID 49815)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_501_600_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5309 (class 1259 OID 49816)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_501_600_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5308 (class 1259 OID 49817)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_501_600_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5312 (class 1259 OID 49818)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_601_700 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5317 (class 1259 OID 49819)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_601_700_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5316 (class 1259 OID 49820)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_601_700_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5315 (class 1259 OID 49821)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_601_700_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5314 (class 1259 OID 49822)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_601_700_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5313 (class 1259 OID 49823)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_601_700_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5318 (class 1259 OID 49824)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_701_800 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5323 (class 1259 OID 49825)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_701_800_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5322 (class 1259 OID 49826)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_701_800_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5321 (class 1259 OID 49827)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_701_800_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5320 (class 1259 OID 49828)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_701_800_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5319 (class 1259 OID 49829)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_701_800_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5324 (class 1259 OID 49830)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_801_900 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5327 (class 1259 OID 49831)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_801_900_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5326 (class 1259 OID 49832)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_801_900_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5325 (class 1259 OID 49833)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_801_900_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5328 (class 1259 OID 49834)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_801_900_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5329 (class 1259 OID 49835)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_801_900_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5330 (class 1259 OID 49836)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx ON ONLY analytics.stockcurrent_part_snapshots_901_1000 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5335 (class 1259 OID 49837)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx1; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx1 ON analytics.stockcurrent_part_snapshots_901_1000_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5334 (class 1259 OID 49838)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx2; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx2 ON analytics.stockcurrent_part_snapshots_901_1000_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5333 (class 1259 OID 49839)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx3; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx3 ON analytics.stockcurrent_part_snapshots_901_1000_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5332 (class 1259 OID 49840)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx4; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx4 ON analytics.stockcurrent_part_snapshots_901_1000_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5331 (class 1259 OID 49841)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx5; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx5 ON analytics.stockcurrent_part_snapshots_901_1000_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5259 (class 1259 OID 49842)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx10; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx10 ON analytics.stockcurrent_part_snapshots_101_200_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5257 (class 1259 OID 49843)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx11; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx11 ON analytics.stockcurrent_part_snapshots_1001_1100_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5256 (class 1259 OID 49844)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx12; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx12 ON analytics.stockcurrent_part_snapshots_1001_1100_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5255 (class 1259 OID 49845)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx13; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx13 ON analytics.stockcurrent_part_snapshots_1001_1100_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5254 (class 1259 OID 49846)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx14; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx14 ON analytics.stockcurrent_part_snapshots_1001_1100_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5253 (class 1259 OID 49847)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx15; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx15 ON analytics.stockcurrent_part_snapshots_1001_1100_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5269 (class 1259 OID 49848)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx16; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx16 ON analytics.stockcurrent_part_snapshots_1101_1200_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5268 (class 1259 OID 49849)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx17; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx17 ON analytics.stockcurrent_part_snapshots_1101_1200_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5267 (class 1259 OID 49850)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx18; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx18 ON analytics.stockcurrent_part_snapshots_1101_1200_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5266 (class 1259 OID 49851)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx19; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx19 ON analytics.stockcurrent_part_snapshots_1101_1200_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5265 (class 1259 OID 49852)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx20; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx20 ON analytics.stockcurrent_part_snapshots_1101_1200_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5275 (class 1259 OID 49853)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx21; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx21 ON analytics.stockcurrent_part_snapshots_1201_1300_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5274 (class 1259 OID 49854)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx22; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx22 ON analytics.stockcurrent_part_snapshots_1201_1300_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5273 (class 1259 OID 49855)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx23; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx23 ON analytics.stockcurrent_part_snapshots_1201_1300_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5272 (class 1259 OID 49856)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx24; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx24 ON analytics.stockcurrent_part_snapshots_1201_1300_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5271 (class 1259 OID 49857)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx25; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx25 ON analytics.stockcurrent_part_snapshots_1201_1300_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5281 (class 1259 OID 49858)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx26; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx26 ON analytics.stockcurrent_part_snapshots_1301_1400_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5280 (class 1259 OID 49859)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx27; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx27 ON analytics.stockcurrent_part_snapshots_1301_1400_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5279 (class 1259 OID 49860)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx28; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx28 ON analytics.stockcurrent_part_snapshots_1301_1400_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5278 (class 1259 OID 49861)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx29; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx29 ON analytics.stockcurrent_part_snapshots_1301_1400_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5277 (class 1259 OID 49862)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx30; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx30 ON analytics.stockcurrent_part_snapshots_1301_1400_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5287 (class 1259 OID 49863)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx31; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx31 ON analytics.stockcurrent_part_snapshots_1401_1500_2024 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5286 (class 1259 OID 49864)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx32; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx32 ON analytics.stockcurrent_part_snapshots_1401_1500_2023 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5285 (class 1259 OID 49865)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx33; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx33 ON analytics.stockcurrent_part_snapshots_1401_1500_2022 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5284 (class 1259 OID 49866)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx34; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx34 ON analytics.stockcurrent_part_snapshots_1401_1500_2021 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5283 (class 1259 OID 49867)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx35; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX stockcurrent_part_snapshots__company_snapdate_point_produ_idx35 ON analytics.stockcurrent_part_snapshots_1401_1500_2020 USING btree (company, snapdate, point, product, attributes);


--
-- TOC entry 5336 (class 1259 OID 49868)
-- Name: tmp_rep_collect_user_idx; Type: INDEX; Schema: analytics; Owner: postgres
--

CREATE INDEX tmp_rep_collect_user_idx ON analytics.temp_rep_collection USING btree ("user");


--
-- TOC entry 5337 (class 1259 OID 49869)
-- Name: indx_function_calls_name; Type: INDEX; Schema: functioncalls; Owner: postgres
--

CREATE INDEX indx_function_calls_name ON functioncalls.function_calls USING btree (name);


--
-- TOC entry 4869 (class 1259 OID 18092)
-- Name: admcomprep_det_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX admcomprep_det_idx ON public.admincompanies_report_details USING btree (date, type);


--
-- TOC entry 4874 (class 1259 OID 18093)
-- Name: attriblistcode_id_company_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX attriblistcode_id_company_idx ON public.attributelistcode USING btree (id, company);


--
-- TOC entry 4879 (class 1259 OID 18094)
-- Name: attributenames_values_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX attributenames_values_idx ON public.attributenames USING btree (lower(("values")::text));


--
-- TOC entry 4882 (class 1259 OID 18095)
-- Name: attributespr_values_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX attributespr_values_idx ON public.attributespr USING btree (lower((value)::text), company, attributeid);


--
-- TOC entry 4968 (class 1259 OID 18096)
-- Name: bonuscards_cardnumber_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX bonuscards_cardnumber_idx ON public.customers_bonuscards USING btree (cardnumber, company);


--
-- TOC entry 4969 (class 1259 OID 18097)
-- Name: bonuscards_tel_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX bonuscards_tel_idx ON public.customers_bonuscards USING btree (telephone, company);


--
-- TOC entry 4888 (class 1259 OID 18098)
-- Name: bonusdiary_idx_card; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX bonusdiary_idx_card ON public.bonuscardsdiary USING btree (card, date, company);


--
-- TOC entry 4889 (class 1259 OID 18099)
-- Name: brands_brandman_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX brands_brandman_idx ON public.brands USING btree (brand, manufacturer);


--
-- TOC entry 4950 (class 1259 OID 18100)
-- Name: c2p_idx_search; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX c2p_idx_search ON public.counterparty2product USING btree (product, company);


--
-- TOC entry 4899 (class 1259 OID 18101)
-- Name: casboxdiary_box_date_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX casboxdiary_box_date_idx ON public.cashboxdiary USING btree (cashbox, opercode, operdate, company);


--
-- TOC entry 4900 (class 1259 OID 18102)
-- Name: casboxdiary_box_operdate_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX casboxdiary_box_operdate_idx ON public.cashboxdiary USING btree (operdate);


--
-- TOC entry 4901 (class 1259 OID 18103)
-- Name: casboxdiary_box_operid_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX casboxdiary_box_operid_idx ON public.cashboxdiary USING btree (cashbox, operid, company);


--
-- TOC entry 4906 (class 1259 OID 18104)
-- Name: cashboxes_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX cashboxes_name_idx ON public.cashboxes USING btree (point, name);


--
-- TOC entry 4898 (class 1259 OID 18105)
-- Name: cashboxusr_iin_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX cashboxusr_iin_idx ON public.cashbox_users USING btree (point, iin);


--
-- TOC entry 4911 (class 1259 OID 18106)
-- Name: categories_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX categories_name_idx ON public.categories USING btree (lower((name)::text), company);


--
-- TOC entry 5017 (class 1259 OID 18107)
-- Name: cert_writeoff_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX cert_writeoff_idx ON public.giftcertificates_writeoff_balances USING btree (id, company) WHERE (write_off IS FALSE);


--
-- TOC entry 4918 (class 1259 OID 18108)
-- Name: changepriceh_stockcomp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX changepriceh_stockcomp_idx ON public.changeprice_history USING btree (company, stockid);


--
-- TOC entry 4927 (class 1259 OID 18109)
-- Name: cnofealist_not_processed_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX cnofealist_not_processed_idx ON public.cnofealist USING btree (company, date) WHERE (processed IS NOT TRUE);


--
-- TOC entry 5137 (class 1259 OID 18110)
-- Name: company; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX company ON public.revision_difference USING btree (company, point);


--
-- TOC entry 4932 (class 1259 OID 18111)
-- Name: company_bin_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX company_bin_idx ON public.companies USING btree (bin);


--
-- TOC entry 4933 (class 1259 OID 18112)
-- Name: consignment_idx_debt; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX consignment_idx_debt ON public.consignment USING btree (customer, company) WHERE (units <> (0)::numeric);


--
-- TOC entry 4934 (class 1259 OID 18113)
-- Name: consignment_idx_find; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX consignment_idx_find ON public.consignment USING btree (customer, company, date);


--
-- TOC entry 4942 (class 1259 OID 18114)
-- Name: consignment_snap_det_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX consignment_snap_det_idx ON public.consignment_snapshots USING btree (company, stockid, snapdate);


--
-- TOC entry 4943 (class 1259 OID 18115)
-- Name: consignment_snap_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX consignment_snap_idx ON public.consignment_snapshots USING btree (company, snapdate);


--
-- TOC entry 4941 (class 1259 OID 18116)
-- Name: consignmentinv_idx_date; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX consignmentinv_idx_date ON public.consignment_invoices USING btree (company, ((date)::date), customer);


--
-- TOC entry 4946 (class 1259 OID 18117)
-- Name: counterparties_bin_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX counterparties_bin_idx ON public.counterparties USING btree (bin, company);


--
-- TOC entry 4947 (class 1259 OID 18118)
-- Name: counterparties_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX counterparties_name_idx ON public.counterparties USING btree (name, company);


--
-- TOC entry 4955 (class 1259 OID 18119)
-- Name: coupon_active_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX coupon_active_idx ON public.coupons USING btree (expire) WHERE (active IS TRUE);


--
-- TOC entry 4956 (class 1259 OID 18120)
-- Name: coupon_number_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX coupon_number_idx ON public.coupons USING btree (company, number);


--
-- TOC entry 4959 (class 1259 OID 18121)
-- Name: couponsdiary_idx_1; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX couponsdiary_idx_1 ON public.couponsdiary USING btree (company, ((date)::date), idcoup);


--
-- TOC entry 4964 (class 1259 OID 18122)
-- Name: customers_bin_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX customers_bin_idx ON public.customers USING btree (bin, company);


--
-- TOC entry 4965 (class 1259 OID 18123)
-- Name: customers_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX customers_name_idx ON public.customers USING btree (name, company);


--
-- TOC entry 5001 (class 1259 OID 18124)
-- Name: debtors_actual_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX debtors_actual_idx ON public.fiz_customers USING btree (company, debt) WHERE (debt > (0)::double precision);


--
-- TOC entry 5002 (class 1259 OID 18125)
-- Name: debtors_firstname_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX debtors_firstname_idx ON public.fiz_customers USING btree (lower((firstname)::text), company);


--
-- TOC entry 5003 (class 1259 OID 18126)
-- Name: debtors_lastname_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX debtors_lastname_idx ON public.fiz_customers USING btree (lastname, company);


--
-- TOC entry 5006 (class 1259 OID 18127)
-- Name: debtors_tel_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX debtors_tel_idx ON public.fiz_customers USING btree (telephone, company);


--
-- TOC entry 4972 (class 1259 OID 18128)
-- Name: debtorsdiary_idx_debtor; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX debtorsdiary_idx_debtor ON public.debtorsdiary USING btree (customer, date, company);


--
-- TOC entry 4975 (class 1259 OID 18129)
-- Name: discounts_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX discounts_idx ON public.discounts USING btree (company, type, object, expirationdate) WHERE (isactive IS TRUE);


--
-- TOC entry 4976 (class 1259 OID 18130)
-- Name: discounts_noactive_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX discounts_noactive_idx ON public.discounts USING btree (company, expirationdate);


--
-- TOC entry 4985 (class 1259 OID 18131)
-- Name: erpusr_comp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX erpusr_comp_idx ON public.erp_users USING btree (login, company);


--
-- TOC entry 4986 (class 1259 OID 18132)
-- Name: erpusr_iin_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX erpusr_iin_idx ON public.erp_users USING btree (iin, company);


--
-- TOC entry 4987 (class 1259 OID 18133)
-- Name: erpusr_log_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX erpusr_log_idx ON public.erp_users USING btree (login);


--
-- TOC entry 4988 (class 1259 OID 18134)
-- Name: esf_check_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX esf_check_idx ON public.esf USING btree (type, turnoverdate, company, status, custid);


--
-- TOC entry 4989 (class 1259 OID 18135)
-- Name: esf_esfregnum_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX esf_esfregnum_idx ON public.esf USING btree (esfregnum, company);


--
-- TOC entry 4990 (class 1259 OID 18136)
-- Name: esf_fail_send_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX esf_fail_send_idx ON public.esf USING btree (type, company, status, revise) WHERE (((status)::text = 'CREATED'::text) AND (revise IS TRUE));


--
-- TOC entry 5013 (class 1259 OID 18137)
-- Name: giftcertificates_active_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX giftcertificates_active_idx ON public.giftcertificates USING btree (expiredate) WHERE (active IS TRUE);


--
-- TOC entry 5014 (class 1259 OID 18138)
-- Name: giftcertificates_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX giftcertificates_idx ON public.giftcertificates USING btree (company, code);


--
-- TOC entry 5020 (class 1259 OID 18139)
-- Name: giftcertificatesdiary_idx_1; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX giftcertificatesdiary_idx_1 ON public.giftcertificatesdiary USING btree (company, ((date)::date), idcert, point);


--
-- TOC entry 5029 (class 1259 OID 18140)
-- Name: idx_attributes; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_attributes ON public.products USING btree (attributes);


--
-- TOC entry 4885 (class 1259 OID 18141)
-- Name: idx_attrlist_id_attr_company; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_attrlist_id_attr_company ON public.attrlist USING btree (listcode, attribute, company);


--
-- TOC entry 5099 (class 1259 OID 18142)
-- Name: idx_barcode; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_barcode ON public.products_barcode USING btree (barcode);


--
-- TOC entry 4914 (class 1259 OID 49230)
-- Name: idx_categories_company_parentid; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_categories_company_parentid ON public.categories USING btree (company, parentid);


--
-- TOC entry 4915 (class 1259 OID 49231)
-- Name: idx_categories_parentid_company; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_categories_parentid_company ON public.categories USING btree (company, parentid);


--
-- TOC entry 5030 (class 1259 OID 18143)
-- Name: idx_details; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_details ON public.products USING btree (details);


--
-- TOC entry 5031 (class 1259 OID 18144)
-- Name: idx_name_company_del; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_name_company_del ON public.products USING btree (name, company, deleted);


--
-- TOC entry 5032 (class 1259 OID 18145)
-- Name: idx_prodid_company; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX idx_prodid_company ON public.products USING btree (id, company);


--
-- TOC entry 5033 (class 1259 OID 49228)
-- Name: idx_products_company_deleted_category; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_products_company_deleted_category ON public.products USING btree (company, deleted, category);


--
-- TOC entry 5181 (class 1259 OID 18146)
-- Name: idx_songs_deleted_at; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_songs_deleted_at ON public.songs5 USING btree (deleted_at);


--
-- TOC entry 5188 (class 1259 OID 49229)
-- Name: idx_stock_minmax_product; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX idx_stock_minmax_product ON public.stock_minmax USING btree (product);


--
-- TOC entry 5043 (class 1259 OID 18147)
-- Name: invoices_alnum_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX invoices_alnum_idx ON public.invoices USING btree (altnumber, company);


--
-- TOC entry 5046 (class 1259 OID 18148)
-- Name: invoices_rep_pos_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX invoices_rep_pos_idx ON public.invoices USING btree (status, company, type, invoicedate);


--
-- TOC entry 5053 (class 1259 OID 18149)
-- Name: mp_company_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX mp_company_idx ON public.margin_plan USING btree (company, active);


--
-- TOC entry 5054 (class 1259 OID 18150)
-- Name: mp_search_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX mp_search_idx ON public.margin_plan USING btree (company, type, active, object);


--
-- TOC entry 5059 (class 1259 OID 18151)
-- Name: news_d_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX news_d_idx ON public.news_diary USING btree (news_id, user_id);


--
-- TOC entry 5072 (class 1259 OID 18152)
-- Name: points_compname; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX points_compname ON public.points USING btree (company, name);


--
-- TOC entry 5073 (class 1259 OID 18153)
-- Name: points_ftpserver; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX points_ftpserver ON public.points USING btree (status, ftpserver) WHERE (ftptransfer IS TRUE);


--
-- TOC entry 5078 (class 1259 OID 18154)
-- Name: prices_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prices_idx ON public.prices USING btree (product, point, company, type);


--
-- TOC entry 5034 (class 1259 OID 18155)
-- Name: prod_code_del_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prod_code_del_idx ON public.products USING btree (code, company) WHERE (deleted IS TRUE);


--
-- TOC entry 5035 (class 1259 OID 18156)
-- Name: prod_code_find_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prod_code_find_idx ON public.products USING btree (code, company);


--
-- TOC entry 5105 (class 1259 OID 18157)
-- Name: prod_code_temp_del_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prod_code_temp_del_idx ON public.products_temp USING btree (code, company) WHERE (deleted IS TRUE);


--
-- TOC entry 5106 (class 1259 OID 18158)
-- Name: prod_code_temp_find_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prod_code_temp_find_idx ON public.products_temp USING btree (code, company);


--
-- TOC entry 5107 (class 1259 OID 18159)
-- Name: prod_code_temp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX prod_code_temp_idx ON public.products_temp USING btree (company, code) WHERE (deleted IS FALSE);


--
-- TOC entry 5036 (class 1259 OID 18160)
-- Name: prod_name_del_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prod_name_del_idx ON public.products USING btree (name, company) WHERE (deleted IS TRUE);


--
-- TOC entry 5037 (class 1259 OID 18161)
-- Name: prod_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX prod_name_idx ON public.products USING btree (company, name) WHERE (deleted IS FALSE);


--
-- TOC entry 5108 (class 1259 OID 18162)
-- Name: prod_name_temp_del_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prod_name_temp_del_idx ON public.products_temp USING btree (name, company) WHERE (deleted IS TRUE);


--
-- TOC entry 5109 (class 1259 OID 18163)
-- Name: prod_name_temp_find_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX prod_name_temp_find_idx ON public.products_temp USING btree (name, company);


--
-- TOC entry 5110 (class 1259 OID 18164)
-- Name: prod_name_temp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX prod_name_temp_idx ON public.products_temp USING btree (company, name) WHERE (deleted IS FALSE);


--
-- TOC entry 5093 (class 1259 OID 18165)
-- Name: product_accounting_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX product_accounting_idx ON public.product_accounting USING btree (product, attributes, company);


--
-- TOC entry 5104 (class 1259 OID 18166)
-- Name: products_spr_search_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX products_spr_search_idx ON public.products_spr USING btree (code);


--
-- TOC entry 5123 (class 1259 OID 18167)
-- Name: promotions_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX promotions_idx ON public.promotions USING btree (company, edate) WHERE (isactive IS TRUE);


--
-- TOC entry 5124 (class 1259 OID 18168)
-- Name: promotions_noactive_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX promotions_noactive_idx ON public.promotions USING btree (company, edate);


--
-- TOC entry 5096 (class 1259 OID 18169)
-- Name: psp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX psp_idx ON public.product_static_prices USING btree (product, company);


--
-- TOC entry 5140 (class 1259 OID 18170)
-- Name: r_list2_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX r_list2_idx ON public.revision_list USING btree (revisionnumber, point, company, createdate, type);


--
-- TOC entry 5141 (class 1259 OID 18171)
-- Name: r_list_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX r_list_idx ON public.revision_list USING btree (point, company);


--
-- TOC entry 5144 (class 1259 OID 18172)
-- Name: r_temp2_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX r_temp2_idx ON public.revision_temp USING btree (createdate, point, "user", company, product, attributes, revisionnumber);


--
-- TOC entry 5145 (class 1259 OID 18173)
-- Name: r_temp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX r_temp_idx ON public.revision_temp USING btree (point, company, product, attributes);


--
-- TOC entry 5149 (class 1259 OID 18174)
-- Name: rev_company_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rev_company_idx ON public.revisiondiary USING btree (createdate, revisiondate, point, "user", company, product, attributes);


--
-- TOC entry 5150 (class 1259 OID 18175)
-- Name: rev_pr_attr_comp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX rev_pr_attr_comp_idx ON public.revisiondiary USING btree (company, product, attributes);


--
-- TOC entry 5133 (class 1259 OID 18176)
-- Name: reviselist_count_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX reviselist_count_idx ON public.reviselist USING btree (company, product, units) WHERE (units > (0)::double precision);


--
-- TOC entry 5134 (class 1259 OID 18177)
-- Name: reviselist_declaration_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX reviselist_declaration_idx ON public.reviselist USING btree (product, declaration, company);


--
-- TOC entry 5155 (class 1259 OID 18178)
-- Name: revisionnumber_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX revisionnumber_idx ON public.revisiontemp USING btree (revisionnumber);


--
-- TOC entry 5148 (class 1259 OID 18179)
-- Name: revnum_prod_attr_rt; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX revnum_prod_attr_rt ON public.revision_temp USING btree (product, attributes, revisionnumber);


--
-- TOC entry 5161 (class 1259 OID 18180)
-- Name: scale_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX scale_name_idx ON public.scale USING btree (lower((name)::text), company);


--
-- TOC entry 5168 (class 1259 OID 18181)
-- Name: settings_name_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX settings_name_idx ON public.settings USING btree (name);


--
-- TOC entry 5158 (class 1259 OID 18182)
-- Name: sp_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX sp_idx ON public.salesplan USING btree (object, type);


--
-- TOC entry 5040 (class 1259 OID 18183)
-- Name: stockcurrent_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX stockcurrent_idx ON public.stockcurrent USING btree (point, product, attributes, company);


--
-- TOC entry 5191 (class 1259 OID 18184)
-- Name: stockcurrent_part_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX stockcurrent_part_idx ON public.stockcurrent_part USING btree (company, point, product, attributes, date, purchaseprice);


--
-- TOC entry 5192 (class 1259 OID 18185)
-- Name: stockcurrent_part_instock_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX stockcurrent_part_instock_idx ON public.stockcurrent_part USING btree (company, point, product, attributes, date, purchaseprice) WHERE ((units)::double precision > (0)::double precision);


--
-- TOC entry 5193 (class 1259 OID 18186)
-- Name: stockcurrent_part_outstock_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX stockcurrent_part_outstock_idx ON public.stockcurrent_part USING btree (company, point, product, attributes, date, purchaseprice) WHERE ((units)::double precision < (0)::double precision);


--
-- TOC entry 5196 (class 1259 OID 18187)
-- Name: stockdiary_inx_1; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX stockdiary_inx_1 ON public.stockdiary USING btree (((date)::date), point, product, company, customer);


--
-- TOC entry 5197 (class 1259 OID 18188)
-- Name: stockdiary_inx_2; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX stockdiary_inx_2 ON public.stockdiary USING btree (point, invoice, company);


--
-- TOC entry 5198 (class 1259 OID 18189)
-- Name: stockdiary_inx_consignment; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX stockdiary_inx_consignment ON public.stockdiary USING btree (((date)::date), point, product, company, customer) WHERE (customer IS NOT NULL);


--
-- TOC entry 5203 (class 1259 OID 18190)
-- Name: storeprices_stock_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX storeprices_stock_idx ON public.storeprices USING btree (stock, company);


--
-- TOC entry 5204 (class 1259 OID 18191)
-- Name: systemmes_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX systemmes_idx ON public.systemmessage USING btree (cashbox, invoice);


--
-- TOC entry 5213 (class 1259 OID 18192)
-- Name: ticket_format_company_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX ticket_format_company_idx ON public.ticket_format USING btree (company, point);


--
-- TOC entry 5216 (class 1259 OID 18193)
-- Name: transaction_promotions_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX transaction_promotions_idx ON public.transaction_promotions USING btree (transactionid, company);


--
-- TOC entry 5085 (class 1259 OID 18194)
-- Name: transactions_consignment_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX transactions_consignment_idx ON public.transactions USING btree (customerid, ((date)::date), company) WHERE (consignment IS TRUE);


--
-- TOC entry 5086 (class 1259 OID 18195)
-- Name: transactions_discount_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX transactions_discount_idx ON public.transactions USING btree (company, fiz_customerid) WHERE (discount <> (0)::double precision);


--
-- TOC entry 5087 (class 1259 OID 18196)
-- Name: transactions_fiz_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX transactions_fiz_idx ON public.transactions USING btree (company, fiz_customerid) WHERE (fiz_customerid <> (0)::bigint);


--
-- TOC entry 5088 (class 1259 OID 18197)
-- Name: transactions_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE UNIQUE INDEX transactions_idx ON public.transactions USING btree (ticketid, cashbox, point, date, company);


--
-- TOC entry 5091 (class 1259 OID 18198)
-- Name: transactions_query_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX transactions_query_idx ON public.transactions USING btree (cashbox, point, ((date)::date), company);


--
-- TOC entry 5092 (class 1259 OID 18199)
-- Name: transactions_seller_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX transactions_seller_idx ON public.transactions USING btree (((date)::date), company, sellerid) WHERE (sellerid <> 0);


--
-- TOC entry 5231 (class 1259 OID 18200)
-- Name: zreportdiary_cashboxdate_idx; Type: INDEX; Schema: public; Owner: postgres
--

CREATE INDEX zreportdiary_cashboxdate_idx ON public.zreportdiary USING btree (cashid, datestart, dateend);


--
-- TOC entry 5347 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx1;


--
-- TOC entry 5346 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx2;


--
-- TOC entry 5345 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx3;


--
-- TOC entry 5344 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx4;


--
-- TOC entry 5343 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produ_idx5;


--
-- TOC entry 5342 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_0_company_snapdate_point_produc_idx;


--
-- TOC entry 5348 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1;


--
-- TOC entry 5360 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2;


--
-- TOC entry 5366 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3;


--
-- TOC entry 5372 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4;


--
-- TOC entry 5378 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5;


--
-- TOC entry 5359 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx6; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx6;


--
-- TOC entry 5358 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx7; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx7;


--
-- TOC entry 5357 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx8; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx8;


--
-- TOC entry 5356 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx9; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx9;


--
-- TOC entry 5354 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx;


--
-- TOC entry 5389 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx1;


--
-- TOC entry 5388 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx2;


--
-- TOC entry 5387 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx3;


--
-- TOC entry 5386 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx4;


--
-- TOC entry 5385 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produ_idx5;


--
-- TOC entry 5384 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_2_company_snapdate_point_produc_idx;


--
-- TOC entry 5395 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx1;


--
-- TOC entry 5394 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx2;


--
-- TOC entry 5393 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx3;


--
-- TOC entry 5392 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx4;


--
-- TOC entry 5391 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produ_idx5;


--
-- TOC entry 5390 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_3_company_snapdate_point_produc_idx;


--
-- TOC entry 5401 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx1;


--
-- TOC entry 5400 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx2;


--
-- TOC entry 5399 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx3;


--
-- TOC entry 5398 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx4;


--
-- TOC entry 5397 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produ_idx5;


--
-- TOC entry 5396 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_4_company_snapdate_point_produc_idx;


--
-- TOC entry 5403 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx1;


--
-- TOC entry 5407 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx2;


--
-- TOC entry 5406 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx3;


--
-- TOC entry 5405 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx4;


--
-- TOC entry 5404 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produ_idx5;


--
-- TOC entry 5402 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_5_company_snapdate_point_produc_idx;


--
-- TOC entry 5413 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx1;


--
-- TOC entry 5412 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx2;


--
-- TOC entry 5411 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx3;


--
-- TOC entry 5410 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx4;


--
-- TOC entry 5409 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produ_idx5;


--
-- TOC entry 5408 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_6_company_snapdate_point_produc_idx;


--
-- TOC entry 5419 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx1;


--
-- TOC entry 5418 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx2;


--
-- TOC entry 5417 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx3;


--
-- TOC entry 5416 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx4;


--
-- TOC entry 5415 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produ_idx5;


--
-- TOC entry 5414 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_7_company_snapdate_point_produc_idx;


--
-- TOC entry 5423 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx1;


--
-- TOC entry 5422 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx2;


--
-- TOC entry 5421 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx3;


--
-- TOC entry 5424 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx4;


--
-- TOC entry 5425 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produ_idx5;


--
-- TOC entry 5420 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_8_company_snapdate_point_produc_idx;


--
-- TOC entry 5431 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx1; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx1;


--
-- TOC entry 5430 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx2; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx2;


--
-- TOC entry 5429 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx3; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx3;


--
-- TOC entry 5428 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx4; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx4;


--
-- TOC entry 5427 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx5; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produ_idx5;


--
-- TOC entry 5426 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snap_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots_9_company_snapdate_point_produc_idx;


--
-- TOC entry 5355 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx10; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produc_idx ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx10;


--
-- TOC entry 5353 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx11; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx11;


--
-- TOC entry 5352 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx12; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx12;


--
-- TOC entry 5351 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx13; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx13;


--
-- TOC entry 5350 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx14; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx14;


--
-- TOC entry 5349 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx15; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx1 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx15;


--
-- TOC entry 5365 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx16; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx16;


--
-- TOC entry 5364 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx17; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx17;


--
-- TOC entry 5363 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx18; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx18;


--
-- TOC entry 5362 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx19; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx19;


--
-- TOC entry 5361 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx20; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx2 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx20;


--
-- TOC entry 5371 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx21; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx21;


--
-- TOC entry 5370 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx22; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx22;


--
-- TOC entry 5369 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx23; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx23;


--
-- TOC entry 5368 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx24; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx24;


--
-- TOC entry 5367 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx25; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx3 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx25;


--
-- TOC entry 5377 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx26; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx26;


--
-- TOC entry 5376 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx27; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx27;


--
-- TOC entry 5375 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx28; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx28;


--
-- TOC entry 5374 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx29; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx29;


--
-- TOC entry 5373 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx30; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx4 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx30;


--
-- TOC entry 5383 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx31; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx31;


--
-- TOC entry 5382 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx32; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx32;


--
-- TOC entry 5381 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx33; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx33;


--
-- TOC entry 5380 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx34; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx34;


--
-- TOC entry 5379 (class 0 OID 0)
-- Name: stockcurrent_part_snapshots__company_snapdate_point_produ_idx35; Type: INDEX ATTACH; Schema: analytics; Owner: postgres
--

ALTER INDEX analytics.stockcurrent_part_snapshots_1_company_snapdate_point_produ_idx5 ATTACH PARTITION analytics.stockcurrent_part_snapshots__company_snapdate_point_produ_idx35;


--
-- TOC entry 5741 (class 2618 OID 17145)
-- Name: group_bonus _RETURN; Type: RULE; Schema: public; Owner: postgres
--

CREATE OR REPLACE VIEW public.group_bonus AS
 SELECT ord.dat,
    ord.id,
    ord.company,
    ord.plan,
    ord.sold,
    ord.total_award,
    ord2.name,
    ord.each_award
   FROM (( SELECT (t.date)::date AS dat,
            p2.id,
            p2.company,
            p.daily AS plan,
            COALESCE(sum(t.price), (0)::double precision) AS sold,
                CASE
                    WHEN (sum(t.price) > p.daily) THEN round(((((
                    CASE
                        WHEN (p2.id = 173) THEN 1.5
                        ELSE (1)::numeric
                    END)::double precision * sum(t.price)) / (100)::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS total_award,
                CASE
                    WHEN (sum(t.price) > p.daily) THEN round((((((
                    CASE
                        WHEN (p2.id = 173) THEN 1.5
                        ELSE (1)::numeric
                    END)::double precision * sum(t.price)) / (100)::double precision) / (count(DISTINCT t.cashboxuser))::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS each_award
           FROM ((public.points p2
             LEFT JOIN public.salesplan p ON (((p.object = p2.id) AND (p.type = 3))))
             LEFT JOIN public.transactions t ON ((t.point = p.object)))
          WHERE (t.date IS NOT NULL)
          GROUP BY ((t.date)::date), p2.id, p.daily) ord
     LEFT JOIN ( SELECT DISTINCT (t.date)::date AS date,
            t.point,
            t.company,
            u.name
           FROM (public.transactions t
             LEFT JOIN public.cashbox_users u ON ((u.id = t.cashboxuser)))) ord2 ON (((ord2.date = ord.dat) AND (ord2.point = ord.id) AND (ord2.company = ord.company))))
  ORDER BY ord.dat DESC;


--
-- TOC entry 5746 (class 2618 OID 17676)
-- Name: team_daily _RETURN; Type: RULE; Schema: public; Owner: postgres
--

CREATE OR REPLACE VIEW public.team_daily AS
 SELECT ord.dat,
    ord.id,
    ord.company,
        CASE
            WHEN (ord.plan IS NULL) THEN (0)::double precision
            ELSE ord.plan
        END AS plan,
        CASE
            WHEN (ord.drate IS NULL) THEN (0)::double precision
            ELSE ord.drate
        END AS drate,
    ord.sold,
        CASE
            WHEN (ord.total_award IS NULL) THEN (0)::numeric
            ELSE ord.total_award
        END AS total_award,
    ord2.name,
        CASE
            WHEN (ord.each_award IS NULL) THEN (0)::numeric
            ELSE ord.each_award
        END AS each_award
   FROM (( SELECT (t.date)::date AS dat,
            p2.id,
            p2.company,
            p.daily AS plan,
            p.drate,
            COALESCE(sum(t.price), (0)::double precision) AS sold,
                CASE
                    WHEN (sum(t.price) > p.daily) THEN round((((p.drate * sum(t.price)) / (100)::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS total_award,
                CASE
                    WHEN (sum(t.price) > p.daily) THEN round(((((p.drate * sum(t.price)) / (100)::double precision) / (count(DISTINCT t.cashboxuser))::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS each_award
           FROM ((public.points p2
             LEFT JOIN public.salesplan p ON (((p.object = p2.id) AND (p.type = 3) AND (p.daily > (0)::double precision) AND (p.drate > (0)::double precision))))
             LEFT JOIN public.transactions t ON ((t.point = p.object)))
          WHERE (t.date IS NOT NULL)
          GROUP BY ((t.date)::date), p2.id, p.daily, p.drate) ord
     LEFT JOIN ( SELECT DISTINCT (t.date)::date AS date,
            t.point,
            t.company,
            u.name
           FROM (public.transactions t
             LEFT JOIN public.cashbox_users u ON ((u.id = t.cashboxuser)))) ord2 ON (((ord2.date = ord.dat) AND (ord2.point = ord.id) AND (ord2.company = ord.company))))
  ORDER BY ord.dat DESC;


--
-- TOC entry 5747 (class 2618 OID 17680)
-- Name: team_monthly _RETURN; Type: RULE; Schema: public; Owner: postgres
--

CREATE OR REPLACE VIEW public.team_monthly AS
 SELECT to_date(('01.'::text || ord.dat), 'DD.MM.YYYY'::text) AS dat,
    ord.id,
    ord.company,
        CASE
            WHEN (ord.plan IS NULL) THEN (0)::double precision
            ELSE ord.plan
        END AS plan,
        CASE
            WHEN (ord.mrate IS NULL) THEN (0)::double precision
            ELSE ord.mrate
        END AS mrate,
    ord.sold,
        CASE
            WHEN (ord.total_award IS NULL) THEN (0)::numeric
            ELSE ord.total_award
        END AS total_award,
    ord2.name,
        CASE
            WHEN (ord.each_award IS NULL) THEN (0)::numeric
            ELSE ord.each_award
        END AS each_award
   FROM (( SELECT to_char(t.date, 'MM.YYYY'::text) AS dat,
            p2.id,
            p2.company,
            p.monthly AS plan,
            p.mrate,
            COALESCE(sum(t.price), (0)::double precision) AS sold,
                CASE
                    WHEN (sum(t.price) > p.monthly) THEN round((((p.mrate * sum(t.price)) / (100)::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS total_award,
                CASE
                    WHEN (sum(t.price) > p.monthly) THEN round(((((p.mrate * sum(t.price)) / (100)::double precision) / (count(DISTINCT t.cashboxuser))::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS each_award
           FROM ((public.points p2
             LEFT JOIN public.salesplan p ON (((p.object = p2.id) AND (p.type = 3) AND (p.monthly > (0)::double precision) AND (p.mrate > (0)::double precision))))
             LEFT JOIN public.transactions t ON ((t.point = p.object)))
          WHERE (t.date IS NOT NULL)
          GROUP BY (to_char(t.date, 'MM.YYYY'::text)), p2.id, p.monthly, p.mrate) ord
     LEFT JOIN ( SELECT DISTINCT to_char(t.date, 'MM.YYYY'::text) AS dat,
            t.point,
            t.company,
            u.name
           FROM (public.transactions t
             LEFT JOIN public.cashbox_users u ON ((u.id = t.cashboxuser)))) ord2 ON (((ord2.dat = ord.dat) AND (ord2.point = ord.id) AND (ord2.company = ord.company))));


--
-- TOC entry 5748 (class 2618 OID 17684)
-- Name: team_quarterly _RETURN; Type: RULE; Schema: public; Owner: postgres
--

CREATE OR REPLACE VIEW public.team_quarterly AS
 SELECT to_date(('01.'::text || ord.dat), 'DD.MM.YYYY'::text) AS dat,
    ord.id,
    ord.company,
        CASE
            WHEN (ord.plan IS NULL) THEN (0)::double precision
            ELSE ord.plan
        END AS plan,
        CASE
            WHEN (ord.qrate IS NULL) THEN (0)::double precision
            ELSE ord.qrate
        END AS qrate,
    ord.sold,
        CASE
            WHEN (ord.total_award IS NULL) THEN (0)::numeric
            ELSE ord.total_award
        END AS total_award,
    ord2.name,
        CASE
            WHEN (ord.each_award IS NULL) THEN (0)::numeric
            ELSE ord.each_award
        END AS each_award
   FROM (( SELECT to_char(t.date, 'MM.YYYY'::text) AS dat,
            p2.id,
            p2.company,
            p.quarterly AS plan,
            p.qrate,
            COALESCE(sum(t.price), (0)::double precision) AS sold,
                CASE
                    WHEN (sum(t.price) > p.quarterly) THEN round((((p.qrate * sum(t.price)) / (100)::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS total_award,
                CASE
                    WHEN (sum(t.price) > p.quarterly) THEN round(((((p.qrate * sum(t.price)) / (100)::double precision) / (count(DISTINCT t.cashboxuser))::double precision))::numeric, 2)
                    ELSE '0'::numeric
                END AS each_award
           FROM ((public.points p2
             LEFT JOIN public.salesplan p ON (((p.object = p2.id) AND (p.type = 3) AND (p.quarterly > (0)::double precision) AND (p.qrate > (0)::double precision))))
             LEFT JOIN public.transactions t ON ((t.point = p.object)))
          WHERE (t.date IS NOT NULL)
          GROUP BY (to_char(t.date, 'MM.YYYY'::text)), p2.id, p.quarterly, p.qrate) ord
     LEFT JOIN ( SELECT DISTINCT to_char(t.date, 'MM.YYYY'::text) AS dat,
            t.point,
            t.company,
            u.name
           FROM (public.transactions t
             LEFT JOIN public.cashbox_users u ON ((u.id = t.cashboxuser)))) ord2 ON (((ord2.dat = ord.dat) AND (ord2.point = ord.id) AND (ord2.company = ord.company))));


--
-- TOC entry 5611 (class 2620 OID 18205)
-- Name: prices add_pricelog; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER add_pricelog BEFORE UPDATE ON public.prices FOR EACH ROW EXECUTE FUNCTION public.add_pricelog();


--
-- TOC entry 5612 (class 2620 OID 18206)
-- Name: prices delete_pricelog; Type: TRIGGER; Schema: public; Owner: postgres
--

CREATE TRIGGER delete_pricelog AFTER DELETE ON public.prices FOR EACH ROW EXECUTE FUNCTION public.delete_pricelog();


--
-- TOC entry 5511 (class 2606 OID 18207)
-- Name: points 	erp_points_fk_companies; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.points
    ADD CONSTRAINT "	erp_points_fk_companies" FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5564 (class 2606 OID 18212)
-- Name: revision_list admin_users_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_list
    ADD CONSTRAINT admin_users_fk FOREIGN KEY (admin) REFERENCES public.erp_users(id);


--
-- TOC entry 5432 (class 2606 OID 18217)
-- Name: attributelistcode attriblistcode_fk_companies; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributelistcode
    ADD CONSTRAINT attriblistcode_fk_companies FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5433 (class 2606 OID 18222)
-- Name: attributenames attribname_fk_cat; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributenames
    ADD CONSTRAINT attribname_fk_cat FOREIGN KEY (category) REFERENCES public.attributecat(id);


--
-- TOC entry 5434 (class 2606 OID 18227)
-- Name: attributenames attribname_fk_format; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributenames
    ADD CONSTRAINT attribname_fk_format FOREIGN KEY (format) REFERENCES public.format(name);


--
-- TOC entry 5435 (class 2606 OID 18232)
-- Name: attributespr attribspr_fk_attribname; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributespr
    ADD CONSTRAINT attribspr_fk_attribname FOREIGN KEY (attributeid) REFERENCES public.attributenames(id);


--
-- TOC entry 5436 (class 2606 OID 18237)
-- Name: attributespr attribspr_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attributespr
    ADD CONSTRAINT attribspr_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5437 (class 2606 OID 18242)
-- Name: attrlist attrlist_fk_attrlistcode; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attrlist
    ADD CONSTRAINT attrlist_fk_attrlistcode FOREIGN KEY (listcode) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5438 (class 2606 OID 18247)
-- Name: attrlist attrlist_fk_attrname; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attrlist
    ADD CONSTRAINT attrlist_fk_attrname FOREIGN KEY (attribute) REFERENCES public.attributenames(id);


--
-- TOC entry 5439 (class 2606 OID 18252)
-- Name: attrlist attrlist_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.attrlist
    ADD CONSTRAINT attrlist_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5473 (class 2606 OID 18257)
-- Name: customers_bonuscards bonuscards_fk_fiz; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.customers_bonuscards
    ADD CONSTRAINT bonuscards_fk_fiz FOREIGN KEY (fizid) REFERENCES public.fiz_customers(id);


--
-- TOC entry 5440 (class 2606 OID 18262)
-- Name: bonuscardsdiary bonuscardsdiary_fk_card; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.bonuscardsdiary
    ADD CONSTRAINT bonuscardsdiary_fk_card FOREIGN KEY (card) REFERENCES public.customers_bonuscards(id);


--
-- TOC entry 5442 (class 2606 OID 18267)
-- Name: cashbox_users cashbox_users_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_users
    ADD CONSTRAINT cashbox_users_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5443 (class 2606 OID 18272)
-- Name: cashbox_users cashbox_users_fk_role; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_users
    ADD CONSTRAINT cashbox_users_fk_role FOREIGN KEY (role) REFERENCES public.cashbox_roles(id);


--
-- TOC entry 5444 (class 2606 OID 18277)
-- Name: cashboxdiary cashboxdiary_fk_cashbox; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxdiary
    ADD CONSTRAINT cashboxdiary_fk_cashbox FOREIGN KEY (cashbox) REFERENCES public.cashboxes(id);


--
-- TOC entry 5445 (class 2606 OID 18282)
-- Name: cashboxdiary cashboxdiary_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxdiary
    ADD CONSTRAINT cashboxdiary_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5446 (class 2606 OID 18287)
-- Name: cashboxdiary cashboxdiary_fk_opercode; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxdiary
    ADD CONSTRAINT cashboxdiary_fk_opercode FOREIGN KEY (opercode) REFERENCES public.opercodes(id);


--
-- TOC entry 5447 (class 2606 OID 18292)
-- Name: cashboxes cashboxes_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxes
    ADD CONSTRAINT cashboxes_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5448 (class 2606 OID 18297)
-- Name: cashboxtoken cashboxtoken_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashboxtoken
    ADD CONSTRAINT cashboxtoken_fk_point FOREIGN KEY (cashbox) REFERENCES public.cashboxes(id);


--
-- TOC entry 5441 (class 2606 OID 18302)
-- Name: cashbox_updates cashboxupdate_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cashbox_updates
    ADD CONSTRAINT cashboxupdate_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5449 (class 2606 OID 18307)
-- Name: categories categories_fk_1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_fk_1 FOREIGN KEY (parentid) REFERENCES public.categories(id);


--
-- TOC entry 5450 (class 2606 OID 18312)
-- Name: categories categories_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.categories
    ADD CONSTRAINT categories_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5451 (class 2606 OID 18317)
-- Name: cnofealist cnofealist_attributes_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cnofealist
    ADD CONSTRAINT cnofealist_attributes_fkey FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5452 (class 2606 OID 18322)
-- Name: cnofealist cnofealist_company_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cnofealist
    ADD CONSTRAINT cnofealist_company_fkey FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5453 (class 2606 OID 18327)
-- Name: cnofealist cnofealist_esf_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cnofealist
    ADD CONSTRAINT cnofealist_esf_fkey FOREIGN KEY (esfid) REFERENCES public.esf(id);


--
-- TOC entry 5454 (class 2606 OID 18332)
-- Name: cnofealist cnofealist_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cnofealist
    ADD CONSTRAINT cnofealist_product_fkey FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5455 (class 2606 OID 18337)
-- Name: cnofealist cnofealist_transactionid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.cnofealist
    ADD CONSTRAINT cnofealist_transactionid_fkey FOREIGN KEY (transactionid) REFERENCES public.transactions(id) ON DELETE CASCADE;


--
-- TOC entry 5456 (class 2606 OID 18342)
-- Name: companies company_fk_gcoea; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.companies
    ADD CONSTRAINT company_fk_gcoea FOREIGN KEY (gcoea) REFERENCES public.gen_class_of_economic_act(code);


--
-- TOC entry 5457 (class 2606 OID 18347)
-- Name: consignment consignment_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment
    ADD CONSTRAINT consignment_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5458 (class 2606 OID 18352)
-- Name: consignment consignment_fk_customer; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment
    ADD CONSTRAINT consignment_fk_customer FOREIGN KEY (customer) REFERENCES public.customers(id);


--
-- TOC entry 5459 (class 2606 OID 18357)
-- Name: consignment consignment_fk_stockcurrent; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment
    ADD CONSTRAINT consignment_fk_stockcurrent FOREIGN KEY (stockid) REFERENCES public.stockcurrent(id);


--
-- TOC entry 5461 (class 2606 OID 18362)
-- Name: consignment_invoices consignmentinv_fk_cashboxuser; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_invoices
    ADD CONSTRAINT consignmentinv_fk_cashboxuser FOREIGN KEY (cashboxuser) REFERENCES public.cashbox_users(id);


--
-- TOC entry 5462 (class 2606 OID 18367)
-- Name: consignment_invoices consignmentinv_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_invoices
    ADD CONSTRAINT consignmentinv_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5463 (class 2606 OID 18372)
-- Name: consignment_invoices consignmentinv_fk_customer; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_invoices
    ADD CONSTRAINT consignmentinv_fk_customer FOREIGN KEY (customer) REFERENCES public.customers(id);


--
-- TOC entry 5460 (class 2606 OID 18377)
-- Name: consignment_invoicelist consignmentinvlist_fk_invoice; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.consignment_invoicelist
    ADD CONSTRAINT consignmentinvlist_fk_invoice FOREIGN KEY (invoice, company) REFERENCES public.consignment_invoices(invoicenumber, company) ON DELETE CASCADE;


--
-- TOC entry 5464 (class 2606 OID 18382)
-- Name: counterparties counterparties_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.counterparties
    ADD CONSTRAINT counterparties_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5465 (class 2606 OID 18387)
-- Name: counterparty2product counterparty2product_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.counterparty2product
    ADD CONSTRAINT counterparty2product_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5466 (class 2606 OID 18392)
-- Name: counterparty2product counterparty2product_fk_party; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.counterparty2product
    ADD CONSTRAINT counterparty2product_fk_party FOREIGN KEY (counterparty) REFERENCES public.counterparties(id);


--
-- TOC entry 5467 (class 2606 OID 18397)
-- Name: counterparty2product counterparty2product_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.counterparty2product
    ADD CONSTRAINT counterparty2product_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5468 (class 2606 OID 18402)
-- Name: coupons coupons_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.coupons
    ADD CONSTRAINT coupons_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5469 (class 2606 OID 18407)
-- Name: coupons coupons_fk_objtypes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.coupons
    ADD CONSTRAINT coupons_fk_objtypes FOREIGN KEY (objtype) REFERENCES public.couponobjtypes(id);


--
-- TOC entry 5470 (class 2606 OID 18412)
-- Name: couponsdiary couponsdiary_fk_comp; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.couponsdiary
    ADD CONSTRAINT couponsdiary_fk_comp FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5471 (class 2606 OID 18417)
-- Name: couponsdiary couponsdiary_fk_coup; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.couponsdiary
    ADD CONSTRAINT couponsdiary_fk_coup FOREIGN KEY (idcoup) REFERENCES public.coupons(id);


--
-- TOC entry 5472 (class 2606 OID 18422)
-- Name: couponsdiary couponsdiary_fk_reason; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.couponsdiary
    ADD CONSTRAINT couponsdiary_fk_reason FOREIGN KEY (reason) REFERENCES public.couponsdiaryreasons(id);


--
-- TOC entry 5512 (class 2606 OID 18427)
-- Name: points erp_points_fk_ftpservers; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.points
    ADD CONSTRAINT erp_points_fk_ftpservers FOREIGN KEY (ftpserver) REFERENCES public.ftpservers(id);


--
-- TOC entry 5513 (class 2606 OID 18432)
-- Name: points erp_points_fk_pointtype; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.points
    ADD CONSTRAINT erp_points_fk_pointtype FOREIGN KEY (point_type) REFERENCES public.point_types(id);


--
-- TOC entry 5476 (class 2606 OID 18437)
-- Name: erp_users erpusr_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.erp_users
    ADD CONSTRAINT erpusr_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5481 (class 2606 OID 18442)
-- Name: esf_details esf_details_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf_details
    ADD CONSTRAINT esf_details_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5482 (class 2606 OID 18447)
-- Name: esf_details esf_details_fk_esf; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf_details
    ADD CONSTRAINT esf_details_fk_esf FOREIGN KEY (esfid) REFERENCES public.esf(id);


--
-- TOC entry 5483 (class 2606 OID 18452)
-- Name: esf_details esf_details_fk_truorigincode; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf_details
    ADD CONSTRAINT esf_details_fk_truorigincode FOREIGN KEY (truorigincode) REFERENCES public.origincodes(id);


--
-- TOC entry 5477 (class 2606 OID 18457)
-- Name: esf esf_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf
    ADD CONSTRAINT esf_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5478 (class 2606 OID 18462)
-- Name: esf esf_fk_reason; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf
    ADD CONSTRAINT esf_fk_reason FOREIGN KEY (reason) REFERENCES public.esf_errors(code);


--
-- TOC entry 5479 (class 2606 OID 18467)
-- Name: esf esf_fk_status; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf
    ADD CONSTRAINT esf_fk_status FOREIGN KEY (status) REFERENCES public.esf_statuses(code);


--
-- TOC entry 5480 (class 2606 OID 18472)
-- Name: esf esf_fk_usr; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.esf
    ADD CONSTRAINT esf_fk_usr FOREIGN KEY (usr) REFERENCES public.erp_users(id);


--
-- TOC entry 5509 (class 2606 OID 18477)
-- Name: margin_plan fk_margin_plan_types; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.margin_plan
    ADD CONSTRAINT fk_margin_plan_types FOREIGN KEY (type) REFERENCES public.margin_plan_types(id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 5484 (class 2606 OID 18482)
-- Name: giftcertificates giftcertificates_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificates
    ADD CONSTRAINT giftcertificates_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5485 (class 2606 OID 18487)
-- Name: giftcertificates giftcertificates_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificates
    ADD CONSTRAINT giftcertificates_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5486 (class 2606 OID 18492)
-- Name: giftcertificates giftcertificates_fk_types; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificates
    ADD CONSTRAINT giftcertificates_fk_types FOREIGN KEY (type) REFERENCES public.giftcertificatetypes(id);


--
-- TOC entry 5487 (class 2606 OID 18497)
-- Name: giftcertificatesdiary giftcertificatesdiary_fk_cert; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatesdiary
    ADD CONSTRAINT giftcertificatesdiary_fk_cert FOREIGN KEY (idcert) REFERENCES public.giftcertificates(id);


--
-- TOC entry 5488 (class 2606 OID 18502)
-- Name: giftcertificatesdiary giftcertificatesdiary_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatesdiary
    ADD CONSTRAINT giftcertificatesdiary_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5489 (class 2606 OID 18507)
-- Name: giftcertificatesdiary giftcertificatesdiary_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatesdiary
    ADD CONSTRAINT giftcertificatesdiary_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5490 (class 2606 OID 18512)
-- Name: giftcertificatesdiary giftcertificatesdiary_fk_reason; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.giftcertificatesdiary
    ADD CONSTRAINT giftcertificatesdiary_fk_reason FOREIGN KEY (reason) REFERENCES public.giftcertificatesdiaryreasons(id);


--
-- TOC entry 5503 (class 2606 OID 18517)
-- Name: invoices invoicecomp_fk_companies; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoicecomp_fk_companies FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5504 (class 2606 OID 18522)
-- Name: invoices invoicecreator_fk_erpusers; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoicecreator_fk_erpusers FOREIGN KEY (creator) REFERENCES public.erp_users(id);


--
-- TOC entry 5491 (class 2606 OID 18527)
-- Name: invoicelist invoicelist_fk_attributes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoicelist
    ADD CONSTRAINT invoicelist_fk_attributes FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5492 (class 2606 OID 18532)
-- Name: invoicelist invoicelist_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoicelist
    ADD CONSTRAINT invoicelist_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5493 (class 2606 OID 18537)
-- Name: invoicelist invoicelist_fk_invoice; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoicelist
    ADD CONSTRAINT invoicelist_fk_invoice FOREIGN KEY (invoice) REFERENCES public.invoices(invoicenumber);


--
-- TOC entry 5505 (class 2606 OID 18542)
-- Name: invoices invoices_fk_counterparty; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoices_fk_counterparty FOREIGN KEY (counterparty) REFERENCES public.counterparties(id);


--
-- TOC entry 5506 (class 2606 OID 18547)
-- Name: invoices invoicestockfrom_fk_points; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoicestockfrom_fk_points FOREIGN KEY (stockfrom) REFERENCES public.points(id);


--
-- TOC entry 5507 (class 2606 OID 18552)
-- Name: invoices invoicestockto_fk_points; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoicestockto_fk_points FOREIGN KEY (stockto) REFERENCES public.points(id);


--
-- TOC entry 5508 (class 2606 OID 18557)
-- Name: invoices invoicetype_fk_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.invoices
    ADD CONSTRAINT invoicetype_fk_type FOREIGN KEY (type) REFERENCES public.invoicetypes(id);


--
-- TOC entry 5610 (class 2606 OID 24587)
-- Name: locales locales_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.locales
    ADD CONSTRAINT locales_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5510 (class 2606 OID 18562)
-- Name: pluproducts_scale pluproducts_scale_scale_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pluproducts_scale
    ADD CONSTRAINT pluproducts_scale_scale_fkey FOREIGN KEY (scale) REFERENCES public.scale(id);


--
-- TOC entry 5514 (class 2606 OID 18567)
-- Name: pointset pointset_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pointset
    ADD CONSTRAINT pointset_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5515 (class 2606 OID 18572)
-- Name: pointset pointset_fk_stock; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.pointset
    ADD CONSTRAINT pointset_fk_stock FOREIGN KEY (stock) REFERENCES public.points(id);


--
-- TOC entry 5516 (class 2606 OID 18577)
-- Name: prices prices_company_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices
    ADD CONSTRAINT prices_company_fkey FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5520 (class 2606 OID 18582)
-- Name: prices_log prices_log_company_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices_log
    ADD CONSTRAINT prices_log_company_fkey FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5521 (class 2606 OID 18587)
-- Name: prices_log prices_log_point_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices_log
    ADD CONSTRAINT prices_log_point_fkey FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5522 (class 2606 OID 18592)
-- Name: prices_log prices_log_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices_log
    ADD CONSTRAINT prices_log_product_fkey FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5523 (class 2606 OID 18597)
-- Name: prices_log prices_log_userid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices_log
    ADD CONSTRAINT prices_log_userid_fkey FOREIGN KEY (userid) REFERENCES public.erp_users(id);


--
-- TOC entry 5517 (class 2606 OID 18602)
-- Name: prices prices_point_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices
    ADD CONSTRAINT prices_point_fkey FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5518 (class 2606 OID 18607)
-- Name: prices prices_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices
    ADD CONSTRAINT prices_product_fkey FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5519 (class 2606 OID 18612)
-- Name: prices prices_userid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.prices
    ADD CONSTRAINT prices_userid_fkey FOREIGN KEY (userid) REFERENCES public.erp_users(id);


--
-- TOC entry 5532 (class 2606 OID 18617)
-- Name: product_accounting product_accounting_fk_attributes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_accounting
    ADD CONSTRAINT product_accounting_fk_attributes FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5533 (class 2606 OID 18622)
-- Name: product_accounting product_accounting_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_accounting
    ADD CONSTRAINT product_accounting_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5534 (class 2606 OID 18627)
-- Name: product_accounting product_accounting_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_accounting
    ADD CONSTRAINT product_accounting_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5535 (class 2606 OID 18632)
-- Name: product_static_prices product_static_prices_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.product_static_prices
    ADD CONSTRAINT product_static_prices_product_fkey FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5536 (class 2606 OID 18637)
-- Name: products_barcode products_barcode_company_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_barcode
    ADD CONSTRAINT products_barcode_company_fkey FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5537 (class 2606 OID 18642)
-- Name: products_barcode products_barcode_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_barcode
    ADD CONSTRAINT products_barcode_product_fkey FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5494 (class 2606 OID 18647)
-- Name: products products_fk_brand; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_fk_brand FOREIGN KEY (brand) REFERENCES public.brands(id);


--
-- TOC entry 5538 (class 2606 OID 18652)
-- Name: products_temp products_fk_brand; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_temp
    ADD CONSTRAINT products_fk_brand FOREIGN KEY (brand) REFERENCES public.brands(id);


--
-- TOC entry 5495 (class 2606 OID 18657)
-- Name: products products_fk_cat; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_fk_cat FOREIGN KEY (category) REFERENCES public.categories(id);


--
-- TOC entry 5496 (class 2606 OID 18662)
-- Name: products products_fk_companies; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_fk_companies FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5497 (class 2606 OID 18667)
-- Name: products products_fk_tax; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_fk_tax FOREIGN KEY (taxid) REFERENCES public.taxes(id);


--
-- TOC entry 5498 (class 2606 OID 18672)
-- Name: products products_fk_unit_spr; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products
    ADD CONSTRAINT products_fk_unit_spr FOREIGN KEY (unitsprid) REFERENCES public.unit_spr(id);


--
-- TOC entry 5539 (class 2606 OID 18677)
-- Name: products_temp products_temp_fk_cat; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_temp
    ADD CONSTRAINT products_temp_fk_cat FOREIGN KEY (category) REFERENCES public.categories(id);


--
-- TOC entry 5540 (class 2606 OID 18682)
-- Name: products_temp products_temp_fk_companies; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_temp
    ADD CONSTRAINT products_temp_fk_companies FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5541 (class 2606 OID 18687)
-- Name: products_temp products_temp_fk_tax; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_temp
    ADD CONSTRAINT products_temp_fk_tax FOREIGN KEY (taxid) REFERENCES public.taxes(id);


--
-- TOC entry 5542 (class 2606 OID 18692)
-- Name: products_temp products_temp_fk_unit_spr; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.products_temp
    ADD CONSTRAINT products_temp_fk_unit_spr FOREIGN KEY (unitsprid) REFERENCES public.unit_spr(id);


--
-- TOC entry 5543 (class 2606 OID 18697)
-- Name: promconditions promcond_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promconditions
    ADD CONSTRAINT promcond_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5544 (class 2606 OID 18702)
-- Name: promconditions promcond_fk_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promconditions
    ADD CONSTRAINT promcond_fk_type FOREIGN KEY (type) REFERENCES public.promconditionstype(id);


--
-- TOC entry 5545 (class 2606 OID 18707)
-- Name: promdiscounts promdisc_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promdiscounts
    ADD CONSTRAINT promdisc_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5546 (class 2606 OID 18712)
-- Name: promdiscounts promdisc_fk_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promdiscounts
    ADD CONSTRAINT promdisc_fk_type FOREIGN KEY (type) REFERENCES public.promdiscountstype(id);


--
-- TOC entry 5547 (class 2606 OID 18717)
-- Name: promotions promotions_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promotions
    ADD CONSTRAINT promotions_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5548 (class 2606 OID 18722)
-- Name: promotions promotions_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.promotions
    ADD CONSTRAINT promotions_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5549 (class 2606 OID 18727)
-- Name: reviselist reviselist_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviselist
    ADD CONSTRAINT reviselist_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5550 (class 2606 OID 18732)
-- Name: reviselist reviselist_fk_esf; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviselist
    ADD CONSTRAINT reviselist_fk_esf FOREIGN KEY (esfid) REFERENCES public.esf(id);


--
-- TOC entry 5551 (class 2606 OID 18737)
-- Name: reviselist reviselist_fk_origcode; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviselist
    ADD CONSTRAINT reviselist_fk_origcode FOREIGN KEY (truorigincode) REFERENCES public.origincodes(id);


--
-- TOC entry 5552 (class 2606 OID 18742)
-- Name: reviselist reviselist_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviselist
    ADD CONSTRAINT reviselist_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5553 (class 2606 OID 18747)
-- Name: reviselist reviselist_fk_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.reviselist
    ADD CONSTRAINT reviselist_fk_user FOREIGN KEY ("user") REFERENCES public.erp_users(id);


--
-- TOC entry 5559 (class 2606 OID 18752)
-- Name: revision_difference revision-difference-attributes-fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_difference
    ADD CONSTRAINT "revision-difference-attributes-fkey" FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5560 (class 2606 OID 18757)
-- Name: revision_difference revision-difference-company-fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_difference
    ADD CONSTRAINT "revision-difference-company-fkey" FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5561 (class 2606 OID 18762)
-- Name: revision_difference revision-difference-point-fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_difference
    ADD CONSTRAINT "revision-difference-point-fkey" FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5562 (class 2606 OID 18767)
-- Name: revision_difference revision-difference-product-fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_difference
    ADD CONSTRAINT "revision-difference-product-fkey" FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5563 (class 2606 OID 18772)
-- Name: revision_difference revision-difference-user-fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_difference
    ADD CONSTRAINT "revision-difference-user-fkey" FOREIGN KEY ("user") REFERENCES public.erp_users(id);


--
-- TOC entry 5565 (class 2606 OID 18777)
-- Name: revision_list revision_list_company_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_list
    ADD CONSTRAINT revision_list_company_fkey FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5566 (class 2606 OID 18782)
-- Name: revision_list revision_list_point_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_list
    ADD CONSTRAINT revision_list_point_fkey FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5567 (class 2606 OID 18787)
-- Name: revision_temp revisiondiary_copy_attributes_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_temp
    ADD CONSTRAINT revisiondiary_copy_attributes_fkey FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5568 (class 2606 OID 18792)
-- Name: revision_temp revisiondiary_copy_company_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_temp
    ADD CONSTRAINT revisiondiary_copy_company_fkey FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5569 (class 2606 OID 18797)
-- Name: revision_temp revisiondiary_copy_point_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_temp
    ADD CONSTRAINT revisiondiary_copy_point_fkey FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5570 (class 2606 OID 18802)
-- Name: revision_temp revisiondiary_copy_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_temp
    ADD CONSTRAINT revisiondiary_copy_product_fkey FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5571 (class 2606 OID 18807)
-- Name: revision_temp revisiondiary_copy_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_temp
    ADD CONSTRAINT revisiondiary_copy_user_fkey FOREIGN KEY ("user") REFERENCES public.erp_users(id);


--
-- TOC entry 5572 (class 2606 OID 18812)
-- Name: revisiondiary revisiondiary_fk_attributes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary
    ADD CONSTRAINT revisiondiary_fk_attributes FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5554 (class 2606 OID 18817)
-- Name: revision_diary revisiondiary_fk_attributes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_diary
    ADD CONSTRAINT revisiondiary_fk_attributes FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5573 (class 2606 OID 18822)
-- Name: revisiondiary revisiondiary_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary
    ADD CONSTRAINT revisiondiary_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5555 (class 2606 OID 18827)
-- Name: revision_diary revisiondiary_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_diary
    ADD CONSTRAINT revisiondiary_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5574 (class 2606 OID 18832)
-- Name: revisiondiary revisiondiary_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary
    ADD CONSTRAINT revisiondiary_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5556 (class 2606 OID 18837)
-- Name: revision_diary revisiondiary_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_diary
    ADD CONSTRAINT revisiondiary_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5575 (class 2606 OID 18842)
-- Name: revisiondiary revisiondiary_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary
    ADD CONSTRAINT revisiondiary_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5557 (class 2606 OID 18847)
-- Name: revision_diary revisiondiary_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_diary
    ADD CONSTRAINT revisiondiary_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5576 (class 2606 OID 18852)
-- Name: revisiondiary revisiondiary_fk_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revisiondiary
    ADD CONSTRAINT revisiondiary_fk_user FOREIGN KEY ("user") REFERENCES public.erp_users(id);


--
-- TOC entry 5558 (class 2606 OID 18857)
-- Name: revision_diary revisiondiary_fk_user; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.revision_diary
    ADD CONSTRAINT revisiondiary_fk_user FOREIGN KEY ("user") REFERENCES public.erp_users(id);


--
-- TOC entry 5577 (class 2606 OID 18862)
-- Name: salesplan salesplan_fk_type; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.salesplan
    ADD CONSTRAINT salesplan_fk_type FOREIGN KEY (type) REFERENCES public.salesplan_types(id);


--
-- TOC entry 5578 (class 2606 OID 18867)
-- Name: scale scale_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.scale
    ADD CONSTRAINT scale_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5499 (class 2606 OID 18872)
-- Name: stockcurrent stockcurrent_fk_attributes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent
    ADD CONSTRAINT stockcurrent_fk_attributes FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5500 (class 2606 OID 18877)
-- Name: stockcurrent stockcurrent_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent
    ADD CONSTRAINT stockcurrent_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5501 (class 2606 OID 18882)
-- Name: stockcurrent stockcurrent_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent
    ADD CONSTRAINT stockcurrent_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5502 (class 2606 OID 18887)
-- Name: stockcurrent stockcurrent_fk_scale; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent
    ADD CONSTRAINT stockcurrent_fk_scale FOREIGN KEY (scale) REFERENCES public.scale(id);


--
-- TOC entry 5579 (class 2606 OID 18892)
-- Name: stockcurrent_part stockcurrent_part_fk_attributes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent_part
    ADD CONSTRAINT stockcurrent_part_fk_attributes FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5580 (class 2606 OID 18897)
-- Name: stockcurrent_part stockcurrent_part_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent_part
    ADD CONSTRAINT stockcurrent_part_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5581 (class 2606 OID 18902)
-- Name: stockcurrent_part stockcurrent_part_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockcurrent_part
    ADD CONSTRAINT stockcurrent_part_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5582 (class 2606 OID 18907)
-- Name: stockdiary stockdiary_fk_attributes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_fk_attributes FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5583 (class 2606 OID 18912)
-- Name: stockdiary stockdiary_fk_cashboxuser; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_fk_cashboxuser FOREIGN KEY (cashboxuser) REFERENCES public.cashbox_users(id);


--
-- TOC entry 5584 (class 2606 OID 18917)
-- Name: stockdiary stockdiary_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5585 (class 2606 OID 18922)
-- Name: stockdiary stockdiary_fk_invoice; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_fk_invoice FOREIGN KEY (invoice) REFERENCES public.invoices(invoicenumber);


--
-- TOC entry 5586 (class 2606 OID 18927)
-- Name: stockdiary stockdiary_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5587 (class 2606 OID 18932)
-- Name: stockdiary stockdiary_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5588 (class 2606 OID 18937)
-- Name: stockdiary stockdiary_fk_reasontype; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.stockdiary
    ADD CONSTRAINT stockdiary_fk_reasontype FOREIGN KEY (reason) REFERENCES public.reasontypes(id);


--
-- TOC entry 5589 (class 2606 OID 18942)
-- Name: storeprices storeprices_fk_points; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.storeprices
    ADD CONSTRAINT storeprices_fk_points FOREIGN KEY (store) REFERENCES public.points(id);


--
-- TOC entry 5590 (class 2606 OID 18947)
-- Name: storeprices storeprices_fk_stockcurrent; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.storeprices
    ADD CONSTRAINT storeprices_fk_stockcurrent FOREIGN KEY (stock) REFERENCES public.stockcurrent(id);


--
-- TOC entry 5591 (class 2606 OID 18952)
-- Name: taxes taxes_taxes_fk; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.taxes
    ADD CONSTRAINT taxes_taxes_fk FOREIGN KEY (parentid) REFERENCES public.taxes(id);


--
-- TOC entry 5592 (class 2606 OID 18957)
-- Name: tezmodules_access tezmodules_access_fk_compay_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tezmodules_access
    ADD CONSTRAINT tezmodules_access_fk_compay_id FOREIGN KEY (company_id) REFERENCES public.companies(id);


--
-- TOC entry 5593 (class 2606 OID 18962)
-- Name: tezmodules_access tezmodules_fk_id; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.tezmodules_access
    ADD CONSTRAINT tezmodules_fk_id FOREIGN KEY (tezmodule_id) REFERENCES public.tezmodules(id);


--
-- TOC entry 5594 (class 2606 OID 18967)
-- Name: transaction_promotions transaction_promotions_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_promotions
    ADD CONSTRAINT transaction_promotions_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5595 (class 2606 OID 18972)
-- Name: transaction_promotions transaction_promotions_fk_product; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_promotions
    ADD CONSTRAINT transaction_promotions_fk_product FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5596 (class 2606 OID 18977)
-- Name: transaction_promotions transaction_promotions_fk_promotion; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_promotions
    ADD CONSTRAINT transaction_promotions_fk_promotion FOREIGN KEY (promotion) REFERENCES public.promotions(id);


--
-- TOC entry 5597 (class 2606 OID 18982)
-- Name: transaction_promotions transaction_promotions_fk_transaction; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_promotions
    ADD CONSTRAINT transaction_promotions_fk_transaction FOREIGN KEY (transactionid) REFERENCES public.transactions(id);


--
-- TOC entry 5524 (class 2606 OID 18987)
-- Name: transaction_details transactiondetails_fk_company; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_details
    ADD CONSTRAINT transactiondetails_fk_company FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5525 (class 2606 OID 18992)
-- Name: transaction_details transactiondetails_fk_transactions; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transaction_details
    ADD CONSTRAINT transactiondetails_fk_transactions FOREIGN KEY (transactionid) REFERENCES public.transactions(id) ON DELETE CASCADE;


--
-- TOC entry 5526 (class 2606 OID 18997)
-- Name: transactions transactions_fk_bonuscard; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_fk_bonuscard FOREIGN KEY (bonuscardid) REFERENCES public.customers_bonuscards(id);


--
-- TOC entry 5527 (class 2606 OID 19002)
-- Name: transactions transactions_fk_cashusr; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_fk_cashusr FOREIGN KEY (cashboxuser) REFERENCES public.cashbox_users(id);


--
-- TOC entry 5528 (class 2606 OID 19007)
-- Name: transactions transactions_fk_cust; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_fk_cust FOREIGN KEY (customerid) REFERENCES public.customers(id);


--
-- TOC entry 5529 (class 2606 OID 19012)
-- Name: transactions transactions_fk_debtor; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_fk_debtor FOREIGN KEY (debtorid) REFERENCES public.fiz_customers(id);


--
-- TOC entry 5530 (class 2606 OID 19017)
-- Name: transactions transactions_fk_fiz_cust; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_fk_fiz_cust FOREIGN KEY (fiz_customerid) REFERENCES public.fiz_customers(id);


--
-- TOC entry 5531 (class 2606 OID 19022)
-- Name: transactions transactions_fk_point; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.transactions
    ADD CONSTRAINT transactions_fk_point FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5474 (class 2606 OID 19027)
-- Name: discounts type_fk_discounttypes; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.discounts
    ADD CONSTRAINT type_fk_discounttypes FOREIGN KEY (type) REFERENCES public.discounttypes(id);


--
-- TOC entry 5475 (class 2606 OID 19032)
-- Name: discounts type_fk_points; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.discounts
    ADD CONSTRAINT type_fk_points FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5598 (class 2606 OID 19037)
-- Name: user2roles user2roles_fk_roles; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user2roles
    ADD CONSTRAINT user2roles_fk_roles FOREIGN KEY (role) REFERENCES public.erp_roles(id);


--
-- TOC entry 5599 (class 2606 OID 19042)
-- Name: user2roles user2roles_fk_users; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.user2roles
    ADD CONSTRAINT user2roles_fk_users FOREIGN KEY ("user") REFERENCES public.erp_users(id);


--
-- TOC entry 5600 (class 2606 OID 19047)
-- Name: workorder workorder_accept_user_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT workorder_accept_user_fkey FOREIGN KEY (accept_user) REFERENCES public.erp_users(id);


--
-- TOC entry 5601 (class 2606 OID 19052)
-- Name: workorder workorder_company_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT workorder_company_fkey FOREIGN KEY (company) REFERENCES public.companies(id);


--
-- TOC entry 5606 (class 2606 OID 19057)
-- Name: workorder_details workorder_details_attributes_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder_details
    ADD CONSTRAINT workorder_details_attributes_fkey FOREIGN KEY (attributes) REFERENCES public.attributelistcode(id);


--
-- TOC entry 5607 (class 2606 OID 19062)
-- Name: workorder_details workorder_details_product_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder_details
    ADD CONSTRAINT workorder_details_product_fkey FOREIGN KEY (product) REFERENCES public.products(id);


--
-- TOC entry 5608 (class 2606 OID 19067)
-- Name: workorder_details workorder_details_workorder_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder_details
    ADD CONSTRAINT workorder_details_workorder_id_fkey FOREIGN KEY (workorder_id) REFERENCES public.workorder(id) ON DELETE CASCADE;


--
-- TOC entry 5602 (class 2606 OID 19072)
-- Name: workorder workorder_point_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT workorder_point_fkey FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5603 (class 2606 OID 19077)
-- Name: workorder workorder_point_fkey1; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT workorder_point_fkey1 FOREIGN KEY (point) REFERENCES public.points(id);


--
-- TOC entry 5604 (class 2606 OID 19082)
-- Name: workorder workorder_provider_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT workorder_provider_fkey FOREIGN KEY (counterparty) REFERENCES public.counterparties(id);


--
-- TOC entry 5605 (class 2606 OID 19087)
-- Name: workorder workorder_userid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.workorder
    ADD CONSTRAINT workorder_userid_fkey FOREIGN KEY (userid) REFERENCES public.erp_users(id);


--
-- TOC entry 5609 (class 2606 OID 19092)
-- Name: zreportdiary zreportdiary_fk_cashboxdiary; Type: FK CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.zreportdiary
    ADD CONSTRAINT zreportdiary_fk_cashboxdiary FOREIGN KEY (cashboxdiaryid) REFERENCES public.cashboxdiary(id);


-- Completed on 2025-11-27 11:39:10 +06

--
-- PostgreSQL database dump complete
--

